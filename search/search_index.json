{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the official documentation for Night Sky Engine. Night Sky Engine is a free and open source fighting game framework made in Unreal Engine 5. It is designed to be powerful yet easy to learn, and can be used to make 2D and 2.5D fighting games.</p> <ul> <li>Want to learn more about what Night Sky Engine is? Check out the About page.</li> <li>Interested in getting started with Night Sky Engine? Head to the Quick Start Guide to get started.</li> </ul> <p>If you have any questions, or need help, join the Discord server.</p> Next About"},{"location":"basics/basics/","title":"Quick Start","text":"<p>Now that you have the bare-minimum rundown of Night Sky Engine, it's time to learn the basics in more detail.</p> <ul> <li>Project Structure: How your project's folders should be structured.</li> <li>Collision Data and Cels: Tying Frame Data, Animations, and Hitboxes Together: Details on the Collision Data asset, and how it relates to frame data, animations, and hitboxes.</li> </ul> Previous Next Your First State Project Structure"},{"location":"basics/collision-data/","title":"Collision Data and Cels: Tying Frame Data, Animations, and Hitboxes Together","text":"<p>In Night Sky Engine, the concept of a Cel is what ties a character's frame data, animations, and hitboxes together. As such, it's the most vital data for a character. I briefly touched upon it in Getting Your Bearings from the Quick Start Guide, but here, I'll explain in more detail how Cels work and how to make new Cels.</p>"},{"location":"basics/collision-data/#frame-data","title":"Frame Data","text":"<p>A Cel can be thought of as a sort of \"keyframe\". They're named as such to invoke the idea of an animation cel. When combined with a State Blueprint, the Cel determines how long the character's current hitboxes and pose lasts for.</p> <p>The reason such a system is used, and not something like a frame data timeline (such as using Unreal Engine's Anim Notifies), is that it makes adjusting the animation to match the frame data incredibly easy. For example, if you have a punch animatoin, and put a Cel at frame 0 (punch start) and another cel at frame 10 (punch fully extended), but then decide that the punch should actually have 4 frames of startup instead, you don't have to edit the animation, reimport it, modify the Cels, and the State. Instead, you can just set the duration of the <code>Set Cel and Blend Cel</code> node in your State blueprint to 4.</p>"},{"location":"basics/collision-data/#animation","title":"Animation","text":"<p>This section assumes that you have an Anim Sequence in Unreal Engine for your character. If not, here's a link to official documentation for animation importing.</p> <p>In the Collision Data asset of your character, each Cel has associated animation data.</p> <p>This screenshot has quite a bit going on, so let's break it down:</p> <ul> <li>Anim: An array of animations for your Player Object. It's structured in an Array format to allow different animations on different Components.<ul> <li>Part Name: This is the name of the component that will be assigned the animation. For example, if you have a Skeletal Mesh Component named \"Body\", it will use the given animation.</li> <li>Anim Sequence: For Skeletal Mesh Components, this is the animation that will be used for the given part.</li> <li>Flipbook: For Paper Flipbook Components, this is the flipbook that will be used for the given part.</li> </ul> </li> <li>Anim Frame: The frame of animation that will be used for this Cel. This depends on your animation's frame rate.</li> <li>Anim Blend In: For Skeletal Mesh Components, this controls the \"blend in\" time. This is used for when the animation asset is different from the currently playing asset.</li> <li>Anim Blend Out: For Skeletal Mesh Components, this controls the \"blend out\" time. This is used for when the animation asset of the next Cel is different from this Cel's.</li> </ul>"},{"location":"basics/collision-data/#hitboxes","title":"Hitboxes","text":"<p>Finally, every Cel can have an arbitrary number of boxes. The Collision Data editor comes with a built-in preview for the boxes, relative to the animating character. </p> <p>Every Collision Box comes with some properties. Here's what they all do:</p> <ul> <li>Type: There are five types of boxes.<ul> <li>Pushbox. This is currently unused, as push collision is handled elsewhere. However, this is planned to be an option as a separate push collision system.</li> <li>Hurtbox.</li> <li>Hitbox.</li> <li>Offset. This can be used as a \"root motion\" system for sprites.</li> <li>Custom. This box type can be used in conjunction with the <code>Custom Type</code> property for custom logic.</li> </ul> </li> <li>Custom Type: For boxes with the Custom type, this specifies what kind of custom box it is. You can set any tag you want, but it should preferably use the naming convention <code>Collision.&lt;Type&gt;</code>.</li> <li>X Position: The box X axis position relative to the character's origin in Night Sky units, divided by 1000. The position is used as the box center.Updating this will update the <code>X Position (Unreal)</code> property, and vice versa.</li> <li>Y Position: The box Y axis position relative to the character's origin in Night Sky units, divided by 1000. The position is used as the box center. Updating this will update the <code>Y Position (Unreal)</code> property, and vice versa.</li> <li>X Size: The box width in Night Sky units, divided by 1000. Updating this will update the <code>X Size (Unreal)</code> property, and vice versa.</li> <li>Y Size: The box height in Night Sky units, divided by 1000. Updating this will update the <code>Y Size (Unreal)</code> property, and vice versa.</li> <li>X Position (Unreal): The box X axis position relative to the character's origin in centimeters. The position is used as the box center. Updating this will update the regular <code>X Position</code> property, and vice versa.</li> <li>Y Position (Unreal): The box Y axis position relative to the character's origin in centimeters. The position is used as the box center. Updating this will update the regular <code>Y Position</code> property, and vice versa.</li> <li>X Size: The box width in centimeters. Updating this will update the regular <code>X Size</code> property, and vice versa.</li> <li>Y Size: The box height in centimeters. Updating this will update the regular <code>Y Size</code> property, and vice versa.</li> </ul> <p></p> Previous Project Structure"},{"location":"basics/structure/","title":"Project Structure","text":"<p>Night Sky Engine's project structure may feel overwhelming at first glance. This page is designed to break down what each folder's intended use is.</p>"},{"location":"basics/structure/#root-folder","title":"Root folder","text":"<p>The intended filesystem for projects is to leave core implementation details in <code>Content/NightSkyEngine</code>, and put game-specific files in <code>Content/&lt;Project Name&gt;</code>.</p>"},{"location":"basics/structure/#blueprints","title":"Blueprints","text":"<p>As one would expect, this folder contains all of the Blueprints for the given folder. Additionally, gameplay-related data assets tend to reside in this folder. Note that Widget Blueprints should be stored elsewhere.</p>"},{"location":"basics/structure/#battle","title":"Battle","text":"<p>Universal battle elements, such as <code>BP_NightSkyGameState</code> and <code>BP_NightSkyPlayerController</code>, reside in this folder.</p>"},{"location":"basics/structure/#characters","title":"Characters","text":"<p>Character-related elements, such as states and pawns, reside in this folder. A subfolder should be created for each character.</p>"},{"location":"basics/structure/#charaselect","title":"CharaSelect","text":"<p>Character select-related elements, such as <code>BP_NightSkyCharaSelectGameState</code>, reside in this folder.</p>"},{"location":"basics/structure/#menu","title":"Menu","text":"<p>Universal menu elements, such as <code>BP_MenuPlayerController</code>, reside in this folder.</p>"},{"location":"basics/structure/#transition","title":"Transition","text":"<p>Used for network seamless loading.</p>"},{"location":"basics/structure/#vsinfo","title":"VSInfo","text":"<p>Used for the versus screen during battle loading.</p>"},{"location":"basics/structure/#wt","title":"WT","text":"<p>Used for WT mode-related elements. Depending on your project needs, this folder may be deleted.</p>"},{"location":"basics/structure/#characterassets","title":"CharacterAssets","text":"<p>Visual and audio assets for characters reside in this folder. Make a new subfolder for each character.</p>"},{"location":"basics/structure/#charaanimations","title":"Chara/Animations","text":"<p>For 3D characters, the character's animations should reside in this folder.</p>"},{"location":"basics/structure/#charaaudio","title":"Chara/Audio","text":"<p>A character's audio should reside in this folder. There should be an SE folder for sound effects, and a Voice folder for voice lines.</p>"},{"location":"basics/structure/#charaflipbooks","title":"Chara/Flipbooks","text":"<p>For 2D characters, the character's flipbooks should reside in this folder.</p>"},{"location":"basics/structure/#charamaterials","title":"Chara/Materials","text":"<p>The character's materials, material instances, and textures should reside in this folder.</p> <p>There should be a Base folder for common parts, and a ColorXX folder for each color, where XX is the color ID.</p>"},{"location":"basics/structure/#charameshes","title":"Chara/Meshes","text":"<p>For 3D characters, the character's meshes should reside in this folder.</p>"},{"location":"basics/structure/#charasprites","title":"Chara/Sprites","text":"<p>For 2D characters, the character's sprites should reside in this folder.</p>"},{"location":"basics/structure/#charaparticles","title":"Chara/Particles","text":"<p>The character's particle effects should reside in this folder.</p>"},{"location":"basics/structure/#charatextures","title":"Chara/Textures","text":"<p>For 2D characters, the character's textures should reside in this folder.</p>"},{"location":"basics/structure/#maps","title":"Maps","text":"<p>All levels should reside in this folder.</p>"},{"location":"basics/structure/#shared","title":"Shared","text":"<p>Common assets, such as master materials, inputs, and others should reside in this folder.</p>"},{"location":"basics/structure/#ui","title":"UI","text":"<p>All UI elements, such as widget blueprints, should reside in this folder.</p> Previous Next Your First State Collision Data and Cels: Tying Frame Data, Animations, and Hitboxes Together"},{"location":"getting-started/about/","title":"About Night Sky Engine","text":""},{"location":"getting-started/about/#what-is-night-sky-engine-written-in","title":"What is Night Sky Engine written in?","text":"<p>Night Sky Engine uses high-level visual scripting powered by Unreal Engine's Blueprint system, giving those with less programming experience the ability to create their own characters. If this scripting isn't enough for your needs, the native C++ backend can be edited freely to extend functionality.</p>"},{"location":"getting-started/about/#what-are-some-key-features-of-night-sky-engine","title":"What are some key features of Night Sky Engine?","text":"<p>Using the Blueprint system and exposed native functions, Night Sky Engine allows for very in-depth control of character states. States are quite robust, allowing the creator to control frame data, set animations, create timers, move objects, and more.</p> <p>Night Sky Engine also allows for both 2D sprite-based characters using Paper2D and 3D skeletal characters. As an added bonus, there's support for both traditionally animated 3D characters and the Arc System Works style of animated 3D characters.</p> <p>One of the most important features included is rollback netcode using GGPO. Stable netplay across the world is possible thanks to this.</p>"},{"location":"getting-started/about/#should-i-download-now-or-wait-for-later","title":"Should I download now, or wait for later?","text":"<p>After over 3 years of development, Night Sky Engine is finally ready for use! Feel free to download it right now and start making the fighting game of your dreams.</p> Previous Next Home Licenses"},{"location":"getting-started/bearings/","title":"Getting Your Bearings","text":"<p>Night Sky Engine is very powerful, but it may take some getting used to in order to unlock the full power of the framework. This page will explain some basic concepts of the framework. More detailed information will be brought up as the guide continues.</p>"},{"location":"getting-started/bearings/#night-sky-game-state","title":"Night Sky Game State","text":"<p>The Night Sky Game State is a class that extends Unreal's Game State Base. Everything related to battle code can be traced back to the code written in this class, such as all objects, the battle camera, and cinematics.</p> <p>When using Blueprint scripting, you most likely won't touch the code of this class. However, you can set fields like the round format (such as first to one round), the round start position, screen and stage boundaries, and more.</p>"},{"location":"getting-started/bearings/#battle-and-player-objects","title":"Battle and Player Objects","text":"<p>If the Night Sky Game State is the foundation of the battle scene, then a Battle Object is the main building block of the battle scene. Every actor that can influence the battle directly is either a Battle Object or inherits from a Battle Object. It stores all sorts of data, from position and speed to frame data and hit values. Regular Battle Objects tend to be used as projectiles or other non-player entities that should be updated.</p> <p>On the other hand, Player Objects are a specialized version of Battle Objects intended for use with player characters. In other words, you directly control Player Objects. These contain even more data, such as health, meter, a state machine, and more.</p>"},{"location":"getting-started/bearings/#the-state-machine","title":"The State Machine","text":"<p>Player Objects have access to a primary state machines. This state machine contains states the Player Object has access to, and methods for changing state. You will most likely never need to modify the state machine itself, as the transition logic lies in the Player Object itself. The state machine's purpose is to keep track of the current state and contain all other states.</p> <p>There's also an advanced, experimental feature for additional state machines. These states run in tandem with the primary state machine, and can be used to run background code independent of the main states. For more experimental games, this is useful for blending logic of multiple states together.</p>"},{"location":"getting-started/bearings/#states","title":"States","text":"<p>In Night Sky Engine, a state is a Blueprint that contains logic for how a Battle Object should behave. They can informally be divided between object states and player states.</p> <p>An object state is attached to a created Battle Object to set properties (such as an attached particle or values for hit) and frame data, or to run code. Object states are one-and-done; once the state is over, the Battle Object is removed.</p> <p>A player state is attached to a Player Object's state machine for much the same reason as an object state. Unlike an object state, a player state will transition into another state upon ending, either via the Exit State macro (which will return the Player Object to a neutral state) or via the Jump to State function (which will forcibly enter a new state). Additionally, conditions can be set for entering the state, such as an input sequence or a variable.</p>"},{"location":"getting-started/bearings/#cels","title":"Cels","text":"<p>Frame data and anything else that should only update at a specific point of a state is handled by the Cel system. Cels are a two-part system: one part being the <code>Cel Gate</code>, and the other part being in the Player Object's Collision Data.</p> <p>By using a <code>Cel Gate</code> macro in a state, you can create a \"keyframe\" of sorts for your state code. Code connected to the On Enter line will execute immediately upon a Cel's activation, and code connected to the On Update line will execute otherwise. The Duration parameter of the macro sets how long a Cel lasts. Once a Cel's duration elapses, the Next Cel line will activate, thereby creating a frame data system. All <code>Cel Gates</code> should be connected via the Next Cel line.</p> <p>For the Collision Data part, Cels can be connected to animation frames and collision data via the Set Cel Name function. By setting the current Battle Object's Cel name to the corresponding entry in the Collision Data, the Battle Object's animation and collision data will be updated.</p> <p>Under normal circumstances, there is no need to directly interact with a <code>Cel Gate</code>. Instead, it is recommended to use the <code>Set Cel</code> macro, or the <code>Set Cel and Blend Cel</code> macro for interpolated animations.</p> <p>As an example, say we have a Set Cel macro for the first 8 frames of a player's standing state. The Cel Name is set to <code>Manny.Stand.00</code>. In the Collision Data, <code>Manny.Stand.00</code> is connected to the first frame of the standing animation and collision data. Upon entering the standing state, the player will immediately set its Cel name, then wait 8 frames. Upon its duration elapsing, the next Cel hooked up to Skip will activate, and so on.</p> <p>When scripting in Blueprints, Cels will be the main way you interact with a state.</p> Previous Next Installing Night Sky Engine What Is A State? Part 1"},{"location":"getting-started/create-state/","title":"Your First State","text":"<p>Let's put what you've learned into practice, and create a new state.</p> <p>First, navigate to your character's folder in the Content Drawer. An example path would be <code>Content/NightSkyEngine/Blueprints/Characters/Manny/States</code>. Right-click in an empty spot of the Content Drawer, and create a new Blueprint. </p> <p>Generally, you do not want to inherit directly from the State class. Instead, I have prepared a plethora of state templates in <code>Content/NightSkyEngine/Blueprints/Characters/Common/States</code>. In this example, we'll create a normal attack, so let's inherit from <code>ST_CommonNormalAttack</code>.</p> <p>The standard naming convention for states is <code>ST_{Character}{StateName}</code>. We'll be creating a new standing light, so let's go with <code>ST_MannyNmlAtk5A</code>. If you don't understand the state name, there is a page on Infil's Fighting Game Glossary about numpad notation.</p> <p>First, you should define default values for your State. On the rightmost panel, you will see the Details tab. For now, here's the basics you need to understand about the State defaults:</p> <ul> <li>The name of your State is used to directly reference the State (for example, in Cancels or Jump to States).</li> <li>The Entry Stance determines what character stance (standing, crouching, jumping) the state may be entered from. If it is set to None, any state will work.</li> <li>Input Condition Lists handles input conditions. If one Condition List's requirements is met, the state may be entered. </li> </ul> <p>Start by setting the State name to a fitting Gameplay Tag (such as <code>State.Attack.Normal.5A</code>), and the entry stance to Standing. For the Input Condition Lists, add one entry, then open the dropdowns. You will notice a new array, called Input Conditions. These are the actual conditions that the list contains. All of these conditions must be met in order for the list to be considered successful.</p> <p>For now, add a new entry into the Condition's Sequence, and set the Input Flag to A (for light). Then, set the Method of the condition to Once. This means that it will only register the input on first press.</p> <p>Now that the default values have been set up, you should move on to the actual code. However, you'll notice that your new State currently has no code. Let's add some!</p> <p>On the leftmost panel, there should be a section labeled Functions. If you hover over it, you'll see a dropdown called \"Override\". First, override the Init function. It will create an Init function, which calls the parent function from <code>ST_CommonNormalAttack</code>.</p> <p>Under Init, you will handle all state values that need to be set when netering the state. In this case, we'll be setting the attack data, such as strength and damage. </p> <p>To interact with the State's owning object, you will need to Get the Parent. Right-click on an empty spot in the Function Graph, and type \"Get Parent\". Find the bottommost entry and click it. This will create a node in the Function Graph which gives you access to the owning object.</p> <p>In this case, we want to call a Subroutine that initializes the default attack values. Drag on the blue circle at the rightmost edge of the Parent node, release the mouse, and type \"Call Subroutine\". Click on the entry, and a new node will appear. This node will call a Subroutine that is stored within the Common Subroutine Data. Under Name, find the gameplay tag for <code>Subroutine.Cmn.AttackLevel.1</code>, which will set default attack values. Then, connect the leftmost white arrow to the \"Parent: Init\" node's rightmost white arrow.</p> <p>Now, we'll go back to the \"Override\" menu, and override the Exec function. This will create a new Event in the Event Graph. You may notice the lack of a \"Parent: Exec\" node in this override. Unless you are sure that you do not want the parent State's default functionality, it is best to create this node yourself. Right-click on the \"Event Exec\" node, and click \"Add Call to Parent Function\". Then, wire in the \"Parent: Exec\" node to \"Event Exec\".</p> <p>There are a lot of nodes that should be plugged into Exec, so I won't explain everything step-by-step. Instead, replicate the following image's node setup: </p> <p>I will explain what each macro or function call does, however:</p> <ul> <li>Set Cel and Blend Cel sets the Cel and Blend Cel names. The Cel system was previously explained, but Blend Cels are used to have animation interpolation between two frames. In other words, rather than just jumping from pose to pose, the character will smoothly transition based on your animation.</li> <li>Enable Hit must be called when you wish to hit the opponent, and Enabled must be set to True to allow hitting the opponent.</li> <li>Set Attacking changes the attacking state of the object. When attacking, the object is allowed to hit or Chain Cancel, but may be counter hit in return. Meanwhile, when not attacking, the object may not hit the opponent or Chain Cancel, but is no longer vulnerable to counter hits.</li> <li>Exit State will exit the current state and enter the default state for the current stance (standing, crouching, or jumping).</li> </ul> <p>Congrats, you have created your first State! Now, to see it in action, open the character's State Data. In this case, it is located at <code>Content/NightSkyEngine/Blueprints/Characters/Manny/DA_MannyStates</code>. Open the asset, and add a new entry to the State Array. Set the value to <code>ST_MannyNmlAtk5A</code>. Now, you can open Play in Editor and test out your new state.</p> Previous Next What Is A State? Part 2 Basics"},{"location":"getting-started/installing/","title":"Installing Night Sky Engine","text":"<p>There are two methods to installing Night Sky Engine: downloading the official release, or building from development source. For those who don't need to touch C++ code, or just want a quick and easy setup, I recommend grabbing the official release. However, if you want to mess around with the engine, or just want the latest changes, you will need to build from source.</p> <p>Warning</p> <p>The official release only has support for Windows on x64. While other platforms do work, they are not bunudled with the official release. You will need to build from source for Mac, Linux, or Windows on ARM.</p>"},{"location":"getting-started/installing/#download-official-release","title":"Download Official Release","text":"<p>To download the latest release, simply download <code>NightSkyEngine.rar</code> from this link.. Then, extract <code>NightSkyEngine.rar</code> using your tool of choice. </p> <p>Then, you will need to install Unreal Engine 5.7. Details can be found here. After installing Unreal Engine, you may run it, then open <code>NightSkyEngine/NightSkyEngine.uproject</code> from within the editor.</p>"},{"location":"getting-started/installing/#build-from-source","title":"Build From Source","text":"<p>Building from source takes more steps than just downloading the release. You'll need to know how to use Git and Visual Studio (or your IDE of choice).</p>"},{"location":"getting-started/installing/#clone-the-engine","title":"Clone the Engine","text":"<p>To get Night Sky Engine, use a Git client (such as the official client or Github Desktop) and clone the Night Sky Engine repository at https://github.com/WistfulHopes/NightSkyEngine.git. If using the command line, type in the following:</p> <p><code>git clone https://github.com/WistfulHopes/NightSkyEngine.git</code></p>"},{"location":"getting-started/installing/#compile-the-engine","title":"Compile the engine","text":"<p>To compile the Night Sky Engine, you will need Unreal Engine 5.7 and Visual Studio. The version of Visual Studio must be 2022. For detailed instructions on installing Visual Studio for use with Unreal Engine, click here.</p> <p>After Visual Studio is set up, you will need to generate Visual Studio project files for Night Sky Engine. To do so, right-click on NightSkyEngine.uproject, and click on \"Generate Visual Studio project files\".</p> <p>There will be a new file in the folder, <code>NightSkyEngine.sln</code>. Open it, and once Visual Studio has loaded, press Ctrl+Shift+B to compile the engine.</p> Previous Next Quick Start Getting Your Bearings"},{"location":"getting-started/licenses/","title":"Licenses","text":"<p>Listed below are the libraries used in Night Sky Engine.</p>"},{"location":"getting-started/licenses/#ggpoue","title":"GGPOUE","text":"<p>Night Sky Engine uses a fork of GGPOUE, a version of GGPO, for networking.</p> <p>You can find the original here.</p> <pre><code>The MIT License\n\nCopyright (c) 2009-2019 GroundStorm Studios, LLC. (http://ggpo.net)\nCopyright (c) 2020 BwdYeti\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n</code></pre>"},{"location":"getting-started/licenses/#the-match-makers-sound-effects-pack-osabisi","title":"THE MATCH-MAKERS Sound Effects Pack (Osabisi)","text":"<p>A sound effect library made by Osabisi.</p> <p>You can find the originals here.</p> Previous Next About Quick Start"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Don't know where to start with Night Sky Engine? Take a look at the below guides:</p> <ul> <li>Installing Night Sky Engine: A written tutorial on how to download and install Night Sky Engine.</li> <li>Getting Your Bearings: After installing the framework, check this out to understand the basics.</li> <li>What Is A State? Part 1: Take a look here to learn more about a State in-depth.</li> <li>What Is A State? Part 2: Continuing from the last part, this part will cover how State logic is defined.</li> <li>Your First State: It's time to learn how to make your first State.</li> </ul> <p>This section is in progress. More pages will be added.</p> Previous Next About Installing Night Sky Engine"},{"location":"getting-started/state-p1/","title":"What Is A State? Part 1","text":"<p>In Night Sky Engine, all characters have their logic built using States and Subroutines. For now, we'll focus on States.</p> <p>If you're familiar with a finite state machine, the concept here is similar. A character's state machine can be in one state at a time, and there are rules for transitioning between states. However, unlike a traditional finite state machine, the Night Sky State Machine allows for more broad categorization of states, in addition to fine-tuned control over transitions.</p> <p>States have two types of main conditions: Input and State Conditions. Input Conditions are based on the controller input: in other words, anything from holding a direction to doing a quarter circle forward and a button together, and even more. Meanwhile, a State Condition is a pre-determined condition for entering the state. Several examples of State Conditions are having enough meter, a Player Register being true or false, and so on.</p> <p>Every state can be grouped into a \"State Type\", such as Standing, Jumping, Normal Attack, etc. You can broadly toggle on and off transitioning into other states. For example, by toggling on the Jumping State Type, any Jumping States can be entered when its Input and State Conditions are met. Additionally, custom State Types may be created in Blueprints.</p> <p>Finally, if you need even more control over entering a state, you can override the <code>Can Enter State</code> function of a state to set custom conditions.</p> <p>If you need a more specific way to transition between different states, there are two ways to handle this: Cancels and Jump to State.</p> <p>A Cancel is a way to \"cancel\" the current state's execution and move to another state, but only when the other state's Input and State Conditions are met. There are several types of cancels, such as Jump Cancels, Special Cancels, Chain Cancels, and Whiff Cancels. For the most control, Chain and Whiff Cancels can be used.</p> <p>A Chain Cancel allows transitioning to another state upon the opponent receiving or blocking an attack. Chain Cancels are on by default on all normal attacks. Meanwhile, a Whiff Cancel allows transitioning to another state at any time. However, Whiff Cancels must be enabled on a per-state basis. The state to transition to is specified by name.</p> <p>Finally, a Jump to State allows bypassing all Input and State Conditions to enter another state. This is useful when a state has an automatic followup, such as landing recovery or a cinematic that only activates on hit.</p> <p>The Exit State macro is a simplification of Jump to State used to return to a neutral state immediately. This is used when a state's logic has ended (like when an attack's recovery is over).</p> Previous Next Getting Your Bearings What Is A State? Part 2"},{"location":"getting-started/state-p2/","title":"What Is A State? Part 2","text":"<p>Now that you broadly know what a state is, I'll cover how state logic is defined.</p> <p>States are defined in Unreal Engine's Blueprint system. If you haven't worked with Blueprints before, take a look at the official Unreal Engine documentation. All states must inherit from the C++ class called <code>State</code> at some point in its chain. This means that you cannot make a Blueprint that inherits from another UObject, or an Actor, and use it as a state.</p> <p>There are two native-declared functions in States: Init and Exec. Init is called upon entering a state, and handles setup. For example, in a character's Stand State, you'd set Speed to zero, enable all State Types, and enable character flipping sides. Meanwhile, Exec is called every frame the game updates, and handles the majority of state logic. For example, you would want to put Cels only in Exec, meaning frame data is locked into the Exec function.</p> <p>Another important system in States is the Event Handler system. There are several types of Events, such as Update, Exit, Landing, etc. Each Event has its own triggers, such as every frame for Update, exiting the state for Exit, touching the ground for Landing, etc. Event Handlers trigger a Blueprint Function by name when the corresponding Event fires.</p> <p>Event Handlers must be initialized before they can be used. Once initialized, they will remain until the State is exited, or if removed by type. Only one Event Handler of a type may be active at once; if another Event Handler of the same type is initialized, it will overwrite the old one.</p> <p>Warning</p> <p>If an Event Handler attempts to call a Blueprint Function that doesn't exist in the current State, nothing will happen! Make sure not to misspell the function name.</p> <p>For large States, reading an Event Graph can become unwieldy. As a result, there are two main ways to clean up your Blueprint Code: Functions and Macros. I recommend using Macros to group Cels, and Functions to group non-Cel code that needs to be used often.</p> <p>In the next part, I'll cover creating your first state.</p> Previous Next What Is A State? Part 1 Your First State"},{"location":"NightSkyEngine/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class AAudioManager </li> <li>class ABattleObject </li> <li>class AFighterLocalRunner </li> <li>class AFighterMultiplayerRunner </li> <li>class AFighterReplayRunner </li> <li>class AFighterSynctestRunner </li> <li>class ALinkActor </li> <li>class ANetworkPawn </li> <li>class ANightSkyAIController </li> <li>class ANightSkyBattleHudActor </li> <li>class ANightSkyCharaSelectGameState </li> <li>class ANightSkyEngineGameModeBase </li> <li>class ANightSkyGameState </li> <li>class ANightSkyPlayerController </li> <li>class ANightSkyVSInfoGameState </li> <li>class ANightSkyWTGameState </li> <li>class ANightSkyWTPlayerController </li> <li>class AParticleManager </li> <li>class APlayerObject </li> <li>class AWTCharacter </li> <li>struct FAnimRotator </li> <li>struct FAnimStruct </li> <li>struct FAnimTransform </li> <li>struct FAnimVector </li> <li>struct FAudioChannel </li> <li>struct FBattleData </li> <li>struct FBattleInputActions </li> <li>struct FBattleObjectLog </li> <li>struct FBattleParticle </li> <li>struct FBattleState </li> <li>struct FCameraShakeStruct </li> <li>struct FCollisionBox A collision box. </li> <li>struct FCollisionStruct </li> <li>struct FEventHandler </li> <li>struct FExtraGauge </li> <li>struct FFlipbookStruct </li> <li>struct FGroundBounceData </li> <li>struct FHitData </li> <li>struct FHitDataCommon </li> <li>struct FHitPosition </li> <li>struct FHitValueOverTime </li> <li>struct FHomingParams </li> <li>struct FInputActionBindingHandle </li> <li>struct FInputBitmask </li> <li>struct FInputBuffer The input buffer for a player object. </li> <li>struct FInputCondition </li> <li>struct FInputConditionList </li> <li>struct FLinkActorStruct </li> <li>struct FLinkedActorContainer </li> <li>struct FMaterialStruct </li> <li>struct FNSESessionInfo </li> <li>struct FNetworkMirror </li> <li>struct FNetworkStats </li> <li>struct FNightSkySaveArchive </li> <li>struct FObjectRecord </li> <li>struct FParticleStruct </li> <li>struct FPlayerObjectLog </li> <li>struct FRandomManager </li> <li>struct FRollbackAnimation </li> <li>struct FRollbackData </li> <li>struct FScreenData </li> <li>struct FSequenceStruct </li> <li>struct FSoundStruct </li> <li>struct FStateCPUData </li> <li>struct FStateMachine The player object's state machine. </li> <li>struct FSuperArmorData </li> <li>struct FTeamData </li> <li>struct FWallBounceData </li> <li>class RpcConnectionManager </li> <li>class UBattleExtension A customizable extension to the battle ruleset. </li> <li>class UBattleExtensionData </li> <li>class UCameraShakeData </li> <li>class UCollisionData </li> <li>class UExtendedCommonActivatableWidget </li> <li>class UFlipbookData </li> <li>class ULinkActorData </li> <li>class UMaterialData </li> <li>class UNSEEnhancedInputUserSettings </li> <li>class UNSEPlayerMappableKeyProfile </li> <li>class UNSEPlayerMappableKeySettings </li> <li>class UNSESessionSubsystem </li> <li>class UNightSkyAnimInstance </li> <li>class UNightSkyAnimMetaData </li> <li>class UNightSkyAnimSequenceUserData </li> <li>class UNightSkyBattleWidget </li> <li>class UNightSkyBlueprintFunctionLibrary </li> <li>class UNightSkyGameInstance </li> <li>class UNightSkySaveInfo </li> <li>class UNightSkySettingsInfo </li> <li>class UParticleData </li> <li>class UPrimaryCharaData </li> <li>class UPrimaryStageData </li> <li>class UReplaySaveInfo </li> <li>class USequenceData </li> <li>class USerializableObj </li> <li>class USoundData </li> <li>class UState A character state that determines behavior. </li> <li>class UStateAlias </li> <li>class UStateData </li> <li>class USubroutine A subroutine callable from any player or object state. </li> <li>class USubroutineData </li> <li>class USubroutineState </li> </ul>"},{"location":"NightSkyEngine/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir Plugins <ul> <li>dir NightSkyEngine <ul> <li>dir Source <ul> <li>dir NightSkyEngine <ul> <li>dir Battle <ul> <li>dir Actors <ul> <li>file AudioManager.cpp </li> <li>file AudioManager.h </li> <li>file LinkActor.cpp </li> <li>file LinkActor.h </li> <li>file ParticleManager.cpp </li> <li>file ParticleManager.h </li> </ul> </li> <li>dir Animation <ul> <li>file NightSkyAnimInstance.cpp </li> <li>file NightSkyAnimInstance.h </li> <li>file NightSkyAnimMetaData.cpp </li> <li>file NightSkyAnimMetaData.h </li> <li>file NightSkyAnimSequenceUserData.cpp </li> <li>file NightSkyAnimSequenceUserData.h </li> </ul> </li> <li>dir CPU <ul> <li>file NightSkyAIController.cpp </li> <li>file NightSkyAIController.h </li> </ul> </li> <li>dir FighterRunners <ul> <li>file FighterLocalRunner.cpp </li> <li>file FighterLocalRunner.h </li> <li>file FighterMultiplayerRunner.cpp </li> <li>file FighterMultiplayerRunner.h </li> <li>file FighterReplayRunner.cpp </li> <li>file FighterReplayRunner.h </li> <li>file FighterSynctestRunner.cpp </li> <li>file FighterSynctestRunner.h </li> </ul> </li> <li>dir Misc <ul> <li>file Bitflags.h </li> <li>file CollisionBox.h </li> <li>file Globals.cpp </li> <li>file Globals.h </li> <li>file InputBuffer.cpp </li> <li>file InputBuffer.h </li> <li>file NightSkyBlueprintFunctionLibrary.cpp </li> <li>file NightSkyBlueprintFunctionLibrary.h </li> <li>file RandomManager.cpp </li> <li>file RandomManager.h </li> <li>file SerializableObj.cpp </li> <li>file SerializableObj.h </li> </ul> </li> <li>dir Objects <ul> <li>file BattleObject.cpp </li> <li>file BattleObject.h </li> <li>file PlayerObject.cpp </li> <li>file PlayerObject.h </li> </ul> </li> <li>dir Script <ul> <li>file BattleExtension.cpp </li> <li>file BattleExtension.h </li> <li>file State.cpp </li> <li>file State.h </li> <li>file StateAlias.h </li> <li>file StateMachine.cpp </li> <li>file StateMachine.h </li> <li>file Subroutine.cpp </li> <li>file Subroutine.h </li> <li>file SubroutineState.h </li> </ul> </li> <li>file NightSkyGameState.cpp </li> <li>file NightSkyGameState.h </li> <li>file NightSkyPlayerController.cpp </li> <li>file NightSkyPlayerController.h </li> </ul> </li> <li>dir CharaSelect <ul> <li>file NightSkyCharaSelectGameState.cpp </li> <li>file NightSkyCharaSelectGameState.h </li> </ul> </li> <li>dir Data <ul> <li>file BattleExtensionData.cpp </li> <li>file BattleExtensionData.h </li> <li>file CameraShakeData.h </li> <li>file CollisionData.cpp </li> <li>file CollisionData.h </li> <li>file FlipbookData.h </li> <li>file LinkActorData.h </li> <li>file MaterialData.h </li> <li>file ParticleData.cpp </li> <li>file ParticleData.h </li> <li>file PrimaryCharaData.h </li> <li>file PrimaryStageData.h </li> <li>file SequenceData.h </li> <li>file SoundData.cpp </li> <li>file SoundData.h </li> <li>file StateData.cpp </li> <li>file StateData.h </li> <li>file SubroutineData.cpp </li> <li>file SubroutineData.h </li> </ul> </li> <li>dir Input <ul> <li>file NSEEnhancedInputUserSettings.cpp </li> <li>file NSEEnhancedInputUserSettings.h </li> <li>file NSEPlayerMappableKeyProfile.cpp </li> <li>file NSEPlayerMappableKeyProfile.h </li> <li>file NSEPlayerMappableKeySettings.cpp </li> <li>file NSEPlayerMappableKeySettings.h </li> </ul> </li> <li>dir Miscellaneous <ul> <li>file NightSkyEngineGameModeBase.cpp </li> <li>file NightSkyEngineGameModeBase.h </li> <li>file NightSkyGameInstance.cpp </li> <li>file NightSkyGameInstance.h </li> <li>file NightSkySaveInfo.cpp </li> <li>file NightSkySaveInfo.h </li> <li>file NightSkySettingsInfo.h </li> <li>file ReplayInfo.cpp </li> <li>file ReplayInfo.h </li> </ul> </li> <li>dir Network <ul> <li>file FighterRunners.h </li> <li>file NSESessionSubsystem.cpp </li> <li>file NSESessionSubsystem.h </li> <li>file NetworkPawn.cpp </li> <li>file NetworkPawn.h </li> <li>file RpcConnectionManager.cpp </li> <li>file RpcConnectionManager.h </li> </ul> </li> <li>dir UI <ul> <li>file ExtendedCommonActivatableWidget.cpp </li> <li>file ExtendedCommonActivatableWidget.h </li> <li>file NightSkyBattleHudActor.cpp </li> <li>file NightSkyBattleHudActor.h </li> <li>file NightSkyBattleWidget.cpp </li> <li>file NightSkyBattleWidget.h </li> </ul> </li> <li>dir VSInfo <ul> <li>file NightSkyVSInfoGameState.cpp </li> <li>file NightSkyVSInfoGameState.h </li> </ul> </li> <li>dir WT <ul> <li>file NightSkyWTGameState.cpp </li> <li>file NightSkyWTGameState.h </li> <li>file NightSkyWTPlayerController.cpp </li> <li>file NightSkyWTPlayerController.h </li> <li>file WTCharacter.cpp </li> <li>file WTCharacter.h </li> </ul> </li> <li>file NightSkyEngine.cpp </li> <li>file NightSkyEngine.h </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"NightSkyEngine/class_a_audio_manager/","title":"Class AAudioManager","text":"<p>ClassList &gt; AAudioManager</p> <p>Inherits the following classes: AActor</p>"},{"location":"NightSkyEngine/class_a_audio_manager/#public-attributes","title":"Public Attributes","text":"Type Name UAudioComponent * AnnouncerVoicePlayer UAudioComponent * CharaAudioPlayers UAudioComponent * CharaVoicePlayers UAudioComponent * CommonAudioPlayers UAudioComponent * MusicPlayer"},{"location":"NightSkyEngine/class_a_audio_manager/#public-functions","title":"Public Functions","text":"Type Name AAudioManager ()  void PauseAllAudio ()  virtual void Tick (float DeltaTime) override"},{"location":"NightSkyEngine/class_a_audio_manager/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_audio_manager/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_audio_manager/#variable-announcervoiceplayer","title":"variable AnnouncerVoicePlayer","text":"<pre><code>UAudioComponent* AAudioManager::AnnouncerVoicePlayer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_audio_manager/#variable-charaaudioplayers","title":"variable CharaAudioPlayers","text":"<pre><code>UAudioComponent* AAudioManager::CharaAudioPlayers[CharaAudioChannelCount];\n</code></pre>"},{"location":"NightSkyEngine/class_a_audio_manager/#variable-charavoiceplayers","title":"variable CharaVoicePlayers","text":"<pre><code>UAudioComponent* AAudioManager::CharaVoicePlayers[CharaVoiceChannelCount];\n</code></pre>"},{"location":"NightSkyEngine/class_a_audio_manager/#variable-commonaudioplayers","title":"variable CommonAudioPlayers","text":"<pre><code>UAudioComponent* AAudioManager::CommonAudioPlayers[CommonAudioChannelCount];\n</code></pre>"},{"location":"NightSkyEngine/class_a_audio_manager/#variable-musicplayer","title":"variable MusicPlayer","text":"<pre><code>UAudioComponent* AAudioManager::MusicPlayer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_audio_manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_audio_manager/#function-aaudiomanager","title":"function AAudioManager","text":"<pre><code>AAudioManager::AAudioManager () \n</code></pre>"},{"location":"NightSkyEngine/class_a_audio_manager/#function-pauseallaudio","title":"function PauseAllAudio","text":"<pre><code>void AAudioManager::PauseAllAudio () \n</code></pre>"},{"location":"NightSkyEngine/class_a_audio_manager/#function-tick","title":"function Tick","text":"<pre><code>virtual void AAudioManager::Tick (\n    float DeltaTime\n) override\n</code></pre>"},{"location":"NightSkyEngine/class_a_audio_manager/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_audio_manager/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void AAudioManager::BeginPlay () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/AudioManager.h</code></p>"},{"location":"NightSkyEngine/class_a_battle_object/","title":"Class ABattleObject","text":"<p>ClassList &gt; ABattleObject</p> <p>Inherits the following classes: APawn</p> <p>Inherited by the following classes: APlayerObject</p>"},{"location":"NightSkyEngine/class_a_battle_object/#public-attributes","title":"Public Attributes","text":"Type Name int32 ActionReg1   = <code>0</code> int32 ActionReg2   = <code>0</code> int32 ActionReg3   = <code>0</code> int32 ActionReg4   = <code>0</code> int32 ActionReg5   = <code>0</code> int32 ActionReg6   = <code>0</code> int32 ActionReg7   = <code>0</code> int32 ActionReg8   = <code>0</code> int32 ActionTime   = <code>0</code> FLinearColor AddColor   = <code>FLinearColor(0, 0, 0, 1)</code> FLinearColor AddFadeColor   = <code>{}</code> float AddFadeSpeed   = <code>0</code> int32 AnglePitch_x1000   = <code>0</code> int32 AngleRoll_x1000   = <code>0</code> int32 AngleYaw_x1000   = <code>0</code> float AnimBlendIn   = <code>{}</code> float AnimBlendOut   = <code>{}</code> int32 AnimFrame   = <code>0</code> TArray&lt; FAnimStruct &gt; AnimStructs uint32 AttackFlags   = <code>0</code> ABattleObject * AttackOwner ABattleObject * AttackTarget   = <code>nullptr</code> int32 B   = <code>0</code> int32 BlendAnimFrame   = <code>0</code> FGameplayTag BlendCelName   = <code>{}</code> bool BlendOffset   = <code>false</code> TArray&lt; FCollisionBox &gt; Boxes int32 CelIndex   = <code>0</code> FGameplayTag CelName   = <code>{}</code> TObjectPtr&lt; ANightSkyCharaSelectGameState &gt; CharaSelectGameState   = <code>nullptr</code> int32 ColPosX   = <code>0</code> int32 ColPosY   = <code>0</code> FHitData CounterHit   = <code>{}</code> FLinearColor DamageColor   = <code>FLinearColor(1, 1, 1, 1)</code> FLinearColor DamageColor2   = <code>FLinearColor(1, 1, 1, 1)</code> TEnumAsByte&lt; EObjDir &gt; Direction   = <code>DIR\\_Right</code> int32 DrawPriority   = <code>0</code> ABattleObject * DrawPriorityLinkObj   = <code>nullptr</code> FEventHandler EventHandlers   = <code>{}</code> float FadeTransparency   = <code>1</code> float FrameBlendPosition   = <code>0</code> TObjectPtr&lt; ANightSkyGameState &gt; GameState   = <code>nullptr</code> bool GotoLabelActive   = <code>false</code> int32 Gravity   = <code>1900</code> int32 GroundHeight   = <code>0</code> FHitDataCommon HitCommon   = <code>{}</code> int32 Hitstop   = <code>0</code> FHomingParams HomingParams   = <code>[**FHomingParams**](struct_f_homing_params.md)()</code> int32 Inertia   = <code>0</code> bool IsActive   = <code>false</code> bool IsPlayer   = <code>false</code> int32 L   = <code>0</code> FGameplayTag LabelName   = <code>{}</code> TObjectPtr&lt; ALinkActor &gt; LinkedActor TObjectPtr&lt; UNiagaraComponent &gt; LinkedParticle   = <code>nullptr</code> ABattleObject * MaterialLinkObj   = <code>nullptr</code> int32 MaxCelTime   = <code>0</code> int32 MiscFlags   = <code>0</code> FLinearColor MulColor   = <code>FLinearColor(1, 1, 1, 1)</code> FLinearColor MulFadeColor   = <code>{}</code> float MulFadeSpeed   = <code>0</code> int32 NextOffsetX   = <code>0</code> int32 NextOffsetY   = <code>0</code> FHitData NormalHit   = <code>{}</code> uint32 ObjNumber   = <code>0</code> unsigned char ObjSync   = <code>0</code> unsigned char ObjSyncEnd   = <code>0</code> uint32 ObjectID   = <code>0</code> FVector ObjectOffset   = <code>FVector::ZeroVector</code> int32 ObjectReg1   = <code>0</code> int32 ObjectReg2   = <code>0</code> int32 ObjectReg3   = <code>0</code> int32 ObjectReg4   = <code>0</code> int32 ObjectReg5   = <code>0</code> int32 ObjectReg6   = <code>0</code> int32 ObjectReg7   = <code>0</code> int32 ObjectReg8   = <code>0</code> FRotator ObjectRotation   = <code>FRotator::ZeroRotator</code> FVector ObjectScale   = <code>FVector::One()</code> TObjectPtr&lt; UState &gt; ObjectState   = <code>nullptr</code> int32 ObjectStateIndex   = <code>0</code> FGameplayTag ObjectStateName   = <code>{}</code> TArray&lt; ABattleObject * &gt; ObjectsToIgnoreHitsFrom float OrthoBlendActive   = <code>0</code> APlayerObject * Player   = <code>nullptr</code> int32 PosX   = <code>0</code> int32 PosY   = <code>0</code> int32 PosZ   = <code>0</code> ABattleObject * PositionLinkObj   = <code>nullptr</code> int32 PrevOffsetX   = <code>0</code> int32 PrevOffsetY   = <code>0</code> int32 PrevPosX   = <code>0</code> int32 PrevPosY   = <code>0</code> int32 PrevPosZ   = <code>0</code> int32 PrevRootMotionX   = <code>0</code> int32 PrevRootMotionY   = <code>0</code> int32 PrevRootMotionZ   = <code>0</code> int32 Pushback   = <code>0</code> int32 R   = <code>0</code> FHitData ReceivedHit   = <code>{}</code> FHitDataCommon ReceivedHitCommon   = <code>{}</code> float ScreenSpaceDepthOffset   = <code>0</code> FName SocketName   = <code>{}</code> EObjType SocketObj   = <code>OBJ\\_Self</code> FVector SocketOffset   = <code>FVector::ZeroVector</code> int32 SpeedX   = <code>0</code> int32 SpeedXRate   = <code>100</code> int32 SpeedXRatePerFrame   = <code>100</code> int32 SpeedY   = <code>0</code> int32 SpeedYRate   = <code>100</code> int32 SpeedYRatePerFrame   = <code>100</code> int32 SpeedZ   = <code>0</code> int32 SpeedZRate   = <code>100</code> int32 SpeedZRatePerFrame   = <code>100</code> ABattleObject * StopLinkObj   = <code>nullptr</code> int32 StunTime   = <code>0</code> int32 StunTimeMax   = <code>0</code> int32 SubroutineReg1   = <code>0</code> int32 SubroutineReg2   = <code>0</code> int32 SubroutineReg3   = <code>0</code> int32 SubroutineReg4   = <code>0</code> int32 SubroutineReturnVal1   = <code>0</code> int32 SubroutineReturnVal2   = <code>0</code> int32 SubroutineReturnVal3   = <code>0</code> int32 SubroutineReturnVal4   = <code>0</code> FSuperArmorData SuperArmorData   = <code>[**FSuperArmorData**](struct_f_super_armor_data.md)()</code> int32 T   = <code>0</code> int32 TimeUntilNextCel   = <code>0</code> int32 Timer0   = <code>0</code> int32 Timer1   = <code>0</code> float Transparency   = <code>1</code> float TransparencySpeed   = <code>0</code> int32 UpdateTime   = <code>0</code> bool bIsCommonState   = <code>false</code> bool bRender   = <code>true</code>"},{"location":"NightSkyEngine/class_a_battle_object/#public-functions","title":"Public Functions","text":"Type Name ABattleObject ()  ABattleObject * AddBattleObject (FGameplayTag InStateName, int32 PosXOffset=0, int32 PosYOffset=0, EPosType PosType=POS_Player)  ABattleObject * AddCommonBattleObject (FGameplayTag InStateName, int32 PosXOffset=0, int32 PosYOffset=0, EPosType PosType=POS_Player)  void AddPosXWithDir (int InPosX)  void AddSpeedXRaw (int InSpeedX)  void AttachToSocketOfObject (FName InSocketName, FVector Offset, EObjType ObjType)  int32 CalculateAngleBetweenPoints (EObjType Obj1, EPosType Pos1, EObjType Obj2, EPosType Pos2)  int32 CalculateDistanceBetweenPoints (EDistanceType Type, EObjType Obj1, EPosType Pos1, EObjType Obj2, EPosType Pos2)  void CalculatePushbox ()  int32 CalculateSpeedAngle () const void CallSubroutine (FGameplayTag Name)  void CallSubroutineWithArgs (FGameplayTag Name, int32 Arg1, int32 Arg2, int32 Arg3, int32 Arg4)  void CameraShake (FGameplayTag PatternName, int32 Scale)  bool CheckBoxOverlap (ABattleObject * OtherObj, const EBoxType SelfType, const FGameplayTag SelfCustomType, const EBoxType OtherType, const FGameplayTag OtherCustomType)  bool CheckIsGrounded () const void CollisionView ()  void CreateCharaParticle (FGameplayTag Name, EPosType PosType, FVector Offset=FVector::ZeroVector, FRotator Rotation=FRotator::ZeroRotator)  void CreateCommonParticle (FGameplayTag Name, EPosType PosType, FVector Offset=FVector::ZeroVector, FRotator Rotation=FRotator::ZeroRotator)  void DeactivateObject ()  void DetachFromSocket ()  void DisableInertia ()  void EnableDeactivateIfBeyondBounds (bool Enable)  void EnableDeactivateOnReceiveHit (bool Enable)  void EnableDeactivateOnStateChange (bool Enable)  void EnableFlip (bool Enabled)  void EnableHit (bool Enabled)  void EnableInertia ()  void FaceOpponent ()  void FlipObject ()  int32 GenerateRandomNumber (int32 Min, int32 Max) const UAnimSequenceBase * GetAnimSequenceForPart (const FName Part) const ABattleObject * GetBattleObject (EObjType Type)  void GetBoxPosition (const EBoxType BoxType, const FGameplayTag CustomType, int &amp; OutPosX, int &amp; OutPosY) const void GetBoxes ()  FGameplayTag GetCelName () const UPaperFlipbook * GetFlipbookForPart (const FName Part) const int32 GetGauge (int32 GaugeIndex) const FGameplayTag GetLabelName () const int32 GetPosYCenter () const void GotoLabel (FGameplayTag InName)  void HaltMomentum ()  void HandleClashCollision (ABattleObject * OtherObj)  void HandleCustomCollision_PostHit (ABattleObject * OtherObj)  void HandleCustomCollision_PreHit (ABattleObject * OtherObj)  void HandleFlip ()  void HandleHitCollision (ABattleObject * AttackedObj)  void HandlePushCollision (ABattleObject * OtherObj)  void IgnoreSuperFreeze (bool Ignore)  void InitEventHandler (EEventType EventType, FName FuncName, int32 Value, FGameplayTag SubroutineName)  FHitData InitHitDataByAttackLevel (bool IsCounter)  void InitObject ()  bool IsStopped () const bool IsTimerPaused () const ALinkActor * LinkActor (FGameplayTag Name)  void LinkCharaParticle (FGameplayTag Name)  void LinkCommonParticle (FGameplayTag Name)  void LoadForRollback (const unsigned char * Buffer)  void PlayCharaSound (FGameplayTag Name)  void PlayCommonSound (FGameplayTag Name)  void PosTypeToPosition (EPosType Type, int32 &amp; OutPosX, int32 &amp; OutPosY) const void PositionLinkUpdate ()  void RemoveEventHandler (EEventType EventType)  void RemoveLinkActor ()  void ResetObject ()  void SaveForRollback (unsigned char * Buffer) const void ScreenPosToWorldPos (const int32 X, const int32 Y, int32 &amp; OutX, int32 &amp; OutY) const void SetAttacking (bool Attacking)  void SetBlendCelName (FGameplayTag InName)  void SetCelDuration (int32 InTime)  void SetCelName (FGameplayTag InName)  void SetFacing (EObjDir NewDir)  void SetFloorCollisionActive (bool Active)  void SetGauge (int32 GaugeIndex, int32 Value)  void SetHitOTG (bool Enable)  void SetIgnoreHitstunScaling (bool Ignore)  void SetIgnoreOTG (bool Ignore)  void SetIgnorePushbackScaling (bool Ignore)  void SetObjectID (int InObjectID)  void SetPitch (int32 Pitch_x1000)  void SetPlayerHit (bool Enable)  void SetProjectileAttribute (bool Attribute)  void SetProrateOnce (bool Once)  void SetPushCollisionActive (bool Active)  void SetPushWidthExtend (int32 Extend)  void SetRoll (int32 Roll_x1000)  void SetSpeedXRaw (int InSpeedX)  void SetTimeUntilNextCel (int32 InTime)  void SetWallCollisionActive (bool Active)  void SetYaw (int32 Yaw_x1000)  void StartSuperFreeze (int Duration, int SelfDuration=0)  virtual void Tick (float DeltaTime) override void TriggerEvent (EEventType EventType, FGameplayTag StateMachineName)  virtual void Update ()  virtual void UpdateVisuals ()  virtual void UpdateVisualsNoRollback ()  void UpdateVisuals_BP ()  void UseGauge (int32 GaugeIndex, int32 Value)"},{"location":"NightSkyEngine/class_a_battle_object/#public-static-functions","title":"Public Static Functions","text":"Type Name int32 NormalizeAngle (int32 Angle_x1000)"},{"location":"NightSkyEngine/class_a_battle_object/#protected-attributes","title":"Protected Attributes","text":"Type Name int32 PushHeight   = <code>0</code> int32 PushHeightLow   = <code>0</code> int32 PushWidth   = <code>0</code> int32 PushWidthExtend   = <code>0</code>"},{"location":"NightSkyEngine/class_a_battle_object/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override void CalculateHoming ()  void FuncCall (const FName &amp; FuncName) const UNightSkyAnimSequenceUserData * GetAnimSequenceUserData (const FName PartName) const TArray&lt; UNightSkyAnimSequenceUserData * &gt; GetAnimSequenceUserDatas () const void Move ()  bool SuperArmorSuccess (const ABattleObject * Attacker) const"},{"location":"NightSkyEngine/class_a_battle_object/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_battle_object/#variable-actionreg1","title":"variable ActionReg1","text":"<pre><code>int32 ABattleObject::ActionReg1;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-actionreg2","title":"variable ActionReg2","text":"<pre><code>int32 ABattleObject::ActionReg2;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-actionreg3","title":"variable ActionReg3","text":"<pre><code>int32 ABattleObject::ActionReg3;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-actionreg4","title":"variable ActionReg4","text":"<pre><code>int32 ABattleObject::ActionReg4;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-actionreg5","title":"variable ActionReg5","text":"<pre><code>int32 ABattleObject::ActionReg5;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-actionreg6","title":"variable ActionReg6","text":"<pre><code>int32 ABattleObject::ActionReg6;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-actionreg7","title":"variable ActionReg7","text":"<pre><code>int32 ABattleObject::ActionReg7;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-actionreg8","title":"variable ActionReg8","text":"<pre><code>int32 ABattleObject::ActionReg8;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-actiontime","title":"variable ActionTime","text":"<pre><code>int32 ABattleObject::ActionTime;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-addcolor","title":"variable AddColor","text":"<pre><code>FLinearColor ABattleObject::AddColor;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-addfadecolor","title":"variable AddFadeColor","text":"<pre><code>FLinearColor ABattleObject::AddFadeColor;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-addfadespeed","title":"variable AddFadeSpeed","text":"<pre><code>float ABattleObject::AddFadeSpeed;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-anglepitch_x1000","title":"variable AnglePitch_x1000","text":"<pre><code>int32 ABattleObject::AnglePitch_x1000;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-angleroll_x1000","title":"variable AngleRoll_x1000","text":"<pre><code>int32 ABattleObject::AngleRoll_x1000;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-angleyaw_x1000","title":"variable AngleYaw_x1000","text":"<pre><code>int32 ABattleObject::AngleYaw_x1000;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-animblendin","title":"variable AnimBlendIn","text":"<pre><code>float ABattleObject::AnimBlendIn;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-animblendout","title":"variable AnimBlendOut","text":"<pre><code>float ABattleObject::AnimBlendOut;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-animframe","title":"variable AnimFrame","text":"<pre><code>int32 ABattleObject::AnimFrame;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-animstructs","title":"variable AnimStructs","text":"<pre><code>TArray&lt;FAnimStruct&gt; ABattleObject::AnimStructs;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-attackflags","title":"variable AttackFlags","text":"<pre><code>uint32 ABattleObject::AttackFlags;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-attackowner","title":"variable AttackOwner","text":"<pre><code>ABattleObject* ABattleObject::AttackOwner;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-attacktarget","title":"variable AttackTarget","text":"<pre><code>ABattleObject* ABattleObject::AttackTarget;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-b","title":"variable B","text":"<pre><code>int32 ABattleObject::B;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-blendanimframe","title":"variable BlendAnimFrame","text":"<pre><code>int32 ABattleObject::BlendAnimFrame;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-blendcelname","title":"variable BlendCelName","text":"<pre><code>FGameplayTag ABattleObject::BlendCelName;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-blendoffset","title":"variable BlendOffset","text":"<pre><code>bool ABattleObject::BlendOffset;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-boxes","title":"variable Boxes","text":"<pre><code>TArray&lt;FCollisionBox&gt; ABattleObject::Boxes;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-celindex","title":"variable CelIndex","text":"<pre><code>int32 ABattleObject::CelIndex;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-celname","title":"variable CelName","text":"<pre><code>FGameplayTag ABattleObject::CelName;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-charaselectgamestate","title":"variable CharaSelectGameState","text":"<pre><code>TObjectPtr&lt;ANightSkyCharaSelectGameState&gt; ABattleObject::CharaSelectGameState;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-colposx","title":"variable ColPosX","text":"<pre><code>int32 ABattleObject::ColPosX;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-colposy","title":"variable ColPosY","text":"<pre><code>int32 ABattleObject::ColPosY;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-counterhit","title":"variable CounterHit","text":"<pre><code>FHitData ABattleObject::CounterHit;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-damagecolor","title":"variable DamageColor","text":"<pre><code>FLinearColor ABattleObject::DamageColor;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-damagecolor2","title":"variable DamageColor2","text":"<pre><code>FLinearColor ABattleObject::DamageColor2;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-direction","title":"variable Direction","text":"<pre><code>TEnumAsByte&lt;EObjDir&gt; ABattleObject::Direction;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-drawpriority","title":"variable DrawPriority","text":"<pre><code>int32 ABattleObject::DrawPriority;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-drawprioritylinkobj","title":"variable DrawPriorityLinkObj","text":"<pre><code>ABattleObject* ABattleObject::DrawPriorityLinkObj;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-eventhandlers","title":"variable EventHandlers","text":"<pre><code>FEventHandler ABattleObject::EventHandlers[EVT_NUM];\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-fadetransparency","title":"variable FadeTransparency","text":"<pre><code>float ABattleObject::FadeTransparency;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-frameblendposition","title":"variable FrameBlendPosition","text":"<pre><code>float ABattleObject::FrameBlendPosition;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-gamestate","title":"variable GameState","text":"<pre><code>TObjectPtr&lt;ANightSkyGameState&gt; ABattleObject::GameState;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-gotolabelactive","title":"variable GotoLabelActive","text":"<pre><code>bool ABattleObject::GotoLabelActive;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-gravity","title":"variable Gravity","text":"<pre><code>int32 ABattleObject::Gravity;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-groundheight","title":"variable GroundHeight","text":"<pre><code>int32 ABattleObject::GroundHeight;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-hitcommon","title":"variable HitCommon","text":"<pre><code>FHitDataCommon ABattleObject::HitCommon;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-hitstop","title":"variable Hitstop","text":"<pre><code>int32 ABattleObject::Hitstop;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-homingparams","title":"variable HomingParams","text":"<pre><code>FHomingParams ABattleObject::HomingParams;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-inertia","title":"variable Inertia","text":"<pre><code>int32 ABattleObject::Inertia;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-isactive","title":"variable IsActive","text":"<pre><code>bool ABattleObject::IsActive;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-isplayer","title":"variable IsPlayer","text":"<pre><code>bool ABattleObject::IsPlayer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-l","title":"variable L","text":"<pre><code>int32 ABattleObject::L;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-labelname","title":"variable LabelName","text":"<pre><code>FGameplayTag ABattleObject::LabelName;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-linkedactor","title":"variable LinkedActor","text":"<pre><code>TObjectPtr&lt;ALinkActor&gt; ABattleObject::LinkedActor;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-linkedparticle","title":"variable LinkedParticle","text":"<pre><code>TObjectPtr&lt;UNiagaraComponent&gt; ABattleObject::LinkedParticle;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-materiallinkobj","title":"variable MaterialLinkObj","text":"<pre><code>ABattleObject* ABattleObject::MaterialLinkObj;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-maxceltime","title":"variable MaxCelTime","text":"<pre><code>int32 ABattleObject::MaxCelTime;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-miscflags","title":"variable MiscFlags","text":"<pre><code>int32 ABattleObject::MiscFlags;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-mulcolor","title":"variable MulColor","text":"<pre><code>FLinearColor ABattleObject::MulColor;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-mulfadecolor","title":"variable MulFadeColor","text":"<pre><code>FLinearColor ABattleObject::MulFadeColor;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-mulfadespeed","title":"variable MulFadeSpeed","text":"<pre><code>float ABattleObject::MulFadeSpeed;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-nextoffsetx","title":"variable NextOffsetX","text":"<pre><code>int32 ABattleObject::NextOffsetX;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-nextoffsety","title":"variable NextOffsetY","text":"<pre><code>int32 ABattleObject::NextOffsetY;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-normalhit","title":"variable NormalHit","text":"<pre><code>FHitData ABattleObject::NormalHit;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objnumber","title":"variable ObjNumber","text":"<pre><code>uint32 ABattleObject::ObjNumber;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objsync","title":"variable ObjSync","text":"<pre><code>unsigned char ABattleObject::ObjSync;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objsyncend","title":"variable ObjSyncEnd","text":"<pre><code>unsigned char ABattleObject::ObjSyncEnd;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectid","title":"variable ObjectID","text":"<pre><code>uint32 ABattleObject::ObjectID;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectoffset","title":"variable ObjectOffset","text":"<pre><code>FVector ABattleObject::ObjectOffset;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectreg1","title":"variable ObjectReg1","text":"<pre><code>int32 ABattleObject::ObjectReg1;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectreg2","title":"variable ObjectReg2","text":"<pre><code>int32 ABattleObject::ObjectReg2;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectreg3","title":"variable ObjectReg3","text":"<pre><code>int32 ABattleObject::ObjectReg3;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectreg4","title":"variable ObjectReg4","text":"<pre><code>int32 ABattleObject::ObjectReg4;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectreg5","title":"variable ObjectReg5","text":"<pre><code>int32 ABattleObject::ObjectReg5;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectreg6","title":"variable ObjectReg6","text":"<pre><code>int32 ABattleObject::ObjectReg6;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectreg7","title":"variable ObjectReg7","text":"<pre><code>int32 ABattleObject::ObjectReg7;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectreg8","title":"variable ObjectReg8","text":"<pre><code>int32 ABattleObject::ObjectReg8;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectrotation","title":"variable ObjectRotation","text":"<pre><code>FRotator ABattleObject::ObjectRotation;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectscale","title":"variable ObjectScale","text":"<pre><code>FVector ABattleObject::ObjectScale;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectstate","title":"variable ObjectState","text":"<pre><code>TObjectPtr&lt;UState&gt; ABattleObject::ObjectState;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectstateindex","title":"variable ObjectStateIndex","text":"<pre><code>int32 ABattleObject::ObjectStateIndex;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectstatename","title":"variable ObjectStateName","text":"<pre><code>FGameplayTag ABattleObject::ObjectStateName;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-objectstoignorehitsfrom","title":"variable ObjectsToIgnoreHitsFrom","text":"<pre><code>TArray&lt;ABattleObject*&gt; ABattleObject::ObjectsToIgnoreHitsFrom;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-orthoblendactive","title":"variable OrthoBlendActive","text":"<pre><code>float ABattleObject::OrthoBlendActive;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-player","title":"variable Player","text":"<pre><code>APlayerObject* ABattleObject::Player;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-posx","title":"variable PosX","text":"<pre><code>int32 ABattleObject::PosX;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-posy","title":"variable PosY","text":"<pre><code>int32 ABattleObject::PosY;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-posz","title":"variable PosZ","text":"<pre><code>int32 ABattleObject::PosZ;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-positionlinkobj","title":"variable PositionLinkObj","text":"<pre><code>ABattleObject* ABattleObject::PositionLinkObj;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-prevoffsetx","title":"variable PrevOffsetX","text":"<pre><code>int32 ABattleObject::PrevOffsetX;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-prevoffsety","title":"variable PrevOffsetY","text":"<pre><code>int32 ABattleObject::PrevOffsetY;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-prevposx","title":"variable PrevPosX","text":"<pre><code>int32 ABattleObject::PrevPosX;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-prevposy","title":"variable PrevPosY","text":"<pre><code>int32 ABattleObject::PrevPosY;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-prevposz","title":"variable PrevPosZ","text":"<pre><code>int32 ABattleObject::PrevPosZ;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-prevrootmotionx","title":"variable PrevRootMotionX","text":"<pre><code>int32 ABattleObject::PrevRootMotionX;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-prevrootmotiony","title":"variable PrevRootMotionY","text":"<pre><code>int32 ABattleObject::PrevRootMotionY;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-prevrootmotionz","title":"variable PrevRootMotionZ","text":"<pre><code>int32 ABattleObject::PrevRootMotionZ;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-pushback","title":"variable Pushback","text":"<pre><code>int32 ABattleObject::Pushback;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-r","title":"variable R","text":"<pre><code>int32 ABattleObject::R;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-receivedhit","title":"variable ReceivedHit","text":"<pre><code>FHitData ABattleObject::ReceivedHit;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-receivedhitcommon","title":"variable ReceivedHitCommon","text":"<pre><code>FHitDataCommon ABattleObject::ReceivedHitCommon;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-screenspacedepthoffset","title":"variable ScreenSpaceDepthOffset","text":"<pre><code>float ABattleObject::ScreenSpaceDepthOffset;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-socketname","title":"variable SocketName","text":"<pre><code>FName ABattleObject::SocketName;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-socketobj","title":"variable SocketObj","text":"<pre><code>EObjType ABattleObject::SocketObj;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-socketoffset","title":"variable SocketOffset","text":"<pre><code>FVector ABattleObject::SocketOffset;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-speedx","title":"variable SpeedX","text":"<pre><code>int32 ABattleObject::SpeedX;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-speedxrate","title":"variable SpeedXRate","text":"<pre><code>int32 ABattleObject::SpeedXRate;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-speedxrateperframe","title":"variable SpeedXRatePerFrame","text":"<pre><code>int32 ABattleObject::SpeedXRatePerFrame;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-speedy","title":"variable SpeedY","text":"<pre><code>int32 ABattleObject::SpeedY;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-speedyrate","title":"variable SpeedYRate","text":"<pre><code>int32 ABattleObject::SpeedYRate;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-speedyrateperframe","title":"variable SpeedYRatePerFrame","text":"<pre><code>int32 ABattleObject::SpeedYRatePerFrame;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-speedz","title":"variable SpeedZ","text":"<pre><code>int32 ABattleObject::SpeedZ;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-speedzrate","title":"variable SpeedZRate","text":"<pre><code>int32 ABattleObject::SpeedZRate;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-speedzrateperframe","title":"variable SpeedZRatePerFrame","text":"<pre><code>int32 ABattleObject::SpeedZRatePerFrame;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-stoplinkobj","title":"variable StopLinkObj","text":"<pre><code>ABattleObject* ABattleObject::StopLinkObj;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-stuntime","title":"variable StunTime","text":"<pre><code>int32 ABattleObject::StunTime;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-stuntimemax","title":"variable StunTimeMax","text":"<pre><code>int32 ABattleObject::StunTimeMax;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-subroutinereg1","title":"variable SubroutineReg1","text":"<pre><code>int32 ABattleObject::SubroutineReg1;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-subroutinereg2","title":"variable SubroutineReg2","text":"<pre><code>int32 ABattleObject::SubroutineReg2;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-subroutinereg3","title":"variable SubroutineReg3","text":"<pre><code>int32 ABattleObject::SubroutineReg3;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-subroutinereg4","title":"variable SubroutineReg4","text":"<pre><code>int32 ABattleObject::SubroutineReg4;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-subroutinereturnval1","title":"variable SubroutineReturnVal1","text":"<pre><code>int32 ABattleObject::SubroutineReturnVal1;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-subroutinereturnval2","title":"variable SubroutineReturnVal2","text":"<pre><code>int32 ABattleObject::SubroutineReturnVal2;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-subroutinereturnval3","title":"variable SubroutineReturnVal3","text":"<pre><code>int32 ABattleObject::SubroutineReturnVal3;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-subroutinereturnval4","title":"variable SubroutineReturnVal4","text":"<pre><code>int32 ABattleObject::SubroutineReturnVal4;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-superarmordata","title":"variable SuperArmorData","text":"<pre><code>FSuperArmorData ABattleObject::SuperArmorData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-t","title":"variable T","text":"<pre><code>int32 ABattleObject::T;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-timeuntilnextcel","title":"variable TimeUntilNextCel","text":"<pre><code>int32 ABattleObject::TimeUntilNextCel;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-timer0","title":"variable Timer0","text":"<pre><code>int32 ABattleObject::Timer0;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-timer1","title":"variable Timer1","text":"<pre><code>int32 ABattleObject::Timer1;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-transparency","title":"variable Transparency","text":"<pre><code>float ABattleObject::Transparency;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-transparencyspeed","title":"variable TransparencySpeed","text":"<pre><code>float ABattleObject::TransparencySpeed;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-updatetime","title":"variable UpdateTime","text":"<pre><code>int32 ABattleObject::UpdateTime;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-biscommonstate","title":"variable bIsCommonState","text":"<pre><code>bool ABattleObject::bIsCommonState;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-brender","title":"variable bRender","text":"<pre><code>bool ABattleObject::bRender;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_battle_object/#function-abattleobject","title":"function ABattleObject","text":"<pre><code>ABattleObject::ABattleObject () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-addbattleobject","title":"function AddBattleObject","text":"<pre><code>ABattleObject * ABattleObject::AddBattleObject (\n    FGameplayTag InStateName,\n    int32 PosXOffset=0,\n    int32 PosYOffset=0,\n    EPosType PosType=POS_Player\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-addcommonbattleobject","title":"function AddCommonBattleObject","text":"<pre><code>ABattleObject * ABattleObject::AddCommonBattleObject (\n    FGameplayTag InStateName,\n    int32 PosXOffset=0,\n    int32 PosYOffset=0,\n    EPosType PosType=POS_Player\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-addposxwithdir","title":"function AddPosXWithDir","text":"<pre><code>void ABattleObject::AddPosXWithDir (\n    int InPosX\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-addspeedxraw","title":"function AddSpeedXRaw","text":"<pre><code>void ABattleObject::AddSpeedXRaw (\n    int InSpeedX\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-attachtosocketofobject","title":"function AttachToSocketOfObject","text":"<pre><code>void ABattleObject::AttachToSocketOfObject (\n    FName InSocketName,\n    FVector Offset,\n    EObjType ObjType\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-calculateanglebetweenpoints","title":"function CalculateAngleBetweenPoints","text":"<pre><code>int32 ABattleObject::CalculateAngleBetweenPoints (\n    EObjType Obj1,\n    EPosType Pos1,\n    EObjType Obj2,\n    EPosType Pos2\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-calculatedistancebetweenpoints","title":"function CalculateDistanceBetweenPoints","text":"<pre><code>int32 ABattleObject::CalculateDistanceBetweenPoints (\n    EDistanceType Type,\n    EObjType Obj1,\n    EPosType Pos1,\n    EObjType Obj2,\n    EPosType Pos2\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-calculatepushbox","title":"function CalculatePushbox","text":"<pre><code>void ABattleObject::CalculatePushbox () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-calculatespeedangle","title":"function CalculateSpeedAngle","text":"<pre><code>int32 ABattleObject::CalculateSpeedAngle () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-callsubroutine","title":"function CallSubroutine","text":"<pre><code>void ABattleObject::CallSubroutine (\n    FGameplayTag Name\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-callsubroutinewithargs","title":"function CallSubroutineWithArgs","text":"<pre><code>void ABattleObject::CallSubroutineWithArgs (\n    FGameplayTag Name,\n    int32 Arg1,\n    int32 Arg2,\n    int32 Arg3,\n    int32 Arg4\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-camerashake","title":"function CameraShake","text":"<pre><code>void ABattleObject::CameraShake (\n    FGameplayTag PatternName,\n    int32 Scale\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-checkboxoverlap","title":"function CheckBoxOverlap","text":"<pre><code>bool ABattleObject::CheckBoxOverlap (\n    ABattleObject * OtherObj,\n    const EBoxType SelfType,\n    const FGameplayTag SelfCustomType,\n    const EBoxType OtherType,\n    const FGameplayTag OtherCustomType\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-checkisgrounded","title":"function CheckIsGrounded","text":"<pre><code>bool ABattleObject::CheckIsGrounded () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-collisionview","title":"function CollisionView","text":"<pre><code>void ABattleObject::CollisionView () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-createcharaparticle","title":"function CreateCharaParticle","text":"<pre><code>void ABattleObject::CreateCharaParticle (\n    FGameplayTag Name,\n    EPosType PosType,\n    FVector Offset=FVector::ZeroVector,\n    FRotator Rotation=FRotator::ZeroRotator\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-createcommonparticle","title":"function CreateCommonParticle","text":"<pre><code>void ABattleObject::CreateCommonParticle (\n    FGameplayTag Name,\n    EPosType PosType,\n    FVector Offset=FVector::ZeroVector,\n    FRotator Rotation=FRotator::ZeroRotator\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-deactivateobject","title":"function DeactivateObject","text":"<pre><code>void ABattleObject::DeactivateObject () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-detachfromsocket","title":"function DetachFromSocket","text":"<pre><code>void ABattleObject::DetachFromSocket () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-disableinertia","title":"function DisableInertia","text":"<pre><code>void ABattleObject::DisableInertia () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-enabledeactivateifbeyondbounds","title":"function EnableDeactivateIfBeyondBounds","text":"<pre><code>void ABattleObject::EnableDeactivateIfBeyondBounds (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-enabledeactivateonreceivehit","title":"function EnableDeactivateOnReceiveHit","text":"<pre><code>void ABattleObject::EnableDeactivateOnReceiveHit (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-enabledeactivateonstatechange","title":"function EnableDeactivateOnStateChange","text":"<pre><code>void ABattleObject::EnableDeactivateOnStateChange (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-enableflip","title":"function EnableFlip","text":"<pre><code>void ABattleObject::EnableFlip (\n    bool Enabled\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-enablehit","title":"function EnableHit","text":"<pre><code>void ABattleObject::EnableHit (\n    bool Enabled\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-enableinertia","title":"function EnableInertia","text":"<pre><code>void ABattleObject::EnableInertia () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-faceopponent","title":"function FaceOpponent","text":"<pre><code>void ABattleObject::FaceOpponent () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-flipobject","title":"function FlipObject","text":"<pre><code>void ABattleObject::FlipObject () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-generaterandomnumber","title":"function GenerateRandomNumber","text":"<pre><code>int32 ABattleObject::GenerateRandomNumber (\n    int32 Min,\n    int32 Max\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-getanimsequenceforpart","title":"function GetAnimSequenceForPart","text":"<pre><code>UAnimSequenceBase * ABattleObject::GetAnimSequenceForPart (\n    const FName Part\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-getbattleobject","title":"function GetBattleObject","text":"<pre><code>ABattleObject * ABattleObject::GetBattleObject (\n    EObjType Type\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-getboxposition","title":"function GetBoxPosition","text":"<pre><code>void ABattleObject::GetBoxPosition (\n    const EBoxType BoxType,\n    const FGameplayTag CustomType,\n    int &amp; OutPosX,\n    int &amp; OutPosY\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-getboxes","title":"function GetBoxes","text":"<pre><code>void ABattleObject::GetBoxes () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-getcelname","title":"function GetCelName","text":"<pre><code>FGameplayTag ABattleObject::GetCelName () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-getflipbookforpart","title":"function GetFlipbookForPart","text":"<pre><code>UPaperFlipbook * ABattleObject::GetFlipbookForPart (\n    const FName Part\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-getgauge","title":"function GetGauge","text":"<pre><code>int32 ABattleObject::GetGauge (\n    int32 GaugeIndex\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-getlabelname","title":"function GetLabelName","text":"<pre><code>FGameplayTag ABattleObject::GetLabelName () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-getposycenter","title":"function GetPosYCenter","text":"<pre><code>int32 ABattleObject::GetPosYCenter () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-gotolabel","title":"function GotoLabel","text":"<pre><code>void ABattleObject::GotoLabel (\n    FGameplayTag InName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-haltmomentum","title":"function HaltMomentum","text":"<pre><code>void ABattleObject::HaltMomentum () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-handleclashcollision","title":"function HandleClashCollision","text":"<pre><code>void ABattleObject::HandleClashCollision (\n    ABattleObject * OtherObj\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-handlecustomcollision_posthit","title":"function HandleCustomCollision_PostHit","text":"<pre><code>void ABattleObject::HandleCustomCollision_PostHit (\n    ABattleObject * OtherObj\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-handlecustomcollision_prehit","title":"function HandleCustomCollision_PreHit","text":"<pre><code>void ABattleObject::HandleCustomCollision_PreHit (\n    ABattleObject * OtherObj\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-handleflip","title":"function HandleFlip","text":"<pre><code>void ABattleObject::HandleFlip () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-handlehitcollision","title":"function HandleHitCollision","text":"<pre><code>void ABattleObject::HandleHitCollision (\n    ABattleObject * AttackedObj\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-handlepushcollision","title":"function HandlePushCollision","text":"<pre><code>void ABattleObject::HandlePushCollision (\n    ABattleObject * OtherObj\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-ignoresuperfreeze","title":"function IgnoreSuperFreeze","text":"<pre><code>void ABattleObject::IgnoreSuperFreeze (\n    bool Ignore\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-initeventhandler","title":"function InitEventHandler","text":"<pre><code>void ABattleObject::InitEventHandler (\n    EEventType EventType,\n    FName FuncName,\n    int32 Value,\n    FGameplayTag SubroutineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-inithitdatabyattacklevel","title":"function InitHitDataByAttackLevel","text":"<pre><code>FHitData ABattleObject::InitHitDataByAttackLevel (\n    bool IsCounter\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-initobject","title":"function InitObject","text":"<pre><code>void ABattleObject::InitObject () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-isstopped","title":"function IsStopped","text":"<pre><code>bool ABattleObject::IsStopped () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-istimerpaused","title":"function IsTimerPaused","text":"<pre><code>bool ABattleObject::IsTimerPaused () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-linkactor","title":"function LinkActor","text":"<pre><code>ALinkActor * ABattleObject::LinkActor (\n    FGameplayTag Name\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-linkcharaparticle","title":"function LinkCharaParticle","text":"<pre><code>void ABattleObject::LinkCharaParticle (\n    FGameplayTag Name\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-linkcommonparticle","title":"function LinkCommonParticle","text":"<pre><code>void ABattleObject::LinkCommonParticle (\n    FGameplayTag Name\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-loadforrollback","title":"function LoadForRollback","text":"<pre><code>void ABattleObject::LoadForRollback (\n    const unsigned char * Buffer\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-playcharasound","title":"function PlayCharaSound","text":"<pre><code>void ABattleObject::PlayCharaSound (\n    FGameplayTag Name\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-playcommonsound","title":"function PlayCommonSound","text":"<pre><code>void ABattleObject::PlayCommonSound (\n    FGameplayTag Name\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-postypetoposition","title":"function PosTypeToPosition","text":"<pre><code>void ABattleObject::PosTypeToPosition (\n    EPosType Type,\n    int32 &amp; OutPosX,\n    int32 &amp; OutPosY\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-positionlinkupdate","title":"function PositionLinkUpdate","text":"<pre><code>void ABattleObject::PositionLinkUpdate () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-removeeventhandler","title":"function RemoveEventHandler","text":"<pre><code>void ABattleObject::RemoveEventHandler (\n    EEventType EventType\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-removelinkactor","title":"function RemoveLinkActor","text":"<pre><code>void ABattleObject::RemoveLinkActor () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-resetobject","title":"function ResetObject","text":"<pre><code>void ABattleObject::ResetObject () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-saveforrollback","title":"function SaveForRollback","text":"<pre><code>void ABattleObject::SaveForRollback (\n    unsigned char * Buffer\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-screenpostoworldpos","title":"function ScreenPosToWorldPos","text":"<pre><code>void ABattleObject::ScreenPosToWorldPos (\n    const int32 X,\n    const int32 Y,\n    int32 &amp; OutX,\n    int32 &amp; OutY\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setattacking","title":"function SetAttacking","text":"<pre><code>void ABattleObject::SetAttacking (\n    bool Attacking\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setblendcelname","title":"function SetBlendCelName","text":"<pre><code>void ABattleObject::SetBlendCelName (\n    FGameplayTag InName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setcelduration","title":"function SetCelDuration","text":"<pre><code>void ABattleObject::SetCelDuration (\n    int32 InTime\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setcelname","title":"function SetCelName","text":"<pre><code>void ABattleObject::SetCelName (\n    FGameplayTag InName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setfacing","title":"function SetFacing","text":"<pre><code>void ABattleObject::SetFacing (\n    EObjDir NewDir\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setfloorcollisionactive","title":"function SetFloorCollisionActive","text":"<pre><code>void ABattleObject::SetFloorCollisionActive (\n    bool Active\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setgauge","title":"function SetGauge","text":"<pre><code>void ABattleObject::SetGauge (\n    int32 GaugeIndex,\n    int32 Value\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-sethitotg","title":"function SetHitOTG","text":"<pre><code>void ABattleObject::SetHitOTG (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setignorehitstunscaling","title":"function SetIgnoreHitstunScaling","text":"<pre><code>void ABattleObject::SetIgnoreHitstunScaling (\n    bool Ignore\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setignoreotg","title":"function SetIgnoreOTG","text":"<pre><code>void ABattleObject::SetIgnoreOTG (\n    bool Ignore\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setignorepushbackscaling","title":"function SetIgnorePushbackScaling","text":"<pre><code>void ABattleObject::SetIgnorePushbackScaling (\n    bool Ignore\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setobjectid","title":"function SetObjectID","text":"<pre><code>void ABattleObject::SetObjectID (\n    int InObjectID\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setpitch","title":"function SetPitch","text":"<pre><code>void ABattleObject::SetPitch (\n    int32 Pitch_x1000\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setplayerhit","title":"function SetPlayerHit","text":"<pre><code>void ABattleObject::SetPlayerHit (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setprojectileattribute","title":"function SetProjectileAttribute","text":"<pre><code>void ABattleObject::SetProjectileAttribute (\n    bool Attribute\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setprorateonce","title":"function SetProrateOnce","text":"<pre><code>void ABattleObject::SetProrateOnce (\n    bool Once\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setpushcollisionactive","title":"function SetPushCollisionActive","text":"<pre><code>void ABattleObject::SetPushCollisionActive (\n    bool Active\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setpushwidthextend","title":"function SetPushWidthExtend","text":"<pre><code>void ABattleObject::SetPushWidthExtend (\n    int32 Extend\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setroll","title":"function SetRoll","text":"<pre><code>void ABattleObject::SetRoll (\n    int32 Roll_x1000\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setspeedxraw","title":"function SetSpeedXRaw","text":"<pre><code>void ABattleObject::SetSpeedXRaw (\n    int InSpeedX\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-settimeuntilnextcel","title":"function SetTimeUntilNextCel","text":"<pre><code>void ABattleObject::SetTimeUntilNextCel (\n    int32 InTime\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setwallcollisionactive","title":"function SetWallCollisionActive","text":"<pre><code>void ABattleObject::SetWallCollisionActive (\n    bool Active\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-setyaw","title":"function SetYaw","text":"<pre><code>void ABattleObject::SetYaw (\n    int32 Yaw_x1000\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-startsuperfreeze","title":"function StartSuperFreeze","text":"<pre><code>void ABattleObject::StartSuperFreeze (\n    int Duration,\n    int SelfDuration=0\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-tick","title":"function Tick","text":"<pre><code>virtual void ABattleObject::Tick (\n    float DeltaTime\n) override\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-triggerevent","title":"function TriggerEvent","text":"<pre><code>void ABattleObject::TriggerEvent (\n    EEventType EventType,\n    FGameplayTag StateMachineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-update","title":"function Update","text":"<pre><code>virtual void ABattleObject::Update () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-updatevisuals","title":"function UpdateVisuals","text":"<pre><code>virtual void ABattleObject::UpdateVisuals () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-updatevisualsnorollback","title":"function UpdateVisualsNoRollback","text":"<pre><code>virtual void ABattleObject::UpdateVisualsNoRollback () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-updatevisuals_bp","title":"function UpdateVisuals_BP","text":"<pre><code>void ABattleObject::UpdateVisuals_BP () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-usegauge","title":"function UseGauge","text":"<pre><code>void ABattleObject::UseGauge (\n    int32 GaugeIndex,\n    int32 Value\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_battle_object/#function-normalizeangle","title":"function NormalizeAngle","text":"<pre><code>static int32 ABattleObject::NormalizeAngle (\n    int32 Angle_x1000\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_battle_object/#variable-pushheight","title":"variable PushHeight","text":"<pre><code>int32 ABattleObject::PushHeight;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-pushheightlow","title":"variable PushHeightLow","text":"<pre><code>int32 ABattleObject::PushHeightLow;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-pushwidth","title":"variable PushWidth","text":"<pre><code>int32 ABattleObject::PushWidth;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#variable-pushwidthextend","title":"variable PushWidthExtend","text":"<pre><code>int32 ABattleObject::PushWidthExtend;\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_battle_object/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void ABattleObject::BeginPlay () override\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-calculatehoming","title":"function CalculateHoming","text":"<pre><code>void ABattleObject::CalculateHoming () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-funccall","title":"function FuncCall","text":"<pre><code>void ABattleObject::FuncCall (\n    const FName &amp; FuncName\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-getanimsequenceuserdata","title":"function GetAnimSequenceUserData","text":"<pre><code>UNightSkyAnimSequenceUserData * ABattleObject::GetAnimSequenceUserData (\n    const FName PartName\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-getanimsequenceuserdatas","title":"function GetAnimSequenceUserDatas","text":"<pre><code>TArray&lt; UNightSkyAnimSequenceUserData * &gt; ABattleObject::GetAnimSequenceUserDatas () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-move","title":"function Move","text":"<pre><code>void ABattleObject::Move () \n</code></pre>"},{"location":"NightSkyEngine/class_a_battle_object/#function-superarmorsuccess","title":"function SuperArmorSuccess","text":"<pre><code>bool ABattleObject::SuperArmorSuccess (\n    const ABattleObject * Attacker\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.h</code></p>"},{"location":"NightSkyEngine/class_a_fighter_local_runner/","title":"Class AFighterLocalRunner","text":"<p>ClassList &gt; AFighterLocalRunner</p> <p>Inherits the following classes: AActor</p> <p>Inherited by the following classes: AFighterMultiplayerRunner,  AFighterReplayRunner</p>"},{"location":"NightSkyEngine/class_a_fighter_local_runner/#public-functions","title":"Public Functions","text":"Type Name AFighterLocalRunner ()  virtual void Update (float DeltaTime)"},{"location":"NightSkyEngine/class_a_fighter_local_runner/#protected-attributes","title":"Protected Attributes","text":"Type Name float ElapsedTime   = <code>0</code> class ANightSkyGameState * GameState"},{"location":"NightSkyEngine/class_a_fighter_local_runner/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_fighter_local_runner/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_fighter_local_runner/#function-afighterlocalrunner","title":"function AFighterLocalRunner","text":"<pre><code>AFighterLocalRunner::AFighterLocalRunner () \n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_local_runner/#function-update","title":"function Update","text":"<pre><code>virtual void AFighterLocalRunner::Update (\n    float DeltaTime\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_local_runner/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_fighter_local_runner/#variable-elapsedtime","title":"variable ElapsedTime","text":"<pre><code>float AFighterLocalRunner::ElapsedTime;\n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_local_runner/#variable-gamestate","title":"variable GameState","text":"<pre><code>class ANightSkyGameState* AFighterLocalRunner::GameState;\n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_local_runner/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_fighter_local_runner/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void AFighterLocalRunner::BeginPlay () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterLocalRunner.h</code></p>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/","title":"Class AFighterMultiplayerRunner","text":"<p>ClassList &gt; AFighterMultiplayerRunner</p> <p>Inherits the following classes: AFighterLocalRunner</p> <p>Inherited by the following classes: AFighterSynctestRunner</p>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; GGPOPlayerHandle &gt; PlayerHandles TArray&lt; GGPOPlayer * &gt; Players class RpcConnectionManager * connectionManager GGPOSession * ggpo   = <code>nullptr</code>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#public-functions","title":"Public Functions","text":"Type Name AFighterMultiplayerRunner ()  virtual void Update (float DeltaTime) override"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#public-functions-inherited-from-afighterlocalrunner","title":"Public Functions inherited from AFighterLocalRunner","text":"<p>See AFighterLocalRunner</p> Type Name AFighterLocalRunner ()  virtual void Update (float DeltaTime)"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#public-static-functions","title":"Public Static Functions","text":"Type Name int fletcher32_checksum (short * data, size_t len)"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#protected-attributes","title":"Protected Attributes","text":"Type Name int MultipliedFramesAhead   = <code>0</code> int MultipliedFramesBehind   = <code>0</code> TArray&lt; int &gt; PlayerInputIndex"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#protected-attributes-inherited-from-afighterlocalrunner","title":"Protected Attributes inherited from AFighterLocalRunner","text":"<p>See AFighterLocalRunner</p> Type Name float ElapsedTime   = <code>0</code> class ANightSkyGameState * GameState"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#protected-functions","title":"Protected Functions","text":"Type Name bool __cdecl AdvanceFrameCallback (int32)  bool __cdecl BeginGameCallback (const char *)  virtual void BeginPlay () override GGPOSessionCallbacks CreateCallbacks ()  virtual void EndPlay (const EEndPlayReason::Type EndPlayReason) override void __cdecl FreeBuffer (void * buffer)  void GgpoUpdate ()  bool __cdecl LoadGameStateCallback (unsigned char * buffer, int32 len)  bool __cdecl LogGameState (const char * filename, unsigned char * buffer, int len)  bool __cdecl OnEventCallback (GGPOEvent * info)  bool __cdecl SaveGameStateCallback (unsigned char ** buffer, int32 * len, int32 * checksum, int32)"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#protected-functions-inherited-from-afighterlocalrunner","title":"Protected Functions inherited from AFighterLocalRunner","text":"<p>See AFighterLocalRunner</p> Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#variable-playerhandles","title":"variable PlayerHandles","text":"<pre><code>TArray&lt;GGPOPlayerHandle&gt; AFighterMultiplayerRunner::PlayerHandles;\n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#variable-players","title":"variable Players","text":"<pre><code>TArray&lt;GGPOPlayer*&gt; AFighterMultiplayerRunner::Players;\n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#variable-connectionmanager","title":"variable connectionManager","text":"<pre><code>class RpcConnectionManager* AFighterMultiplayerRunner::connectionManager;\n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#variable-ggpo","title":"variable ggpo","text":"<pre><code>GGPOSession* AFighterMultiplayerRunner::ggpo;\n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#function-afightermultiplayerrunner","title":"function AFighterMultiplayerRunner","text":"<pre><code>AFighterMultiplayerRunner::AFighterMultiplayerRunner () \n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#function-update","title":"function Update","text":"<pre><code>virtual void AFighterMultiplayerRunner::Update (\n    float DeltaTime\n) override\n</code></pre> <p>Implements AFighterLocalRunner::Update</p>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#function-fletcher32_checksum","title":"function fletcher32_checksum","text":"<pre><code>static int AFighterMultiplayerRunner::fletcher32_checksum (\n    short * data,\n    size_t len\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#variable-multipliedframesahead","title":"variable MultipliedFramesAhead","text":"<pre><code>int AFighterMultiplayerRunner::MultipliedFramesAhead;\n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#variable-multipliedframesbehind","title":"variable MultipliedFramesBehind","text":"<pre><code>int AFighterMultiplayerRunner::MultipliedFramesBehind;\n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#variable-playerinputindex","title":"variable PlayerInputIndex","text":"<pre><code>TArray&lt;int&gt; AFighterMultiplayerRunner::PlayerInputIndex;\n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#function-advanceframecallback","title":"function AdvanceFrameCallback","text":"<pre><code>bool __cdecl AFighterMultiplayerRunner::AdvanceFrameCallback (\n    int32\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#function-begingamecallback","title":"function BeginGameCallback","text":"<pre><code>bool __cdecl AFighterMultiplayerRunner::BeginGameCallback (\n    const char *\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void AFighterMultiplayerRunner::BeginPlay () override\n</code></pre> <p>Implements AFighterLocalRunner::BeginPlay</p>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#function-createcallbacks","title":"function CreateCallbacks","text":"<pre><code>GGPOSessionCallbacks AFighterMultiplayerRunner::CreateCallbacks () \n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#function-endplay","title":"function EndPlay","text":"<pre><code>virtual void AFighterMultiplayerRunner::EndPlay (\n    const EEndPlayReason::Type EndPlayReason\n) override\n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#function-freebuffer","title":"function FreeBuffer","text":"<pre><code>void __cdecl AFighterMultiplayerRunner::FreeBuffer (\n    void * buffer\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#function-ggpoupdate","title":"function GgpoUpdate","text":"<pre><code>void AFighterMultiplayerRunner::GgpoUpdate () \n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#function-loadgamestatecallback","title":"function LoadGameStateCallback","text":"<pre><code>bool __cdecl AFighterMultiplayerRunner::LoadGameStateCallback (\n    unsigned char * buffer,\n    int32 len\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#function-loggamestate","title":"function LogGameState","text":"<pre><code>bool __cdecl AFighterMultiplayerRunner::LogGameState (\n    const char * filename,\n    unsigned char * buffer,\n    int len\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#function-oneventcallback","title":"function OnEventCallback","text":"<pre><code>bool __cdecl AFighterMultiplayerRunner::OnEventCallback (\n    GGPOEvent * info\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_multiplayer_runner/#function-savegamestatecallback","title":"function SaveGameStateCallback","text":"<pre><code>bool __cdecl AFighterMultiplayerRunner::SaveGameStateCallback (\n    unsigned char ** buffer,\n    int32 * len,\n    int32 * checksum,\n    int32\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterMultiplayerRunner.h</code></p>"},{"location":"NightSkyEngine/class_a_fighter_replay_runner/","title":"Class AFighterReplayRunner","text":"<p>ClassList &gt; AFighterReplayRunner</p> <p>Inherits the following classes: AFighterLocalRunner</p>"},{"location":"NightSkyEngine/class_a_fighter_replay_runner/#public-functions","title":"Public Functions","text":"Type Name AFighterReplayRunner ()  virtual void Update (float DeltaTime) override"},{"location":"NightSkyEngine/class_a_fighter_replay_runner/#public-functions-inherited-from-afighterlocalrunner","title":"Public Functions inherited from AFighterLocalRunner","text":"<p>See AFighterLocalRunner</p> Type Name AFighterLocalRunner ()  virtual void Update (float DeltaTime)"},{"location":"NightSkyEngine/class_a_fighter_replay_runner/#protected-attributes","title":"Protected Attributes","text":"Type Name UNightSkyGameInstance * GameInstance"},{"location":"NightSkyEngine/class_a_fighter_replay_runner/#protected-attributes-inherited-from-afighterlocalrunner","title":"Protected Attributes inherited from AFighterLocalRunner","text":"<p>See AFighterLocalRunner</p> Type Name float ElapsedTime   = <code>0</code> class ANightSkyGameState * GameState"},{"location":"NightSkyEngine/class_a_fighter_replay_runner/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_fighter_replay_runner/#protected-functions-inherited-from-afighterlocalrunner","title":"Protected Functions inherited from AFighterLocalRunner","text":"<p>See AFighterLocalRunner</p> Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_fighter_replay_runner/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_fighter_replay_runner/#function-afighterreplayrunner","title":"function AFighterReplayRunner","text":"<pre><code>AFighterReplayRunner::AFighterReplayRunner () \n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_replay_runner/#function-update","title":"function Update","text":"<pre><code>virtual void AFighterReplayRunner::Update (\n    float DeltaTime\n) override\n</code></pre> <p>Implements AFighterLocalRunner::Update</p>"},{"location":"NightSkyEngine/class_a_fighter_replay_runner/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_fighter_replay_runner/#variable-gameinstance","title":"variable GameInstance","text":"<pre><code>UNightSkyGameInstance* AFighterReplayRunner::GameInstance;\n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_replay_runner/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_fighter_replay_runner/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void AFighterReplayRunner::BeginPlay () override\n</code></pre> <p>Implements AFighterLocalRunner::BeginPlay</p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterReplayRunner.h</code></p>"},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/","title":"Class AFighterSynctestRunner","text":"<p>ClassList &gt; AFighterSynctestRunner</p> <p>Inherits the following classes: AFighterMultiplayerRunner</p>"},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#public-attributes-inherited-from-afightermultiplayerrunner","title":"Public Attributes inherited from AFighterMultiplayerRunner","text":"<p>See AFighterMultiplayerRunner</p> Type Name TArray&lt; GGPOPlayerHandle &gt; PlayerHandles TArray&lt; GGPOPlayer * &gt; Players class RpcConnectionManager * connectionManager GGPOSession * ggpo   = <code>nullptr</code>"},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#public-functions","title":"Public Functions","text":"Type Name AFighterSynctestRunner ()  virtual void Update (float DeltaTime) override"},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#public-functions-inherited-from-afightermultiplayerrunner","title":"Public Functions inherited from AFighterMultiplayerRunner","text":"<p>See AFighterMultiplayerRunner</p> Type Name AFighterMultiplayerRunner ()  virtual void Update (float DeltaTime) override"},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#public-functions-inherited-from-afighterlocalrunner","title":"Public Functions inherited from AFighterLocalRunner","text":"<p>See AFighterLocalRunner</p> Type Name AFighterLocalRunner ()  virtual void Update (float DeltaTime)"},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#public-static-functions-inherited-from-afightermultiplayerrunner","title":"Public Static Functions inherited from AFighterMultiplayerRunner","text":"<p>See AFighterMultiplayerRunner</p> Type Name int fletcher32_checksum (short * data, size_t len)"},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#protected-attributes-inherited-from-afightermultiplayerrunner","title":"Protected Attributes inherited from AFighterMultiplayerRunner","text":"<p>See AFighterMultiplayerRunner</p> Type Name int MultipliedFramesAhead   = <code>0</code> int MultipliedFramesBehind   = <code>0</code> TArray&lt; int &gt; PlayerInputIndex"},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#protected-attributes-inherited-from-afighterlocalrunner","title":"Protected Attributes inherited from AFighterLocalRunner","text":"<p>See AFighterLocalRunner</p> Type Name float ElapsedTime   = <code>0</code> class ANightSkyGameState * GameState"},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#protected-functions-inherited-from-afightermultiplayerrunner","title":"Protected Functions inherited from AFighterMultiplayerRunner","text":"<p>See AFighterMultiplayerRunner</p> Type Name bool __cdecl AdvanceFrameCallback (int32)  bool __cdecl BeginGameCallback (const char *)  virtual void BeginPlay () override GGPOSessionCallbacks CreateCallbacks ()  virtual void EndPlay (const EEndPlayReason::Type EndPlayReason) override void __cdecl FreeBuffer (void * buffer)  void GgpoUpdate ()  bool __cdecl LoadGameStateCallback (unsigned char * buffer, int32 len)  bool __cdecl LogGameState (const char * filename, unsigned char * buffer, int len)  bool __cdecl OnEventCallback (GGPOEvent * info)  bool __cdecl SaveGameStateCallback (unsigned char ** buffer, int32 * len, int32 * checksum, int32)"},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#protected-functions-inherited-from-afighterlocalrunner","title":"Protected Functions inherited from AFighterLocalRunner","text":"<p>See AFighterLocalRunner</p> Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#function-afightersynctestrunner","title":"function AFighterSynctestRunner","text":"<pre><code>AFighterSynctestRunner::AFighterSynctestRunner () \n</code></pre>"},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#function-update","title":"function Update","text":"<pre><code>virtual void AFighterSynctestRunner::Update (\n    float DeltaTime\n) override\n</code></pre> <p>Implements AFighterMultiplayerRunner::Update</p>"},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_fighter_synctest_runner/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void AFighterSynctestRunner::BeginPlay () override\n</code></pre> <p>Implements AFighterMultiplayerRunner::BeginPlay</p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterSynctestRunner.h</code></p>"},{"location":"NightSkyEngine/class_a_link_actor/","title":"Class ALinkActor","text":"<p>ClassList &gt; ALinkActor</p> <p>Inherits the following classes: AActor</p>"},{"location":"NightSkyEngine/class_a_link_actor/#public-functions","title":"Public Functions","text":"Type Name ALinkActor ()  void Exit ()  void Init ()  virtual void Tick (float DeltaTime) override void Update ()"},{"location":"NightSkyEngine/class_a_link_actor/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_link_actor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_link_actor/#function-alinkactor","title":"function ALinkActor","text":"<pre><code>ALinkActor::ALinkActor () \n</code></pre>"},{"location":"NightSkyEngine/class_a_link_actor/#function-exit","title":"function Exit","text":"<pre><code>void ALinkActor::Exit () \n</code></pre>"},{"location":"NightSkyEngine/class_a_link_actor/#function-init","title":"function Init","text":"<pre><code>void ALinkActor::Init () \n</code></pre>"},{"location":"NightSkyEngine/class_a_link_actor/#function-tick","title":"function Tick","text":"<pre><code>virtual void ALinkActor::Tick (\n    float DeltaTime\n) override\n</code></pre>"},{"location":"NightSkyEngine/class_a_link_actor/#function-update","title":"function Update","text":"<pre><code>void ALinkActor::Update () \n</code></pre>"},{"location":"NightSkyEngine/class_a_link_actor/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_link_actor/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void ALinkActor::BeginPlay () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/LinkActor.h</code></p>"},{"location":"NightSkyEngine/class_a_network_pawn/","title":"Class ANetworkPawn","text":"<p>ClassList &gt; ANetworkPawn</p> <p>Inherits the following classes: APawn</p>"},{"location":"NightSkyEngine/class_a_network_pawn/#public-attributes","title":"Public Attributes","text":"Type Name bool CharaDataReceived   = <code>false</code> class AFighterMultiplayerRunner * FighterMultiplayerRunner   = <code>nullptr</code> bool bRematchAccepted   = <code>false</code>"},{"location":"NightSkyEngine/class_a_network_pawn/#public-functions","title":"Public Functions","text":"Type Name ANetworkPawn ()  void ClientChecksumCheck (uint32 Checksum, int32 InFrame)  void ClientGetBattleData (FBattleData InBattleData, FNetworkMirror Mirror)  void ClientGetCharaData (TArray&lt; FPrimaryAssetId &gt; Assets)  virtual void GetLifetimeReplicatedProps (TArray&lt; FLifetimeProperty &gt; &amp; OutLifetimeProps) override const void SendGgpoToClient (const TArray&lt; int8 &gt; &amp; GgpoMessage)  void SendGgpoToServer (const TArray&lt; int8 &gt; &amp; GgpoMessage)  void SendRematchToServer ()  void ServerChecksumCheck (uint32 Checksum, int32 InFrame)  void ServerGetBattleData (FBattleData InBattleData, FNetworkMirror Mirror)  void ServerGetCharaData (TArray&lt; FPrimaryAssetId &gt; Assets)  void ServerGetFinishedLoading (bool Finished)"},{"location":"NightSkyEngine/class_a_network_pawn/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_network_pawn/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_network_pawn/#variable-charadatareceived","title":"variable CharaDataReceived","text":"<pre><code>bool ANetworkPawn::CharaDataReceived;\n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#variable-fightermultiplayerrunner","title":"variable FighterMultiplayerRunner","text":"<pre><code>class AFighterMultiplayerRunner* ANetworkPawn::FighterMultiplayerRunner;\n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#variable-brematchaccepted","title":"variable bRematchAccepted","text":"<pre><code>bool ANetworkPawn::bRematchAccepted;\n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_network_pawn/#function-anetworkpawn","title":"function ANetworkPawn","text":"<pre><code>ANetworkPawn::ANetworkPawn () \n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#function-clientchecksumcheck","title":"function ClientChecksumCheck","text":"<pre><code>void ANetworkPawn::ClientChecksumCheck (\n    uint32 Checksum,\n    int32 InFrame\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#function-clientgetbattledata","title":"function ClientGetBattleData","text":"<pre><code>void ANetworkPawn::ClientGetBattleData (\n    FBattleData InBattleData,\n    FNetworkMirror Mirror\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#function-clientgetcharadata","title":"function ClientGetCharaData","text":"<pre><code>void ANetworkPawn::ClientGetCharaData (\n    TArray&lt; FPrimaryAssetId &gt; Assets\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#function-getlifetimereplicatedprops","title":"function GetLifetimeReplicatedProps","text":"<pre><code>virtual void ANetworkPawn::GetLifetimeReplicatedProps (\n    TArray&lt; FLifetimeProperty &gt; &amp; OutLifetimeProps\n) override const\n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#function-sendggpotoclient","title":"function SendGgpoToClient","text":"<pre><code>void ANetworkPawn::SendGgpoToClient (\n    const TArray&lt; int8 &gt; &amp; GgpoMessage\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#function-sendggpotoserver","title":"function SendGgpoToServer","text":"<pre><code>void ANetworkPawn::SendGgpoToServer (\n    const TArray&lt; int8 &gt; &amp; GgpoMessage\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#function-sendrematchtoserver","title":"function SendRematchToServer","text":"<pre><code>void ANetworkPawn::SendRematchToServer () \n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#function-serverchecksumcheck","title":"function ServerChecksumCheck","text":"<pre><code>void ANetworkPawn::ServerChecksumCheck (\n    uint32 Checksum,\n    int32 InFrame\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#function-servergetbattledata","title":"function ServerGetBattleData","text":"<pre><code>void ANetworkPawn::ServerGetBattleData (\n    FBattleData InBattleData,\n    FNetworkMirror Mirror\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#function-servergetcharadata","title":"function ServerGetCharaData","text":"<pre><code>void ANetworkPawn::ServerGetCharaData (\n    TArray&lt; FPrimaryAssetId &gt; Assets\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#function-servergetfinishedloading","title":"function ServerGetFinishedLoading","text":"<pre><code>void ANetworkPawn::ServerGetFinishedLoading (\n    bool Finished\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_network_pawn/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_network_pawn/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void ANetworkPawn::BeginPlay () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Network/NetworkPawn.h</code></p>"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/","title":"Class ANightSkyAIController","text":"<p>ClassList &gt; ANightSkyAIController</p> <p>Inherits the following classes: AAIController</p>"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#public-attributes","title":"Public Attributes","text":"Type Name TObjectPtr&lt; ANightSkyGameState &gt; GameState   = <code>nullptr</code> TObjectPtr&lt; APlayerObject &gt; Player   = <code>nullptr</code>"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#public-functions","title":"Public Functions","text":"Type Name ANightSkyAIController ()  int32 CheckAttackWeight (const UState * State) const int32 CheckBasicWeight (const UState * State) const int32 CheckDefenseWeight (const UState * State)  int32 GetEnemyDistanceX () const int32 GetEnemyDistanceY () const void ResetParams ()  bool SetInputs ()  void Update ()"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#variable-gamestate","title":"variable GameState","text":"<pre><code>TObjectPtr&lt;ANightSkyGameState&gt; ANightSkyAIController::GameState;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#variable-player","title":"variable Player","text":"<pre><code>TObjectPtr&lt;APlayerObject&gt; ANightSkyAIController::Player;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#function-anightskyaicontroller","title":"function ANightSkyAIController","text":"<pre><code>ANightSkyAIController::ANightSkyAIController () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#function-checkattackweight","title":"function CheckAttackWeight","text":"<pre><code>int32 ANightSkyAIController::CheckAttackWeight (\n    const UState * State\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#function-checkbasicweight","title":"function CheckBasicWeight","text":"<pre><code>int32 ANightSkyAIController::CheckBasicWeight (\n    const UState * State\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#function-checkdefenseweight","title":"function CheckDefenseWeight","text":"<pre><code>int32 ANightSkyAIController::CheckDefenseWeight (\n    const UState * State\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#function-getenemydistancex","title":"function GetEnemyDistanceX","text":"<pre><code>int32 ANightSkyAIController::GetEnemyDistanceX () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#function-getenemydistancey","title":"function GetEnemyDistanceY","text":"<pre><code>int32 ANightSkyAIController::GetEnemyDistanceY () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#function-resetparams","title":"function ResetParams","text":"<pre><code>void ANightSkyAIController::ResetParams () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#function-setinputs","title":"function SetInputs","text":"<pre><code>bool ANightSkyAIController::SetInputs () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#function-update","title":"function Update","text":"<pre><code>void ANightSkyAIController::Update () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_a_i_controller/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void ANightSkyAIController::BeginPlay () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/CPU/NightSkyAIController.h</code></p>"},{"location":"NightSkyEngine/class_a_night_sky_battle_hud_actor/","title":"Class ANightSkyBattleHudActor","text":"<p>ClassList &gt; ANightSkyBattleHudActor</p> <p>Inherits the following classes: AActor</p>"},{"location":"NightSkyEngine/class_a_night_sky_battle_hud_actor/#public-attributes","title":"Public Attributes","text":"Type Name UNightSkyBattleWidget * BottomWidget UNightSkyBattleWidget * TopWidget"},{"location":"NightSkyEngine/class_a_night_sky_battle_hud_actor/#public-functions","title":"Public Functions","text":"Type Name ANightSkyBattleHudActor ()"},{"location":"NightSkyEngine/class_a_night_sky_battle_hud_actor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_battle_hud_actor/#variable-bottomwidget","title":"variable BottomWidget","text":"<pre><code>UNightSkyBattleWidget* ANightSkyBattleHudActor::BottomWidget;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_battle_hud_actor/#variable-topwidget","title":"variable TopWidget","text":"<pre><code>UNightSkyBattleWidget* ANightSkyBattleHudActor::TopWidget;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_battle_hud_actor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_battle_hud_actor/#function-anightskybattlehudactor","title":"function ANightSkyBattleHudActor","text":"<pre><code>ANightSkyBattleHudActor::ANightSkyBattleHudActor () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/UI/NightSkyBattleHudActor.h</code></p>"},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/","title":"Class ANightSkyCharaSelectGameState","text":"<p>ClassList &gt; ANightSkyCharaSelectGameState</p> <p>Inherits the following classes: AGameStateBase</p>"},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; APlayerObject * &gt; P1Charas TArray&lt; FVector &gt; P1Positions TArray&lt; APlayerObject * &gt; P2Charas TArray&lt; FVector &gt; P2Positions"},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#public-functions","title":"Public Functions","text":"Type Name ANightSkyCharaSelectGameState ()  void AddColorIndex (int InColor, bool IsP1=true)  void AddPlayerObject (UPrimaryCharaData * Player, bool IsP1=true)  virtual void Tick (float DeltaTime) override"},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#variable-p1charas","title":"variable P1Charas","text":"<pre><code>TArray&lt;APlayerObject*&gt; ANightSkyCharaSelectGameState::P1Charas;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#variable-p1positions","title":"variable P1Positions","text":"<pre><code>TArray&lt;FVector&gt; ANightSkyCharaSelectGameState::P1Positions;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#variable-p2charas","title":"variable P2Charas","text":"<pre><code>TArray&lt;APlayerObject*&gt; ANightSkyCharaSelectGameState::P2Charas;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#variable-p2positions","title":"variable P2Positions","text":"<pre><code>TArray&lt;FVector&gt; ANightSkyCharaSelectGameState::P2Positions;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#function-anightskycharaselectgamestate","title":"function ANightSkyCharaSelectGameState","text":"<pre><code>ANightSkyCharaSelectGameState::ANightSkyCharaSelectGameState () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#function-addcolorindex","title":"function AddColorIndex","text":"<pre><code>void ANightSkyCharaSelectGameState::AddColorIndex (\n    int InColor,\n    bool IsP1=true\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#function-addplayerobject","title":"function AddPlayerObject","text":"<pre><code>void ANightSkyCharaSelectGameState::AddPlayerObject (\n    UPrimaryCharaData * Player,\n    bool IsP1=true\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#function-tick","title":"function Tick","text":"<pre><code>virtual void ANightSkyCharaSelectGameState::Tick (\n    float DeltaTime\n) override\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_chara_select_game_state/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void ANightSkyCharaSelectGameState::BeginPlay () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/CharaSelect/NightSkyCharaSelectGameState.h</code></p>"},{"location":"NightSkyEngine/class_a_night_sky_engine_game_mode_base/","title":"Class ANightSkyEngineGameModeBase","text":"<p>ClassList &gt; ANightSkyEngineGameModeBase</p> <p>Inherits the following classes: AGameModeBase</p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkyEngineGameModeBase.h</code></p>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/","title":"Class ANightSkyGameState","text":"<p>ClassList &gt; ANightSkyGameState</p> <p>Inherits the following classes: AGameStateBase</p> <p>Inherited by the following classes: ANightSkyWTGameState</p>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#public-attributes","title":"Public Attributes","text":"Type Name AAudioManager * AudioManager   = <code>nullptr</code> UBattleExtensionData * BattleExtensionData   = <code>{}</code> TArray&lt; FGameplayTag &gt; BattleExtensionNames   = <code>{}</code> TArray&lt; UBattleExtension * &gt; BattleExtensions   = <code>{}</code> ANightSkyBattleHudActor * BattleHudActor   = <code>nullptr</code> TSubclassOf&lt; ABattleObject &gt; BattleObjectClass   = <code>ABattleObject::StaticClass()</code> FTransform BattleSceneTransform FBattleState BattleState   = <code>{}</code> ACameraActor * CameraActor   = <code>nullptr</code> class AFighterLocalRunner * FighterRunner   = <code>nullptr</code> class UNightSkyGameInstance * GameInstance   = <code>nullptr</code> int32 LocalFrame   = <code>0</code> int MaxBattleObjects   = <code>400</code> TArray&lt; ABattleObject * &gt; Objects   = <code>{}</code> class AParticleManager * ParticleManager   = <code>nullptr</code> TArray&lt; APlayerObject * &gt; Players   = <code>{}</code> int32 RemoteFrame   = <code>0</code> class ALevelSequenceActor * SequenceActor   = <code>nullptr</code> ACameraActor * SequenceCameraActor   = <code>nullptr</code> TSubclassOf&lt; ACameraActor &gt; SequenceCameraActorClass APlayerObject * SequenceEnemy   = <code>nullptr</code> APlayerObject * SequenceTarget   = <code>nullptr</code> TArray&lt; ABattleObject * &gt; SortedObjects   = <code>{}</code> bool bIsPlayingSequence   = <code>false</code> bool bPauseGame   = <code>false</code> bool bViewCollision   = <code>false</code>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#public-functions","title":"Public Functions","text":"Type Name ANightSkyGameState ()  ABattleObject * AddBattleObject (const UState * InState, int PosX, int PosY, EObjDir Dir, int32 ObjectStateIndex, bool bIsCommonState, APlayerObject * Parent) const void AssignEnemy ()  void BattleHudVisibility (bool Visible)  APlayerObject * CallAssist (const bool IsP1, int AssistIndex, const FGameplayTag AssistName)  void CallBattleExtension (FGameplayTag Name)  void CameraShake (const TSubclassOf&lt; UCameraShakeBase &gt; &amp; Pattern, float Scale) const bool CanTag (const APlayerObject * InPlayer, int TeamIndex) const void EndMatch ()  void EndMatch_BP ()  int32 GetGauge (bool IsP1, int32 GaugeIndex) const int GetLocalInputs (int Index) const APlayerObject * GetMainPlayer (bool IsP1) const bool GetPaused () const EScreenFlag GetScreenFlags () const TArray&lt; APlayerObject * &gt; GetTeam (bool IsP1) const int32 GetTeamCount (bool bIsP1) const void HUDInit () const bool IsTagBattle () const void LoadForRollback (const TArray&lt; uint8 &gt; &amp; InBytes)  void LoadGameState (FRollbackData &amp; RollbackData)  void ManageAudio ()  void MatchInit ()  void PlayAnnouncerVoice (USoundBase * InSoundWave, float MaxDuration)  void PlayAnnouncerVoice (const FGameplayTag Name)  void PlayCharaAudio (USoundBase * InSoundWave, float MaxDuration)  void PlayCommonAudio (USoundBase * InSoundWave, float MaxDuration)  void PlayLevelSequence (APlayerObject * Target, APlayerObject * Enemy, ULevelSequence * Sequence)  void PlayMusic (USoundBase * InSoundWave, float MaxDuration)  void PlayMusic (const FGameplayTag Name)  void PlayVoiceLine (USoundBase * InSoundWave, float MaxDuration, int Player)  void RollbackStartAudio (int32 InFrame)  void RoundInit ()  TArray&lt; uint8 &gt; SaveForRollback ()  void SaveGameState (FRollbackData &amp; RollbackData, int32 * InChecksum)  void ScreenPosToWorldPos (int32 X, int32 Y, int32 &amp; OutX, int32 &amp; OutY) const void SetDrawPriorityBack (ABattleObject * InObject) const void SetDrawPriorityFront (ABattleObject * InObject) const void SetGauge (bool IsP1, int32 GaugeIndex, int32 Value)  void SetOtherChecksum (uint32 RemoteChecksum, int32 InFrame)  void SetPaused (bool bPause)  void SetScreenBounds () const void SetScreenCorners ()  void SetScreenFlags (UPARAM(meta=(Bitmask, BitmaskEnum=\"/Script/NightSkyEngine.EScreenFlag\")) int32 InFlags)  void SetTeamCooldown (const bool IsP1, const int TeamIndex, const int Cooldown)  void StartSuperFreeze (int32 Duration, int32 SelfDuration, ABattleObject * CallingObject)  void StopLevelSequence ()  APlayerObject * SwitchMainPlayer (APlayerObject * InPlayer, int TeamIndex, bool bForce=false, bool bEvenOnScreen=false)  virtual void Tick (float DeltaTime) override void UpdateCamera ()  void UpdateGameState ()  void UpdateGameState (int32 Input1, int32 Input2, bool bShouldResimulate)  void UpdateHUD ()  void UpdateHUDAnimations_BP ()  void UpdateHUD_BP ()  void UpdateScreen ()  void UseGauge (bool IsP1, int32 GaugeIndex, int32 Value)"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override void CollisionView () const int32 CreateChecksum ()  virtual void EndPlay (const EEndPlayReason::Type EndPlayReason) override FGGPONetworkStats GetNetworkStats () const void HandleHitCollision () const bool HandleMatchWin ()  void HandlePushCollision () const void HandleRoundWin ()  void Init ()  void NextRoundTransition (bool bIsP1)  void PlayIntros ()  void ResetTraining ()  void SortObjects ()  void UpdateLocalInput ()  void UpdateVisuals (bool bShouldResimulate) const"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-audiomanager","title":"variable AudioManager","text":"<pre><code>AAudioManager* ANightSkyGameState::AudioManager;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-battleextensiondata","title":"variable BattleExtensionData","text":"<pre><code>UBattleExtensionData* ANightSkyGameState::BattleExtensionData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-battleextensionnames","title":"variable BattleExtensionNames","text":"<pre><code>TArray&lt;FGameplayTag&gt; ANightSkyGameState::BattleExtensionNames;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-battleextensions","title":"variable BattleExtensions","text":"<pre><code>TArray&lt;UBattleExtension*&gt; ANightSkyGameState::BattleExtensions;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-battlehudactor","title":"variable BattleHudActor","text":"<pre><code>ANightSkyBattleHudActor* ANightSkyGameState::BattleHudActor;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-battleobjectclass","title":"variable BattleObjectClass","text":"<pre><code>TSubclassOf&lt;ABattleObject&gt; ANightSkyGameState::BattleObjectClass;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-battlescenetransform","title":"variable BattleSceneTransform","text":"<pre><code>FTransform ANightSkyGameState::BattleSceneTransform;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-battlestate","title":"variable BattleState","text":"<pre><code>FBattleState ANightSkyGameState::BattleState;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-cameraactor","title":"variable CameraActor","text":"<pre><code>ACameraActor* ANightSkyGameState::CameraActor;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-fighterrunner","title":"variable FighterRunner","text":"<pre><code>class AFighterLocalRunner* ANightSkyGameState::FighterRunner;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-gameinstance","title":"variable GameInstance","text":"<pre><code>class UNightSkyGameInstance* ANightSkyGameState::GameInstance;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-localframe","title":"variable LocalFrame","text":"<pre><code>int32 ANightSkyGameState::LocalFrame;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-maxbattleobjects","title":"variable MaxBattleObjects","text":"<pre><code>int ANightSkyGameState::MaxBattleObjects;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-objects","title":"variable Objects","text":"<pre><code>TArray&lt;ABattleObject*&gt; ANightSkyGameState::Objects;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-particlemanager","title":"variable ParticleManager","text":"<pre><code>class AParticleManager* ANightSkyGameState::ParticleManager;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-players","title":"variable Players","text":"<pre><code>TArray&lt;APlayerObject*&gt; ANightSkyGameState::Players;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-remoteframe","title":"variable RemoteFrame","text":"<pre><code>int32 ANightSkyGameState::RemoteFrame;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-sequenceactor","title":"variable SequenceActor","text":"<pre><code>class ALevelSequenceActor* ANightSkyGameState::SequenceActor;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-sequencecameraactor","title":"variable SequenceCameraActor","text":"<pre><code>ACameraActor* ANightSkyGameState::SequenceCameraActor;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-sequencecameraactorclass","title":"variable SequenceCameraActorClass","text":"<pre><code>TSubclassOf&lt;ACameraActor&gt; ANightSkyGameState::SequenceCameraActorClass;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-sequenceenemy","title":"variable SequenceEnemy","text":"<pre><code>APlayerObject* ANightSkyGameState::SequenceEnemy;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-sequencetarget","title":"variable SequenceTarget","text":"<pre><code>APlayerObject* ANightSkyGameState::SequenceTarget;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-sortedobjects","title":"variable SortedObjects","text":"<pre><code>TArray&lt;ABattleObject*&gt; ANightSkyGameState::SortedObjects;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-bisplayingsequence","title":"variable bIsPlayingSequence","text":"<pre><code>bool ANightSkyGameState::bIsPlayingSequence;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-bpausegame","title":"variable bPauseGame","text":"<pre><code>bool ANightSkyGameState::bPauseGame;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#variable-bviewcollision","title":"variable bViewCollision","text":"<pre><code>bool ANightSkyGameState::bViewCollision;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-anightskygamestate","title":"function ANightSkyGameState","text":"<pre><code>ANightSkyGameState::ANightSkyGameState () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-addbattleobject","title":"function AddBattleObject","text":"<pre><code>ABattleObject * ANightSkyGameState::AddBattleObject (\n    const UState * InState,\n    int PosX,\n    int PosY,\n    EObjDir Dir,\n    int32 ObjectStateIndex,\n    bool bIsCommonState,\n    APlayerObject * Parent\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-assignenemy","title":"function AssignEnemy","text":"<pre><code>void ANightSkyGameState::AssignEnemy () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-battlehudvisibility","title":"function BattleHudVisibility","text":"<pre><code>void ANightSkyGameState::BattleHudVisibility (\n    bool Visible\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-callassist","title":"function CallAssist","text":"<pre><code>APlayerObject * ANightSkyGameState::CallAssist (\n    const bool IsP1,\n    int AssistIndex,\n    const FGameplayTag AssistName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-callbattleextension","title":"function CallBattleExtension","text":"<pre><code>void ANightSkyGameState::CallBattleExtension (\n    FGameplayTag Name\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-camerashake","title":"function CameraShake","text":"<pre><code>void ANightSkyGameState::CameraShake (\n    const TSubclassOf&lt; UCameraShakeBase &gt; &amp; Pattern,\n    float Scale\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-cantag","title":"function CanTag","text":"<pre><code>bool ANightSkyGameState::CanTag (\n    const APlayerObject * InPlayer,\n    int TeamIndex\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-endmatch","title":"function EndMatch","text":"<pre><code>void ANightSkyGameState::EndMatch () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-endmatch_bp","title":"function EndMatch_BP","text":"<pre><code>void ANightSkyGameState::EndMatch_BP () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-getgauge","title":"function GetGauge","text":"<pre><code>int32 ANightSkyGameState::GetGauge (\n    bool IsP1,\n    int32 GaugeIndex\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-getlocalinputs","title":"function GetLocalInputs","text":"<pre><code>int ANightSkyGameState::GetLocalInputs (\n    int Index\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-getmainplayer","title":"function GetMainPlayer","text":"<pre><code>APlayerObject * ANightSkyGameState::GetMainPlayer (\n    bool IsP1\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-getpaused","title":"function GetPaused","text":"<pre><code>bool ANightSkyGameState::GetPaused () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-getscreenflags","title":"function GetScreenFlags","text":"<pre><code>EScreenFlag ANightSkyGameState::GetScreenFlags () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-getteam","title":"function GetTeam","text":"<pre><code>TArray&lt; APlayerObject * &gt; ANightSkyGameState::GetTeam (\n    bool IsP1\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-getteamcount","title":"function GetTeamCount","text":"<pre><code>int32 ANightSkyGameState::GetTeamCount (\n    bool bIsP1\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-hudinit","title":"function HUDInit","text":"<pre><code>void ANightSkyGameState::HUDInit () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-istagbattle","title":"function IsTagBattle","text":"<pre><code>bool ANightSkyGameState::IsTagBattle () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-loadforrollback","title":"function LoadForRollback","text":"<pre><code>void ANightSkyGameState::LoadForRollback (\n    const TArray&lt; uint8 &gt; &amp; InBytes\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-loadgamestate","title":"function LoadGameState","text":"<pre><code>void ANightSkyGameState::LoadGameState (\n    FRollbackData &amp; RollbackData\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-manageaudio","title":"function ManageAudio","text":"<pre><code>void ANightSkyGameState::ManageAudio () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-matchinit","title":"function MatchInit","text":"<pre><code>void ANightSkyGameState::MatchInit () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-playannouncervoice-12","title":"function PlayAnnouncerVoice [1/2]","text":"<pre><code>void ANightSkyGameState::PlayAnnouncerVoice (\n    USoundBase * InSoundWave,\n    float MaxDuration\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-playannouncervoice-22","title":"function PlayAnnouncerVoice [2/2]","text":"<pre><code>void ANightSkyGameState::PlayAnnouncerVoice (\n    const FGameplayTag Name\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-playcharaaudio","title":"function PlayCharaAudio","text":"<pre><code>void ANightSkyGameState::PlayCharaAudio (\n    USoundBase * InSoundWave,\n    float MaxDuration\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-playcommonaudio","title":"function PlayCommonAudio","text":"<pre><code>void ANightSkyGameState::PlayCommonAudio (\n    USoundBase * InSoundWave,\n    float MaxDuration\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-playlevelsequence","title":"function PlayLevelSequence","text":"<pre><code>void ANightSkyGameState::PlayLevelSequence (\n    APlayerObject * Target,\n    APlayerObject * Enemy,\n    ULevelSequence * Sequence\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-playmusic-12","title":"function PlayMusic [1/2]","text":"<pre><code>void ANightSkyGameState::PlayMusic (\n    USoundBase * InSoundWave,\n    float MaxDuration\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-playmusic-22","title":"function PlayMusic [2/2]","text":"<pre><code>void ANightSkyGameState::PlayMusic (\n    const FGameplayTag Name\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-playvoiceline","title":"function PlayVoiceLine","text":"<pre><code>void ANightSkyGameState::PlayVoiceLine (\n    USoundBase * InSoundWave,\n    float MaxDuration,\n    int Player\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-rollbackstartaudio","title":"function RollbackStartAudio","text":"<pre><code>void ANightSkyGameState::RollbackStartAudio (\n    int32 InFrame\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-roundinit","title":"function RoundInit","text":"<pre><code>void ANightSkyGameState::RoundInit () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-saveforrollback","title":"function SaveForRollback","text":"<pre><code>TArray&lt; uint8 &gt; ANightSkyGameState::SaveForRollback () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-savegamestate","title":"function SaveGameState","text":"<pre><code>void ANightSkyGameState::SaveGameState (\n    FRollbackData &amp; RollbackData,\n    int32 * InChecksum\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-screenpostoworldpos","title":"function ScreenPosToWorldPos","text":"<pre><code>void ANightSkyGameState::ScreenPosToWorldPos (\n    int32 X,\n    int32 Y,\n    int32 &amp; OutX,\n    int32 &amp; OutY\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-setdrawpriorityback","title":"function SetDrawPriorityBack","text":"<pre><code>void ANightSkyGameState::SetDrawPriorityBack (\n    ABattleObject * InObject\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-setdrawpriorityfront","title":"function SetDrawPriorityFront","text":"<pre><code>void ANightSkyGameState::SetDrawPriorityFront (\n    ABattleObject * InObject\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-setgauge","title":"function SetGauge","text":"<pre><code>void ANightSkyGameState::SetGauge (\n    bool IsP1,\n    int32 GaugeIndex,\n    int32 Value\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-setotherchecksum","title":"function SetOtherChecksum","text":"<pre><code>void ANightSkyGameState::SetOtherChecksum (\n    uint32 RemoteChecksum,\n    int32 InFrame\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-setpaused","title":"function SetPaused","text":"<pre><code>void ANightSkyGameState::SetPaused (\n    bool bPause\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-setscreenbounds","title":"function SetScreenBounds","text":"<pre><code>void ANightSkyGameState::SetScreenBounds () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-setscreencorners","title":"function SetScreenCorners","text":"<pre><code>void ANightSkyGameState::SetScreenCorners () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-setscreenflags","title":"function SetScreenFlags","text":"<pre><code>void ANightSkyGameState::SetScreenFlags (\n    UPARAM(meta=(Bitmask, BitmaskEnum=\"/Script/NightSkyEngine.EScreenFlag\")) int32 InFlags\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-setteamcooldown","title":"function SetTeamCooldown","text":"<pre><code>void ANightSkyGameState::SetTeamCooldown (\n    const bool IsP1,\n    const int TeamIndex,\n    const int Cooldown\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-startsuperfreeze","title":"function StartSuperFreeze","text":"<pre><code>void ANightSkyGameState::StartSuperFreeze (\n    int32 Duration,\n    int32 SelfDuration,\n    ABattleObject * CallingObject\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-stoplevelsequence","title":"function StopLevelSequence","text":"<pre><code>void ANightSkyGameState::StopLevelSequence () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-switchmainplayer","title":"function SwitchMainPlayer","text":"<pre><code>APlayerObject * ANightSkyGameState::SwitchMainPlayer (\n    APlayerObject * InPlayer,\n    int TeamIndex,\n    bool bForce=false,\n    bool bEvenOnScreen=false\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-tick","title":"function Tick","text":"<pre><code>virtual void ANightSkyGameState::Tick (\n    float DeltaTime\n) override\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-updatecamera","title":"function UpdateCamera","text":"<pre><code>void ANightSkyGameState::UpdateCamera () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-updategamestate-12","title":"function UpdateGameState [1/2]","text":"<pre><code>void ANightSkyGameState::UpdateGameState () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-updategamestate-22","title":"function UpdateGameState [2/2]","text":"<pre><code>void ANightSkyGameState::UpdateGameState (\n    int32 Input1,\n    int32 Input2,\n    bool bShouldResimulate\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-updatehud","title":"function UpdateHUD","text":"<pre><code>void ANightSkyGameState::UpdateHUD () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-updatehudanimations_bp","title":"function UpdateHUDAnimations_BP","text":"<pre><code>void ANightSkyGameState::UpdateHUDAnimations_BP () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-updatehud_bp","title":"function UpdateHUD_BP","text":"<pre><code>void ANightSkyGameState::UpdateHUD_BP () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-updatescreen","title":"function UpdateScreen","text":"<pre><code>void ANightSkyGameState::UpdateScreen () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-usegauge","title":"function UseGauge","text":"<pre><code>void ANightSkyGameState::UseGauge (\n    bool IsP1,\n    int32 GaugeIndex,\n    int32 Value\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void ANightSkyGameState::BeginPlay () override\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-collisionview","title":"function CollisionView","text":"<pre><code>void ANightSkyGameState::CollisionView () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-createchecksum","title":"function CreateChecksum","text":"<pre><code>int32 ANightSkyGameState::CreateChecksum () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-endplay","title":"function EndPlay","text":"<pre><code>virtual void ANightSkyGameState::EndPlay (\n    const EEndPlayReason::Type EndPlayReason\n) override\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-getnetworkstats","title":"function GetNetworkStats","text":"<pre><code>FGGPONetworkStats ANightSkyGameState::GetNetworkStats () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-handlehitcollision","title":"function HandleHitCollision","text":"<pre><code>void ANightSkyGameState::HandleHitCollision () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-handlematchwin","title":"function HandleMatchWin","text":"<pre><code>bool ANightSkyGameState::HandleMatchWin () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-handlepushcollision","title":"function HandlePushCollision","text":"<pre><code>void ANightSkyGameState::HandlePushCollision () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-handleroundwin","title":"function HandleRoundWin","text":"<pre><code>void ANightSkyGameState::HandleRoundWin () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-init","title":"function Init","text":"<pre><code>void ANightSkyGameState::Init () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-nextroundtransition","title":"function NextRoundTransition","text":"<pre><code>void ANightSkyGameState::NextRoundTransition (\n    bool bIsP1\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-playintros","title":"function PlayIntros","text":"<pre><code>void ANightSkyGameState::PlayIntros () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-resettraining","title":"function ResetTraining","text":"<pre><code>void ANightSkyGameState::ResetTraining () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-sortobjects","title":"function SortObjects","text":"<pre><code>void ANightSkyGameState::SortObjects () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-updatelocalinput","title":"function UpdateLocalInput","text":"<pre><code>void ANightSkyGameState::UpdateLocalInput () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_game_state/#function-updatevisuals","title":"function UpdateVisuals","text":"<pre><code>void ANightSkyGameState::UpdateVisuals (\n    bool bShouldResimulate\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyGameState.h</code></p>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/","title":"Class ANightSkyPlayerController","text":"<p>ClassList &gt; ANightSkyPlayerController</p> <p>Inherits the following classes: APlayerController</p> <p>Inherited by the following classes: ANightSkyWTPlayerController</p>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#public-attributes","title":"Public Attributes","text":"Type Name int Frame FBattleInputActions InputActions TSoftObjectPtr&lt; UInputMappingContext &gt; InputMapping int Inputs ANetworkPawn * NetworkPawn bool bRematch bool bRematchAccepted bool bSentCharaData"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#public-functions","title":"Public Functions","text":"Type Name ANightSkyPlayerController ()  void ClosePauseMenu ()  void OpenPauseMenu ()  void PauseGame ()  void PostRematch ()  void PressA ()  void PressB ()  void PressC ()  void PressD ()  void PressDown ()  void PressE ()  void PressF ()  void PressG ()  void PressH ()  void PressLeft ()  void PressRight ()  void PressUp ()  void ReleaseA ()  void ReleaseB ()  void ReleaseC ()  void ReleaseD ()  void ReleaseDown ()  void ReleaseE ()  void ReleaseF ()  void ReleaseG ()  void ReleaseH ()  void ReleaseLeft ()  void ReleaseRight ()  void ReleaseUp ()  void Rematch ()  void ResetTraining ()  void SendBattleData ()  void SendGgpo (ANetworkPawn * InNetworkPawn, bool Client) const virtual void SetupInputComponent () override virtual void Tick (float DeltaTime) override"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#variable-frame","title":"variable Frame","text":"<pre><code>int ANightSkyPlayerController::Frame;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#variable-inputactions","title":"variable InputActions","text":"<pre><code>FBattleInputActions ANightSkyPlayerController::InputActions;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#variable-inputmapping","title":"variable InputMapping","text":"<pre><code>TSoftObjectPtr&lt;UInputMappingContext&gt; ANightSkyPlayerController::InputMapping;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#variable-inputs","title":"variable Inputs","text":"<pre><code>int ANightSkyPlayerController::Inputs;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#variable-networkpawn","title":"variable NetworkPawn","text":"<pre><code>ANetworkPawn* ANightSkyPlayerController::NetworkPawn;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#variable-brematch","title":"variable bRematch","text":"<pre><code>bool ANightSkyPlayerController::bRematch;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#variable-brematchaccepted","title":"variable bRematchAccepted","text":"<pre><code>bool ANightSkyPlayerController::bRematchAccepted;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#variable-bsentcharadata","title":"variable bSentCharaData","text":"<pre><code>bool ANightSkyPlayerController::bSentCharaData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-anightskyplayercontroller","title":"function ANightSkyPlayerController","text":"<pre><code>ANightSkyPlayerController::ANightSkyPlayerController () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-closepausemenu","title":"function ClosePauseMenu","text":"<pre><code>void ANightSkyPlayerController::ClosePauseMenu () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-openpausemenu","title":"function OpenPauseMenu","text":"<pre><code>void ANightSkyPlayerController::OpenPauseMenu () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-pausegame","title":"function PauseGame","text":"<pre><code>void ANightSkyPlayerController::PauseGame () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-postrematch","title":"function PostRematch","text":"<pre><code>void ANightSkyPlayerController::PostRematch () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-pressa","title":"function PressA","text":"<pre><code>void ANightSkyPlayerController::PressA () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-pressb","title":"function PressB","text":"<pre><code>void ANightSkyPlayerController::PressB () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-pressc","title":"function PressC","text":"<pre><code>void ANightSkyPlayerController::PressC () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-pressd","title":"function PressD","text":"<pre><code>void ANightSkyPlayerController::PressD () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-pressdown","title":"function PressDown","text":"<pre><code>void ANightSkyPlayerController::PressDown () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-presse","title":"function PressE","text":"<pre><code>void ANightSkyPlayerController::PressE () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-pressf","title":"function PressF","text":"<pre><code>void ANightSkyPlayerController::PressF () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-pressg","title":"function PressG","text":"<pre><code>void ANightSkyPlayerController::PressG () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-pressh","title":"function PressH","text":"<pre><code>void ANightSkyPlayerController::PressH () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-pressleft","title":"function PressLeft","text":"<pre><code>void ANightSkyPlayerController::PressLeft () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-pressright","title":"function PressRight","text":"<pre><code>void ANightSkyPlayerController::PressRight () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-pressup","title":"function PressUp","text":"<pre><code>void ANightSkyPlayerController::PressUp () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-releasea","title":"function ReleaseA","text":"<pre><code>void ANightSkyPlayerController::ReleaseA () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-releaseb","title":"function ReleaseB","text":"<pre><code>void ANightSkyPlayerController::ReleaseB () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-releasec","title":"function ReleaseC","text":"<pre><code>void ANightSkyPlayerController::ReleaseC () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-released","title":"function ReleaseD","text":"<pre><code>void ANightSkyPlayerController::ReleaseD () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-releasedown","title":"function ReleaseDown","text":"<pre><code>void ANightSkyPlayerController::ReleaseDown () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-releasee","title":"function ReleaseE","text":"<pre><code>void ANightSkyPlayerController::ReleaseE () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-releasef","title":"function ReleaseF","text":"<pre><code>void ANightSkyPlayerController::ReleaseF () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-releaseg","title":"function ReleaseG","text":"<pre><code>void ANightSkyPlayerController::ReleaseG () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-releaseh","title":"function ReleaseH","text":"<pre><code>void ANightSkyPlayerController::ReleaseH () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-releaseleft","title":"function ReleaseLeft","text":"<pre><code>void ANightSkyPlayerController::ReleaseLeft () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-releaseright","title":"function ReleaseRight","text":"<pre><code>void ANightSkyPlayerController::ReleaseRight () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-releaseup","title":"function ReleaseUp","text":"<pre><code>void ANightSkyPlayerController::ReleaseUp () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-rematch","title":"function Rematch","text":"<pre><code>void ANightSkyPlayerController::Rematch () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-resettraining","title":"function ResetTraining","text":"<pre><code>void ANightSkyPlayerController::ResetTraining () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-sendbattledata","title":"function SendBattleData","text":"<pre><code>void ANightSkyPlayerController::SendBattleData () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-sendggpo","title":"function SendGgpo","text":"<pre><code>void ANightSkyPlayerController::SendGgpo (\n    ANetworkPawn * InNetworkPawn,\n    bool Client\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-setupinputcomponent","title":"function SetupInputComponent","text":"<pre><code>virtual void ANightSkyPlayerController::SetupInputComponent () override\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-tick","title":"function Tick","text":"<pre><code>virtual void ANightSkyPlayerController::Tick (\n    float DeltaTime\n) override\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_player_controller/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void ANightSkyPlayerController::BeginPlay () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyPlayerController.h</code></p>"},{"location":"NightSkyEngine/class_a_night_sky_v_s_info_game_state/","title":"Class ANightSkyVSInfoGameState","text":"<p>ClassList &gt; ANightSkyVSInfoGameState</p> <p>Inherits the following classes: AGameStateBase</p>"},{"location":"NightSkyEngine/class_a_night_sky_v_s_info_game_state/#public-attributes","title":"Public Attributes","text":"Type Name double MaxVSInfoTime   = <code>6</code>"},{"location":"NightSkyEngine/class_a_night_sky_v_s_info_game_state/#public-functions","title":"Public Functions","text":"Type Name ANightSkyVSInfoGameState ()  virtual void BeginPlay () override void OnCharaPackageLoaded (const FName &amp; PackageName, UPackage * LoadedPackage, EAsyncLoadingResult::Type Result)  void OnMapPackageLoaded (const FName &amp; PackageName, UPackage * LoadedPackage, EAsyncLoadingResult::Type Result)  virtual void Tick (float DeltaSeconds) override"},{"location":"NightSkyEngine/class_a_night_sky_v_s_info_game_state/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_v_s_info_game_state/#variable-maxvsinfotime","title":"variable MaxVSInfoTime","text":"<pre><code>double ANightSkyVSInfoGameState::MaxVSInfoTime;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_v_s_info_game_state/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_v_s_info_game_state/#function-anightskyvsinfogamestate","title":"function ANightSkyVSInfoGameState","text":"<pre><code>ANightSkyVSInfoGameState::ANightSkyVSInfoGameState () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_v_s_info_game_state/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void ANightSkyVSInfoGameState::BeginPlay () override\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_v_s_info_game_state/#function-oncharapackageloaded","title":"function OnCharaPackageLoaded","text":"<pre><code>void ANightSkyVSInfoGameState::OnCharaPackageLoaded (\n    const FName &amp; PackageName,\n    UPackage * LoadedPackage,\n    EAsyncLoadingResult::Type Result\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_v_s_info_game_state/#function-onmappackageloaded","title":"function OnMapPackageLoaded","text":"<pre><code>void ANightSkyVSInfoGameState::OnMapPackageLoaded (\n    const FName &amp; PackageName,\n    UPackage * LoadedPackage,\n    EAsyncLoadingResult::Type Result\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_v_s_info_game_state/#function-tick","title":"function Tick","text":"<pre><code>virtual void ANightSkyVSInfoGameState::Tick (\n    float DeltaSeconds\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/VSInfo/NightSkyVSInfoGameState.h</code></p>"},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/","title":"Class ANightSkyWTGameState","text":"<p>ClassList &gt; ANightSkyWTGameState</p> <p>Inherits the following classes: ANightSkyGameState</p>"},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#public-attributes","title":"Public Attributes","text":"Type Name FOnBattleEndDelegate OnBattleEndDelegate bool bIsBattling bool bIsMatchEnd"},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#public-attributes-inherited-from-anightskygamestate","title":"Public Attributes inherited from ANightSkyGameState","text":"<p>See ANightSkyGameState</p> Type Name AAudioManager * AudioManager   = <code>nullptr</code> UBattleExtensionData * BattleExtensionData   = <code>{}</code> TArray&lt; FGameplayTag &gt; BattleExtensionNames   = <code>{}</code> TArray&lt; UBattleExtension * &gt; BattleExtensions   = <code>{}</code> ANightSkyBattleHudActor * BattleHudActor   = <code>nullptr</code> TSubclassOf&lt; ABattleObject &gt; BattleObjectClass   = <code>ABattleObject::StaticClass()</code> FTransform BattleSceneTransform FBattleState BattleState   = <code>{}</code> ACameraActor * CameraActor   = <code>nullptr</code> class AFighterLocalRunner * FighterRunner   = <code>nullptr</code> class UNightSkyGameInstance * GameInstance   = <code>nullptr</code> int32 LocalFrame   = <code>0</code> int MaxBattleObjects   = <code>400</code> TArray&lt; ABattleObject * &gt; Objects   = <code>{}</code> class AParticleManager * ParticleManager   = <code>nullptr</code> TArray&lt; APlayerObject * &gt; Players   = <code>{}</code> int32 RemoteFrame   = <code>0</code> class ALevelSequenceActor * SequenceActor   = <code>nullptr</code> ACameraActor * SequenceCameraActor   = <code>nullptr</code> TSubclassOf&lt; ACameraActor &gt; SequenceCameraActorClass APlayerObject * SequenceEnemy   = <code>nullptr</code> APlayerObject * SequenceTarget   = <code>nullptr</code> TArray&lt; ABattleObject * &gt; SortedObjects   = <code>{}</code> bool bIsPlayingSequence   = <code>false</code> bool bPauseGame   = <code>false</code> bool bViewCollision   = <code>false</code>"},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#public-functions","title":"Public Functions","text":"Type Name ANightSkyWTGameState ()  void Init (APlayerObject * P1, APlayerObject * P2)  virtual void Tick (float DeltaTime) override"},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#public-functions-inherited-from-anightskygamestate","title":"Public Functions inherited from ANightSkyGameState","text":"<p>See ANightSkyGameState</p> Type Name ANightSkyGameState ()  ABattleObject * AddBattleObject (const UState * InState, int PosX, int PosY, EObjDir Dir, int32 ObjectStateIndex, bool bIsCommonState, APlayerObject * Parent) const void AssignEnemy ()  void BattleHudVisibility (bool Visible)  APlayerObject * CallAssist (const bool IsP1, int AssistIndex, const FGameplayTag AssistName)  void CallBattleExtension (FGameplayTag Name)  void CameraShake (const TSubclassOf&lt; UCameraShakeBase &gt; &amp; Pattern, float Scale) const bool CanTag (const APlayerObject * InPlayer, int TeamIndex) const void EndMatch ()  void EndMatch_BP ()  int32 GetGauge (bool IsP1, int32 GaugeIndex) const int GetLocalInputs (int Index) const APlayerObject * GetMainPlayer (bool IsP1) const bool GetPaused () const EScreenFlag GetScreenFlags () const TArray&lt; APlayerObject * &gt; GetTeam (bool IsP1) const int32 GetTeamCount (bool bIsP1) const void HUDInit () const bool IsTagBattle () const void LoadForRollback (const TArray&lt; uint8 &gt; &amp; InBytes)  void LoadGameState (FRollbackData &amp; RollbackData)  void ManageAudio ()  void MatchInit ()  void PlayAnnouncerVoice (USoundBase * InSoundWave, float MaxDuration)  void PlayAnnouncerVoice (const FGameplayTag Name)  void PlayCharaAudio (USoundBase * InSoundWave, float MaxDuration)  void PlayCommonAudio (USoundBase * InSoundWave, float MaxDuration)  void PlayLevelSequence (APlayerObject * Target, APlayerObject * Enemy, ULevelSequence * Sequence)  void PlayMusic (USoundBase * InSoundWave, float MaxDuration)  void PlayMusic (const FGameplayTag Name)  void PlayVoiceLine (USoundBase * InSoundWave, float MaxDuration, int Player)  void RollbackStartAudio (int32 InFrame)  void RoundInit ()  TArray&lt; uint8 &gt; SaveForRollback ()  void SaveGameState (FRollbackData &amp; RollbackData, int32 * InChecksum)  void ScreenPosToWorldPos (int32 X, int32 Y, int32 &amp; OutX, int32 &amp; OutY) const void SetDrawPriorityBack (ABattleObject * InObject) const void SetDrawPriorityFront (ABattleObject * InObject) const void SetGauge (bool IsP1, int32 GaugeIndex, int32 Value)  void SetOtherChecksum (uint32 RemoteChecksum, int32 InFrame)  void SetPaused (bool bPause)  void SetScreenBounds () const void SetScreenCorners ()  void SetScreenFlags (UPARAM(meta=(Bitmask, BitmaskEnum=\"/Script/NightSkyEngine.EScreenFlag\")) int32 InFlags)  void SetTeamCooldown (const bool IsP1, const int TeamIndex, const int Cooldown)  void StartSuperFreeze (int32 Duration, int32 SelfDuration, ABattleObject * CallingObject)  void StopLevelSequence ()  APlayerObject * SwitchMainPlayer (APlayerObject * InPlayer, int TeamIndex, bool bForce=false, bool bEvenOnScreen=false)  virtual void Tick (float DeltaTime) override void UpdateCamera ()  void UpdateGameState ()  void UpdateGameState (int32 Input1, int32 Input2, bool bShouldResimulate)  void UpdateHUD ()  void UpdateHUDAnimations_BP ()  void UpdateHUD_BP ()  void UpdateScreen ()  void UseGauge (bool IsP1, int32 GaugeIndex, int32 Value)"},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#protected-functions-inherited-from-anightskygamestate","title":"Protected Functions inherited from ANightSkyGameState","text":"<p>See ANightSkyGameState</p> Type Name virtual void BeginPlay () override void CollisionView () const int32 CreateChecksum ()  virtual void EndPlay (const EEndPlayReason::Type EndPlayReason) override FGGPONetworkStats GetNetworkStats () const void HandleHitCollision () const bool HandleMatchWin ()  void HandlePushCollision () const void HandleRoundWin ()  void Init ()  void NextRoundTransition (bool bIsP1)  void PlayIntros ()  void ResetTraining ()  void SortObjects ()  void UpdateLocalInput ()  void UpdateVisuals (bool bShouldResimulate) const"},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#variable-onbattleenddelegate","title":"variable OnBattleEndDelegate","text":"<pre><code>FOnBattleEndDelegate ANightSkyWTGameState::OnBattleEndDelegate;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#variable-bisbattling","title":"variable bIsBattling","text":"<pre><code>bool ANightSkyWTGameState::bIsBattling;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#variable-bismatchend","title":"variable bIsMatchEnd","text":"<pre><code>bool ANightSkyWTGameState::bIsMatchEnd;\n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#function-anightskywtgamestate","title":"function ANightSkyWTGameState","text":"<pre><code>ANightSkyWTGameState::ANightSkyWTGameState () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#function-init","title":"function Init","text":"<pre><code>void ANightSkyWTGameState::Init (\n    APlayerObject * P1,\n    APlayerObject * P2\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#function-tick","title":"function Tick","text":"<pre><code>virtual void ANightSkyWTGameState::Tick (\n    float DeltaTime\n) override\n</code></pre> <p>Implements ANightSkyGameState::Tick</p>"},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_w_t_game_state/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void ANightSkyWTGameState::BeginPlay () override\n</code></pre> <p>Implements ANightSkyGameState::BeginPlay</p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/WT/NightSkyWTGameState.h</code></p>"},{"location":"NightSkyEngine/class_a_night_sky_w_t_player_controller/","title":"Class ANightSkyWTPlayerController","text":"<p>ClassList &gt; ANightSkyWTPlayerController</p> <p>Inherits the following classes: ANightSkyPlayerController</p>"},{"location":"NightSkyEngine/class_a_night_sky_w_t_player_controller/#public-attributes-inherited-from-anightskyplayercontroller","title":"Public Attributes inherited from ANightSkyPlayerController","text":"<p>See ANightSkyPlayerController</p> Type Name int Frame FBattleInputActions InputActions TSoftObjectPtr&lt; UInputMappingContext &gt; InputMapping int Inputs ANetworkPawn * NetworkPawn bool bRematch bool bRematchAccepted bool bSentCharaData"},{"location":"NightSkyEngine/class_a_night_sky_w_t_player_controller/#public-functions","title":"Public Functions","text":"Type Name ANightSkyWTPlayerController ()  virtual void Tick (float DeltaTime) override"},{"location":"NightSkyEngine/class_a_night_sky_w_t_player_controller/#public-functions-inherited-from-anightskyplayercontroller","title":"Public Functions inherited from ANightSkyPlayerController","text":"<p>See ANightSkyPlayerController</p> Type Name ANightSkyPlayerController ()  void ClosePauseMenu ()  void OpenPauseMenu ()  void PauseGame ()  void PostRematch ()  void PressA ()  void PressB ()  void PressC ()  void PressD ()  void PressDown ()  void PressE ()  void PressF ()  void PressG ()  void PressH ()  void PressLeft ()  void PressRight ()  void PressUp ()  void ReleaseA ()  void ReleaseB ()  void ReleaseC ()  void ReleaseD ()  void ReleaseDown ()  void ReleaseE ()  void ReleaseF ()  void ReleaseG ()  void ReleaseH ()  void ReleaseLeft ()  void ReleaseRight ()  void ReleaseUp ()  void Rematch ()  void ResetTraining ()  void SendBattleData ()  void SendGgpo (ANetworkPawn * InNetworkPawn, bool Client) const virtual void SetupInputComponent () override virtual void Tick (float DeltaTime) override"},{"location":"NightSkyEngine/class_a_night_sky_w_t_player_controller/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_night_sky_w_t_player_controller/#protected-functions-inherited-from-anightskyplayercontroller","title":"Protected Functions inherited from ANightSkyPlayerController","text":"<p>See ANightSkyPlayerController</p> Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_night_sky_w_t_player_controller/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_w_t_player_controller/#function-anightskywtplayercontroller","title":"function ANightSkyWTPlayerController","text":"<pre><code>ANightSkyWTPlayerController::ANightSkyWTPlayerController () \n</code></pre>"},{"location":"NightSkyEngine/class_a_night_sky_w_t_player_controller/#function-tick","title":"function Tick","text":"<pre><code>virtual void ANightSkyWTPlayerController::Tick (\n    float DeltaTime\n) override\n</code></pre> <p>Implements ANightSkyPlayerController::Tick</p>"},{"location":"NightSkyEngine/class_a_night_sky_w_t_player_controller/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_night_sky_w_t_player_controller/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void ANightSkyWTPlayerController::BeginPlay () override\n</code></pre> <p>Implements ANightSkyPlayerController::BeginPlay</p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/WT/NightSkyWTPlayerController.h</code></p>"},{"location":"NightSkyEngine/class_a_particle_manager/","title":"Class AParticleManager","text":"<p>ClassList &gt; AParticleManager</p> <p>Inherits the following classes: AActor</p>"},{"location":"NightSkyEngine/class_a_particle_manager/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; FBattleParticle &gt; BattleParticles"},{"location":"NightSkyEngine/class_a_particle_manager/#public-functions","title":"Public Functions","text":"Type Name AParticleManager ()  void PauseParticles ()  void RollbackParticles (int RollbackFrames)  virtual void Tick (float DeltaTime) override void UpdateParticles ()"},{"location":"NightSkyEngine/class_a_particle_manager/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_particle_manager/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_particle_manager/#variable-battleparticles","title":"variable BattleParticles","text":"<pre><code>TArray&lt;FBattleParticle&gt; AParticleManager::BattleParticles;\n</code></pre>"},{"location":"NightSkyEngine/class_a_particle_manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_particle_manager/#function-aparticlemanager","title":"function AParticleManager","text":"<pre><code>AParticleManager::AParticleManager () \n</code></pre>"},{"location":"NightSkyEngine/class_a_particle_manager/#function-pauseparticles","title":"function PauseParticles","text":"<pre><code>void AParticleManager::PauseParticles () \n</code></pre>"},{"location":"NightSkyEngine/class_a_particle_manager/#function-rollbackparticles","title":"function RollbackParticles","text":"<pre><code>void AParticleManager::RollbackParticles (\n    int RollbackFrames\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_particle_manager/#function-tick","title":"function Tick","text":"<pre><code>virtual void AParticleManager::Tick (\n    float DeltaTime\n) override\n</code></pre>"},{"location":"NightSkyEngine/class_a_particle_manager/#function-updateparticles","title":"function UpdateParticles","text":"<pre><code>void AParticleManager::UpdateParticles () \n</code></pre>"},{"location":"NightSkyEngine/class_a_particle_manager/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_particle_manager/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void AParticleManager::BeginPlay () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/ParticleManager.h</code></p>"},{"location":"NightSkyEngine/class_a_player_object/","title":"Class APlayerObject","text":"<p>ClassList &gt; APlayerObject</p> <p>Inherits the following classes: ABattleObject</p>"},{"location":"NightSkyEngine/class_a_player_object/#public-attributes","title":"Public Attributes","text":"Type Name int32 AirDashCount int32 AirDashMinimumHeight uint32 AirDashTimer   = <code>0</code> int32 AirJumpCount int32 AirPushHeight int32 AirPushHeightLow int32 AirPushWidth int32 BAirDashNoAttackTime int32 BAirDashSpeed int32 BAirDashTime int32 BDashGravity int32 BDashHeight int32 BDashSpeed int32 BJumpSpeed int32 BSuperJumpSpeed int32 BWalkSpeed UCameraShakeData * CameraShakeData bool CanProximityThrow bool CanReverseBeat TArray&lt; int32 &gt; ChainCancelOptions UParticleData * CharaParticleData UStateData * CharaStateData USubroutineData * CharaSubroutineData int32 CloseNormalRange int32 CmnPlayerReg1   = <code>0</code> int32 CmnPlayerReg2   = <code>0</code> int32 CmnPlayerReg3   = <code>0</code> int32 CmnPlayerReg4   = <code>0</code> int32 CmnPlayerReg5   = <code>0</code> int32 CmnPlayerReg6   = <code>0</code> int32 CmnPlayerReg7   = <code>0</code> int32 CmnPlayerReg8   = <code>0</code> UCollisionData * CollisionData int32 ColorIndex   = <code>1</code> int32 ComboCounter int32 ComboRate   = <code>60</code> int32 ComboTimer UCollisionData * CommonCollisionData ULinkActorData * CommonLinkActorData UStateData * CommonObjectStateData TArray&lt; FGameplayTag &gt; CommonObjectStateNames TArray&lt; UState * &gt; CommonObjectStates UParticleData * CommonParticleData USequenceData * CommonSequenceData USoundData * CommonSoundData USubroutineData * CommonSubroutineData TArray&lt; FGameplayTag &gt; CommonSubroutineNames TArray&lt; USubroutine * &gt; CommonSubroutines bool ComponentVisible int32 CrouchPushHeight int32 CrouchPushWidth int32 CurrentHealth TMap&lt; FGameplayTag, FGameplayTag &gt; DamageReactionCels APlayerObject * Enemy TArray&lt; FExtraGauge &gt; ExtraGauges int32 FAirDashNoAttackTime int32 FAirDashSpeed int32 FAirDashTime int32 FDashAccel int32 FDashFriction int32 FDashInitSpeed int32 FDashMaxSpeed int32 FJumpSpeed int32 FSuperJumpSpeed int32 FWalkSpeed bool FlipInputs int32 ForwardAirDashMeterGain int32 ForwardDashMeterGain int32 ForwardJumpMeterGain int32 ForwardWalkMeterGain uint32 Inputs bool IntroEndFlag   = <code>false</code> FGameplayTag IntroName uint32 InvulnFlags   = <code>0</code> int32 JumpGravity int32 JumpHeight ULinkActorData * LinkActorData UMaterialData * MaterialData int32 MaxColorIndex   = <code>2</code> int32 MaxHealth int32 MaxMeter   = <code>10000</code> int32 MaxOTGCount int32 MeterPercentOnHit   = <code>72</code> int32 MeterPercentOnHitGuard   = <code>18</code> int32 MeterPercentOnReceiveHit   = <code>40</code> int32 MeterPercentOnReceiveHitGuard   = <code>10</code> TArray&lt; int32 &gt; MovesUsedInChain   = <code>{}</code> TArray&lt; int32 &gt; MovesUsedInCombo   = <code>{}</code> int32 OTGCount UStateData * ObjectStateData TArray&lt; FGameplayTag &gt; ObjectStateNames TArray&lt; UState * &gt; ObjectStates int32 OtgProration   = <code>80</code> uint32 PlayerFlags   = <code>0</code> int32 PlayerIndex int32 PlayerReg1   = <code>0</code> int32 PlayerReg2   = <code>0</code> int32 PlayerReg3   = <code>0</code> int32 PlayerReg4   = <code>0</code> int32 PlayerReg5   = <code>0</code> int32 PlayerReg6   = <code>0</code> int32 PlayerReg7   = <code>0</code> int32 PlayerReg8   = <code>0</code> unsigned char PlayerSync unsigned char PlayerSyncEnd FStateMachine PrimaryStateMachine FInputCondition ProximityThrowInput int32 RecoverableHealth bool RoundEndFlag   = <code>false</code> int32 RoundWinTimer   = <code>120</code> USequenceData * SequenceData USoundData * SoundData TEnumAsByte&lt; EActionStance &gt; Stance int32 StandPushHeight int32 StandPushWidth FGameplayTag StateEntryName ABattleObject * StoredBattleObjects FInputBuffer StoredInputBuffer TArray&lt; FLinkedActorContainer &gt; StoredLinkActors uint32 StrikeInvulnerableTimer   = <code>0</code> TMap&lt; FGameplayTag, UStateData * &gt; SubStateData TArray&lt; FStateMachine &gt; SubStateMachines TArray&lt; FGameplayTag &gt; SubroutineNames TArray&lt; USubroutine * &gt; Subroutines int32 SuperJumpGravity int32 SuperJumpHeight int32 TeamIndex uint32 ThrowInvulnerableTimer   = <code>0</code> int32 ThrowResistAfterWakeUp   = <code>5</code> uint32 ThrowResistTimer   = <code>0</code> int32 ThrowTechWindow   = <code>6</code> int32 TotalProration   = <code>10000</code> USoundData * VoiceData int32 WallTouchTimer TArray&lt; int32 &gt; WhiffCancelOptions bool bCrumpled bool bIsCpu   = <code>false</code> bool bLimitCrumple   = <code>true</code> bool bMirrorWhenFlip"},{"location":"NightSkyEngine/class_a_player_object/#public-attributes-inherited-from-abattleobject","title":"Public Attributes inherited from ABattleObject","text":"<p>See ABattleObject</p> Type Name int32 ActionReg1   = <code>0</code> int32 ActionReg2   = <code>0</code> int32 ActionReg3   = <code>0</code> int32 ActionReg4   = <code>0</code> int32 ActionReg5   = <code>0</code> int32 ActionReg6   = <code>0</code> int32 ActionReg7   = <code>0</code> int32 ActionReg8   = <code>0</code> int32 ActionTime   = <code>0</code> FLinearColor AddColor   = <code>FLinearColor(0, 0, 0, 1)</code> FLinearColor AddFadeColor   = <code>{}</code> float AddFadeSpeed   = <code>0</code> int32 AnglePitch_x1000   = <code>0</code> int32 AngleRoll_x1000   = <code>0</code> int32 AngleYaw_x1000   = <code>0</code> float AnimBlendIn   = <code>{}</code> float AnimBlendOut   = <code>{}</code> int32 AnimFrame   = <code>0</code> TArray&lt; FAnimStruct &gt; AnimStructs uint32 AttackFlags   = <code>0</code> ABattleObject * AttackOwner ABattleObject * AttackTarget   = <code>nullptr</code> int32 B   = <code>0</code> int32 BlendAnimFrame   = <code>0</code> FGameplayTag BlendCelName   = <code>{}</code> bool BlendOffset   = <code>false</code> TArray&lt; FCollisionBox &gt; Boxes int32 CelIndex   = <code>0</code> FGameplayTag CelName   = <code>{}</code> TObjectPtr&lt; ANightSkyCharaSelectGameState &gt; CharaSelectGameState   = <code>nullptr</code> int32 ColPosX   = <code>0</code> int32 ColPosY   = <code>0</code> FHitData CounterHit   = <code>{}</code> FLinearColor DamageColor   = <code>FLinearColor(1, 1, 1, 1)</code> FLinearColor DamageColor2   = <code>FLinearColor(1, 1, 1, 1)</code> TEnumAsByte&lt; EObjDir &gt; Direction   = <code>DIR\\_Right</code> int32 DrawPriority   = <code>0</code> ABattleObject * DrawPriorityLinkObj   = <code>nullptr</code> FEventHandler EventHandlers   = <code>{}</code> float FadeTransparency   = <code>1</code> float FrameBlendPosition   = <code>0</code> TObjectPtr&lt; ANightSkyGameState &gt; GameState   = <code>nullptr</code> bool GotoLabelActive   = <code>false</code> int32 Gravity   = <code>1900</code> int32 GroundHeight   = <code>0</code> FHitDataCommon HitCommon   = <code>{}</code> int32 Hitstop   = <code>0</code> FHomingParams HomingParams   = <code>[**FHomingParams**](struct_f_homing_params.md)()</code> int32 Inertia   = <code>0</code> bool IsActive   = <code>false</code> bool IsPlayer   = <code>false</code> int32 L   = <code>0</code> FGameplayTag LabelName   = <code>{}</code> TObjectPtr&lt; ALinkActor &gt; LinkedActor TObjectPtr&lt; UNiagaraComponent &gt; LinkedParticle   = <code>nullptr</code> ABattleObject * MaterialLinkObj   = <code>nullptr</code> int32 MaxCelTime   = <code>0</code> int32 MiscFlags   = <code>0</code> FLinearColor MulColor   = <code>FLinearColor(1, 1, 1, 1)</code> FLinearColor MulFadeColor   = <code>{}</code> float MulFadeSpeed   = <code>0</code> int32 NextOffsetX   = <code>0</code> int32 NextOffsetY   = <code>0</code> FHitData NormalHit   = <code>{}</code> uint32 ObjNumber   = <code>0</code> unsigned char ObjSync   = <code>0</code> unsigned char ObjSyncEnd   = <code>0</code> uint32 ObjectID   = <code>0</code> FVector ObjectOffset   = <code>FVector::ZeroVector</code> int32 ObjectReg1   = <code>0</code> int32 ObjectReg2   = <code>0</code> int32 ObjectReg3   = <code>0</code> int32 ObjectReg4   = <code>0</code> int32 ObjectReg5   = <code>0</code> int32 ObjectReg6   = <code>0</code> int32 ObjectReg7   = <code>0</code> int32 ObjectReg8   = <code>0</code> FRotator ObjectRotation   = <code>FRotator::ZeroRotator</code> FVector ObjectScale   = <code>FVector::One()</code> TObjectPtr&lt; UState &gt; ObjectState   = <code>nullptr</code> int32 ObjectStateIndex   = <code>0</code> FGameplayTag ObjectStateName   = <code>{}</code> TArray&lt; ABattleObject * &gt; ObjectsToIgnoreHitsFrom float OrthoBlendActive   = <code>0</code> APlayerObject * Player   = <code>nullptr</code> int32 PosX   = <code>0</code> int32 PosY   = <code>0</code> int32 PosZ   = <code>0</code> ABattleObject * PositionLinkObj   = <code>nullptr</code> int32 PrevOffsetX   = <code>0</code> int32 PrevOffsetY   = <code>0</code> int32 PrevPosX   = <code>0</code> int32 PrevPosY   = <code>0</code> int32 PrevPosZ   = <code>0</code> int32 PrevRootMotionX   = <code>0</code> int32 PrevRootMotionY   = <code>0</code> int32 PrevRootMotionZ   = <code>0</code> int32 Pushback   = <code>0</code> int32 R   = <code>0</code> FHitData ReceivedHit   = <code>{}</code> FHitDataCommon ReceivedHitCommon   = <code>{}</code> float ScreenSpaceDepthOffset   = <code>0</code> FName SocketName   = <code>{}</code> EObjType SocketObj   = <code>OBJ\\_Self</code> FVector SocketOffset   = <code>FVector::ZeroVector</code> int32 SpeedX   = <code>0</code> int32 SpeedXRate   = <code>100</code> int32 SpeedXRatePerFrame   = <code>100</code> int32 SpeedY   = <code>0</code> int32 SpeedYRate   = <code>100</code> int32 SpeedYRatePerFrame   = <code>100</code> int32 SpeedZ   = <code>0</code> int32 SpeedZRate   = <code>100</code> int32 SpeedZRatePerFrame   = <code>100</code> ABattleObject * StopLinkObj   = <code>nullptr</code> int32 StunTime   = <code>0</code> int32 StunTimeMax   = <code>0</code> int32 SubroutineReg1   = <code>0</code> int32 SubroutineReg2   = <code>0</code> int32 SubroutineReg3   = <code>0</code> int32 SubroutineReg4   = <code>0</code> int32 SubroutineReturnVal1   = <code>0</code> int32 SubroutineReturnVal2   = <code>0</code> int32 SubroutineReturnVal3   = <code>0</code> int32 SubroutineReturnVal4   = <code>0</code> FSuperArmorData SuperArmorData   = <code>[**FSuperArmorData**](struct_f_super_armor_data.md)()</code> int32 T   = <code>0</code> int32 TimeUntilNextCel   = <code>0</code> int32 Timer0   = <code>0</code> int32 Timer1   = <code>0</code> float Transparency   = <code>1</code> float TransparencySpeed   = <code>0</code> int32 UpdateTime   = <code>0</code> bool bIsCommonState   = <code>false</code> bool bRender   = <code>true</code>"},{"location":"NightSkyEngine/class_a_player_object/#public-functions","title":"Public Functions","text":"Type Name APlayerObject ()  void AddAirDash (int32 NewAirDash)  void AddAirJump (int32 NewAirJump)  void AddAutoComboCancel (FGameplayTag Option, EInputFlags Button)  void AddBattleObjectToStorage (ABattleObject * InActor, int Index)  void AddChainCancelOption (FGameplayTag Option)  void AddHealth (int Value)  void AddMeter (int Meter)  void AddObjectState (FGameplayTag Name, UState * State, bool IsCommon)  void AddRecoverableHealth (int Value)  void AddState (FGameplayTag Name, UState * State, FGameplayTag StateMachineName)  void AddSubroutine (FGameplayTag Name, USubroutine * Subroutine, bool IsCommon)  void AddWhiffCancelOption (FGameplayTag Option)  void BattleHudVisibility (bool Visible)  APlayerObject * CallAssist (int AssistIndex, FGameplayTag AssistName)  bool CanEnterState (UState * State, FGameplayTag StateMachineName)  bool CheckEnemyInRange (int32 XBegin, int32 XEnd, int32 YBegin, int32 YEnd) const bool CheckHasHit () const bool CheckInput (const FInputCondition &amp; Input)  bool CheckIsAttacking () const bool CheckIsStunned () const bool CheckStateEnabled (EStateType StateType, FGameplayTag CustomStateType, FGameplayTag StateMachineName)  void DisableAll (FGameplayTag StateMachineName)  void DisableCustomState (FGameplayTag CustomStateType, FGameplayTag StateMachineName)  void DisableState (UPARAM(meta=(Bitmask, BitmaskEnum=\"/Script/NightSkyEngine.EEnableFlags\")) int32 Bitmask, FGameplayTag StateMachineName)  void EditorUpdate ()  void EmptyStateMachine ()  void EnableAll (FGameplayTag StateMachineName)  void EnableAttacks ()  void EnableCancelIntoSelf (bool Enable)  void EnableChainCancel (bool Enable)  void EnableCustomState (FGameplayTag CustomStateType, FGameplayTag StateMachineName)  void EnableForwardAirdashCancel (bool Enable)  void EnableJumpCancel (bool Enable)  void EnableReverseBeat (bool Enable)  void EnableSpecialCancel (bool Enable)  void EnableState (UPARAM(meta=(Bitmask, BitmaskEnum=\"/Script/NightSkyEngine.EEnableFlags\")) int32 Bitmask, FGameplayTag StateMachineName)  void EnableSuperCancel (bool Enable)  void EnableWhiffCancel (bool Enable)  void EndMatch () const void EndRound () const void ForceEnableFarNormal (bool Enable)  EBlockType GetAttackBlockType () const FGameplayTag GetCurrentStateName (FGameplayTag StateMachineName)  int32 GetEnableFlags (FGameplayTag StateMachineName)  FGameplayTag GetLastStateName () const FGameplayTag GetStateEntryName () const FStateMachine &amp; GetStateMachine (FGameplayTag StateMachineName)  bool HandleAutoCombo (int32 StateIndex, FStateMachine &amp; StateMachine)  void HandleBlockAction ()  void HandleBufferedState ()  void HandleBufferedState (FStateMachine &amp; StateMachine)  void HandleEndCombo ()  void HandleFlipInput ()  void HandleHitAction (EHitAction HACT)  void HandleProximityBlock ()  bool HandleStateInputs (int32 StateIndex, bool Buffer, FStateMachine &amp; StateMachine)  void HandleStateMachine (bool Buffer, FStateMachine &amp; StateMachine)  bool HandleStateTransition (int32 StateIndex, bool Buffer, FStateMachine &amp; StateMachine)  void InitBP ()  void InitPlayer ()  bool IsCorrectBlock (EBlockType BlockType)  bool IsEnemyAttackState () const bool IsEnemyBlocking () const bool IsEnemyThrow () const bool IsInvulnerable (const ABattleObject * Attacker) const bool IsInvulnerable_BP () const bool IsMainPlayer () const bool IsOnScreen () const bool IsTouchingWall () const bool JumpToState (FGameplayTag NewName, FGameplayTag StateMachineName, bool IsLabel=false)  bool JumpToStateByClass (TSubclassOf&lt; UState &gt; Class, FGameplayTag StateMachineName, bool IsLabel=false)  bool JumpToStateByClassPrimary (TSubclassOf&lt; UState &gt; Class, bool IsLabel=false)  bool JumpToStatePrimary (FGameplayTag NewName, bool IsLabel=false)  void LoadForRollbackBP (TArray&lt; uint8 &gt; InBytes)  void LoadForRollbackPlayer (const unsigned char * Buffer)  void OnStateChange ()  void PauseRoundTimer (bool Pause)  void PlayCommonLevelSequence (FGameplayTag Name)  void PlayLevelSequence (FGameplayTag Name)  void PlayVoiceLine (FGameplayTag Name)  void PostStateChange ()  void RecoverHealth (int Value)  void RemoveAutoComboCancel (EInputFlags Button)  void RemoveChainCancelOption (FGameplayTag Option)  void RemoveWhiffCancelOption (FGameplayTag Option)  void ResetAirDash ()  void ResetAirJump ()  void RoundInit (bool ResetHealth)  void RoundInit_BP ()  TArray&lt; uint8 &gt; SaveForRollbackBP ()  void SaveForRollbackPlayer (unsigned char * Buffer) const void SetAirDashNoAttackTimer (bool IsForward)  void SetAirDashTimer (bool IsForward)  void SetDamageReactionCel (FGameplayTag Type)  void SetDefaultComponentVisibility ()  void SetDefaultLandingAction (bool Enable)  void SetGuardValues ()  void SetHeadAttribute (bool Attribute)  void SetHeadInvulnerable (bool Invulnerable)  void SetHealth (int Value)  void SetHitValues (bool bCustomAir=false)  void SetHitValuesOverTime ()  void SetHitgrabActive (bool Active)  void SetKnockdownState ()  void SetMeterCooldownTimer (int Timer)  void SetOnScreen (bool OnScreen)  void SetProjectileInvulnerable (bool Invulnerable)  void SetRecoverableHealth (int Value)  void SetStance (EActionStance InStance)  void SetStateForCPU (FGameplayTag StateName, FGameplayTag StateMachineName)  void SetStrikeInvulnerable (bool Invulnerable)  void SetStrikeInvulnerableForTime (int32 Timer)  void SetStunTime (int32 NewTime)  void SetTeamCooldown (int NewTeamIndex, int Cooldown)  void SetThrowActive (bool Active)  void SetThrowExeState (FGameplayTag ExeState)  void SetThrowInvulnerable (bool Invulnerable)  void SetThrowInvulnerableForTime (int32 Timer)  void SetThrowPosition (int32 ThrowPosX, int32 ThrowPosY)  void SetThrowRange (int32 InThrowRange)  void SetThrowResistForTime (int32 Timer)  void StopLevelSequence ()  APlayerObject * SwitchMainPlayer (int NewTeamIndex, bool bForce=false, bool bEvenOnScreen=false)  void ThrowEnd ()  void ThrowExe ()  void ToggleComponentVisibility (FName ComponentName, bool Visible)  virtual void Update () override void UpdateNotBattle ()  void UseMeter (int Use)"},{"location":"NightSkyEngine/class_a_player_object/#public-functions-inherited-from-abattleobject","title":"Public Functions inherited from ABattleObject","text":"<p>See ABattleObject</p> Type Name ABattleObject ()  ABattleObject * AddBattleObject (FGameplayTag InStateName, int32 PosXOffset=0, int32 PosYOffset=0, EPosType PosType=POS_Player)  ABattleObject * AddCommonBattleObject (FGameplayTag InStateName, int32 PosXOffset=0, int32 PosYOffset=0, EPosType PosType=POS_Player)  void AddPosXWithDir (int InPosX)  void AddSpeedXRaw (int InSpeedX)  void AttachToSocketOfObject (FName InSocketName, FVector Offset, EObjType ObjType)  int32 CalculateAngleBetweenPoints (EObjType Obj1, EPosType Pos1, EObjType Obj2, EPosType Pos2)  int32 CalculateDistanceBetweenPoints (EDistanceType Type, EObjType Obj1, EPosType Pos1, EObjType Obj2, EPosType Pos2)  void CalculatePushbox ()  int32 CalculateSpeedAngle () const void CallSubroutine (FGameplayTag Name)  void CallSubroutineWithArgs (FGameplayTag Name, int32 Arg1, int32 Arg2, int32 Arg3, int32 Arg4)  void CameraShake (FGameplayTag PatternName, int32 Scale)  bool CheckBoxOverlap (ABattleObject * OtherObj, const EBoxType SelfType, const FGameplayTag SelfCustomType, const EBoxType OtherType, const FGameplayTag OtherCustomType)  bool CheckIsGrounded () const void CollisionView ()  void CreateCharaParticle (FGameplayTag Name, EPosType PosType, FVector Offset=FVector::ZeroVector, FRotator Rotation=FRotator::ZeroRotator)  void CreateCommonParticle (FGameplayTag Name, EPosType PosType, FVector Offset=FVector::ZeroVector, FRotator Rotation=FRotator::ZeroRotator)  void DeactivateObject ()  void DetachFromSocket ()  void DisableInertia ()  void EnableDeactivateIfBeyondBounds (bool Enable)  void EnableDeactivateOnReceiveHit (bool Enable)  void EnableDeactivateOnStateChange (bool Enable)  void EnableFlip (bool Enabled)  void EnableHit (bool Enabled)  void EnableInertia ()  void FaceOpponent ()  void FlipObject ()  int32 GenerateRandomNumber (int32 Min, int32 Max) const UAnimSequenceBase * GetAnimSequenceForPart (const FName Part) const ABattleObject * GetBattleObject (EObjType Type)  void GetBoxPosition (const EBoxType BoxType, const FGameplayTag CustomType, int &amp; OutPosX, int &amp; OutPosY) const void GetBoxes ()  FGameplayTag GetCelName () const UPaperFlipbook * GetFlipbookForPart (const FName Part) const int32 GetGauge (int32 GaugeIndex) const FGameplayTag GetLabelName () const int32 GetPosYCenter () const void GotoLabel (FGameplayTag InName)  void HaltMomentum ()  void HandleClashCollision (ABattleObject * OtherObj)  void HandleCustomCollision_PostHit (ABattleObject * OtherObj)  void HandleCustomCollision_PreHit (ABattleObject * OtherObj)  void HandleFlip ()  void HandleHitCollision (ABattleObject * AttackedObj)  void HandlePushCollision (ABattleObject * OtherObj)  void IgnoreSuperFreeze (bool Ignore)  void InitEventHandler (EEventType EventType, FName FuncName, int32 Value, FGameplayTag SubroutineName)  FHitData InitHitDataByAttackLevel (bool IsCounter)  void InitObject ()  bool IsStopped () const bool IsTimerPaused () const ALinkActor * LinkActor (FGameplayTag Name)  void LinkCharaParticle (FGameplayTag Name)  void LinkCommonParticle (FGameplayTag Name)  void LoadForRollback (const unsigned char * Buffer)  void PlayCharaSound (FGameplayTag Name)  void PlayCommonSound (FGameplayTag Name)  void PosTypeToPosition (EPosType Type, int32 &amp; OutPosX, int32 &amp; OutPosY) const void PositionLinkUpdate ()  void RemoveEventHandler (EEventType EventType)  void RemoveLinkActor ()  void ResetObject ()  void SaveForRollback (unsigned char * Buffer) const void ScreenPosToWorldPos (const int32 X, const int32 Y, int32 &amp; OutX, int32 &amp; OutY) const void SetAttacking (bool Attacking)  void SetBlendCelName (FGameplayTag InName)  void SetCelDuration (int32 InTime)  void SetCelName (FGameplayTag InName)  void SetFacing (EObjDir NewDir)  void SetFloorCollisionActive (bool Active)  void SetGauge (int32 GaugeIndex, int32 Value)  void SetHitOTG (bool Enable)  void SetIgnoreHitstunScaling (bool Ignore)  void SetIgnoreOTG (bool Ignore)  void SetIgnorePushbackScaling (bool Ignore)  void SetObjectID (int InObjectID)  void SetPitch (int32 Pitch_x1000)  void SetPlayerHit (bool Enable)  void SetProjectileAttribute (bool Attribute)  void SetProrateOnce (bool Once)  void SetPushCollisionActive (bool Active)  void SetPushWidthExtend (int32 Extend)  void SetRoll (int32 Roll_x1000)  void SetSpeedXRaw (int InSpeedX)  void SetTimeUntilNextCel (int32 InTime)  void SetWallCollisionActive (bool Active)  void SetYaw (int32 Yaw_x1000)  void StartSuperFreeze (int Duration, int SelfDuration=0)  virtual void Tick (float DeltaTime) override void TriggerEvent (EEventType EventType, FGameplayTag StateMachineName)  virtual void Update ()  virtual void UpdateVisuals ()  virtual void UpdateVisualsNoRollback ()  void UpdateVisuals_BP ()  void UseGauge (int32 GaugeIndex, int32 Value)"},{"location":"NightSkyEngine/class_a_player_object/#public-static-functions","title":"Public Static Functions","text":"Type Name uint32 FlipInput (uint32 Input)"},{"location":"NightSkyEngine/class_a_player_object/#public-static-functions-inherited-from-abattleobject","title":"Public Static Functions inherited from ABattleObject","text":"<p>See ABattleObject</p> Type Name int32 NormalizeAngle (int32 Angle_x1000)"},{"location":"NightSkyEngine/class_a_player_object/#protected-attributes","title":"Protected Attributes","text":"Type Name uint32 AirDashNoAttackTime   = <code>0</code> uint32 AirDashTimerMax   = <code>0</code> int32 AutoComboCancels   = <code>{}</code> FGameplayTag BufferedStateName uint32 CancelFlags   = <code>0</code> uint32 CurrentAirDashCount   = <code>0</code> uint32 CurrentAirJumpCount   = <code>0</code> FGameplayTag ExeStateName uint32 InstantBlockLockoutTimer   = <code>0</code> FGameplayTag LastStateName uint32 MeterCooldownTimer   = <code>0</code> int32 ThrowRange   = <code>0</code> int32 ThrowTechTimer   = <code>0</code> bool bIsAutoCombo   = <code>false</code>"},{"location":"NightSkyEngine/class_a_player_object/#protected-attributes-inherited-from-abattleobject","title":"Protected Attributes inherited from ABattleObject","text":"<p>See ABattleObject</p> Type Name int32 PushHeight   = <code>0</code> int32 PushHeightLow   = <code>0</code> int32 PushWidth   = <code>0</code> int32 PushWidthExtend   = <code>0</code>"},{"location":"NightSkyEngine/class_a_player_object/#protected-functions-inherited-from-abattleobject","title":"Protected Functions inherited from ABattleObject","text":"<p>See ABattleObject</p> Type Name virtual void BeginPlay () override void CalculateHoming ()  void FuncCall (const FName &amp; FuncName) const UNightSkyAnimSequenceUserData * GetAnimSequenceUserData (const FName PartName) const TArray&lt; UNightSkyAnimSequenceUserData * &gt; GetAnimSequenceUserDatas () const void Move ()  bool SuperArmorSuccess (const ABattleObject * Attacker) const"},{"location":"NightSkyEngine/class_a_player_object/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_player_object/#variable-airdashcount","title":"variable AirDashCount","text":"<pre><code>int32 APlayerObject::AirDashCount;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-airdashminimumheight","title":"variable AirDashMinimumHeight","text":"<pre><code>int32 APlayerObject::AirDashMinimumHeight;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-airdashtimer","title":"variable AirDashTimer","text":"<pre><code>uint32 APlayerObject::AirDashTimer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-airjumpcount","title":"variable AirJumpCount","text":"<pre><code>int32 APlayerObject::AirJumpCount;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-airpushheight","title":"variable AirPushHeight","text":"<pre><code>int32 APlayerObject::AirPushHeight;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-airpushheightlow","title":"variable AirPushHeightLow","text":"<pre><code>int32 APlayerObject::AirPushHeightLow;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-airpushwidth","title":"variable AirPushWidth","text":"<pre><code>int32 APlayerObject::AirPushWidth;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-bairdashnoattacktime","title":"variable BAirDashNoAttackTime","text":"<pre><code>int32 APlayerObject::BAirDashNoAttackTime;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-bairdashspeed","title":"variable BAirDashSpeed","text":"<pre><code>int32 APlayerObject::BAirDashSpeed;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-bairdashtime","title":"variable BAirDashTime","text":"<pre><code>int32 APlayerObject::BAirDashTime;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-bdashgravity","title":"variable BDashGravity","text":"<pre><code>int32 APlayerObject::BDashGravity;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-bdashheight","title":"variable BDashHeight","text":"<pre><code>int32 APlayerObject::BDashHeight;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-bdashspeed","title":"variable BDashSpeed","text":"<pre><code>int32 APlayerObject::BDashSpeed;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-bjumpspeed","title":"variable BJumpSpeed","text":"<pre><code>int32 APlayerObject::BJumpSpeed;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-bsuperjumpspeed","title":"variable BSuperJumpSpeed","text":"<pre><code>int32 APlayerObject::BSuperJumpSpeed;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-bwalkspeed","title":"variable BWalkSpeed","text":"<pre><code>int32 APlayerObject::BWalkSpeed;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-camerashakedata","title":"variable CameraShakeData","text":"<pre><code>UCameraShakeData* APlayerObject::CameraShakeData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-canproximitythrow","title":"variable CanProximityThrow","text":"<pre><code>bool APlayerObject::CanProximityThrow;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-canreversebeat","title":"variable CanReverseBeat","text":"<pre><code>bool APlayerObject::CanReverseBeat;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-chaincanceloptions","title":"variable ChainCancelOptions","text":"<pre><code>TArray&lt;int32&gt; APlayerObject::ChainCancelOptions;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-charaparticledata","title":"variable CharaParticleData","text":"<pre><code>UParticleData* APlayerObject::CharaParticleData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-charastatedata","title":"variable CharaStateData","text":"<pre><code>UStateData* APlayerObject::CharaStateData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-charasubroutinedata","title":"variable CharaSubroutineData","text":"<pre><code>USubroutineData* APlayerObject::CharaSubroutineData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-closenormalrange","title":"variable CloseNormalRange","text":"<pre><code>int32 APlayerObject::CloseNormalRange;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-cmnplayerreg1","title":"variable CmnPlayerReg1","text":"<pre><code>int32 APlayerObject::CmnPlayerReg1;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-cmnplayerreg2","title":"variable CmnPlayerReg2","text":"<pre><code>int32 APlayerObject::CmnPlayerReg2;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-cmnplayerreg3","title":"variable CmnPlayerReg3","text":"<pre><code>int32 APlayerObject::CmnPlayerReg3;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-cmnplayerreg4","title":"variable CmnPlayerReg4","text":"<pre><code>int32 APlayerObject::CmnPlayerReg4;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-cmnplayerreg5","title":"variable CmnPlayerReg5","text":"<pre><code>int32 APlayerObject::CmnPlayerReg5;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-cmnplayerreg6","title":"variable CmnPlayerReg6","text":"<pre><code>int32 APlayerObject::CmnPlayerReg6;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-cmnplayerreg7","title":"variable CmnPlayerReg7","text":"<pre><code>int32 APlayerObject::CmnPlayerReg7;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-cmnplayerreg8","title":"variable CmnPlayerReg8","text":"<pre><code>int32 APlayerObject::CmnPlayerReg8;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-collisiondata","title":"variable CollisionData","text":"<pre><code>UCollisionData* APlayerObject::CollisionData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-colorindex","title":"variable ColorIndex","text":"<pre><code>int32 APlayerObject::ColorIndex;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-combocounter","title":"variable ComboCounter","text":"<pre><code>int32 APlayerObject::ComboCounter;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-comborate","title":"variable ComboRate","text":"<pre><code>int32 APlayerObject::ComboRate;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-combotimer","title":"variable ComboTimer","text":"<pre><code>int32 APlayerObject::ComboTimer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-commoncollisiondata","title":"variable CommonCollisionData","text":"<pre><code>UCollisionData* APlayerObject::CommonCollisionData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-commonlinkactordata","title":"variable CommonLinkActorData","text":"<pre><code>ULinkActorData* APlayerObject::CommonLinkActorData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-commonobjectstatedata","title":"variable CommonObjectStateData","text":"<pre><code>UStateData* APlayerObject::CommonObjectStateData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-commonobjectstatenames","title":"variable CommonObjectStateNames","text":"<pre><code>TArray&lt;FGameplayTag&gt; APlayerObject::CommonObjectStateNames;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-commonobjectstates","title":"variable CommonObjectStates","text":"<pre><code>TArray&lt;UState*&gt; APlayerObject::CommonObjectStates;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-commonparticledata","title":"variable CommonParticleData","text":"<pre><code>UParticleData* APlayerObject::CommonParticleData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-commonsequencedata","title":"variable CommonSequenceData","text":"<pre><code>USequenceData* APlayerObject::CommonSequenceData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-commonsounddata","title":"variable CommonSoundData","text":"<pre><code>USoundData* APlayerObject::CommonSoundData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-commonsubroutinedata","title":"variable CommonSubroutineData","text":"<pre><code>USubroutineData* APlayerObject::CommonSubroutineData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-commonsubroutinenames","title":"variable CommonSubroutineNames","text":"<pre><code>TArray&lt;FGameplayTag&gt; APlayerObject::CommonSubroutineNames;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-commonsubroutines","title":"variable CommonSubroutines","text":"<pre><code>TArray&lt;USubroutine*&gt; APlayerObject::CommonSubroutines;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-componentvisible","title":"variable ComponentVisible","text":"<pre><code>bool APlayerObject::ComponentVisible[MaxComponentCount];\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-crouchpushheight","title":"variable CrouchPushHeight","text":"<pre><code>int32 APlayerObject::CrouchPushHeight;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-crouchpushwidth","title":"variable CrouchPushWidth","text":"<pre><code>int32 APlayerObject::CrouchPushWidth;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-currenthealth","title":"variable CurrentHealth","text":"<pre><code>int32 APlayerObject::CurrentHealth;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-damagereactioncels","title":"variable DamageReactionCels","text":"<pre><code>TMap&lt;FGameplayTag, FGameplayTag&gt; APlayerObject::DamageReactionCels;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-enemy","title":"variable Enemy","text":"<pre><code>APlayerObject* APlayerObject::Enemy;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-extragauges","title":"variable ExtraGauges","text":"<pre><code>TArray&lt;FExtraGauge&gt; APlayerObject::ExtraGauges;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-fairdashnoattacktime","title":"variable FAirDashNoAttackTime","text":"<pre><code>int32 APlayerObject::FAirDashNoAttackTime;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-fairdashspeed","title":"variable FAirDashSpeed","text":"<pre><code>int32 APlayerObject::FAirDashSpeed;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-fairdashtime","title":"variable FAirDashTime","text":"<pre><code>int32 APlayerObject::FAirDashTime;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-fdashaccel","title":"variable FDashAccel","text":"<pre><code>int32 APlayerObject::FDashAccel;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-fdashfriction","title":"variable FDashFriction","text":"<pre><code>int32 APlayerObject::FDashFriction;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-fdashinitspeed","title":"variable FDashInitSpeed","text":"<pre><code>int32 APlayerObject::FDashInitSpeed;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-fdashmaxspeed","title":"variable FDashMaxSpeed","text":"<pre><code>int32 APlayerObject::FDashMaxSpeed;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-fjumpspeed","title":"variable FJumpSpeed","text":"<pre><code>int32 APlayerObject::FJumpSpeed;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-fsuperjumpspeed","title":"variable FSuperJumpSpeed","text":"<pre><code>int32 APlayerObject::FSuperJumpSpeed;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-fwalkspeed","title":"variable FWalkSpeed","text":"<pre><code>int32 APlayerObject::FWalkSpeed;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-flipinputs","title":"variable FlipInputs","text":"<pre><code>bool APlayerObject::FlipInputs;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-forwardairdashmetergain","title":"variable ForwardAirDashMeterGain","text":"<pre><code>int32 APlayerObject::ForwardAirDashMeterGain;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-forwarddashmetergain","title":"variable ForwardDashMeterGain","text":"<pre><code>int32 APlayerObject::ForwardDashMeterGain;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-forwardjumpmetergain","title":"variable ForwardJumpMeterGain","text":"<pre><code>int32 APlayerObject::ForwardJumpMeterGain;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-forwardwalkmetergain","title":"variable ForwardWalkMeterGain","text":"<pre><code>int32 APlayerObject::ForwardWalkMeterGain;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-inputs","title":"variable Inputs","text":"<pre><code>uint32 APlayerObject::Inputs;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-introendflag","title":"variable IntroEndFlag","text":"<pre><code>bool APlayerObject::IntroEndFlag;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-introname","title":"variable IntroName","text":"<pre><code>FGameplayTag APlayerObject::IntroName;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-invulnflags","title":"variable InvulnFlags","text":"<pre><code>uint32 APlayerObject::InvulnFlags;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-jumpgravity","title":"variable JumpGravity","text":"<pre><code>int32 APlayerObject::JumpGravity;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-jumpheight","title":"variable JumpHeight","text":"<pre><code>int32 APlayerObject::JumpHeight;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-linkactordata","title":"variable LinkActorData","text":"<pre><code>ULinkActorData* APlayerObject::LinkActorData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-materialdata","title":"variable MaterialData","text":"<pre><code>UMaterialData* APlayerObject::MaterialData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-maxcolorindex","title":"variable MaxColorIndex","text":"<pre><code>int32 APlayerObject::MaxColorIndex;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-maxhealth","title":"variable MaxHealth","text":"<pre><code>int32 APlayerObject::MaxHealth;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-maxmeter","title":"variable MaxMeter","text":"<pre><code>int32 APlayerObject::MaxMeter;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-maxotgcount","title":"variable MaxOTGCount","text":"<pre><code>int32 APlayerObject::MaxOTGCount;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-meterpercentonhit","title":"variable MeterPercentOnHit","text":"<pre><code>int32 APlayerObject::MeterPercentOnHit;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-meterpercentonhitguard","title":"variable MeterPercentOnHitGuard","text":"<pre><code>int32 APlayerObject::MeterPercentOnHitGuard;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-meterpercentonreceivehit","title":"variable MeterPercentOnReceiveHit","text":"<pre><code>int32 APlayerObject::MeterPercentOnReceiveHit;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-meterpercentonreceivehitguard","title":"variable MeterPercentOnReceiveHitGuard","text":"<pre><code>int32 APlayerObject::MeterPercentOnReceiveHitGuard;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-movesusedinchain","title":"variable MovesUsedInChain","text":"<pre><code>TArray&lt;int32&gt; APlayerObject::MovesUsedInChain;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-movesusedincombo","title":"variable MovesUsedInCombo","text":"<pre><code>TArray&lt;int32&gt; APlayerObject::MovesUsedInCombo;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-otgcount","title":"variable OTGCount","text":"<pre><code>int32 APlayerObject::OTGCount;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-objectstatedata","title":"variable ObjectStateData","text":"<pre><code>UStateData* APlayerObject::ObjectStateData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-objectstatenames","title":"variable ObjectStateNames","text":"<pre><code>TArray&lt;FGameplayTag&gt; APlayerObject::ObjectStateNames;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-objectstates","title":"variable ObjectStates","text":"<pre><code>TArray&lt;UState*&gt; APlayerObject::ObjectStates;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-otgproration","title":"variable OtgProration","text":"<pre><code>int32 APlayerObject::OtgProration;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-playerflags","title":"variable PlayerFlags","text":"<pre><code>uint32 APlayerObject::PlayerFlags;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-playerindex","title":"variable PlayerIndex","text":"<pre><code>int32 APlayerObject::PlayerIndex;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-playerreg1","title":"variable PlayerReg1","text":"<pre><code>int32 APlayerObject::PlayerReg1;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-playerreg2","title":"variable PlayerReg2","text":"<pre><code>int32 APlayerObject::PlayerReg2;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-playerreg3","title":"variable PlayerReg3","text":"<pre><code>int32 APlayerObject::PlayerReg3;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-playerreg4","title":"variable PlayerReg4","text":"<pre><code>int32 APlayerObject::PlayerReg4;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-playerreg5","title":"variable PlayerReg5","text":"<pre><code>int32 APlayerObject::PlayerReg5;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-playerreg6","title":"variable PlayerReg6","text":"<pre><code>int32 APlayerObject::PlayerReg6;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-playerreg7","title":"variable PlayerReg7","text":"<pre><code>int32 APlayerObject::PlayerReg7;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-playerreg8","title":"variable PlayerReg8","text":"<pre><code>int32 APlayerObject::PlayerReg8;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-playersync","title":"variable PlayerSync","text":"<pre><code>unsigned char APlayerObject::PlayerSync;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-playersyncend","title":"variable PlayerSyncEnd","text":"<pre><code>unsigned char APlayerObject::PlayerSyncEnd;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-primarystatemachine","title":"variable PrimaryStateMachine","text":"<pre><code>FStateMachine APlayerObject::PrimaryStateMachine;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-proximitythrowinput","title":"variable ProximityThrowInput","text":"<pre><code>FInputCondition APlayerObject::ProximityThrowInput;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-recoverablehealth","title":"variable RecoverableHealth","text":"<pre><code>int32 APlayerObject::RecoverableHealth;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-roundendflag","title":"variable RoundEndFlag","text":"<pre><code>bool APlayerObject::RoundEndFlag;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-roundwintimer","title":"variable RoundWinTimer","text":"<pre><code>int32 APlayerObject::RoundWinTimer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-sequencedata","title":"variable SequenceData","text":"<pre><code>USequenceData* APlayerObject::SequenceData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-sounddata","title":"variable SoundData","text":"<pre><code>USoundData* APlayerObject::SoundData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-stance","title":"variable Stance","text":"<pre><code>TEnumAsByte&lt;EActionStance&gt; APlayerObject::Stance;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-standpushheight","title":"variable StandPushHeight","text":"<pre><code>int32 APlayerObject::StandPushHeight;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-standpushwidth","title":"variable StandPushWidth","text":"<pre><code>int32 APlayerObject::StandPushWidth;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-stateentryname","title":"variable StateEntryName","text":"<pre><code>FGameplayTag APlayerObject::StateEntryName;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-storedbattleobjects","title":"variable StoredBattleObjects","text":"<pre><code>ABattleObject* APlayerObject::StoredBattleObjects[16];\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-storedinputbuffer","title":"variable StoredInputBuffer","text":"<pre><code>FInputBuffer APlayerObject::StoredInputBuffer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-storedlinkactors","title":"variable StoredLinkActors","text":"<pre><code>TArray&lt;FLinkedActorContainer&gt; APlayerObject::StoredLinkActors;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-strikeinvulnerabletimer","title":"variable StrikeInvulnerableTimer","text":"<pre><code>uint32 APlayerObject::StrikeInvulnerableTimer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-substatedata","title":"variable SubStateData","text":"<pre><code>TMap&lt;FGameplayTag, UStateData*&gt; APlayerObject::SubStateData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-substatemachines","title":"variable SubStateMachines","text":"<pre><code>TArray&lt;FStateMachine&gt; APlayerObject::SubStateMachines;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-subroutinenames","title":"variable SubroutineNames","text":"<pre><code>TArray&lt;FGameplayTag&gt; APlayerObject::SubroutineNames;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-subroutines","title":"variable Subroutines","text":"<pre><code>TArray&lt;USubroutine*&gt; APlayerObject::Subroutines;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-superjumpgravity","title":"variable SuperJumpGravity","text":"<pre><code>int32 APlayerObject::SuperJumpGravity;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-superjumpheight","title":"variable SuperJumpHeight","text":"<pre><code>int32 APlayerObject::SuperJumpHeight;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-teamindex","title":"variable TeamIndex","text":"<pre><code>int32 APlayerObject::TeamIndex;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-throwinvulnerabletimer","title":"variable ThrowInvulnerableTimer","text":"<pre><code>uint32 APlayerObject::ThrowInvulnerableTimer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-throwresistafterwakeup","title":"variable ThrowResistAfterWakeUp","text":"<pre><code>int32 APlayerObject::ThrowResistAfterWakeUp;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-throwresisttimer","title":"variable ThrowResistTimer","text":"<pre><code>uint32 APlayerObject::ThrowResistTimer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-throwtechwindow","title":"variable ThrowTechWindow","text":"<pre><code>int32 APlayerObject::ThrowTechWindow;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-totalproration","title":"variable TotalProration","text":"<pre><code>int32 APlayerObject::TotalProration;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-voicedata","title":"variable VoiceData","text":"<pre><code>USoundData* APlayerObject::VoiceData;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-walltouchtimer","title":"variable WallTouchTimer","text":"<pre><code>int32 APlayerObject::WallTouchTimer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-whiffcanceloptions","title":"variable WhiffCancelOptions","text":"<pre><code>TArray&lt;int32&gt; APlayerObject::WhiffCancelOptions;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-bcrumpled","title":"variable bCrumpled","text":"<pre><code>bool APlayerObject::bCrumpled;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-biscpu","title":"variable bIsCpu","text":"<pre><code>bool APlayerObject::bIsCpu;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-blimitcrumple","title":"variable bLimitCrumple","text":"<pre><code>bool APlayerObject::bLimitCrumple;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-bmirrorwhenflip","title":"variable bMirrorWhenFlip","text":"<pre><code>bool APlayerObject::bMirrorWhenFlip;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_player_object/#function-aplayerobject","title":"function APlayerObject","text":"<pre><code>APlayerObject::APlayerObject () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-addairdash","title":"function AddAirDash","text":"<pre><code>void APlayerObject::AddAirDash (\n    int32 NewAirDash\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-addairjump","title":"function AddAirJump","text":"<pre><code>void APlayerObject::AddAirJump (\n    int32 NewAirJump\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-addautocombocancel","title":"function AddAutoComboCancel","text":"<pre><code>void APlayerObject::AddAutoComboCancel (\n    FGameplayTag Option,\n    EInputFlags Button\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-addbattleobjecttostorage","title":"function AddBattleObjectToStorage","text":"<pre><code>void APlayerObject::AddBattleObjectToStorage (\n    ABattleObject * InActor,\n    int Index\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-addchaincanceloption","title":"function AddChainCancelOption","text":"<pre><code>void APlayerObject::AddChainCancelOption (\n    FGameplayTag Option\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-addhealth","title":"function AddHealth","text":"<pre><code>void APlayerObject::AddHealth (\n    int Value\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-addmeter","title":"function AddMeter","text":"<pre><code>void APlayerObject::AddMeter (\n    int Meter\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-addobjectstate","title":"function AddObjectState","text":"<pre><code>void APlayerObject::AddObjectState (\n    FGameplayTag Name,\n    UState * State,\n    bool IsCommon\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-addrecoverablehealth","title":"function AddRecoverableHealth","text":"<pre><code>void APlayerObject::AddRecoverableHealth (\n    int Value\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-addstate","title":"function AddState","text":"<pre><code>void APlayerObject::AddState (\n    FGameplayTag Name,\n    UState * State,\n    FGameplayTag StateMachineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-addsubroutine","title":"function AddSubroutine","text":"<pre><code>void APlayerObject::AddSubroutine (\n    FGameplayTag Name,\n    USubroutine * Subroutine,\n    bool IsCommon\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-addwhiffcanceloption","title":"function AddWhiffCancelOption","text":"<pre><code>void APlayerObject::AddWhiffCancelOption (\n    FGameplayTag Option\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-battlehudvisibility","title":"function BattleHudVisibility","text":"<pre><code>void APlayerObject::BattleHudVisibility (\n    bool Visible\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-callassist","title":"function CallAssist","text":"<pre><code>APlayerObject * APlayerObject::CallAssist (\n    int AssistIndex,\n    FGameplayTag AssistName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-canenterstate","title":"function CanEnterState","text":"<pre><code>bool APlayerObject::CanEnterState (\n    UState * State,\n    FGameplayTag StateMachineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-checkenemyinrange","title":"function CheckEnemyInRange","text":"<pre><code>bool APlayerObject::CheckEnemyInRange (\n    int32 XBegin,\n    int32 XEnd,\n    int32 YBegin,\n    int32 YEnd\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-checkhashit","title":"function CheckHasHit","text":"<pre><code>bool APlayerObject::CheckHasHit () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-checkinput","title":"function CheckInput","text":"<pre><code>bool APlayerObject::CheckInput (\n    const FInputCondition &amp; Input\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-checkisattacking","title":"function CheckIsAttacking","text":"<pre><code>bool APlayerObject::CheckIsAttacking () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-checkisstunned","title":"function CheckIsStunned","text":"<pre><code>bool APlayerObject::CheckIsStunned () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-checkstateenabled","title":"function CheckStateEnabled","text":"<pre><code>bool APlayerObject::CheckStateEnabled (\n    EStateType StateType,\n    FGameplayTag CustomStateType,\n    FGameplayTag StateMachineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-disableall","title":"function DisableAll","text":"<pre><code>void APlayerObject::DisableAll (\n    FGameplayTag StateMachineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-disablecustomstate","title":"function DisableCustomState","text":"<pre><code>void APlayerObject::DisableCustomState (\n    FGameplayTag CustomStateType,\n    FGameplayTag StateMachineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-disablestate","title":"function DisableState","text":"<pre><code>void APlayerObject::DisableState (\n    UPARAM(meta=(Bitmask, BitmaskEnum=\"/Script/NightSkyEngine.EEnableFlags\")) int32 Bitmask,\n    FGameplayTag StateMachineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-editorupdate","title":"function EditorUpdate","text":"<pre><code>void APlayerObject::EditorUpdate () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-emptystatemachine","title":"function EmptyStateMachine","text":"<pre><code>void APlayerObject::EmptyStateMachine () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-enableall","title":"function EnableAll","text":"<pre><code>void APlayerObject::EnableAll (\n    FGameplayTag StateMachineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-enableattacks","title":"function EnableAttacks","text":"<pre><code>void APlayerObject::EnableAttacks () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-enablecancelintoself","title":"function EnableCancelIntoSelf","text":"<pre><code>void APlayerObject::EnableCancelIntoSelf (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-enablechaincancel","title":"function EnableChainCancel","text":"<pre><code>void APlayerObject::EnableChainCancel (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-enablecustomstate","title":"function EnableCustomState","text":"<pre><code>void APlayerObject::EnableCustomState (\n    FGameplayTag CustomStateType,\n    FGameplayTag StateMachineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-enableforwardairdashcancel","title":"function EnableForwardAirdashCancel","text":"<pre><code>void APlayerObject::EnableForwardAirdashCancel (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-enablejumpcancel","title":"function EnableJumpCancel","text":"<pre><code>void APlayerObject::EnableJumpCancel (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-enablereversebeat","title":"function EnableReverseBeat","text":"<pre><code>void APlayerObject::EnableReverseBeat (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-enablespecialcancel","title":"function EnableSpecialCancel","text":"<pre><code>void APlayerObject::EnableSpecialCancel (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-enablestate","title":"function EnableState","text":"<pre><code>void APlayerObject::EnableState (\n    UPARAM(meta=(Bitmask, BitmaskEnum=\"/Script/NightSkyEngine.EEnableFlags\")) int32 Bitmask,\n    FGameplayTag StateMachineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-enablesupercancel","title":"function EnableSuperCancel","text":"<pre><code>void APlayerObject::EnableSuperCancel (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-enablewhiffcancel","title":"function EnableWhiffCancel","text":"<pre><code>void APlayerObject::EnableWhiffCancel (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-endmatch","title":"function EndMatch","text":"<pre><code>void APlayerObject::EndMatch () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-endround","title":"function EndRound","text":"<pre><code>void APlayerObject::EndRound () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-forceenablefarnormal","title":"function ForceEnableFarNormal","text":"<pre><code>void APlayerObject::ForceEnableFarNormal (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-getattackblocktype","title":"function GetAttackBlockType","text":"<pre><code>EBlockType APlayerObject::GetAttackBlockType () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-getcurrentstatename","title":"function GetCurrentStateName","text":"<pre><code>FGameplayTag APlayerObject::GetCurrentStateName (\n    FGameplayTag StateMachineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-getenableflags","title":"function GetEnableFlags","text":"<pre><code>int32 APlayerObject::GetEnableFlags (\n    FGameplayTag StateMachineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-getlaststatename","title":"function GetLastStateName","text":"<pre><code>FGameplayTag APlayerObject::GetLastStateName () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-getstateentryname","title":"function GetStateEntryName","text":"<pre><code>FGameplayTag APlayerObject::GetStateEntryName () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-getstatemachine","title":"function GetStateMachine","text":"<pre><code>FStateMachine &amp; APlayerObject::GetStateMachine (\n    FGameplayTag StateMachineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-handleautocombo","title":"function HandleAutoCombo","text":"<pre><code>bool APlayerObject::HandleAutoCombo (\n    int32 StateIndex,\n    FStateMachine &amp; StateMachine\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-handleblockaction","title":"function HandleBlockAction","text":"<pre><code>void APlayerObject::HandleBlockAction () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-handlebufferedstate-12","title":"function HandleBufferedState [1/2]","text":"<pre><code>void APlayerObject::HandleBufferedState () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-handlebufferedstate-22","title":"function HandleBufferedState [2/2]","text":"<pre><code>void APlayerObject::HandleBufferedState (\n    FStateMachine &amp; StateMachine\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-handleendcombo","title":"function HandleEndCombo","text":"<pre><code>void APlayerObject::HandleEndCombo () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-handleflipinput","title":"function HandleFlipInput","text":"<pre><code>void APlayerObject::HandleFlipInput () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-handlehitaction","title":"function HandleHitAction","text":"<pre><code>void APlayerObject::HandleHitAction (\n    EHitAction HACT\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-handleproximityblock","title":"function HandleProximityBlock","text":"<pre><code>void APlayerObject::HandleProximityBlock () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-handlestateinputs","title":"function HandleStateInputs","text":"<pre><code>bool APlayerObject::HandleStateInputs (\n    int32 StateIndex,\n    bool Buffer,\n    FStateMachine &amp; StateMachine\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-handlestatemachine","title":"function HandleStateMachine","text":"<pre><code>void APlayerObject::HandleStateMachine (\n    bool Buffer,\n    FStateMachine &amp; StateMachine\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-handlestatetransition","title":"function HandleStateTransition","text":"<pre><code>bool APlayerObject::HandleStateTransition (\n    int32 StateIndex,\n    bool Buffer,\n    FStateMachine &amp; StateMachine\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-initbp","title":"function InitBP","text":"<pre><code>void APlayerObject::InitBP () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-initplayer","title":"function InitPlayer","text":"<pre><code>void APlayerObject::InitPlayer () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-iscorrectblock","title":"function IsCorrectBlock","text":"<pre><code>bool APlayerObject::IsCorrectBlock (\n    EBlockType BlockType\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-isenemyattackstate","title":"function IsEnemyAttackState","text":"<pre><code>bool APlayerObject::IsEnemyAttackState () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-isenemyblocking","title":"function IsEnemyBlocking","text":"<pre><code>bool APlayerObject::IsEnemyBlocking () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-isenemythrow","title":"function IsEnemyThrow","text":"<pre><code>bool APlayerObject::IsEnemyThrow () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-isinvulnerable","title":"function IsInvulnerable","text":"<pre><code>bool APlayerObject::IsInvulnerable (\n    const ABattleObject * Attacker\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-isinvulnerable_bp","title":"function IsInvulnerable_BP","text":"<pre><code>bool APlayerObject::IsInvulnerable_BP () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-ismainplayer","title":"function IsMainPlayer","text":"<pre><code>bool APlayerObject::IsMainPlayer () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-isonscreen","title":"function IsOnScreen","text":"<pre><code>bool APlayerObject::IsOnScreen () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-istouchingwall","title":"function IsTouchingWall","text":"<pre><code>bool APlayerObject::IsTouchingWall () const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-jumptostate","title":"function JumpToState","text":"<pre><code>bool APlayerObject::JumpToState (\n    FGameplayTag NewName,\n    FGameplayTag StateMachineName,\n    bool IsLabel=false\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-jumptostatebyclass","title":"function JumpToStateByClass","text":"<pre><code>bool APlayerObject::JumpToStateByClass (\n    TSubclassOf&lt; UState &gt; Class,\n    FGameplayTag StateMachineName,\n    bool IsLabel=false\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-jumptostatebyclassprimary","title":"function JumpToStateByClassPrimary","text":"<pre><code>bool APlayerObject::JumpToStateByClassPrimary (\n    TSubclassOf&lt; UState &gt; Class,\n    bool IsLabel=false\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-jumptostateprimary","title":"function JumpToStatePrimary","text":"<pre><code>bool APlayerObject::JumpToStatePrimary (\n    FGameplayTag NewName,\n    bool IsLabel=false\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-loadforrollbackbp","title":"function LoadForRollbackBP","text":"<pre><code>void APlayerObject::LoadForRollbackBP (\n    TArray&lt; uint8 &gt; InBytes\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-loadforrollbackplayer","title":"function LoadForRollbackPlayer","text":"<pre><code>void APlayerObject::LoadForRollbackPlayer (\n    const unsigned char * Buffer\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-onstatechange","title":"function OnStateChange","text":"<pre><code>void APlayerObject::OnStateChange () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-pauseroundtimer","title":"function PauseRoundTimer","text":"<pre><code>void APlayerObject::PauseRoundTimer (\n    bool Pause\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-playcommonlevelsequence","title":"function PlayCommonLevelSequence","text":"<pre><code>void APlayerObject::PlayCommonLevelSequence (\n    FGameplayTag Name\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-playlevelsequence","title":"function PlayLevelSequence","text":"<pre><code>void APlayerObject::PlayLevelSequence (\n    FGameplayTag Name\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-playvoiceline","title":"function PlayVoiceLine","text":"<pre><code>void APlayerObject::PlayVoiceLine (\n    FGameplayTag Name\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-poststatechange","title":"function PostStateChange","text":"<pre><code>void APlayerObject::PostStateChange () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-recoverhealth","title":"function RecoverHealth","text":"<pre><code>void APlayerObject::RecoverHealth (\n    int Value\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-removeautocombocancel","title":"function RemoveAutoComboCancel","text":"<pre><code>void APlayerObject::RemoveAutoComboCancel (\n    EInputFlags Button\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-removechaincanceloption","title":"function RemoveChainCancelOption","text":"<pre><code>void APlayerObject::RemoveChainCancelOption (\n    FGameplayTag Option\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-removewhiffcanceloption","title":"function RemoveWhiffCancelOption","text":"<pre><code>void APlayerObject::RemoveWhiffCancelOption (\n    FGameplayTag Option\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-resetairdash","title":"function ResetAirDash","text":"<pre><code>void APlayerObject::ResetAirDash () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-resetairjump","title":"function ResetAirJump","text":"<pre><code>void APlayerObject::ResetAirJump () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-roundinit","title":"function RoundInit","text":"<pre><code>void APlayerObject::RoundInit (\n    bool ResetHealth\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-roundinit_bp","title":"function RoundInit_BP","text":"<pre><code>void APlayerObject::RoundInit_BP () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-saveforrollbackbp","title":"function SaveForRollbackBP","text":"<pre><code>TArray&lt; uint8 &gt; APlayerObject::SaveForRollbackBP () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-saveforrollbackplayer","title":"function SaveForRollbackPlayer","text":"<pre><code>void APlayerObject::SaveForRollbackPlayer (\n    unsigned char * Buffer\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setairdashnoattacktimer","title":"function SetAirDashNoAttackTimer","text":"<pre><code>void APlayerObject::SetAirDashNoAttackTimer (\n    bool IsForward\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setairdashtimer","title":"function SetAirDashTimer","text":"<pre><code>void APlayerObject::SetAirDashTimer (\n    bool IsForward\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setdamagereactioncel","title":"function SetDamageReactionCel","text":"<pre><code>void APlayerObject::SetDamageReactionCel (\n    FGameplayTag Type\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setdefaultcomponentvisibility","title":"function SetDefaultComponentVisibility","text":"<pre><code>void APlayerObject::SetDefaultComponentVisibility () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setdefaultlandingaction","title":"function SetDefaultLandingAction","text":"<pre><code>void APlayerObject::SetDefaultLandingAction (\n    bool Enable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setguardvalues","title":"function SetGuardValues","text":"<pre><code>void APlayerObject::SetGuardValues () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setheadattribute","title":"function SetHeadAttribute","text":"<pre><code>void APlayerObject::SetHeadAttribute (\n    bool Attribute\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setheadinvulnerable","title":"function SetHeadInvulnerable","text":"<pre><code>void APlayerObject::SetHeadInvulnerable (\n    bool Invulnerable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-sethealth","title":"function SetHealth","text":"<pre><code>void APlayerObject::SetHealth (\n    int Value\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-sethitvalues","title":"function SetHitValues","text":"<pre><code>void APlayerObject::SetHitValues (\n    bool bCustomAir=false\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-sethitvaluesovertime","title":"function SetHitValuesOverTime","text":"<pre><code>void APlayerObject::SetHitValuesOverTime () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-sethitgrabactive","title":"function SetHitgrabActive","text":"<pre><code>void APlayerObject::SetHitgrabActive (\n    bool Active\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setknockdownstate","title":"function SetKnockdownState","text":"<pre><code>void APlayerObject::SetKnockdownState () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setmetercooldowntimer","title":"function SetMeterCooldownTimer","text":"<pre><code>void APlayerObject::SetMeterCooldownTimer (\n    int Timer\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setonscreen","title":"function SetOnScreen","text":"<pre><code>void APlayerObject::SetOnScreen (\n    bool OnScreen\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setprojectileinvulnerable","title":"function SetProjectileInvulnerable","text":"<pre><code>void APlayerObject::SetProjectileInvulnerable (\n    bool Invulnerable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setrecoverablehealth","title":"function SetRecoverableHealth","text":"<pre><code>void APlayerObject::SetRecoverableHealth (\n    int Value\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setstance","title":"function SetStance","text":"<pre><code>void APlayerObject::SetStance (\n    EActionStance InStance\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setstateforcpu","title":"function SetStateForCPU","text":"<pre><code>void APlayerObject::SetStateForCPU (\n    FGameplayTag StateName,\n    FGameplayTag StateMachineName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setstrikeinvulnerable","title":"function SetStrikeInvulnerable","text":"<pre><code>void APlayerObject::SetStrikeInvulnerable (\n    bool Invulnerable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setstrikeinvulnerablefortime","title":"function SetStrikeInvulnerableForTime","text":"<pre><code>void APlayerObject::SetStrikeInvulnerableForTime (\n    int32 Timer\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setstuntime","title":"function SetStunTime","text":"<pre><code>void APlayerObject::SetStunTime (\n    int32 NewTime\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setteamcooldown","title":"function SetTeamCooldown","text":"<pre><code>void APlayerObject::SetTeamCooldown (\n    int NewTeamIndex,\n    int Cooldown\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setthrowactive","title":"function SetThrowActive","text":"<pre><code>void APlayerObject::SetThrowActive (\n    bool Active\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setthrowexestate","title":"function SetThrowExeState","text":"<pre><code>void APlayerObject::SetThrowExeState (\n    FGameplayTag ExeState\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setthrowinvulnerable","title":"function SetThrowInvulnerable","text":"<pre><code>void APlayerObject::SetThrowInvulnerable (\n    bool Invulnerable\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setthrowinvulnerablefortime","title":"function SetThrowInvulnerableForTime","text":"<pre><code>void APlayerObject::SetThrowInvulnerableForTime (\n    int32 Timer\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setthrowposition","title":"function SetThrowPosition","text":"<pre><code>void APlayerObject::SetThrowPosition (\n    int32 ThrowPosX,\n    int32 ThrowPosY\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setthrowrange","title":"function SetThrowRange","text":"<pre><code>void APlayerObject::SetThrowRange (\n    int32 InThrowRange\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-setthrowresistfortime","title":"function SetThrowResistForTime","text":"<pre><code>void APlayerObject::SetThrowResistForTime (\n    int32 Timer\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-stoplevelsequence","title":"function StopLevelSequence","text":"<pre><code>void APlayerObject::StopLevelSequence () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-switchmainplayer","title":"function SwitchMainPlayer","text":"<pre><code>APlayerObject * APlayerObject::SwitchMainPlayer (\n    int NewTeamIndex,\n    bool bForce=false,\n    bool bEvenOnScreen=false\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-throwend","title":"function ThrowEnd","text":"<pre><code>void APlayerObject::ThrowEnd () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-throwexe","title":"function ThrowExe","text":"<pre><code>void APlayerObject::ThrowExe () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-togglecomponentvisibility","title":"function ToggleComponentVisibility","text":"<pre><code>void APlayerObject::ToggleComponentVisibility (\n    FName ComponentName,\n    bool Visible\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-update","title":"function Update","text":"<pre><code>virtual void APlayerObject::Update () override\n</code></pre> <p>Implements ABattleObject::Update</p>"},{"location":"NightSkyEngine/class_a_player_object/#function-updatenotbattle","title":"function UpdateNotBattle","text":"<pre><code>void APlayerObject::UpdateNotBattle () \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#function-usemeter","title":"function UseMeter","text":"<pre><code>void APlayerObject::UseMeter (\n    int Use\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_player_object/#function-flipinput","title":"function FlipInput","text":"<pre><code>static uint32 APlayerObject::FlipInput (\n    uint32 Input\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_player_object/#variable-airdashnoattacktime","title":"variable AirDashNoAttackTime","text":"<pre><code>uint32 APlayerObject::AirDashNoAttackTime;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-airdashtimermax","title":"variable AirDashTimerMax","text":"<pre><code>uint32 APlayerObject::AirDashTimerMax;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-autocombocancels","title":"variable AutoComboCancels","text":"<pre><code>int32 APlayerObject::AutoComboCancels[8];\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-bufferedstatename","title":"variable BufferedStateName","text":"<pre><code>FGameplayTag APlayerObject::BufferedStateName;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-cancelflags","title":"variable CancelFlags","text":"<pre><code>uint32 APlayerObject::CancelFlags;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-currentairdashcount","title":"variable CurrentAirDashCount","text":"<pre><code>uint32 APlayerObject::CurrentAirDashCount;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-currentairjumpcount","title":"variable CurrentAirJumpCount","text":"<pre><code>uint32 APlayerObject::CurrentAirJumpCount;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-exestatename","title":"variable ExeStateName","text":"<pre><code>FGameplayTag APlayerObject::ExeStateName;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-instantblocklockouttimer","title":"variable InstantBlockLockoutTimer","text":"<pre><code>uint32 APlayerObject::InstantBlockLockoutTimer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-laststatename","title":"variable LastStateName","text":"<pre><code>FGameplayTag APlayerObject::LastStateName;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-metercooldowntimer","title":"variable MeterCooldownTimer","text":"<pre><code>uint32 APlayerObject::MeterCooldownTimer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-throwrange","title":"variable ThrowRange","text":"<pre><code>int32 APlayerObject::ThrowRange;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-throwtechtimer","title":"variable ThrowTechTimer","text":"<pre><code>int32 APlayerObject::ThrowTechTimer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_player_object/#variable-bisautocombo","title":"variable bIsAutoCombo","text":"<pre><code>bool APlayerObject::bIsAutoCombo;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/PlayerObject.h</code></p>"},{"location":"NightSkyEngine/class_a_w_t_character/","title":"Class AWTCharacter","text":"<p>ClassList &gt; AWTCharacter</p> <p>Inherits the following classes: ACharacter</p>"},{"location":"NightSkyEngine/class_a_w_t_character/#public-attributes","title":"Public Attributes","text":"Type Name APlayerObject * BattlePlayer TSubclassOf&lt; APlayerObject &gt; BattlePlayerClass ANightSkyWTGameState * GameState"},{"location":"NightSkyEngine/class_a_w_t_character/#public-functions","title":"Public Functions","text":"Type Name AWTCharacter ()  void EndBattle ()  void EndBattle_BP ()  virtual void SetupPlayerInputComponent (class UInputComponent * PlayerInputComponent) override void StartBattle (AWTCharacter * Opponent)  virtual void Tick (float DeltaTime) override"},{"location":"NightSkyEngine/class_a_w_t_character/#protected-functions","title":"Protected Functions","text":"Type Name virtual void BeginPlay () override"},{"location":"NightSkyEngine/class_a_w_t_character/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_a_w_t_character/#variable-battleplayer","title":"variable BattlePlayer","text":"<pre><code>APlayerObject* AWTCharacter::BattlePlayer;\n</code></pre>"},{"location":"NightSkyEngine/class_a_w_t_character/#variable-battleplayerclass","title":"variable BattlePlayerClass","text":"<pre><code>TSubclassOf&lt;APlayerObject&gt; AWTCharacter::BattlePlayerClass;\n</code></pre>"},{"location":"NightSkyEngine/class_a_w_t_character/#variable-gamestate","title":"variable GameState","text":"<pre><code>ANightSkyWTGameState* AWTCharacter::GameState;\n</code></pre>"},{"location":"NightSkyEngine/class_a_w_t_character/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_w_t_character/#function-awtcharacter","title":"function AWTCharacter","text":"<pre><code>AWTCharacter::AWTCharacter () \n</code></pre>"},{"location":"NightSkyEngine/class_a_w_t_character/#function-endbattle","title":"function EndBattle","text":"<pre><code>void AWTCharacter::EndBattle () \n</code></pre>"},{"location":"NightSkyEngine/class_a_w_t_character/#function-endbattle_bp","title":"function EndBattle_BP","text":"<pre><code>void AWTCharacter::EndBattle_BP () \n</code></pre>"},{"location":"NightSkyEngine/class_a_w_t_character/#function-setupplayerinputcomponent","title":"function SetupPlayerInputComponent","text":"<pre><code>virtual void AWTCharacter::SetupPlayerInputComponent (\n    class UInputComponent * PlayerInputComponent\n) override\n</code></pre>"},{"location":"NightSkyEngine/class_a_w_t_character/#function-startbattle","title":"function StartBattle","text":"<pre><code>void AWTCharacter::StartBattle (\n    AWTCharacter * Opponent\n) \n</code></pre>"},{"location":"NightSkyEngine/class_a_w_t_character/#function-tick","title":"function Tick","text":"<pre><code>virtual void AWTCharacter::Tick (\n    float DeltaTime\n) override\n</code></pre>"},{"location":"NightSkyEngine/class_a_w_t_character/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_a_w_t_character/#function-beginplay","title":"function BeginPlay","text":"<pre><code>virtual void AWTCharacter::BeginPlay () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/WT/WTCharacter.h</code></p>"},{"location":"NightSkyEngine/struct_f_anim_rotator/","title":"Struct FAnimRotator","text":"<p>ClassList &gt; FAnimRotator</p>"},{"location":"NightSkyEngine/struct_f_anim_rotator/#public-attributes","title":"Public Attributes","text":"Type Name int32 Pitch int32 Roll int32 Yaw"},{"location":"NightSkyEngine/struct_f_anim_rotator/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_anim_rotator/#variable-pitch","title":"variable Pitch","text":"<pre><code>int32 FAnimRotator::Pitch;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_anim_rotator/#variable-roll","title":"variable Roll","text":"<pre><code>int32 FAnimRotator::Roll;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_anim_rotator/#variable-yaw","title":"variable Yaw","text":"<pre><code>int32 FAnimRotator::Yaw;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimSequenceUserData.h</code></p>"},{"location":"NightSkyEngine/struct_f_anim_struct/","title":"Struct FAnimStruct","text":"<p>ClassList &gt; FAnimStruct</p>"},{"location":"NightSkyEngine/struct_f_anim_struct/#public-attributes","title":"Public Attributes","text":"Type Name UAnimSequenceBase * AnimSequence UPaperFlipbook * Flipbook FName PartName   = <code>\"Body\"</code>"},{"location":"NightSkyEngine/struct_f_anim_struct/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_anim_struct/#variable-animsequence","title":"variable AnimSequence","text":"<pre><code>UAnimSequenceBase* FAnimStruct::AnimSequence;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_anim_struct/#variable-flipbook","title":"variable Flipbook","text":"<pre><code>UPaperFlipbook* FAnimStruct::Flipbook;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_anim_struct/#variable-partname","title":"variable PartName","text":"<pre><code>FName FAnimStruct::PartName;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/CollisionData.h</code></p>"},{"location":"NightSkyEngine/struct_f_anim_transform/","title":"Struct FAnimTransform","text":"<p>ClassList &gt; FAnimTransform</p>"},{"location":"NightSkyEngine/struct_f_anim_transform/#public-attributes","title":"Public Attributes","text":"Type Name FAnimVector Position FAnimRotator Rotation FAnimVector Scale"},{"location":"NightSkyEngine/struct_f_anim_transform/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_anim_transform/#variable-position","title":"variable Position","text":"<pre><code>FAnimVector FAnimTransform::Position;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_anim_transform/#variable-rotation","title":"variable Rotation","text":"<pre><code>FAnimRotator FAnimTransform::Rotation;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_anim_transform/#variable-scale","title":"variable Scale","text":"<pre><code>FAnimVector FAnimTransform::Scale;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimSequenceUserData.h</code></p>"},{"location":"NightSkyEngine/struct_f_anim_vector/","title":"Struct FAnimVector","text":"<p>ClassList &gt; FAnimVector</p>"},{"location":"NightSkyEngine/struct_f_anim_vector/#public-attributes","title":"Public Attributes","text":"Type Name int32 X int32 Y int32 Z"},{"location":"NightSkyEngine/struct_f_anim_vector/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_anim_vector/#variable-x","title":"variable X","text":"<pre><code>int32 FAnimVector::X;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_anim_vector/#variable-y","title":"variable Y","text":"<pre><code>int32 FAnimVector::Y;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_anim_vector/#variable-z","title":"variable Z","text":"<pre><code>int32 FAnimVector::Z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimSequenceUserData.h</code></p>"},{"location":"NightSkyEngine/struct_f_audio_channel/","title":"Struct FAudioChannel","text":"<p>ClassList &gt; FAudioChannel</p>"},{"location":"NightSkyEngine/struct_f_audio_channel/#public-attributes","title":"Public Attributes","text":"Type Name bool Finished   = <code>true</code> float MaxDuration   = <code>1.0f</code> USoundBase * SoundWave int StartingFrame"},{"location":"NightSkyEngine/struct_f_audio_channel/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_audio_channel/#variable-finished","title":"variable Finished","text":"<pre><code>bool FAudioChannel::Finished;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_audio_channel/#variable-maxduration","title":"variable MaxDuration","text":"<pre><code>float FAudioChannel::MaxDuration;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_audio_channel/#variable-soundwave","title":"variable SoundWave","text":"<pre><code>USoundBase* FAudioChannel::SoundWave;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_audio_channel/#variable-startingframe","title":"variable StartingFrame","text":"<pre><code>int FAudioChannel::StartingFrame;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyGameState.h</code></p>"},{"location":"NightSkyEngine/struct_f_battle_data/","title":"Struct FBattleData","text":"<p>ClassList &gt; FBattleData</p>"},{"location":"NightSkyEngine/struct_f_battle_data/#public-attributes","title":"Public Attributes","text":"Type Name EBattleFormat BattleFormat TArray&lt; int32 &gt; ColorIndicesP1 TArray&lt; int32 &gt; ColorIndicesP2 FGameplayTag MusicName TArray&lt; UPrimaryCharaData * &gt; PlayerListP1 TArray&lt; UPrimaryCharaData * &gt; PlayerListP2 FRandomManager Random int32 RoundCount UPrimaryStageData * Stage int32 StartRoundTimer int32 TimeUntilRoundStart   = <code>180</code>"},{"location":"NightSkyEngine/struct_f_battle_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_battle_data/#variable-battleformat","title":"variable BattleFormat","text":"<pre><code>EBattleFormat FBattleData::BattleFormat;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_data/#variable-colorindicesp1","title":"variable ColorIndicesP1","text":"<pre><code>TArray&lt;int32&gt; FBattleData::ColorIndicesP1;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_data/#variable-colorindicesp2","title":"variable ColorIndicesP2","text":"<pre><code>TArray&lt;int32&gt; FBattleData::ColorIndicesP2;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_data/#variable-musicname","title":"variable MusicName","text":"<pre><code>FGameplayTag FBattleData::MusicName;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_data/#variable-playerlistp1","title":"variable PlayerListP1","text":"<pre><code>TArray&lt;UPrimaryCharaData*&gt; FBattleData::PlayerListP1;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_data/#variable-playerlistp2","title":"variable PlayerListP2","text":"<pre><code>TArray&lt;UPrimaryCharaData*&gt; FBattleData::PlayerListP2;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_data/#variable-random","title":"variable Random","text":"<pre><code>FRandomManager FBattleData::Random;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_data/#variable-roundcount","title":"variable RoundCount","text":"<pre><code>int32 FBattleData::RoundCount;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_data/#variable-stage","title":"variable Stage","text":"<pre><code>UPrimaryStageData* FBattleData::Stage;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_data/#variable-startroundtimer","title":"variable StartRoundTimer","text":"<pre><code>int32 FBattleData::StartRoundTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_data/#variable-timeuntilroundstart","title":"variable TimeUntilRoundStart","text":"<pre><code>int32 FBattleData::TimeUntilRoundStart;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkyGameInstance.h</code></p>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/","title":"Struct FBattleInputActions","text":"<p>ClassList &gt; FBattleInputActions</p>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#public-attributes","title":"Public Attributes","text":"Type Name TObjectPtr&lt; const UInputAction &gt; PauseGame TObjectPtr&lt; const UInputAction &gt; PressA TObjectPtr&lt; const UInputAction &gt; PressB TObjectPtr&lt; const UInputAction &gt; PressC TObjectPtr&lt; const UInputAction &gt; PressD TObjectPtr&lt; const UInputAction &gt; PressDown TObjectPtr&lt; const UInputAction &gt; PressE TObjectPtr&lt; const UInputAction &gt; PressF TObjectPtr&lt; const UInputAction &gt; PressG TObjectPtr&lt; const UInputAction &gt; PressH TObjectPtr&lt; const UInputAction &gt; PressLeft TObjectPtr&lt; const UInputAction &gt; PressRight TObjectPtr&lt; const UInputAction &gt; PressUp TObjectPtr&lt; const UInputAction &gt; ReleaseA TObjectPtr&lt; const UInputAction &gt; ReleaseB TObjectPtr&lt; const UInputAction &gt; ReleaseC TObjectPtr&lt; const UInputAction &gt; ReleaseD TObjectPtr&lt; const UInputAction &gt; ReleaseDown TObjectPtr&lt; const UInputAction &gt; ReleaseE TObjectPtr&lt; const UInputAction &gt; ReleaseF TObjectPtr&lt; const UInputAction &gt; ReleaseG TObjectPtr&lt; const UInputAction &gt; ReleaseH TObjectPtr&lt; const UInputAction &gt; ReleaseLeft TObjectPtr&lt; const UInputAction &gt; ReleaseRight TObjectPtr&lt; const UInputAction &gt; ReleaseUp TObjectPtr&lt; const UInputAction &gt; ResetTraining"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-pausegame","title":"variable PauseGame","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::PauseGame;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-pressa","title":"variable PressA","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::PressA;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-pressb","title":"variable PressB","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::PressB;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-pressc","title":"variable PressC","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::PressC;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-pressd","title":"variable PressD","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::PressD;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-pressdown","title":"variable PressDown","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::PressDown;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-presse","title":"variable PressE","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::PressE;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-pressf","title":"variable PressF","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::PressF;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-pressg","title":"variable PressG","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::PressG;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-pressh","title":"variable PressH","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::PressH;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-pressleft","title":"variable PressLeft","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::PressLeft;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-pressright","title":"variable PressRight","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::PressRight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-pressup","title":"variable PressUp","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::PressUp;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-releasea","title":"variable ReleaseA","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::ReleaseA;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-releaseb","title":"variable ReleaseB","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::ReleaseB;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-releasec","title":"variable ReleaseC","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::ReleaseC;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-released","title":"variable ReleaseD","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::ReleaseD;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-releasedown","title":"variable ReleaseDown","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::ReleaseDown;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-releasee","title":"variable ReleaseE","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::ReleaseE;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-releasef","title":"variable ReleaseF","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::ReleaseF;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-releaseg","title":"variable ReleaseG","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::ReleaseG;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-releaseh","title":"variable ReleaseH","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::ReleaseH;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-releaseleft","title":"variable ReleaseLeft","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::ReleaseLeft;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-releaseright","title":"variable ReleaseRight","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::ReleaseRight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-releaseup","title":"variable ReleaseUp","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::ReleaseUp;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_input_actions/#variable-resettraining","title":"variable ResetTraining","text":"<pre><code>TObjectPtr&lt;const UInputAction&gt; FBattleInputActions::ResetTraining;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyPlayerController.h</code></p>"},{"location":"NightSkyEngine/struct_f_battle_object_log/","title":"Struct FBattleObjectLog","text":"<p>ClassList &gt; FBattleObjectLog</p> <p>More...</p> <ul> <li><code>#include &lt;BattleObject.h&gt;</code></li> </ul> <p>Inherited by the following classes: FPlayerObjectLog</p>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#public-attributes","title":"Public Attributes","text":"Type Name int32 ActionReg1   = <code>0</code> int32 ActionReg2   = <code>0</code> int32 ActionReg3   = <code>0</code> int32 ActionReg4   = <code>0</code> int32 ActionReg5   = <code>0</code> int32 ActionReg6   = <code>0</code> int32 ActionReg7   = <code>0</code> int32 ActionReg8   = <code>0</code> int32 ActionTime   = <code>0</code> FLinearColor AddColor   = <code>FLinearColor(0, 0, 0, 1)</code> FLinearColor AddFadeColor   = <code>{}</code> float AddFadeSpeed   = <code>0</code> int32 AnglePitch_x10   = <code>0</code> int32 AngleRoll_x10   = <code>0</code> int32 AngleYaw_x10   = <code>0</code> float AnimBlendIn   = <code>{}</code> float AnimBlendOut   = <code>{}</code> int32 AnimFrame   = <code>0</code> uint32 AttackFlags   = <code>0</code> ABattleObject * AttackOwner ABattleObject * AttackTarget   = <code>nullptr</code> int32 B   = <code>0</code> int32 BlendAnimFrame   = <code>0</code> FGameplayTag BlendCelName   = <code>{}</code> bool BlendOffset   = <code>false</code> int32 CelIndex   = <code>0</code> FGameplayTag CelName   = <code>{}</code> int32 ColPosX   = <code>0</code> int32 ColPosY   = <code>0</code> FHitData CounterHit   = <code>{}</code> FLinearColor DamageColor   = <code>FLinearColor(1, 1, 1, 1)</code> FLinearColor DamageColor2   = <code>FLinearColor(1, 1, 1, 1)</code> TEnumAsByte&lt; EObjDir &gt; Direction   = <code>DIR\\_Right</code> int32 DrawPriority   = <code>0</code> ABattleObject * DrawPriorityLinkObj   = <code>nullptr</code> FEventHandler EventHandlers   = <code>{}</code> float FadeTransparency   = <code>1</code> float FrameBlendPosition   = <code>0</code> bool GotoLabelActive   = <code>false</code> int32 Gravity   = <code>1900</code> int32 GroundHeight   = <code>0</code> FHitDataCommon HitCommon   = <code>{}</code> uint32 Hitstop   = <code>0</code> FHomingParams HomingParams   = <code>[**FHomingParams**](struct_f_homing_params.md)()</code> int32 Inertia   = <code>0</code> bool IsActive   = <code>false</code> bool IsPlayer   = <code>false</code> int32 L   = <code>0</code> FGameplayTag LabelName   = <code>{}</code> ABattleObject * MaterialLinkObj   = <code>nullptr</code> int32 MaxCelTime   = <code>0</code> int32 MiscFlags   = <code>0</code> FLinearColor MulColor   = <code>FLinearColor(1, 1, 1, 1)</code> FLinearColor MulFadeColor   = <code>{}</code> float MulFadeSpeed   = <code>0</code> int32 NextOffsetX   = <code>0</code> int32 NextOffsetY   = <code>0</code> FHitData NormalHit   = <code>{}</code> unsigned char ObjSync   = <code>0</code> unsigned char ObjSyncEnd   = <code>0</code> uint32 ObjectID   = <code>0</code> FVector ObjectOffset   = <code>FVector::ZeroVector</code> int32 ObjectReg1   = <code>0</code> int32 ObjectReg2   = <code>0</code> int32 ObjectReg3   = <code>0</code> int32 ObjectReg4   = <code>0</code> int32 ObjectReg5   = <code>0</code> int32 ObjectReg6   = <code>0</code> int32 ObjectReg7   = <code>0</code> int32 ObjectReg8   = <code>0</code> FRotator ObjectRotation   = <code>FRotator::ZeroRotator</code> FVector ObjectScale   = <code>FVector::One()</code> int32 ObjectStateIndex   = <code>0</code> FGameplayTag ObjectStateName   = <code>{}</code> APlayerObject * Player   = <code>nullptr</code> int32 PosX   = <code>0</code> int32 PosY   = <code>0</code> int32 PosZ   = <code>0</code> ABattleObject * PositionLinkObj   = <code>nullptr</code> int32 PrevOffsetX   = <code>0</code> int32 PrevOffsetY   = <code>0</code> int32 PrevPosX   = <code>0</code> int32 PrevPosY   = <code>0</code> int32 PrevPosZ   = <code>0</code> int32 PrevRootMotionX   = <code>0</code> int32 PrevRootMotionY   = <code>0</code> int32 PrevRootMotionZ   = <code>0</code> int32 Pushback   = <code>0</code> int32 R   = <code>0</code> FHitData ReceivedHit   = <code>{}</code> FHitDataCommon ReceivedHitCommon   = <code>{}</code> bool ReturnReg   = <code>false</code> FName SocketName   = <code>{}</code> EObjType SocketObj   = <code>OBJ\\_Self</code> FVector SocketOffset   = <code>FVector::ZeroVector</code> int32 SpeedX   = <code>0</code> int32 SpeedXRate   = <code>100</code> int32 SpeedXRatePerFrame   = <code>100</code> int32 SpeedY   = <code>0</code> int32 SpeedYRate   = <code>100</code> int32 SpeedYRatePerFrame   = <code>100</code> int32 SpeedZ   = <code>0</code> int32 SpeedZRate   = <code>100</code> int32 SpeedZRatePerFrame   = <code>100</code> ABattleObject * StopLinkObj   = <code>nullptr</code> uint32 StunTime   = <code>0</code> uint32 StunTimeMax   = <code>0</code> int32 SubroutineReg1   = <code>0</code> int32 SubroutineReg2   = <code>0</code> int32 SubroutineReg3   = <code>0</code> int32 SubroutineReg4   = <code>0</code> int32 SubroutineReturnVal1   = <code>0</code> int32 SubroutineReturnVal2   = <code>0</code> int32 SubroutineReturnVal3   = <code>0</code> int32 SubroutineReturnVal4   = <code>0</code> FSuperArmorData SuperArmorData   = <code>[**FSuperArmorData**](struct_f_super_armor_data.md)()</code> int32 T   = <code>0</code> int32 TimeUntilNextCel   = <code>0</code> int32 Timer0   = <code>0</code> int32 Timer1   = <code>0</code> float Transparency   = <code>1</code> float TransparencySpeed   = <code>0</code> int32 UpdateTime   = <code>0</code> bool bIsCommonState   = <code>false</code> bool bRender   = <code>true</code>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#public-functions","title":"Public Functions","text":"Type Name virtual void LogForSyncTestFile (std::ofstream &amp; file)  virtual ~FBattleObjectLog () = default"},{"location":"NightSkyEngine/struct_f_battle_object_log/#protected-attributes","title":"Protected Attributes","text":"Type Name int32 PushHeight   = <code>0</code> int32 PushHeightLow   = <code>0</code> int32 PushWidth   = <code>0</code> int32 PushWidthExtend   = <code>0</code>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#detailed-description","title":"Detailed Description","text":"<p>This struct is only for sync logs. </p>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-actionreg1","title":"variable ActionReg1","text":"<pre><code>int32 FBattleObjectLog::ActionReg1;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-actionreg2","title":"variable ActionReg2","text":"<pre><code>int32 FBattleObjectLog::ActionReg2;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-actionreg3","title":"variable ActionReg3","text":"<pre><code>int32 FBattleObjectLog::ActionReg3;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-actionreg4","title":"variable ActionReg4","text":"<pre><code>int32 FBattleObjectLog::ActionReg4;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-actionreg5","title":"variable ActionReg5","text":"<pre><code>int32 FBattleObjectLog::ActionReg5;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-actionreg6","title":"variable ActionReg6","text":"<pre><code>int32 FBattleObjectLog::ActionReg6;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-actionreg7","title":"variable ActionReg7","text":"<pre><code>int32 FBattleObjectLog::ActionReg7;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-actionreg8","title":"variable ActionReg8","text":"<pre><code>int32 FBattleObjectLog::ActionReg8;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-actiontime","title":"variable ActionTime","text":"<pre><code>int32 FBattleObjectLog::ActionTime;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-addcolor","title":"variable AddColor","text":"<pre><code>FLinearColor FBattleObjectLog::AddColor;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-addfadecolor","title":"variable AddFadeColor","text":"<pre><code>FLinearColor FBattleObjectLog::AddFadeColor;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-addfadespeed","title":"variable AddFadeSpeed","text":"<pre><code>float FBattleObjectLog::AddFadeSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-anglepitch_x10","title":"variable AnglePitch_x10","text":"<pre><code>int32 FBattleObjectLog::AnglePitch_x10;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-angleroll_x10","title":"variable AngleRoll_x10","text":"<pre><code>int32 FBattleObjectLog::AngleRoll_x10;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-angleyaw_x10","title":"variable AngleYaw_x10","text":"<pre><code>int32 FBattleObjectLog::AngleYaw_x10;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-animblendin","title":"variable AnimBlendIn","text":"<pre><code>float FBattleObjectLog::AnimBlendIn;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-animblendout","title":"variable AnimBlendOut","text":"<pre><code>float FBattleObjectLog::AnimBlendOut;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-animframe","title":"variable AnimFrame","text":"<pre><code>int32 FBattleObjectLog::AnimFrame;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-attackflags","title":"variable AttackFlags","text":"<pre><code>uint32 FBattleObjectLog::AttackFlags;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-attackowner","title":"variable AttackOwner","text":"<pre><code>ABattleObject* FBattleObjectLog::AttackOwner;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-attacktarget","title":"variable AttackTarget","text":"<pre><code>ABattleObject* FBattleObjectLog::AttackTarget;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-b","title":"variable B","text":"<pre><code>int32 FBattleObjectLog::B;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-blendanimframe","title":"variable BlendAnimFrame","text":"<pre><code>int32 FBattleObjectLog::BlendAnimFrame;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-blendcelname","title":"variable BlendCelName","text":"<pre><code>FGameplayTag FBattleObjectLog::BlendCelName;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-blendoffset","title":"variable BlendOffset","text":"<pre><code>bool FBattleObjectLog::BlendOffset;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-celindex","title":"variable CelIndex","text":"<pre><code>int32 FBattleObjectLog::CelIndex;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-celname","title":"variable CelName","text":"<pre><code>FGameplayTag FBattleObjectLog::CelName;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-colposx","title":"variable ColPosX","text":"<pre><code>int32 FBattleObjectLog::ColPosX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-colposy","title":"variable ColPosY","text":"<pre><code>int32 FBattleObjectLog::ColPosY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-counterhit","title":"variable CounterHit","text":"<pre><code>FHitData FBattleObjectLog::CounterHit;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-damagecolor","title":"variable DamageColor","text":"<pre><code>FLinearColor FBattleObjectLog::DamageColor;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-damagecolor2","title":"variable DamageColor2","text":"<pre><code>FLinearColor FBattleObjectLog::DamageColor2;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-direction","title":"variable Direction","text":"<pre><code>TEnumAsByte&lt;EObjDir&gt; FBattleObjectLog::Direction;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-drawpriority","title":"variable DrawPriority","text":"<pre><code>int32 FBattleObjectLog::DrawPriority;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-drawprioritylinkobj","title":"variable DrawPriorityLinkObj","text":"<pre><code>ABattleObject* FBattleObjectLog::DrawPriorityLinkObj;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-eventhandlers","title":"variable EventHandlers","text":"<pre><code>FEventHandler FBattleObjectLog::EventHandlers[EVT_NUM];\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-fadetransparency","title":"variable FadeTransparency","text":"<pre><code>float FBattleObjectLog::FadeTransparency;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-frameblendposition","title":"variable FrameBlendPosition","text":"<pre><code>float FBattleObjectLog::FrameBlendPosition;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-gotolabelactive","title":"variable GotoLabelActive","text":"<pre><code>bool FBattleObjectLog::GotoLabelActive;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-gravity","title":"variable Gravity","text":"<pre><code>int32 FBattleObjectLog::Gravity;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-groundheight","title":"variable GroundHeight","text":"<pre><code>int32 FBattleObjectLog::GroundHeight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-hitcommon","title":"variable HitCommon","text":"<pre><code>FHitDataCommon FBattleObjectLog::HitCommon;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-hitstop","title":"variable Hitstop","text":"<pre><code>uint32 FBattleObjectLog::Hitstop;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-homingparams","title":"variable HomingParams","text":"<pre><code>FHomingParams FBattleObjectLog::HomingParams;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-inertia","title":"variable Inertia","text":"<pre><code>int32 FBattleObjectLog::Inertia;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-isactive","title":"variable IsActive","text":"<pre><code>bool FBattleObjectLog::IsActive;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-isplayer","title":"variable IsPlayer","text":"<pre><code>bool FBattleObjectLog::IsPlayer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-l","title":"variable L","text":"<pre><code>int32 FBattleObjectLog::L;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-labelname","title":"variable LabelName","text":"<pre><code>FGameplayTag FBattleObjectLog::LabelName;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-materiallinkobj","title":"variable MaterialLinkObj","text":"<pre><code>ABattleObject* FBattleObjectLog::MaterialLinkObj;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-maxceltime","title":"variable MaxCelTime","text":"<pre><code>int32 FBattleObjectLog::MaxCelTime;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-miscflags","title":"variable MiscFlags","text":"<pre><code>int32 FBattleObjectLog::MiscFlags;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-mulcolor","title":"variable MulColor","text":"<pre><code>FLinearColor FBattleObjectLog::MulColor;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-mulfadecolor","title":"variable MulFadeColor","text":"<pre><code>FLinearColor FBattleObjectLog::MulFadeColor;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-mulfadespeed","title":"variable MulFadeSpeed","text":"<pre><code>float FBattleObjectLog::MulFadeSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-nextoffsetx","title":"variable NextOffsetX","text":"<pre><code>int32 FBattleObjectLog::NextOffsetX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-nextoffsety","title":"variable NextOffsetY","text":"<pre><code>int32 FBattleObjectLog::NextOffsetY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-normalhit","title":"variable NormalHit","text":"<pre><code>FHitData FBattleObjectLog::NormalHit;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objsync","title":"variable ObjSync","text":"<pre><code>unsigned char FBattleObjectLog::ObjSync;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objsyncend","title":"variable ObjSyncEnd","text":"<pre><code>unsigned char FBattleObjectLog::ObjSyncEnd;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objectid","title":"variable ObjectID","text":"<pre><code>uint32 FBattleObjectLog::ObjectID;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objectoffset","title":"variable ObjectOffset","text":"<pre><code>FVector FBattleObjectLog::ObjectOffset;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objectreg1","title":"variable ObjectReg1","text":"<pre><code>int32 FBattleObjectLog::ObjectReg1;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objectreg2","title":"variable ObjectReg2","text":"<pre><code>int32 FBattleObjectLog::ObjectReg2;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objectreg3","title":"variable ObjectReg3","text":"<pre><code>int32 FBattleObjectLog::ObjectReg3;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objectreg4","title":"variable ObjectReg4","text":"<pre><code>int32 FBattleObjectLog::ObjectReg4;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objectreg5","title":"variable ObjectReg5","text":"<pre><code>int32 FBattleObjectLog::ObjectReg5;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objectreg6","title":"variable ObjectReg6","text":"<pre><code>int32 FBattleObjectLog::ObjectReg6;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objectreg7","title":"variable ObjectReg7","text":"<pre><code>int32 FBattleObjectLog::ObjectReg7;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objectreg8","title":"variable ObjectReg8","text":"<pre><code>int32 FBattleObjectLog::ObjectReg8;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objectrotation","title":"variable ObjectRotation","text":"<pre><code>FRotator FBattleObjectLog::ObjectRotation;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objectscale","title":"variable ObjectScale","text":"<pre><code>FVector FBattleObjectLog::ObjectScale;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objectstateindex","title":"variable ObjectStateIndex","text":"<pre><code>int32 FBattleObjectLog::ObjectStateIndex;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-objectstatename","title":"variable ObjectStateName","text":"<pre><code>FGameplayTag FBattleObjectLog::ObjectStateName;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-player","title":"variable Player","text":"<pre><code>APlayerObject* FBattleObjectLog::Player;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-posx","title":"variable PosX","text":"<pre><code>int32 FBattleObjectLog::PosX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-posy","title":"variable PosY","text":"<pre><code>int32 FBattleObjectLog::PosY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-posz","title":"variable PosZ","text":"<pre><code>int32 FBattleObjectLog::PosZ;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-positionlinkobj","title":"variable PositionLinkObj","text":"<pre><code>ABattleObject* FBattleObjectLog::PositionLinkObj;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-prevoffsetx","title":"variable PrevOffsetX","text":"<pre><code>int32 FBattleObjectLog::PrevOffsetX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-prevoffsety","title":"variable PrevOffsetY","text":"<pre><code>int32 FBattleObjectLog::PrevOffsetY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-prevposx","title":"variable PrevPosX","text":"<pre><code>int32 FBattleObjectLog::PrevPosX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-prevposy","title":"variable PrevPosY","text":"<pre><code>int32 FBattleObjectLog::PrevPosY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-prevposz","title":"variable PrevPosZ","text":"<pre><code>int32 FBattleObjectLog::PrevPosZ;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-prevrootmotionx","title":"variable PrevRootMotionX","text":"<pre><code>int32 FBattleObjectLog::PrevRootMotionX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-prevrootmotiony","title":"variable PrevRootMotionY","text":"<pre><code>int32 FBattleObjectLog::PrevRootMotionY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-prevrootmotionz","title":"variable PrevRootMotionZ","text":"<pre><code>int32 FBattleObjectLog::PrevRootMotionZ;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-pushback","title":"variable Pushback","text":"<pre><code>int32 FBattleObjectLog::Pushback;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-r","title":"variable R","text":"<pre><code>int32 FBattleObjectLog::R;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-receivedhit","title":"variable ReceivedHit","text":"<pre><code>FHitData FBattleObjectLog::ReceivedHit;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-receivedhitcommon","title":"variable ReceivedHitCommon","text":"<pre><code>FHitDataCommon FBattleObjectLog::ReceivedHitCommon;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-returnreg","title":"variable ReturnReg","text":"<pre><code>bool FBattleObjectLog::ReturnReg;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-socketname","title":"variable SocketName","text":"<pre><code>FName FBattleObjectLog::SocketName;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-socketobj","title":"variable SocketObj","text":"<pre><code>EObjType FBattleObjectLog::SocketObj;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-socketoffset","title":"variable SocketOffset","text":"<pre><code>FVector FBattleObjectLog::SocketOffset;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-speedx","title":"variable SpeedX","text":"<pre><code>int32 FBattleObjectLog::SpeedX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-speedxrate","title":"variable SpeedXRate","text":"<pre><code>int32 FBattleObjectLog::SpeedXRate;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-speedxrateperframe","title":"variable SpeedXRatePerFrame","text":"<pre><code>int32 FBattleObjectLog::SpeedXRatePerFrame;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-speedy","title":"variable SpeedY","text":"<pre><code>int32 FBattleObjectLog::SpeedY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-speedyrate","title":"variable SpeedYRate","text":"<pre><code>int32 FBattleObjectLog::SpeedYRate;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-speedyrateperframe","title":"variable SpeedYRatePerFrame","text":"<pre><code>int32 FBattleObjectLog::SpeedYRatePerFrame;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-speedz","title":"variable SpeedZ","text":"<pre><code>int32 FBattleObjectLog::SpeedZ;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-speedzrate","title":"variable SpeedZRate","text":"<pre><code>int32 FBattleObjectLog::SpeedZRate;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-speedzrateperframe","title":"variable SpeedZRatePerFrame","text":"<pre><code>int32 FBattleObjectLog::SpeedZRatePerFrame;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-stoplinkobj","title":"variable StopLinkObj","text":"<pre><code>ABattleObject* FBattleObjectLog::StopLinkObj;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-stuntime","title":"variable StunTime","text":"<pre><code>uint32 FBattleObjectLog::StunTime;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-stuntimemax","title":"variable StunTimeMax","text":"<pre><code>uint32 FBattleObjectLog::StunTimeMax;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-subroutinereg1","title":"variable SubroutineReg1","text":"<pre><code>int32 FBattleObjectLog::SubroutineReg1;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-subroutinereg2","title":"variable SubroutineReg2","text":"<pre><code>int32 FBattleObjectLog::SubroutineReg2;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-subroutinereg3","title":"variable SubroutineReg3","text":"<pre><code>int32 FBattleObjectLog::SubroutineReg3;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-subroutinereg4","title":"variable SubroutineReg4","text":"<pre><code>int32 FBattleObjectLog::SubroutineReg4;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-subroutinereturnval1","title":"variable SubroutineReturnVal1","text":"<pre><code>int32 FBattleObjectLog::SubroutineReturnVal1;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-subroutinereturnval2","title":"variable SubroutineReturnVal2","text":"<pre><code>int32 FBattleObjectLog::SubroutineReturnVal2;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-subroutinereturnval3","title":"variable SubroutineReturnVal3","text":"<pre><code>int32 FBattleObjectLog::SubroutineReturnVal3;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-subroutinereturnval4","title":"variable SubroutineReturnVal4","text":"<pre><code>int32 FBattleObjectLog::SubroutineReturnVal4;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-superarmordata","title":"variable SuperArmorData","text":"<pre><code>FSuperArmorData FBattleObjectLog::SuperArmorData;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-t","title":"variable T","text":"<pre><code>int32 FBattleObjectLog::T;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-timeuntilnextcel","title":"variable TimeUntilNextCel","text":"<pre><code>int32 FBattleObjectLog::TimeUntilNextCel;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-timer0","title":"variable Timer0","text":"<pre><code>int32 FBattleObjectLog::Timer0;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-timer1","title":"variable Timer1","text":"<pre><code>int32 FBattleObjectLog::Timer1;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-transparency","title":"variable Transparency","text":"<pre><code>float FBattleObjectLog::Transparency;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-transparencyspeed","title":"variable TransparencySpeed","text":"<pre><code>float FBattleObjectLog::TransparencySpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-updatetime","title":"variable UpdateTime","text":"<pre><code>int32 FBattleObjectLog::UpdateTime;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-biscommonstate","title":"variable bIsCommonState","text":"<pre><code>bool FBattleObjectLog::bIsCommonState;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-brender","title":"variable bRender","text":"<pre><code>bool FBattleObjectLog::bRender;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/struct_f_battle_object_log/#function-logforsynctestfile","title":"function LogForSyncTestFile","text":"<pre><code>virtual void FBattleObjectLog::LogForSyncTestFile (\n    std::ofstream &amp; file\n) \n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#function-fbattleobjectlog","title":"function ~FBattleObjectLog","text":"<pre><code>virtual FBattleObjectLog::~FBattleObjectLog () = default\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-pushheight","title":"variable PushHeight","text":"<pre><code>int32 FBattleObjectLog::PushHeight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-pushheightlow","title":"variable PushHeightLow","text":"<pre><code>int32 FBattleObjectLog::PushHeightLow;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-pushwidth","title":"variable PushWidth","text":"<pre><code>int32 FBattleObjectLog::PushWidth;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_object_log/#variable-pushwidthextend","title":"variable PushWidthExtend","text":"<pre><code>int32 FBattleObjectLog::PushWidthExtend;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.h</code></p>"},{"location":"NightSkyEngine/struct_f_battle_particle/","title":"Struct FBattleParticle","text":"<p>ClassList &gt; FBattleParticle</p>"},{"location":"NightSkyEngine/struct_f_battle_particle/#public-attributes","title":"Public Attributes","text":"Type Name UNiagaraComponent * NiagaraComponent ABattleObject * ParticleOwner"},{"location":"NightSkyEngine/struct_f_battle_particle/#public-functions","title":"Public Functions","text":"Type Name FBattleParticle ()  FBattleParticle (UNiagaraComponent * InNiagaraComponent, ABattleObject * InOwner)"},{"location":"NightSkyEngine/struct_f_battle_particle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_battle_particle/#variable-niagaracomponent","title":"variable NiagaraComponent","text":"<pre><code>UNiagaraComponent* FBattleParticle::NiagaraComponent;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_particle/#variable-particleowner","title":"variable ParticleOwner","text":"<pre><code>ABattleObject* FBattleParticle::ParticleOwner;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_particle/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/struct_f_battle_particle/#function-fbattleparticle-12","title":"function FBattleParticle [1/2]","text":"<pre><code>inline FBattleParticle::FBattleParticle () \n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_particle/#function-fbattleparticle-22","title":"function FBattleParticle [2/2]","text":"<pre><code>inline FBattleParticle::FBattleParticle (\n    UNiagaraComponent * InNiagaraComponent,\n    ABattleObject * InOwner\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/ParticleManager.h</code></p>"},{"location":"NightSkyEngine/struct_f_battle_state/","title":"Struct FBattleState","text":"<p>ClassList &gt; FBattleState</p>"},{"location":"NightSkyEngine/struct_f_battle_state/#public-attributes","title":"Public Attributes","text":"Type Name int32 ActiveObjectCount   = <code>0</code> FAudioChannel AnnouncerVoiceChannel int32 AssistCooldown   = <code>180</code> EBattleFormat BattleFormat   = <code>EBattleFormat::Rounds</code> EBattlePhase BattlePhase   = <code>EBattlePhase::Intro</code> char BattleStateSync char BattleStateSyncEnd FVector CameraPosition   = <code>FVector()</code> FAudioChannel CharaAudioChannels FAudioChannel CharaVoiceChannels FAudioChannel CommonAudioChannels EIntroSide CurrentIntroSide   = <code>INT\\_None</code> int32 CurrentSequenceTime   = <code>-1</code> TEnumAsByte&lt; EWinSide &gt; CurrentWinSide   = <code>WIN\\_None</code> int32 FadeTimer int32 FrameNumber   = <code>0</code> TArray&lt; int32 &gt; GaugeP1 TArray&lt; int32 &gt; GaugeP2 bool IsPlayingSequence   = <code>false</code> APlayerObject * MainPlayer int32 MaxFadeTimer   = <code>12</code> TArray&lt; int32 &gt; MaxGauge int32 MaxMeter   = <code>{10000, 10000}</code> int32 MaxRoundCount int32 MaxTimeUntilRoundStart int32 Meter   = <code>{0, 0}</code> FAudioChannel MusicChannel float OrthoBlendActive int32 P1RoundsWon   = <code>0</code> int32 P2RoundsWon   = <code>0</code> bool PauseParticles   = <code>false</code> bool PauseTimer   = <code>false</code> FRandomManager RandomManager int32 RoundCount   = <code>0</code> int32 RoundStartPos   = <code>297500</code> int32 RoundTimer   = <code>0</code> FScreenData ScreenData ABattleObject * SuperFreezeCaller   = <code>nullptr</code> int32 SuperFreezeDuration   = <code>0</code> int32 SuperFreezeSelfDuration   = <code>0</code> int32 TagCooldown   = <code>300</code> FTeamData TeamData int32 TimeUntilRoundStart   = <code>0</code> bool bHUDVisible   = <code>true</code>"},{"location":"NightSkyEngine/struct_f_battle_state/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_battle_state/#variable-activeobjectcount","title":"variable ActiveObjectCount","text":"<pre><code>int32 FBattleState::ActiveObjectCount;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-announcervoicechannel","title":"variable AnnouncerVoiceChannel","text":"<pre><code>FAudioChannel FBattleState::AnnouncerVoiceChannel;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-assistcooldown","title":"variable AssistCooldown","text":"<pre><code>int32 FBattleState::AssistCooldown;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-battleformat","title":"variable BattleFormat","text":"<pre><code>EBattleFormat FBattleState::BattleFormat;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-battlephase","title":"variable BattlePhase","text":"<pre><code>EBattlePhase FBattleState::BattlePhase;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-battlestatesync","title":"variable BattleStateSync","text":"<pre><code>char FBattleState::BattleStateSync;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-battlestatesyncend","title":"variable BattleStateSyncEnd","text":"<pre><code>char FBattleState::BattleStateSyncEnd;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-cameraposition","title":"variable CameraPosition","text":"<pre><code>FVector FBattleState::CameraPosition;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-charaaudiochannels","title":"variable CharaAudioChannels","text":"<pre><code>FAudioChannel FBattleState::CharaAudioChannels[CharaAudioChannelCount];\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-charavoicechannels","title":"variable CharaVoiceChannels","text":"<pre><code>FAudioChannel FBattleState::CharaVoiceChannels[CharaVoiceChannelCount];\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-commonaudiochannels","title":"variable CommonAudioChannels","text":"<pre><code>FAudioChannel FBattleState::CommonAudioChannels[CommonAudioChannelCount];\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-currentintroside","title":"variable CurrentIntroSide","text":"<pre><code>EIntroSide FBattleState::CurrentIntroSide;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-currentsequencetime","title":"variable CurrentSequenceTime","text":"<pre><code>int32 FBattleState::CurrentSequenceTime;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-currentwinside","title":"variable CurrentWinSide","text":"<pre><code>TEnumAsByte&lt;EWinSide&gt; FBattleState::CurrentWinSide;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-fadetimer","title":"variable FadeTimer","text":"<pre><code>int32 FBattleState::FadeTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-framenumber","title":"variable FrameNumber","text":"<pre><code>int32 FBattleState::FrameNumber;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-gaugep1","title":"variable GaugeP1","text":"<pre><code>TArray&lt;int32&gt; FBattleState::GaugeP1;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-gaugep2","title":"variable GaugeP2","text":"<pre><code>TArray&lt;int32&gt; FBattleState::GaugeP2;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-isplayingsequence","title":"variable IsPlayingSequence","text":"<pre><code>bool FBattleState::IsPlayingSequence;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-mainplayer","title":"variable MainPlayer","text":"<pre><code>APlayerObject* FBattleState::MainPlayer[2];\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-maxfadetimer","title":"variable MaxFadeTimer","text":"<pre><code>int32 FBattleState::MaxFadeTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-maxgauge","title":"variable MaxGauge","text":"<pre><code>TArray&lt;int32&gt; FBattleState::MaxGauge;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-maxmeter","title":"variable MaxMeter","text":"<pre><code>int32 FBattleState::MaxMeter[2];\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-maxroundcount","title":"variable MaxRoundCount","text":"<pre><code>int32 FBattleState::MaxRoundCount;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-maxtimeuntilroundstart","title":"variable MaxTimeUntilRoundStart","text":"<pre><code>int32 FBattleState::MaxTimeUntilRoundStart;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-meter","title":"variable Meter","text":"<pre><code>int32 FBattleState::Meter[2];\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-musicchannel","title":"variable MusicChannel","text":"<pre><code>FAudioChannel FBattleState::MusicChannel;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-orthoblendactive","title":"variable OrthoBlendActive","text":"<pre><code>float FBattleState::OrthoBlendActive;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-p1roundswon","title":"variable P1RoundsWon","text":"<pre><code>int32 FBattleState::P1RoundsWon;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-p2roundswon","title":"variable P2RoundsWon","text":"<pre><code>int32 FBattleState::P2RoundsWon;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-pauseparticles","title":"variable PauseParticles","text":"<pre><code>bool FBattleState::PauseParticles;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-pausetimer","title":"variable PauseTimer","text":"<pre><code>bool FBattleState::PauseTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-randommanager","title":"variable RandomManager","text":"<pre><code>FRandomManager FBattleState::RandomManager;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-roundcount","title":"variable RoundCount","text":"<pre><code>int32 FBattleState::RoundCount;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-roundstartpos","title":"variable RoundStartPos","text":"<pre><code>int32 FBattleState::RoundStartPos;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-roundtimer","title":"variable RoundTimer","text":"<pre><code>int32 FBattleState::RoundTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-screendata","title":"variable ScreenData","text":"<pre><code>FScreenData FBattleState::ScreenData;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-superfreezecaller","title":"variable SuperFreezeCaller","text":"<pre><code>ABattleObject* FBattleState::SuperFreezeCaller;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-superfreezeduration","title":"variable SuperFreezeDuration","text":"<pre><code>int32 FBattleState::SuperFreezeDuration;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-superfreezeselfduration","title":"variable SuperFreezeSelfDuration","text":"<pre><code>int32 FBattleState::SuperFreezeSelfDuration;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-tagcooldown","title":"variable TagCooldown","text":"<pre><code>int32 FBattleState::TagCooldown;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-teamdata","title":"variable TeamData","text":"<pre><code>FTeamData FBattleState::TeamData[2];\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-timeuntilroundstart","title":"variable TimeUntilRoundStart","text":"<pre><code>int32 FBattleState::TimeUntilRoundStart;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_battle_state/#variable-bhudvisible","title":"variable bHUDVisible","text":"<pre><code>bool FBattleState::bHUDVisible;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyGameState.h</code></p>"},{"location":"NightSkyEngine/struct_f_camera_shake_struct/","title":"Struct FCameraShakeStruct","text":"<p>ClassList &gt; FCameraShakeStruct</p>"},{"location":"NightSkyEngine/struct_f_camera_shake_struct/#public-attributes","title":"Public Attributes","text":"Type Name TSubclassOf&lt; UCameraShakeBase &gt; CameraShake FGameplayTag Name"},{"location":"NightSkyEngine/struct_f_camera_shake_struct/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_camera_shake_struct/#variable-camerashake","title":"variable CameraShake","text":"<pre><code>TSubclassOf&lt;UCameraShakeBase&gt; FCameraShakeStruct::CameraShake;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_camera_shake_struct/#variable-name","title":"variable Name","text":"<pre><code>FGameplayTag FCameraShakeStruct::Name;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/CameraShakeData.h</code></p>"},{"location":"NightSkyEngine/struct_f_collision_box/","title":"Struct FCollisionBox","text":"<p>ClassList &gt; FCollisionBox</p> <p>A collision box. More...</p> <ul> <li><code>#include &lt;CollisionBox.h&gt;</code></li> </ul>"},{"location":"NightSkyEngine/struct_f_collision_box/#public-attributes","title":"Public Attributes","text":"Type Name FGameplayTag CustomType int32 PosX   = <code>0</code> int32 PosY   = <code>0</code> int32 SizeX   = <code>0</code> int32 SizeY   = <code>0</code> TEnumAsByte&lt; EBoxType &gt; Type   = <code>BOX\\_Hurt</code>"},{"location":"NightSkyEngine/struct_f_collision_box/#public-functions","title":"Public Functions","text":"Type Name bool operator!= (const FCollisionBox &amp; OtherBox) const"},{"location":"NightSkyEngine/struct_f_collision_box/#detailed-description","title":"Detailed Description","text":"<p>Primarily used for push and hit collision, but some box types are used for specific operations. </p>"},{"location":"NightSkyEngine/struct_f_collision_box/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_collision_box/#variable-customtype","title":"variable CustomType","text":"<pre><code>FGameplayTag FCollisionBox::CustomType;\n</code></pre> <p>The custom box type. Used with BOX_Custom to define custom box behaviors. </p>"},{"location":"NightSkyEngine/struct_f_collision_box/#variable-posx","title":"variable PosX","text":"<pre><code>int32 FCollisionBox::PosX;\n</code></pre> <p>X position. </p>"},{"location":"NightSkyEngine/struct_f_collision_box/#variable-posy","title":"variable PosY","text":"<pre><code>int32 FCollisionBox::PosY;\n</code></pre> <p>Y position. </p>"},{"location":"NightSkyEngine/struct_f_collision_box/#variable-sizex","title":"variable SizeX","text":"<pre><code>int32 FCollisionBox::SizeX;\n</code></pre> <p>X size. </p>"},{"location":"NightSkyEngine/struct_f_collision_box/#variable-sizey","title":"variable SizeY","text":"<pre><code>int32 FCollisionBox::SizeY;\n</code></pre> <p>Y size. </p>"},{"location":"NightSkyEngine/struct_f_collision_box/#variable-type","title":"variable Type","text":"<pre><code>TEnumAsByte&lt;EBoxType&gt; FCollisionBox::Type;\n</code></pre> <p>The type of box. </p>"},{"location":"NightSkyEngine/struct_f_collision_box/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/struct_f_collision_box/#function-operator","title":"function operator!=","text":"<pre><code>inline bool FCollisionBox::operator!= (\n    const FCollisionBox &amp; OtherBox\n) const\n</code></pre> <p>Compares against another collision box for inequality.</p> <p>Parameters:</p> <ul> <li><code>OtherBox</code> The box to compare against. </li> </ul> <p>Returns:</p> <p>If any of the fields of the other box are different, return true. Otherwise return false. </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/CollisionBox.h</code></p>"},{"location":"NightSkyEngine/struct_f_collision_struct/","title":"Struct FCollisionStruct","text":"<p>ClassList &gt; FCollisionStruct</p>"},{"location":"NightSkyEngine/struct_f_collision_struct/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; FAnimStruct &gt; Anim float AnimBlendIn   = <code>0.25</code> float AnimBlendOut   = <code>0.25</code> int32 AnimFrame   = <code>0</code> TArray&lt; FCollisionBox &gt; Boxes FGameplayTag CelName"},{"location":"NightSkyEngine/struct_f_collision_struct/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_collision_struct/#variable-anim","title":"variable Anim","text":"<pre><code>TArray&lt;FAnimStruct&gt; FCollisionStruct::Anim;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_collision_struct/#variable-animblendin","title":"variable AnimBlendIn","text":"<pre><code>float FCollisionStruct::AnimBlendIn;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_collision_struct/#variable-animblendout","title":"variable AnimBlendOut","text":"<pre><code>float FCollisionStruct::AnimBlendOut;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_collision_struct/#variable-animframe","title":"variable AnimFrame","text":"<pre><code>int32 FCollisionStruct::AnimFrame;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_collision_struct/#variable-boxes","title":"variable Boxes","text":"<pre><code>TArray&lt;FCollisionBox&gt; FCollisionStruct::Boxes;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_collision_struct/#variable-celname","title":"variable CelName","text":"<pre><code>FGameplayTag FCollisionStruct::CelName;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/CollisionData.h</code></p>"},{"location":"NightSkyEngine/struct_f_event_handler/","title":"Struct FEventHandler","text":"<p>ClassList &gt; FEventHandler</p>"},{"location":"NightSkyEngine/struct_f_event_handler/#public-attributes","title":"Public Attributes","text":"Type Name FName FunctionName FGameplayTag SubroutineName"},{"location":"NightSkyEngine/struct_f_event_handler/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_event_handler/#variable-functionname","title":"variable FunctionName","text":"<pre><code>FName FEventHandler::FunctionName;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_event_handler/#variable-subroutinename","title":"variable SubroutineName","text":"<pre><code>FGameplayTag FEventHandler::SubroutineName;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.h</code></p>"},{"location":"NightSkyEngine/struct_f_extra_gauge/","title":"Struct FExtraGauge","text":"<p>ClassList &gt; FExtraGauge</p>"},{"location":"NightSkyEngine/struct_f_extra_gauge/#public-attributes","title":"Public Attributes","text":"Type Name int32 InitialValue int32 MaxValue int32 Sections int32 Value"},{"location":"NightSkyEngine/struct_f_extra_gauge/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_extra_gauge/#variable-initialvalue","title":"variable InitialValue","text":"<pre><code>int32 FExtraGauge::InitialValue;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_extra_gauge/#variable-maxvalue","title":"variable MaxValue","text":"<pre><code>int32 FExtraGauge::MaxValue;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_extra_gauge/#variable-sections","title":"variable Sections","text":"<pre><code>int32 FExtraGauge::Sections;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_extra_gauge/#variable-value","title":"variable Value","text":"<pre><code>int32 FExtraGauge::Value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/PlayerObject.h</code></p>"},{"location":"NightSkyEngine/struct_f_flipbook_struct/","title":"Struct FFlipbookStruct","text":"<p>ClassList &gt; FFlipbookStruct</p>"},{"location":"NightSkyEngine/struct_f_flipbook_struct/#public-attributes","title":"Public Attributes","text":"Type Name UPaperFlipbook * Flipbook FGameplayTag Name"},{"location":"NightSkyEngine/struct_f_flipbook_struct/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_flipbook_struct/#variable-flipbook","title":"variable Flipbook","text":"<pre><code>UPaperFlipbook* FFlipbookStruct::Flipbook;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_flipbook_struct/#variable-name","title":"variable Name","text":"<pre><code>FGameplayTag FFlipbookStruct::Name;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/FlipbookData.h</code></p>"},{"location":"NightSkyEngine/struct_f_ground_bounce_data/","title":"Struct FGroundBounceData","text":"<p>ClassList &gt; FGroundBounceData</p>"},{"location":"NightSkyEngine/struct_f_ground_bounce_data/#public-attributes","title":"Public Attributes","text":"Type Name int32 GroundBounceCount   = <code>-1</code> int32 GroundBounceGravity   = <code>INT\\_MAX</code> int32 GroundBounceStop   = <code>INT\\_MAX</code> int32 GroundBounceUntech   = <code>INT\\_MAX</code> int32 GroundBounceXRate   = <code>INT\\_MAX</code> int32 GroundBounceXSpeed   = <code>INT\\_MAX</code> int32 GroundBounceYRate   = <code>INT\\_MAX</code> int32 GroundBounceYSpeed   = <code>INT\\_MAX</code>"},{"location":"NightSkyEngine/struct_f_ground_bounce_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_ground_bounce_data/#variable-groundbouncecount","title":"variable GroundBounceCount","text":"<pre><code>int32 FGroundBounceData::GroundBounceCount;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_ground_bounce_data/#variable-groundbouncegravity","title":"variable GroundBounceGravity","text":"<pre><code>int32 FGroundBounceData::GroundBounceGravity;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_ground_bounce_data/#variable-groundbouncestop","title":"variable GroundBounceStop","text":"<pre><code>int32 FGroundBounceData::GroundBounceStop;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_ground_bounce_data/#variable-groundbounceuntech","title":"variable GroundBounceUntech","text":"<pre><code>int32 FGroundBounceData::GroundBounceUntech;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_ground_bounce_data/#variable-groundbouncexrate","title":"variable GroundBounceXRate","text":"<pre><code>int32 FGroundBounceData::GroundBounceXRate;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_ground_bounce_data/#variable-groundbouncexspeed","title":"variable GroundBounceXSpeed","text":"<pre><code>int32 FGroundBounceData::GroundBounceXSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_ground_bounce_data/#variable-groundbounceyrate","title":"variable GroundBounceYRate","text":"<pre><code>int32 FGroundBounceData::GroundBounceYRate;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_ground_bounce_data/#variable-groundbounceyspeed","title":"variable GroundBounceYSpeed","text":"<pre><code>int32 FGroundBounceData::GroundBounceYSpeed;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.h</code></p>"},{"location":"NightSkyEngine/struct_f_hit_data/","title":"Struct FHitData","text":"<p>ClassList &gt; FHitData</p>"},{"location":"NightSkyEngine/struct_f_hit_data/#public-attributes","title":"Public Attributes","text":"Type Name TEnumAsByte&lt; EHitAction &gt; AirHitAction   = <code>HACT\\_AirNormal</code> int32 AirPushbackX   = <code>INT\\_MAX</code> FHitValueOverTime AirPushbackXOverTime int32 AirPushbackY   = <code>INT\\_MAX</code> FHitValueOverTime AirPushbackYOverTime int32 BlowbackLevel   = <code>INT\\_MAX</code> FGameplayTag CustomHitAction int32 Damage   = <code>INT\\_MAX</code> int32 EnemyHitstopModifier   = <code>INT\\_MAX</code> TEnumAsByte&lt; EFloatingCrumpleType &gt; FloatingCrumpleType int32 ForcedProration   = <code>INT\\_MAX</code> int32 Gravity   = <code>INT\\_MAX</code> FHitValueOverTime GravityOverTime FGroundBounceData GroundBounce TEnumAsByte&lt; EHitAction &gt; GroundHitAction   = <code>HACT\\_GroundNormal</code> int32 GroundPushbackX   = <code>INT\\_MAX</code> int32 HardKnockdown   = <code>INT\\_MAX</code> int32 Hitstop   = <code>INT\\_MAX</code> int32 Hitstun   = <code>INT\\_MAX</code> int32 InitialProration   = <code>INT\\_MAX</code> int32 KnockdownTime   = <code>INT\\_MAX</code> int32 MinimumDamagePercent   = <code>INT\\_MAX</code> FHitPosition Position int32 RecoverableDamagePercent   = <code>INT\\_MAX</code> int32 Untech   = <code>INT\\_MAX</code> FWallBounceData WallBounce"},{"location":"NightSkyEngine/struct_f_hit_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_hit_data/#variable-airhitaction","title":"variable AirHitAction","text":"<pre><code>TEnumAsByte&lt;EHitAction&gt; FHitData::AirHitAction;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-airpushbackx","title":"variable AirPushbackX","text":"<pre><code>int32 FHitData::AirPushbackX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-airpushbackxovertime","title":"variable AirPushbackXOverTime","text":"<pre><code>FHitValueOverTime FHitData::AirPushbackXOverTime;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-airpushbacky","title":"variable AirPushbackY","text":"<pre><code>int32 FHitData::AirPushbackY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-airpushbackyovertime","title":"variable AirPushbackYOverTime","text":"<pre><code>FHitValueOverTime FHitData::AirPushbackYOverTime;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-blowbacklevel","title":"variable BlowbackLevel","text":"<pre><code>int32 FHitData::BlowbackLevel;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-customhitaction","title":"variable CustomHitAction","text":"<pre><code>FGameplayTag FHitData::CustomHitAction;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-damage","title":"variable Damage","text":"<pre><code>int32 FHitData::Damage;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-enemyhitstopmodifier","title":"variable EnemyHitstopModifier","text":"<pre><code>int32 FHitData::EnemyHitstopModifier;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-floatingcrumpletype","title":"variable FloatingCrumpleType","text":"<pre><code>TEnumAsByte&lt;EFloatingCrumpleType&gt; FHitData::FloatingCrumpleType;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-forcedproration","title":"variable ForcedProration","text":"<pre><code>int32 FHitData::ForcedProration;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-gravity","title":"variable Gravity","text":"<pre><code>int32 FHitData::Gravity;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-gravityovertime","title":"variable GravityOverTime","text":"<pre><code>FHitValueOverTime FHitData::GravityOverTime;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-groundbounce","title":"variable GroundBounce","text":"<pre><code>FGroundBounceData FHitData::GroundBounce;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-groundhitaction","title":"variable GroundHitAction","text":"<pre><code>TEnumAsByte&lt;EHitAction&gt; FHitData::GroundHitAction;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-groundpushbackx","title":"variable GroundPushbackX","text":"<pre><code>int32 FHitData::GroundPushbackX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-hardknockdown","title":"variable HardKnockdown","text":"<pre><code>int32 FHitData::HardKnockdown;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-hitstop","title":"variable Hitstop","text":"<pre><code>int32 FHitData::Hitstop;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-hitstun","title":"variable Hitstun","text":"<pre><code>int32 FHitData::Hitstun;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-initialproration","title":"variable InitialProration","text":"<pre><code>int32 FHitData::InitialProration;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-knockdowntime","title":"variable KnockdownTime","text":"<pre><code>int32 FHitData::KnockdownTime;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-minimumdamagepercent","title":"variable MinimumDamagePercent","text":"<pre><code>int32 FHitData::MinimumDamagePercent;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-position","title":"variable Position","text":"<pre><code>FHitPosition FHitData::Position;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-recoverabledamagepercent","title":"variable RecoverableDamagePercent","text":"<pre><code>int32 FHitData::RecoverableDamagePercent;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-untech","title":"variable Untech","text":"<pre><code>int32 FHitData::Untech;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data/#variable-wallbounce","title":"variable WallBounce","text":"<pre><code>FWallBounceData FHitData::WallBounce;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.h</code></p>"},{"location":"NightSkyEngine/struct_f_hit_data_common/","title":"Struct FHitDataCommon","text":"<p>ClassList &gt; FHitDataCommon</p>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#public-attributes","title":"Public Attributes","text":"Type Name int32 AirGuardPushbackX   = <code>INT\\_MAX</code> int32 AirGuardPushbackY   = <code>INT\\_MAX</code> int32 AttackLevel   = <code>0</code> TEnumAsByte&lt; EBlockType &gt; BlockType   = <code>BLK\\_Mid</code> int32 BlockstopModifier   = <code>INT\\_MAX</code> int32 Blockstun   = <code>INT\\_MAX</code> int32 ChipDamagePercent   = <code>0</code> FLinearColor DamageColor   = <code>FLinearColor(1.0, 1.0, 1.0)</code> FLinearColor DamageColor2   = <code>FLinearColor(1.0, 1.0, 1.0)</code> bool DeathCamOverride   = <code>false</code> int32 EnemyBlockstopModifier   = <code>0</code> int32 GroundGuardPushbackX   = <code>INT\\_MAX</code> int32 GuardGravity   = <code>INT\\_MAX</code> FGameplayTag GuardSFX FGameplayTag GuardSFXOverride FGameplayTag GuardVFX FGameplayTag GuardVFXOverride int32 HitAngle   = <code>0</code> FGameplayTag HitSFX FGameplayTag HitSFXOverride FGameplayTag HitVFX FGameplayTag HitVFXOverride int32 ProximityBlockDistanceX   = <code>240000</code> int32 ProximityBlockDistanceY   = <code>160000</code> EHitSFXType SFXType   = <code>EHitSFXType::SFX\\_Punch</code> EHitVFXType VFXType   = <code>EHitVFXType::VFX\\_Strike</code>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-airguardpushbackx","title":"variable AirGuardPushbackX","text":"<pre><code>int32 FHitDataCommon::AirGuardPushbackX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-airguardpushbacky","title":"variable AirGuardPushbackY","text":"<pre><code>int32 FHitDataCommon::AirGuardPushbackY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-attacklevel","title":"variable AttackLevel","text":"<pre><code>int32 FHitDataCommon::AttackLevel;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-blocktype","title":"variable BlockType","text":"<pre><code>TEnumAsByte&lt;EBlockType&gt; FHitDataCommon::BlockType;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-blockstopmodifier","title":"variable BlockstopModifier","text":"<pre><code>int32 FHitDataCommon::BlockstopModifier;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-blockstun","title":"variable Blockstun","text":"<pre><code>int32 FHitDataCommon::Blockstun;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-chipdamagepercent","title":"variable ChipDamagePercent","text":"<pre><code>int32 FHitDataCommon::ChipDamagePercent;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-damagecolor","title":"variable DamageColor","text":"<pre><code>FLinearColor FHitDataCommon::DamageColor;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-damagecolor2","title":"variable DamageColor2","text":"<pre><code>FLinearColor FHitDataCommon::DamageColor2;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-deathcamoverride","title":"variable DeathCamOverride","text":"<pre><code>bool FHitDataCommon::DeathCamOverride;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-enemyblockstopmodifier","title":"variable EnemyBlockstopModifier","text":"<pre><code>int32 FHitDataCommon::EnemyBlockstopModifier;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-groundguardpushbackx","title":"variable GroundGuardPushbackX","text":"<pre><code>int32 FHitDataCommon::GroundGuardPushbackX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-guardgravity","title":"variable GuardGravity","text":"<pre><code>int32 FHitDataCommon::GuardGravity;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-guardsfx","title":"variable GuardSFX","text":"<pre><code>FGameplayTag FHitDataCommon::GuardSFX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-guardsfxoverride","title":"variable GuardSFXOverride","text":"<pre><code>FGameplayTag FHitDataCommon::GuardSFXOverride;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-guardvfx","title":"variable GuardVFX","text":"<pre><code>FGameplayTag FHitDataCommon::GuardVFX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-guardvfxoverride","title":"variable GuardVFXOverride","text":"<pre><code>FGameplayTag FHitDataCommon::GuardVFXOverride;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-hitangle","title":"variable HitAngle","text":"<pre><code>int32 FHitDataCommon::HitAngle;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-hitsfx","title":"variable HitSFX","text":"<pre><code>FGameplayTag FHitDataCommon::HitSFX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-hitsfxoverride","title":"variable HitSFXOverride","text":"<pre><code>FGameplayTag FHitDataCommon::HitSFXOverride;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-hitvfx","title":"variable HitVFX","text":"<pre><code>FGameplayTag FHitDataCommon::HitVFX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-hitvfxoverride","title":"variable HitVFXOverride","text":"<pre><code>FGameplayTag FHitDataCommon::HitVFXOverride;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-proximityblockdistancex","title":"variable ProximityBlockDistanceX","text":"<pre><code>int32 FHitDataCommon::ProximityBlockDistanceX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-proximityblockdistancey","title":"variable ProximityBlockDistanceY","text":"<pre><code>int32 FHitDataCommon::ProximityBlockDistanceY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-sfxtype","title":"variable SFXType","text":"<pre><code>EHitSFXType FHitDataCommon::SFXType;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_data_common/#variable-vfxtype","title":"variable VFXType","text":"<pre><code>EHitVFXType FHitDataCommon::VFXType;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.h</code></p>"},{"location":"NightSkyEngine/struct_f_hit_position/","title":"Struct FHitPosition","text":"<p>ClassList &gt; FHitPosition</p>"},{"location":"NightSkyEngine/struct_f_hit_position/#public-attributes","title":"Public Attributes","text":"Type Name int32 PosX   = <code>INT\\_MAX</code> int32 PosY   = <code>INT\\_MAX</code> TEnumAsByte&lt; EHitPositionType &gt; Type"},{"location":"NightSkyEngine/struct_f_hit_position/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_hit_position/#variable-posx","title":"variable PosX","text":"<pre><code>int32 FHitPosition::PosX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_position/#variable-posy","title":"variable PosY","text":"<pre><code>int32 FHitPosition::PosY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_position/#variable-type","title":"variable Type","text":"<pre><code>TEnumAsByte&lt;EHitPositionType&gt; FHitPosition::Type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.h</code></p>"},{"location":"NightSkyEngine/struct_f_hit_value_over_time/","title":"Struct FHitValueOverTime","text":"<p>ClassList &gt; FHitValueOverTime</p>"},{"location":"NightSkyEngine/struct_f_hit_value_over_time/#public-attributes","title":"Public Attributes","text":"Type Name int32 BeginFrame   = <code>INT\\_MAX</code> int32 EndFrame   = <code>INT\\_MAX</code> int32 Value   = <code>INT\\_MAX</code>"},{"location":"NightSkyEngine/struct_f_hit_value_over_time/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_hit_value_over_time/#variable-beginframe","title":"variable BeginFrame","text":"<pre><code>int32 FHitValueOverTime::BeginFrame;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_value_over_time/#variable-endframe","title":"variable EndFrame","text":"<pre><code>int32 FHitValueOverTime::EndFrame;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_hit_value_over_time/#variable-value","title":"variable Value","text":"<pre><code>int32 FHitValueOverTime::Value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.h</code></p>"},{"location":"NightSkyEngine/struct_f_homing_params/","title":"Struct FHomingParams","text":"<p>ClassList &gt; FHomingParams</p>"},{"location":"NightSkyEngine/struct_f_homing_params/#public-attributes","title":"Public Attributes","text":"Type Name int32 OffsetX int32 OffsetY int32 ParamA int32 ParamB TEnumAsByte&lt; EPosType &gt; Pos TEnumAsByte&lt; EObjType &gt; Target   = <code>OBJ\\_Null</code> TEnumAsByte&lt; EHomingType &gt; Type"},{"location":"NightSkyEngine/struct_f_homing_params/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_homing_params/#variable-offsetx","title":"variable OffsetX","text":"<pre><code>int32 FHomingParams::OffsetX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_homing_params/#variable-offsety","title":"variable OffsetY","text":"<pre><code>int32 FHomingParams::OffsetY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_homing_params/#variable-parama","title":"variable ParamA","text":"<pre><code>int32 FHomingParams::ParamA;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_homing_params/#variable-paramb","title":"variable ParamB","text":"<pre><code>int32 FHomingParams::ParamB;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_homing_params/#variable-pos","title":"variable Pos","text":"<pre><code>TEnumAsByte&lt;EPosType&gt; FHomingParams::Pos;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_homing_params/#variable-target","title":"variable Target","text":"<pre><code>TEnumAsByte&lt;EObjType&gt; FHomingParams::Target;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_homing_params/#variable-type","title":"variable Type","text":"<pre><code>TEnumAsByte&lt;EHomingType&gt; FHomingParams::Type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.h</code></p>"},{"location":"NightSkyEngine/struct_f_input_action_binding_handle/","title":"Struct FInputActionBindingHandle","text":"<p>ClassList &gt; FInputActionBindingHandle</p>"},{"location":"NightSkyEngine/struct_f_input_action_binding_handle/#public-attributes","title":"Public Attributes","text":"Type Name FUIActionBindingHandle Handle"},{"location":"NightSkyEngine/struct_f_input_action_binding_handle/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_input_action_binding_handle/#variable-handle","title":"variable Handle","text":"<pre><code>FUIActionBindingHandle FInputActionBindingHandle::Handle;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/UI/ExtendedCommonActivatableWidget.h</code></p>"},{"location":"NightSkyEngine/struct_f_input_bitmask/","title":"Struct FInputBitmask","text":"<p>ClassList &gt; FInputBitmask</p> <p>More...</p> <ul> <li><code>#include &lt;State.h&gt;</code></li> </ul>"},{"location":"NightSkyEngine/struct_f_input_bitmask/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; TEnumAsByte&lt; EInputFlags &gt; &gt; DisallowedInputs int32 Hold   = <code>0</code> int InputFlag int32 Lenience   = <code>3</code>"},{"location":"NightSkyEngine/struct_f_input_bitmask/#public-functions","title":"Public Functions","text":"Type Name FInputBitmask ()  FInputBitmask (EInputFlags Input)"},{"location":"NightSkyEngine/struct_f_input_bitmask/#detailed-description","title":"Detailed Description","text":"<p>A container struct for input bitmasks. </p>"},{"location":"NightSkyEngine/struct_f_input_bitmask/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_input_bitmask/#variable-disallowedinputs","title":"variable DisallowedInputs","text":"<pre><code>TArray&lt;TEnumAsByte&lt;EInputFlags&gt; &gt; FInputBitmask::DisallowedInputs;\n</code></pre> <p>Disallowed inputs. If any inputs in this array are detected, this input is invalidated. </p>"},{"location":"NightSkyEngine/struct_f_input_bitmask/#variable-hold","title":"variable Hold","text":"<pre><code>int32 FInputBitmask::Hold;\n</code></pre> <p>How long the input must be held for. Unless you're creating a charge/hold input, leave as zero. Does not work with the Negative or Negative Strict input methods. </p>"},{"location":"NightSkyEngine/struct_f_input_bitmask/#variable-inputflag","title":"variable InputFlag","text":"<pre><code>int FInputBitmask::InputFlag;\n</code></pre> <p>The input flag.</p> <p>See also: EInputFlags </p>"},{"location":"NightSkyEngine/struct_f_input_bitmask/#variable-lenience","title":"variable Lenience","text":"<pre><code>int32 FInputBitmask::Lenience;\n</code></pre> <p>How much buffer time there is for the input. </p>"},{"location":"NightSkyEngine/struct_f_input_bitmask/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/struct_f_input_bitmask/#function-finputbitmask-12","title":"function FInputBitmask [1/2]","text":"<pre><code>inline FInputBitmask::FInputBitmask () \n</code></pre>"},{"location":"NightSkyEngine/struct_f_input_bitmask/#function-finputbitmask-22","title":"function FInputBitmask [2/2]","text":"<pre><code>inline FInputBitmask::FInputBitmask (\n    EInputFlags Input\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/State.h</code></p>"},{"location":"NightSkyEngine/struct_f_input_buffer/","title":"Struct FInputBuffer","text":"<p>ClassList &gt; FInputBuffer</p> <p>The input buffer for a player object. More...</p> <ul> <li><code>#include &lt;InputBuffer.h&gt;</code></li> </ul>"},{"location":"NightSkyEngine/struct_f_input_buffer/#public-attributes","title":"Public Attributes","text":"Type Name int32 InputBufferInternal   = <code>{ 16 }</code> int32 InputTime   = <code>{}</code>"},{"location":"NightSkyEngine/struct_f_input_buffer/#public-functions","title":"Public Functions","text":"Type Name bool CheckInputCondition (const FInputCondition &amp; InputCondition) Checks an input condition against the buffer. bool CheckInputSequence () const bool CheckInputSequenceNegative () const bool CheckInputSequenceNegativeStrict () const bool CheckInputSequenceOnce () const bool CheckInputSequenceOnceStrict () const bool CheckInputSequencePressAndRelease () const bool CheckInputSequencePressAndReleaseStrict () const bool CheckInputSequenceStrict () const void Emplace (int32 Input, uint32 Index) Stores the input at an arbitrary buffer position. Intended for CPU usage. void FlipInputsInBuffer ()  void Update (int32 Input, bool bStopped=false) Stores the input for this frame. void WriteInputCondition (const FInputCondition &amp; InputCondition)"},{"location":"NightSkyEngine/struct_f_input_buffer/#detailed-description","title":"Detailed Description","text":"<p>Stores inputs every frame, and handles input checking. </p>"},{"location":"NightSkyEngine/struct_f_input_buffer/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_input_buffer/#variable-inputbufferinternal","title":"variable InputBufferInternal","text":"<pre><code>int32 FInputBuffer::InputBufferInternal[InputBufferSize];\n</code></pre> <p>All stored inputs. Inputs are stored with the newest at the end and the oldest at the beginning. </p>"},{"location":"NightSkyEngine/struct_f_input_buffer/#variable-inputtime","title":"variable InputTime","text":"<pre><code>int32 FInputBuffer::InputTime[InputBufferSize];\n</code></pre> <p>All input times. Input times are looped over and incremented every actionable frame. </p>"},{"location":"NightSkyEngine/struct_f_input_buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/struct_f_input_buffer/#function-checkinputcondition","title":"function CheckInputCondition","text":"<p>Checks an input condition against the buffer. <pre><code>bool FInputBuffer::CheckInputCondition (\n    const FInputCondition &amp; InputCondition\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>InputCondition</code> The input condition to check. </li> </ul> <p>Returns:</p> <p>If the input condition matches the buffer, return true. Otherwise return false. </p>"},{"location":"NightSkyEngine/struct_f_input_buffer/#function-checkinputsequence","title":"function CheckInputSequence","text":"<pre><code>bool FInputBuffer::CheckInputSequence () const\n</code></pre> <p>Checks the input sequence against the buffer with the Normal method. </p> <p>See also: EInputMethod</p> <p>Returns:</p> <p>If the input sequence matches the buffer, return true. Otherwise return false. </p>"},{"location":"NightSkyEngine/struct_f_input_buffer/#function-checkinputsequencenegative","title":"function CheckInputSequenceNegative","text":"<pre><code>bool FInputBuffer::CheckInputSequenceNegative () const\n</code></pre> <p>Checks the input sequence against the buffer with the Negative method. </p> <p>See also: EInputMethod</p> <p>Returns:</p> <p>If the input sequence matches the buffer, return true. Otherwise return false. </p>"},{"location":"NightSkyEngine/struct_f_input_buffer/#function-checkinputsequencenegativestrict","title":"function CheckInputSequenceNegativeStrict","text":"<pre><code>bool FInputBuffer::CheckInputSequenceNegativeStrict () const\n</code></pre> <p>Checks the input sequence against the buffer with the Negative Strict method. </p> <p>See also: EInputMethod</p> <p>Returns:</p> <p>If the input sequence matches the buffer, return true. Otherwise return false. </p>"},{"location":"NightSkyEngine/struct_f_input_buffer/#function-checkinputsequenceonce","title":"function CheckInputSequenceOnce","text":"<pre><code>bool FInputBuffer::CheckInputSequenceOnce () const\n</code></pre> <p>Checks the input sequence against the buffer with the Once method. </p> <p>See also: EInputMethod</p> <p>Returns:</p> <p>If the input sequence matches the buffer, return true. Otherwise return false. </p>"},{"location":"NightSkyEngine/struct_f_input_buffer/#function-checkinputsequenceoncestrict","title":"function CheckInputSequenceOnceStrict","text":"<pre><code>bool FInputBuffer::CheckInputSequenceOnceStrict () const\n</code></pre> <p>Checks the input sequence against the buffer with the Once Strict method. </p> <p>See also: EInputMethod</p> <p>Returns:</p> <p>If the input sequence matches the buffer, return true. Otherwise return false. </p>"},{"location":"NightSkyEngine/struct_f_input_buffer/#function-checkinputsequencepressandrelease","title":"function CheckInputSequencePressAndRelease","text":"<pre><code>bool FInputBuffer::CheckInputSequencePressAndRelease () const\n</code></pre> <p>Checks the input sequence against the buffer with the Once method. </p> <p>See also: EInputMethod</p> <p>Returns:</p> <p>If the input sequence matches the buffer, return true. Otherwise return false. </p>"},{"location":"NightSkyEngine/struct_f_input_buffer/#function-checkinputsequencepressandreleasestrict","title":"function CheckInputSequencePressAndReleaseStrict","text":"<pre><code>bool FInputBuffer::CheckInputSequencePressAndReleaseStrict () const\n</code></pre> <p>Checks the input sequence against the buffer with the Once Strict method. </p> <p>See also: EInputMethod</p> <p>Returns:</p> <p>If the input sequence matches the buffer, return true. Otherwise return false. </p>"},{"location":"NightSkyEngine/struct_f_input_buffer/#function-checkinputsequencestrict","title":"function CheckInputSequenceStrict","text":"<pre><code>bool FInputBuffer::CheckInputSequenceStrict () const\n</code></pre> <p>Checks the input sequence against the buffer with the Strict method. </p> <p>See also: EInputMethod</p> <p>Returns:</p> <p>If the input sequence matches the buffer, return true. Otherwise return false. </p>"},{"location":"NightSkyEngine/struct_f_input_buffer/#function-emplace","title":"function Emplace","text":"<p>Stores the input at an arbitrary buffer position. Intended for CPU usage. <pre><code>void FInputBuffer::Emplace (\n    int32 Input,\n    uint32 Index\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>Input</code> The input bitmask to store. </li> <li><code>Index</code> The index of the buffer to store at. </li> </ul>"},{"location":"NightSkyEngine/struct_f_input_buffer/#function-flipinputsinbuffer","title":"function FlipInputsInBuffer","text":"<pre><code>void FInputBuffer::FlipInputsInBuffer () \n</code></pre> <p>Flips the directional inputs in the buffer. For use after a character switches sides. </p>"},{"location":"NightSkyEngine/struct_f_input_buffer/#function-update","title":"function Update","text":"<p>Stores the input for this frame. <pre><code>void FInputBuffer::Update (\n    int32 Input,\n    bool bStopped=false\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>Input</code> The input bitmask to store. </li> <li><code>bStopped</code> If the owning object is in hitstop/super freeze. </li> </ul>"},{"location":"NightSkyEngine/struct_f_input_buffer/#function-writeinputcondition","title":"function WriteInputCondition","text":"<pre><code>void FInputBuffer::WriteInputCondition (\n    const FInputCondition &amp; InputCondition\n) \n</code></pre> <p>Writes an input condition to the buffer. For use with CPU. </p> <p>Parameters:</p> <ul> <li><code>InputCondition</code> The input condition to write. </li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/InputBuffer.h</code></p>"},{"location":"NightSkyEngine/struct_f_input_condition/","title":"Struct FInputCondition","text":"<p>ClassList &gt; FInputCondition</p> <p>More...</p> <ul> <li><code>#include &lt;State.h&gt;</code></li> </ul>"},{"location":"NightSkyEngine/struct_f_input_condition/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; TEnumAsByte&lt; EInputFlags &gt; &gt; DisallowedInputs int ImpreciseInputCount   = <code>0</code> EInputMethod Method   = <code>EInputMethod::Normal</code> TArray&lt; FInputBitmask &gt; Sequence"},{"location":"NightSkyEngine/struct_f_input_condition/#detailed-description","title":"Detailed Description","text":"<p>Contains an input condition. </p>"},{"location":"NightSkyEngine/struct_f_input_condition/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_input_condition/#variable-disallowedinputs","title":"variable DisallowedInputs","text":"<pre><code>TArray&lt;TEnumAsByte&lt;EInputFlags&gt; &gt; FInputCondition::DisallowedInputs;\n</code></pre> <p>Disallowed inputs. If any inputs in this array are detected, the entire condition is invalidated. </p>"},{"location":"NightSkyEngine/struct_f_input_condition/#variable-impreciseinputcount","title":"variable ImpreciseInputCount","text":"<pre><code>int FInputCondition::ImpreciseInputCount;\n</code></pre> <p>This value determines how many imprecise inputs are allowed in this condition. An imprecise input is a diagonal input that matches the cardinal direction. For use with the Strict or Once Strict input methods. </p>"},{"location":"NightSkyEngine/struct_f_input_condition/#variable-method","title":"variable Method","text":"<pre><code>EInputMethod FInputCondition::Method;\n</code></pre> <p>The input method used for this condition. </p>"},{"location":"NightSkyEngine/struct_f_input_condition/#variable-sequence","title":"variable Sequence","text":"<pre><code>TArray&lt;FInputBitmask&gt; FInputCondition::Sequence;\n</code></pre> <p>A sequence of input bitmasks. Depending on lenience, the amount of time between inputs is increased or decreased. </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/State.h</code></p>"},{"location":"NightSkyEngine/struct_f_input_condition_list/","title":"Struct FInputConditionList","text":"<p>ClassList &gt; FInputConditionList</p> <p>More...</p> <ul> <li><code>#include &lt;State.h&gt;</code></li> </ul>"},{"location":"NightSkyEngine/struct_f_input_condition_list/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; FInputCondition &gt; InputConditions"},{"location":"NightSkyEngine/struct_f_input_condition_list/#detailed-description","title":"Detailed Description","text":"<p>A list of input conditions. Every condition in this list must be met for the state to be entered. </p>"},{"location":"NightSkyEngine/struct_f_input_condition_list/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_input_condition_list/#variable-inputconditions","title":"variable InputConditions","text":"<pre><code>TArray&lt;FInputCondition&gt; FInputConditionList::InputConditions;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/State.h</code></p>"},{"location":"NightSkyEngine/struct_f_link_actor_struct/","title":"Struct FLinkActorStruct","text":"<p>ClassList &gt; FLinkActorStruct</p>"},{"location":"NightSkyEngine/struct_f_link_actor_struct/#public-attributes","title":"Public Attributes","text":"Type Name TSubclassOf&lt; ALinkActor &gt; ActorClass int32 MaxInstances   = <code>1</code> FGameplayTag Name"},{"location":"NightSkyEngine/struct_f_link_actor_struct/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_link_actor_struct/#variable-actorclass","title":"variable ActorClass","text":"<pre><code>TSubclassOf&lt;ALinkActor&gt; FLinkActorStruct::ActorClass;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_link_actor_struct/#variable-maxinstances","title":"variable MaxInstances","text":"<pre><code>int32 FLinkActorStruct::MaxInstances;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_link_actor_struct/#variable-name","title":"variable Name","text":"<pre><code>FGameplayTag FLinkActorStruct::Name;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/LinkActorData.h</code></p>"},{"location":"NightSkyEngine/struct_f_linked_actor_container/","title":"Struct FLinkedActorContainer","text":"<p>ClassList &gt; FLinkedActorContainer</p>"},{"location":"NightSkyEngine/struct_f_linked_actor_container/#public-attributes","title":"Public Attributes","text":"Type Name int32 Index FGameplayTag Name TObjectPtr&lt; ALinkActor &gt; StoredActor bool bIsActive"},{"location":"NightSkyEngine/struct_f_linked_actor_container/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_linked_actor_container/#variable-index","title":"variable Index","text":"<pre><code>int32 FLinkedActorContainer::Index;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_linked_actor_container/#variable-name","title":"variable Name","text":"<pre><code>FGameplayTag FLinkedActorContainer::Name;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_linked_actor_container/#variable-storedactor","title":"variable StoredActor","text":"<pre><code>TObjectPtr&lt;ALinkActor&gt; FLinkedActorContainer::StoredActor;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_linked_actor_container/#variable-bisactive","title":"variable bIsActive","text":"<pre><code>bool FLinkedActorContainer::bIsActive;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.h</code></p>"},{"location":"NightSkyEngine/struct_f_material_struct/","title":"Struct FMaterialStruct","text":"<p>ClassList &gt; FMaterialStruct</p>"},{"location":"NightSkyEngine/struct_f_material_struct/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; UMaterialInterface * &gt; Material FName Name UMaterialInterface * OverlayMaterial"},{"location":"NightSkyEngine/struct_f_material_struct/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_material_struct/#variable-material","title":"variable Material","text":"<pre><code>TArray&lt;UMaterialInterface*&gt; FMaterialStruct::Material;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_material_struct/#variable-name","title":"variable Name","text":"<pre><code>FName FMaterialStruct::Name;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_material_struct/#variable-overlaymaterial","title":"variable OverlayMaterial","text":"<pre><code>UMaterialInterface* FMaterialStruct::OverlayMaterial;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/MaterialData.h</code></p>"},{"location":"NightSkyEngine/struct_f_n_s_e_session_info/","title":"Struct FNSESessionInfo","text":"<p>ClassList &gt; FNSESessionInfo</p>"},{"location":"NightSkyEngine/struct_f_n_s_e_session_info/#public-attributes","title":"Public Attributes","text":"Type Name int32 NumOpenPrivateConnections int32 NumOpenPublicConnections FString OwningUserName FOnlineSessionSearchResult SessionSearchResult   = <code>{}</code>"},{"location":"NightSkyEngine/struct_f_n_s_e_session_info/#public-functions","title":"Public Functions","text":"Type Name FNSESessionInfo () = default FNSESessionInfo (const FOnlineSessionSearchResult &amp; Result, const FString &amp; Name, int32 OpenPrivate, int32 OpenPublic)"},{"location":"NightSkyEngine/struct_f_n_s_e_session_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_n_s_e_session_info/#variable-numopenprivateconnections","title":"variable NumOpenPrivateConnections","text":"<pre><code>int32 FNSESessionInfo::NumOpenPrivateConnections;\n</code></pre> <p>The number of private connections that are available (read only) </p>"},{"location":"NightSkyEngine/struct_f_n_s_e_session_info/#variable-numopenpublicconnections","title":"variable NumOpenPublicConnections","text":"<pre><code>int32 FNSESessionInfo::NumOpenPublicConnections;\n</code></pre> <p>The number of publicly available connections that are available (read only) </p>"},{"location":"NightSkyEngine/struct_f_n_s_e_session_info/#variable-owningusername","title":"variable OwningUserName","text":"<pre><code>FString FNSESessionInfo::OwningUserName;\n</code></pre> <p>Owner name of the session </p>"},{"location":"NightSkyEngine/struct_f_n_s_e_session_info/#variable-sessionsearchresult","title":"variable SessionSearchResult","text":"<pre><code>FOnlineSessionSearchResult FNSESessionInfo::SessionSearchResult;\n</code></pre> <p>Session </p>"},{"location":"NightSkyEngine/struct_f_n_s_e_session_info/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/struct_f_n_s_e_session_info/#function-fnsesessioninfo-12","title":"function FNSESessionInfo [1/2]","text":"<pre><code>FNSESessionInfo::FNSESessionInfo () = default\n</code></pre>"},{"location":"NightSkyEngine/struct_f_n_s_e_session_info/#function-fnsesessioninfo-22","title":"function FNSESessionInfo [2/2]","text":"<pre><code>FNSESessionInfo::FNSESessionInfo (\n    const FOnlineSessionSearchResult &amp; Result,\n    const FString &amp; Name,\n    int32 OpenPrivate,\n    int32 OpenPublic\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Network/NSESessionSubsystem.h</code></p>"},{"location":"NightSkyEngine/struct_f_network_mirror/","title":"Struct FNetworkMirror","text":"<p>ClassList &gt; FNetworkMirror</p>"},{"location":"NightSkyEngine/struct_f_network_mirror/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; FPrimaryAssetId &gt; PlayerList FPrimaryAssetId Stage"},{"location":"NightSkyEngine/struct_f_network_mirror/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_network_mirror/#variable-playerlist","title":"variable PlayerList","text":"<pre><code>TArray&lt;FPrimaryAssetId&gt; FNetworkMirror::PlayerList;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_network_mirror/#variable-stage","title":"variable Stage","text":"<pre><code>FPrimaryAssetId FNetworkMirror::Stage;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Network/NetworkPawn.h</code></p>"},{"location":"NightSkyEngine/struct_f_network_stats/","title":"Struct FNetworkStats","text":"<p>ClassList &gt; FNetworkStats</p>"},{"location":"NightSkyEngine/struct_f_network_stats/#public-attributes","title":"Public Attributes","text":"Type Name int32 Ping int32 RollbackFrames"},{"location":"NightSkyEngine/struct_f_network_stats/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_network_stats/#variable-ping","title":"variable Ping","text":"<pre><code>int32 FNetworkStats::Ping;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_network_stats/#variable-rollbackframes","title":"variable RollbackFrames","text":"<pre><code>int32 FNetworkStats::RollbackFrames;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyGameState.h</code></p>"},{"location":"NightSkyEngine/struct_f_night_sky_save_archive/","title":"Struct FNightSkySaveArchive","text":"<p>ClassList &gt; FNightSkySaveArchive</p> <p>Inherits the following classes: FObjectAndNameAsStringProxyArchive</p>"},{"location":"NightSkyEngine/struct_f_night_sky_save_archive/#public-functions","title":"Public Functions","text":"Type Name FNightSkySaveArchive (FArchive &amp; InInnerArchive)"},{"location":"NightSkyEngine/struct_f_night_sky_save_archive/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/struct_f_night_sky_save_archive/#function-fnightskysavearchive","title":"function FNightSkySaveArchive","text":"<pre><code>inline FNightSkySaveArchive::FNightSkySaveArchive (\n    FArchive &amp; InInnerArchive\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkySaveInfo.h</code></p>"},{"location":"NightSkyEngine/struct_f_object_record/","title":"Struct FObjectRecord","text":"<p>ClassList &gt; FObjectRecord</p>"},{"location":"NightSkyEngine/struct_f_object_record/#public-attributes","title":"Public Attributes","text":"Type Name UClass * Class TArray&lt; uint8 &gt; Data FName Name UObject * Outer int32 OuterID UObject * Self FTransform Transform bool bActor"},{"location":"NightSkyEngine/struct_f_object_record/#public-functions","title":"Public Functions","text":"Type Name FObjectRecord ()"},{"location":"NightSkyEngine/struct_f_object_record/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_object_record/#variable-class","title":"variable Class","text":"<pre><code>UClass* FObjectRecord::Class;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_object_record/#variable-data","title":"variable Data","text":"<pre><code>TArray&lt;uint8&gt; FObjectRecord::Data;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_object_record/#variable-name","title":"variable Name","text":"<pre><code>FName FObjectRecord::Name;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_object_record/#variable-outer","title":"variable Outer","text":"<pre><code>UObject* FObjectRecord::Outer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_object_record/#variable-outerid","title":"variable OuterID","text":"<pre><code>int32 FObjectRecord::OuterID;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_object_record/#variable-self","title":"variable Self","text":"<pre><code>UObject* FObjectRecord::Self;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_object_record/#variable-transform","title":"variable Transform","text":"<pre><code>FTransform FObjectRecord::Transform;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_object_record/#variable-bactor","title":"variable bActor","text":"<pre><code>bool FObjectRecord::bActor;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_object_record/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/struct_f_object_record/#function-fobjectrecord","title":"function FObjectRecord","text":"<pre><code>inline FObjectRecord::FObjectRecord () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkySaveInfo.h</code></p>"},{"location":"NightSkyEngine/struct_f_particle_struct/","title":"Struct FParticleStruct","text":"<p>ClassList &gt; FParticleStruct</p>"},{"location":"NightSkyEngine/struct_f_particle_struct/#public-attributes","title":"Public Attributes","text":"Type Name FGameplayTag Name class UNiagaraSystem * ParticleSystem"},{"location":"NightSkyEngine/struct_f_particle_struct/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_particle_struct/#variable-name","title":"variable Name","text":"<pre><code>FGameplayTag FParticleStruct::Name;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_particle_struct/#variable-particlesystem","title":"variable ParticleSystem","text":"<pre><code>class UNiagaraSystem* FParticleStruct::ParticleSystem;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/ParticleData.h</code></p>"},{"location":"NightSkyEngine/struct_f_player_object_log/","title":"Struct FPlayerObjectLog","text":"<p>ClassList &gt; FPlayerObjectLog</p> <p>Inherits the following classes: FBattleObjectLog</p>"},{"location":"NightSkyEngine/struct_f_player_object_log/#public-attributes","title":"Public Attributes","text":"Type Name int32 AirDashCount int32 AirDashMinimumHeight uint32 AirDashTimer   = <code>0</code> int32 AirJumpCount int32 AirPushHeight int32 AirPushHeightLow int32 AirPushWidth int32 BAirDashNoAttackTime int32 BAirDashSpeed int32 BAirDashTime int32 BDashGravity int32 BDashHeight int32 BDashSpeed int32 BJumpSpeed int32 BSuperJumpSpeed int32 BWalkSpeed bool CanProximityThrow bool CanReverseBeat int32 CloseNormalRange int32 CmnPlayerReg1   = <code>0</code> int32 CmnPlayerReg2   = <code>0</code> int32 CmnPlayerReg3   = <code>0</code> int32 CmnPlayerReg4   = <code>0</code> int32 CmnPlayerReg5   = <code>0</code> int32 CmnPlayerReg6   = <code>0</code> int32 CmnPlayerReg7   = <code>0</code> int32 CmnPlayerReg8   = <code>0</code> int32 ComboCounter int32 ComboRate   = <code>60</code> int32 ComboTimer bool ComponentVisible int32 CrouchPushHeight int32 CrouchPushWidth int32 CurrentHealth APlayerObject * Enemy int32 FAirDashNoAttackTime int32 FAirDashSpeed int32 FAirDashTime int32 FDashAccel int32 FDashFriction int32 FDashInitSpeed int32 FDashMaxSpeed int32 FJumpSpeed int32 FSuperJumpSpeed int32 FWalkSpeed bool FlipInputs int32 ForwardAirDashMeterGain int32 ForwardDashMeterGain int32 ForwardJumpMeterGain int32 ForwardWalkMeterGain uint32 Inputs bool IntroEndFlag   = <code>false</code> FGameplayTag IntroName uint32 InvulnFlags   = <code>0</code> int32 JumpGravity int32 JumpHeight int32 MaxHealth int32 MaxMeter   = <code>10000</code> int32 MaxOTGCount int32 MeterPercentOnHit   = <code>72</code> int32 MeterPercentOnHitGuard   = <code>18</code> int32 MeterPercentOnReceiveHit   = <code>40</code> int32 MeterPercentOnReceiveHitGuard   = <code>10</code> int32 OTGCount int32 OtgProration   = <code>80</code> uint32 PlayerFlags   = <code>0</code> int32 PlayerIndex int32 PlayerReg1   = <code>0</code> int32 PlayerReg2   = <code>0</code> int32 PlayerReg3   = <code>0</code> int32 PlayerReg4   = <code>0</code> int32 PlayerReg5   = <code>0</code> int32 PlayerReg6   = <code>0</code> int32 PlayerReg7   = <code>0</code> int32 PlayerReg8   = <code>0</code> unsigned char PlayerSync unsigned char PlayerSyncEnd FInputCondition ProximityThrowInput int32 RecoverableHealth bool RoundEndFlag   = <code>false</code> int32 RoundWinTimer   = <code>120</code> TEnumAsByte&lt; EActionStance &gt; Stance int32 StandPushHeight int32 StandPushWidth FGameplayTag StateEntryName ABattleObject * StoredBattleObjects FInputBuffer StoredInputBuffer uint32 StrikeInvulnerableTimer   = <code>0</code> int32 SuperJumpGravity int32 SuperJumpHeight int32 TeamIndex uint32 ThrowInvulnerableTimer   = <code>0</code> int32 ThrowResistAfterWakeUp   = <code>5</code> uint32 ThrowResistTimer   = <code>0</code> int32 ThrowTechWindow   = <code>6</code> int32 TotalProration   = <code>10000</code> int32 WallTouchTimer bool bCrumpled bool bLimitCrumple   = <code>true</code>"},{"location":"NightSkyEngine/struct_f_player_object_log/#public-attributes-inherited-from-fbattleobjectlog","title":"Public Attributes inherited from FBattleObjectLog","text":"<p>See FBattleObjectLog</p> Type Name int32 ActionReg1   = <code>0</code> int32 ActionReg2   = <code>0</code> int32 ActionReg3   = <code>0</code> int32 ActionReg4   = <code>0</code> int32 ActionReg5   = <code>0</code> int32 ActionReg6   = <code>0</code> int32 ActionReg7   = <code>0</code> int32 ActionReg8   = <code>0</code> int32 ActionTime   = <code>0</code> FLinearColor AddColor   = <code>FLinearColor(0, 0, 0, 1)</code> FLinearColor AddFadeColor   = <code>{}</code> float AddFadeSpeed   = <code>0</code> int32 AnglePitch_x10   = <code>0</code> int32 AngleRoll_x10   = <code>0</code> int32 AngleYaw_x10   = <code>0</code> float AnimBlendIn   = <code>{}</code> float AnimBlendOut   = <code>{}</code> int32 AnimFrame   = <code>0</code> uint32 AttackFlags   = <code>0</code> ABattleObject * AttackOwner ABattleObject * AttackTarget   = <code>nullptr</code> int32 B   = <code>0</code> int32 BlendAnimFrame   = <code>0</code> FGameplayTag BlendCelName   = <code>{}</code> bool BlendOffset   = <code>false</code> int32 CelIndex   = <code>0</code> FGameplayTag CelName   = <code>{}</code> int32 ColPosX   = <code>0</code> int32 ColPosY   = <code>0</code> FHitData CounterHit   = <code>{}</code> FLinearColor DamageColor   = <code>FLinearColor(1, 1, 1, 1)</code> FLinearColor DamageColor2   = <code>FLinearColor(1, 1, 1, 1)</code> TEnumAsByte&lt; EObjDir &gt; Direction   = <code>DIR\\_Right</code> int32 DrawPriority   = <code>0</code> ABattleObject * DrawPriorityLinkObj   = <code>nullptr</code> FEventHandler EventHandlers   = <code>{}</code> float FadeTransparency   = <code>1</code> float FrameBlendPosition   = <code>0</code> bool GotoLabelActive   = <code>false</code> int32 Gravity   = <code>1900</code> int32 GroundHeight   = <code>0</code> FHitDataCommon HitCommon   = <code>{}</code> uint32 Hitstop   = <code>0</code> FHomingParams HomingParams   = <code>[**FHomingParams**](struct_f_homing_params.md)()</code> int32 Inertia   = <code>0</code> bool IsActive   = <code>false</code> bool IsPlayer   = <code>false</code> int32 L   = <code>0</code> FGameplayTag LabelName   = <code>{}</code> ABattleObject * MaterialLinkObj   = <code>nullptr</code> int32 MaxCelTime   = <code>0</code> int32 MiscFlags   = <code>0</code> FLinearColor MulColor   = <code>FLinearColor(1, 1, 1, 1)</code> FLinearColor MulFadeColor   = <code>{}</code> float MulFadeSpeed   = <code>0</code> int32 NextOffsetX   = <code>0</code> int32 NextOffsetY   = <code>0</code> FHitData NormalHit   = <code>{}</code> unsigned char ObjSync   = <code>0</code> unsigned char ObjSyncEnd   = <code>0</code> uint32 ObjectID   = <code>0</code> FVector ObjectOffset   = <code>FVector::ZeroVector</code> int32 ObjectReg1   = <code>0</code> int32 ObjectReg2   = <code>0</code> int32 ObjectReg3   = <code>0</code> int32 ObjectReg4   = <code>0</code> int32 ObjectReg5   = <code>0</code> int32 ObjectReg6   = <code>0</code> int32 ObjectReg7   = <code>0</code> int32 ObjectReg8   = <code>0</code> FRotator ObjectRotation   = <code>FRotator::ZeroRotator</code> FVector ObjectScale   = <code>FVector::One()</code> int32 ObjectStateIndex   = <code>0</code> FGameplayTag ObjectStateName   = <code>{}</code> APlayerObject * Player   = <code>nullptr</code> int32 PosX   = <code>0</code> int32 PosY   = <code>0</code> int32 PosZ   = <code>0</code> ABattleObject * PositionLinkObj   = <code>nullptr</code> int32 PrevOffsetX   = <code>0</code> int32 PrevOffsetY   = <code>0</code> int32 PrevPosX   = <code>0</code> int32 PrevPosY   = <code>0</code> int32 PrevPosZ   = <code>0</code> int32 PrevRootMotionX   = <code>0</code> int32 PrevRootMotionY   = <code>0</code> int32 PrevRootMotionZ   = <code>0</code> int32 Pushback   = <code>0</code> int32 R   = <code>0</code> FHitData ReceivedHit   = <code>{}</code> FHitDataCommon ReceivedHitCommon   = <code>{}</code> bool ReturnReg   = <code>false</code> FName SocketName   = <code>{}</code> EObjType SocketObj   = <code>OBJ\\_Self</code> FVector SocketOffset   = <code>FVector::ZeroVector</code> int32 SpeedX   = <code>0</code> int32 SpeedXRate   = <code>100</code> int32 SpeedXRatePerFrame   = <code>100</code> int32 SpeedY   = <code>0</code> int32 SpeedYRate   = <code>100</code> int32 SpeedYRatePerFrame   = <code>100</code> int32 SpeedZ   = <code>0</code> int32 SpeedZRate   = <code>100</code> int32 SpeedZRatePerFrame   = <code>100</code> ABattleObject * StopLinkObj   = <code>nullptr</code> uint32 StunTime   = <code>0</code> uint32 StunTimeMax   = <code>0</code> int32 SubroutineReg1   = <code>0</code> int32 SubroutineReg2   = <code>0</code> int32 SubroutineReg3   = <code>0</code> int32 SubroutineReg4   = <code>0</code> int32 SubroutineReturnVal1   = <code>0</code> int32 SubroutineReturnVal2   = <code>0</code> int32 SubroutineReturnVal3   = <code>0</code> int32 SubroutineReturnVal4   = <code>0</code> FSuperArmorData SuperArmorData   = <code>[**FSuperArmorData**](struct_f_super_armor_data.md)()</code> int32 T   = <code>0</code> int32 TimeUntilNextCel   = <code>0</code> int32 Timer0   = <code>0</code> int32 Timer1   = <code>0</code> float Transparency   = <code>1</code> float TransparencySpeed   = <code>0</code> int32 UpdateTime   = <code>0</code> bool bIsCommonState   = <code>false</code> bool bRender   = <code>true</code>"},{"location":"NightSkyEngine/struct_f_player_object_log/#public-functions","title":"Public Functions","text":"Type Name virtual void LogForSyncTestFile (std::ofstream &amp; file) override"},{"location":"NightSkyEngine/struct_f_player_object_log/#public-functions-inherited-from-fbattleobjectlog","title":"Public Functions inherited from FBattleObjectLog","text":"<p>See FBattleObjectLog</p> Type Name virtual void LogForSyncTestFile (std::ofstream &amp; file)  virtual ~FBattleObjectLog () = default"},{"location":"NightSkyEngine/struct_f_player_object_log/#protected-attributes","title":"Protected Attributes","text":"Type Name uint32 AirDashNoAttackTime   = <code>0</code> uint32 AirDashTimerMax   = <code>0</code> int32 AutoComboCancels   = <code>{}</code> FGameplayTag BufferedStateName uint32 CancelFlags   = <code>0</code> uint32 CurrentAirDashCount   = <code>0</code> uint32 CurrentAirJumpCount   = <code>0</code> FGameplayTag ExeStateName uint32 InstantBlockLockoutTimer   = <code>0</code> FGameplayTag LastStateName uint32 MeterCooldownTimer   = <code>0</code> int32 ThrowRange   = <code>0</code> int32 ThrowTechTimer   = <code>0</code> bool bIsAutoCombo   = <code>false</code>"},{"location":"NightSkyEngine/struct_f_player_object_log/#protected-attributes-inherited-from-fbattleobjectlog","title":"Protected Attributes inherited from FBattleObjectLog","text":"<p>See FBattleObjectLog</p> Type Name int32 PushHeight   = <code>0</code> int32 PushHeightLow   = <code>0</code> int32 PushWidth   = <code>0</code> int32 PushWidthExtend   = <code>0</code>"},{"location":"NightSkyEngine/struct_f_player_object_log/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-airdashcount","title":"variable AirDashCount","text":"<pre><code>int32 FPlayerObjectLog::AirDashCount;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-airdashminimumheight","title":"variable AirDashMinimumHeight","text":"<pre><code>int32 FPlayerObjectLog::AirDashMinimumHeight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-airdashtimer","title":"variable AirDashTimer","text":"<pre><code>uint32 FPlayerObjectLog::AirDashTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-airjumpcount","title":"variable AirJumpCount","text":"<pre><code>int32 FPlayerObjectLog::AirJumpCount;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-airpushheight","title":"variable AirPushHeight","text":"<pre><code>int32 FPlayerObjectLog::AirPushHeight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-airpushheightlow","title":"variable AirPushHeightLow","text":"<pre><code>int32 FPlayerObjectLog::AirPushHeightLow;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-airpushwidth","title":"variable AirPushWidth","text":"<pre><code>int32 FPlayerObjectLog::AirPushWidth;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-bairdashnoattacktime","title":"variable BAirDashNoAttackTime","text":"<pre><code>int32 FPlayerObjectLog::BAirDashNoAttackTime;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-bairdashspeed","title":"variable BAirDashSpeed","text":"<pre><code>int32 FPlayerObjectLog::BAirDashSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-bairdashtime","title":"variable BAirDashTime","text":"<pre><code>int32 FPlayerObjectLog::BAirDashTime;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-bdashgravity","title":"variable BDashGravity","text":"<pre><code>int32 FPlayerObjectLog::BDashGravity;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-bdashheight","title":"variable BDashHeight","text":"<pre><code>int32 FPlayerObjectLog::BDashHeight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-bdashspeed","title":"variable BDashSpeed","text":"<pre><code>int32 FPlayerObjectLog::BDashSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-bjumpspeed","title":"variable BJumpSpeed","text":"<pre><code>int32 FPlayerObjectLog::BJumpSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-bsuperjumpspeed","title":"variable BSuperJumpSpeed","text":"<pre><code>int32 FPlayerObjectLog::BSuperJumpSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-bwalkspeed","title":"variable BWalkSpeed","text":"<pre><code>int32 FPlayerObjectLog::BWalkSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-canproximitythrow","title":"variable CanProximityThrow","text":"<pre><code>bool FPlayerObjectLog::CanProximityThrow;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-canreversebeat","title":"variable CanReverseBeat","text":"<pre><code>bool FPlayerObjectLog::CanReverseBeat;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-closenormalrange","title":"variable CloseNormalRange","text":"<pre><code>int32 FPlayerObjectLog::CloseNormalRange;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-cmnplayerreg1","title":"variable CmnPlayerReg1","text":"<pre><code>int32 FPlayerObjectLog::CmnPlayerReg1;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-cmnplayerreg2","title":"variable CmnPlayerReg2","text":"<pre><code>int32 FPlayerObjectLog::CmnPlayerReg2;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-cmnplayerreg3","title":"variable CmnPlayerReg3","text":"<pre><code>int32 FPlayerObjectLog::CmnPlayerReg3;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-cmnplayerreg4","title":"variable CmnPlayerReg4","text":"<pre><code>int32 FPlayerObjectLog::CmnPlayerReg4;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-cmnplayerreg5","title":"variable CmnPlayerReg5","text":"<pre><code>int32 FPlayerObjectLog::CmnPlayerReg5;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-cmnplayerreg6","title":"variable CmnPlayerReg6","text":"<pre><code>int32 FPlayerObjectLog::CmnPlayerReg6;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-cmnplayerreg7","title":"variable CmnPlayerReg7","text":"<pre><code>int32 FPlayerObjectLog::CmnPlayerReg7;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-cmnplayerreg8","title":"variable CmnPlayerReg8","text":"<pre><code>int32 FPlayerObjectLog::CmnPlayerReg8;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-combocounter","title":"variable ComboCounter","text":"<pre><code>int32 FPlayerObjectLog::ComboCounter;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-comborate","title":"variable ComboRate","text":"<pre><code>int32 FPlayerObjectLog::ComboRate;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-combotimer","title":"variable ComboTimer","text":"<pre><code>int32 FPlayerObjectLog::ComboTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-componentvisible","title":"variable ComponentVisible","text":"<pre><code>bool FPlayerObjectLog::ComponentVisible[MaxComponentCount];\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-crouchpushheight","title":"variable CrouchPushHeight","text":"<pre><code>int32 FPlayerObjectLog::CrouchPushHeight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-crouchpushwidth","title":"variable CrouchPushWidth","text":"<pre><code>int32 FPlayerObjectLog::CrouchPushWidth;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-currenthealth","title":"variable CurrentHealth","text":"<pre><code>int32 FPlayerObjectLog::CurrentHealth;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-enemy","title":"variable Enemy","text":"<pre><code>APlayerObject* FPlayerObjectLog::Enemy;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-fairdashnoattacktime","title":"variable FAirDashNoAttackTime","text":"<pre><code>int32 FPlayerObjectLog::FAirDashNoAttackTime;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-fairdashspeed","title":"variable FAirDashSpeed","text":"<pre><code>int32 FPlayerObjectLog::FAirDashSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-fairdashtime","title":"variable FAirDashTime","text":"<pre><code>int32 FPlayerObjectLog::FAirDashTime;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-fdashaccel","title":"variable FDashAccel","text":"<pre><code>int32 FPlayerObjectLog::FDashAccel;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-fdashfriction","title":"variable FDashFriction","text":"<pre><code>int32 FPlayerObjectLog::FDashFriction;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-fdashinitspeed","title":"variable FDashInitSpeed","text":"<pre><code>int32 FPlayerObjectLog::FDashInitSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-fdashmaxspeed","title":"variable FDashMaxSpeed","text":"<pre><code>int32 FPlayerObjectLog::FDashMaxSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-fjumpspeed","title":"variable FJumpSpeed","text":"<pre><code>int32 FPlayerObjectLog::FJumpSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-fsuperjumpspeed","title":"variable FSuperJumpSpeed","text":"<pre><code>int32 FPlayerObjectLog::FSuperJumpSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-fwalkspeed","title":"variable FWalkSpeed","text":"<pre><code>int32 FPlayerObjectLog::FWalkSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-flipinputs","title":"variable FlipInputs","text":"<pre><code>bool FPlayerObjectLog::FlipInputs;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-forwardairdashmetergain","title":"variable ForwardAirDashMeterGain","text":"<pre><code>int32 FPlayerObjectLog::ForwardAirDashMeterGain;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-forwarddashmetergain","title":"variable ForwardDashMeterGain","text":"<pre><code>int32 FPlayerObjectLog::ForwardDashMeterGain;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-forwardjumpmetergain","title":"variable ForwardJumpMeterGain","text":"<pre><code>int32 FPlayerObjectLog::ForwardJumpMeterGain;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-forwardwalkmetergain","title":"variable ForwardWalkMeterGain","text":"<pre><code>int32 FPlayerObjectLog::ForwardWalkMeterGain;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-inputs","title":"variable Inputs","text":"<pre><code>uint32 FPlayerObjectLog::Inputs;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-introendflag","title":"variable IntroEndFlag","text":"<pre><code>bool FPlayerObjectLog::IntroEndFlag;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-introname","title":"variable IntroName","text":"<pre><code>FGameplayTag FPlayerObjectLog::IntroName;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-invulnflags","title":"variable InvulnFlags","text":"<pre><code>uint32 FPlayerObjectLog::InvulnFlags;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-jumpgravity","title":"variable JumpGravity","text":"<pre><code>int32 FPlayerObjectLog::JumpGravity;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-jumpheight","title":"variable JumpHeight","text":"<pre><code>int32 FPlayerObjectLog::JumpHeight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-maxhealth","title":"variable MaxHealth","text":"<pre><code>int32 FPlayerObjectLog::MaxHealth;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-maxmeter","title":"variable MaxMeter","text":"<pre><code>int32 FPlayerObjectLog::MaxMeter;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-maxotgcount","title":"variable MaxOTGCount","text":"<pre><code>int32 FPlayerObjectLog::MaxOTGCount;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-meterpercentonhit","title":"variable MeterPercentOnHit","text":"<pre><code>int32 FPlayerObjectLog::MeterPercentOnHit;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-meterpercentonhitguard","title":"variable MeterPercentOnHitGuard","text":"<pre><code>int32 FPlayerObjectLog::MeterPercentOnHitGuard;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-meterpercentonreceivehit","title":"variable MeterPercentOnReceiveHit","text":"<pre><code>int32 FPlayerObjectLog::MeterPercentOnReceiveHit;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-meterpercentonreceivehitguard","title":"variable MeterPercentOnReceiveHitGuard","text":"<pre><code>int32 FPlayerObjectLog::MeterPercentOnReceiveHitGuard;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-otgcount","title":"variable OTGCount","text":"<pre><code>int32 FPlayerObjectLog::OTGCount;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-otgproration","title":"variable OtgProration","text":"<pre><code>int32 FPlayerObjectLog::OtgProration;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-playerflags","title":"variable PlayerFlags","text":"<pre><code>uint32 FPlayerObjectLog::PlayerFlags;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-playerindex","title":"variable PlayerIndex","text":"<pre><code>int32 FPlayerObjectLog::PlayerIndex;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-playerreg1","title":"variable PlayerReg1","text":"<pre><code>int32 FPlayerObjectLog::PlayerReg1;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-playerreg2","title":"variable PlayerReg2","text":"<pre><code>int32 FPlayerObjectLog::PlayerReg2;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-playerreg3","title":"variable PlayerReg3","text":"<pre><code>int32 FPlayerObjectLog::PlayerReg3;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-playerreg4","title":"variable PlayerReg4","text":"<pre><code>int32 FPlayerObjectLog::PlayerReg4;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-playerreg5","title":"variable PlayerReg5","text":"<pre><code>int32 FPlayerObjectLog::PlayerReg5;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-playerreg6","title":"variable PlayerReg6","text":"<pre><code>int32 FPlayerObjectLog::PlayerReg6;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-playerreg7","title":"variable PlayerReg7","text":"<pre><code>int32 FPlayerObjectLog::PlayerReg7;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-playerreg8","title":"variable PlayerReg8","text":"<pre><code>int32 FPlayerObjectLog::PlayerReg8;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-playersync","title":"variable PlayerSync","text":"<pre><code>unsigned char FPlayerObjectLog::PlayerSync;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-playersyncend","title":"variable PlayerSyncEnd","text":"<pre><code>unsigned char FPlayerObjectLog::PlayerSyncEnd;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-proximitythrowinput","title":"variable ProximityThrowInput","text":"<pre><code>FInputCondition FPlayerObjectLog::ProximityThrowInput;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-recoverablehealth","title":"variable RecoverableHealth","text":"<pre><code>int32 FPlayerObjectLog::RecoverableHealth;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-roundendflag","title":"variable RoundEndFlag","text":"<pre><code>bool FPlayerObjectLog::RoundEndFlag;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-roundwintimer","title":"variable RoundWinTimer","text":"<pre><code>int32 FPlayerObjectLog::RoundWinTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-stance","title":"variable Stance","text":"<pre><code>TEnumAsByte&lt;EActionStance&gt; FPlayerObjectLog::Stance;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-standpushheight","title":"variable StandPushHeight","text":"<pre><code>int32 FPlayerObjectLog::StandPushHeight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-standpushwidth","title":"variable StandPushWidth","text":"<pre><code>int32 FPlayerObjectLog::StandPushWidth;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-stateentryname","title":"variable StateEntryName","text":"<pre><code>FGameplayTag FPlayerObjectLog::StateEntryName;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-storedbattleobjects","title":"variable StoredBattleObjects","text":"<pre><code>ABattleObject* FPlayerObjectLog::StoredBattleObjects[16];\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-storedinputbuffer","title":"variable StoredInputBuffer","text":"<pre><code>FInputBuffer FPlayerObjectLog::StoredInputBuffer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-strikeinvulnerabletimer","title":"variable StrikeInvulnerableTimer","text":"<pre><code>uint32 FPlayerObjectLog::StrikeInvulnerableTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-superjumpgravity","title":"variable SuperJumpGravity","text":"<pre><code>int32 FPlayerObjectLog::SuperJumpGravity;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-superjumpheight","title":"variable SuperJumpHeight","text":"<pre><code>int32 FPlayerObjectLog::SuperJumpHeight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-teamindex","title":"variable TeamIndex","text":"<pre><code>int32 FPlayerObjectLog::TeamIndex;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-throwinvulnerabletimer","title":"variable ThrowInvulnerableTimer","text":"<pre><code>uint32 FPlayerObjectLog::ThrowInvulnerableTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-throwresistafterwakeup","title":"variable ThrowResistAfterWakeUp","text":"<pre><code>int32 FPlayerObjectLog::ThrowResistAfterWakeUp;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-throwresisttimer","title":"variable ThrowResistTimer","text":"<pre><code>uint32 FPlayerObjectLog::ThrowResistTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-throwtechwindow","title":"variable ThrowTechWindow","text":"<pre><code>int32 FPlayerObjectLog::ThrowTechWindow;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-totalproration","title":"variable TotalProration","text":"<pre><code>int32 FPlayerObjectLog::TotalProration;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-walltouchtimer","title":"variable WallTouchTimer","text":"<pre><code>int32 FPlayerObjectLog::WallTouchTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-bcrumpled","title":"variable bCrumpled","text":"<pre><code>bool FPlayerObjectLog::bCrumpled;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-blimitcrumple","title":"variable bLimitCrumple","text":"<pre><code>bool FPlayerObjectLog::bLimitCrumple;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/struct_f_player_object_log/#function-logforsynctestfile","title":"function LogForSyncTestFile","text":"<pre><code>virtual void FPlayerObjectLog::LogForSyncTestFile (\n    std::ofstream &amp; file\n) override\n</code></pre> <p>Implements FBattleObjectLog::LogForSyncTestFile</p>"},{"location":"NightSkyEngine/struct_f_player_object_log/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-airdashnoattacktime","title":"variable AirDashNoAttackTime","text":"<pre><code>uint32 FPlayerObjectLog::AirDashNoAttackTime;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-airdashtimermax","title":"variable AirDashTimerMax","text":"<pre><code>uint32 FPlayerObjectLog::AirDashTimerMax;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-autocombocancels","title":"variable AutoComboCancels","text":"<pre><code>int32 FPlayerObjectLog::AutoComboCancels[8];\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-bufferedstatename","title":"variable BufferedStateName","text":"<pre><code>FGameplayTag FPlayerObjectLog::BufferedStateName;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-cancelflags","title":"variable CancelFlags","text":"<pre><code>uint32 FPlayerObjectLog::CancelFlags;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-currentairdashcount","title":"variable CurrentAirDashCount","text":"<pre><code>uint32 FPlayerObjectLog::CurrentAirDashCount;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-currentairjumpcount","title":"variable CurrentAirJumpCount","text":"<pre><code>uint32 FPlayerObjectLog::CurrentAirJumpCount;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-exestatename","title":"variable ExeStateName","text":"<pre><code>FGameplayTag FPlayerObjectLog::ExeStateName;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-instantblocklockouttimer","title":"variable InstantBlockLockoutTimer","text":"<pre><code>uint32 FPlayerObjectLog::InstantBlockLockoutTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-laststatename","title":"variable LastStateName","text":"<pre><code>FGameplayTag FPlayerObjectLog::LastStateName;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-metercooldowntimer","title":"variable MeterCooldownTimer","text":"<pre><code>uint32 FPlayerObjectLog::MeterCooldownTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-throwrange","title":"variable ThrowRange","text":"<pre><code>int32 FPlayerObjectLog::ThrowRange;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-throwtechtimer","title":"variable ThrowTechTimer","text":"<pre><code>int32 FPlayerObjectLog::ThrowTechTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_player_object_log/#variable-bisautocombo","title":"variable bIsAutoCombo","text":"<pre><code>bool FPlayerObjectLog::bIsAutoCombo;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/PlayerObject.h</code></p>"},{"location":"NightSkyEngine/struct_f_random_manager/","title":"Struct FRandomManager","text":"<p>ClassList &gt; FRandomManager</p>"},{"location":"NightSkyEngine/struct_f_random_manager/#public-functions","title":"Public Functions","text":"Type Name FRandomManager ()  FRandomManager (uint32 InSeed)  int32 GenerateRandomNumber ()  uint32 GetSeed () const int Rand ()  int RandRange (int Min, int Max)  void Reseed (uint32 InSeed)"},{"location":"NightSkyEngine/struct_f_random_manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/struct_f_random_manager/#function-frandommanager-12","title":"function FRandomManager [1/2]","text":"<pre><code>inline FRandomManager::FRandomManager () \n</code></pre>"},{"location":"NightSkyEngine/struct_f_random_manager/#function-frandommanager-22","title":"function FRandomManager [2/2]","text":"<pre><code>inline FRandomManager::FRandomManager (\n    uint32 InSeed\n) \n</code></pre>"},{"location":"NightSkyEngine/struct_f_random_manager/#function-generaterandomnumber","title":"function GenerateRandomNumber","text":"<pre><code>int32 FRandomManager::GenerateRandomNumber () \n</code></pre>"},{"location":"NightSkyEngine/struct_f_random_manager/#function-getseed","title":"function GetSeed","text":"<pre><code>inline uint32 FRandomManager::GetSeed () const\n</code></pre>"},{"location":"NightSkyEngine/struct_f_random_manager/#function-rand","title":"function Rand","text":"<pre><code>inline int FRandomManager::Rand () \n</code></pre>"},{"location":"NightSkyEngine/struct_f_random_manager/#function-randrange","title":"function RandRange","text":"<pre><code>inline int FRandomManager::RandRange (\n    int Min,\n    int Max\n) \n</code></pre>"},{"location":"NightSkyEngine/struct_f_random_manager/#function-reseed","title":"function Reseed","text":"<pre><code>inline void FRandomManager::Reseed (\n    uint32 InSeed\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/RandomManager.h</code></p>"},{"location":"NightSkyEngine/struct_f_rollback_animation/","title":"Struct FRollbackAnimation","text":"<p>ClassList &gt; FRollbackAnimation</p>"},{"location":"NightSkyEngine/struct_f_rollback_animation/#public-attributes","title":"Public Attributes","text":"Type Name UWidgetAnimation * Anim float Time bool bPlaying"},{"location":"NightSkyEngine/struct_f_rollback_animation/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_rollback_animation/#variable-anim","title":"variable Anim","text":"<pre><code>UWidgetAnimation* FRollbackAnimation::Anim;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_rollback_animation/#variable-time","title":"variable Time","text":"<pre><code>float FRollbackAnimation::Time;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_rollback_animation/#variable-bplaying","title":"variable bPlaying","text":"<pre><code>bool FRollbackAnimation::bPlaying;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/UI/NightSkyBattleWidget.h</code></p>"},{"location":"NightSkyEngine/struct_f_rollback_data/","title":"Struct FRollbackData","text":"<p>ClassList &gt; FRollbackData</p>"},{"location":"NightSkyEngine/struct_f_rollback_data/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; uint8 &gt; BattleStateBuffer TArray&lt; uint8 &gt; BattleStateData TArray&lt; TArray&lt; uint8 &gt; &gt; CharBuffer TArray&lt; TArray&lt; uint8 &gt; &gt; ExtensionData TArray&lt; bool &gt; ObjActive TArray&lt; TArray&lt; uint8 &gt; &gt; ObjBuffer TArray&lt; TArray&lt; uint8 &gt; &gt; PlayerData TArray&lt; TArray&lt; uint8 &gt; &gt; StateData TArray&lt; TArray&lt; uint8 &gt; &gt; WidgetAnimationData"},{"location":"NightSkyEngine/struct_f_rollback_data/#public-functions","title":"Public Functions","text":"Type Name void Serialize (FArchive &amp; Ar)"},{"location":"NightSkyEngine/struct_f_rollback_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_rollback_data/#variable-battlestatebuffer","title":"variable BattleStateBuffer","text":"<pre><code>TArray&lt;uint8&gt; FRollbackData::BattleStateBuffer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_rollback_data/#variable-battlestatedata","title":"variable BattleStateData","text":"<pre><code>TArray&lt;uint8&gt; FRollbackData::BattleStateData;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_rollback_data/#variable-charbuffer","title":"variable CharBuffer","text":"<pre><code>TArray&lt;TArray&lt;uint8&gt; &gt; FRollbackData::CharBuffer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_rollback_data/#variable-extensiondata","title":"variable ExtensionData","text":"<pre><code>TArray&lt;TArray&lt;uint8&gt; &gt; FRollbackData::ExtensionData;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_rollback_data/#variable-objactive","title":"variable ObjActive","text":"<pre><code>TArray&lt;bool&gt; FRollbackData::ObjActive;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_rollback_data/#variable-objbuffer","title":"variable ObjBuffer","text":"<pre><code>TArray&lt;TArray&lt;uint8&gt; &gt; FRollbackData::ObjBuffer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_rollback_data/#variable-playerdata","title":"variable PlayerData","text":"<pre><code>TArray&lt;TArray&lt;uint8&gt; &gt; FRollbackData::PlayerData;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_rollback_data/#variable-statedata","title":"variable StateData","text":"<pre><code>TArray&lt;TArray&lt;uint8&gt; &gt; FRollbackData::StateData;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_rollback_data/#variable-widgetanimationdata","title":"variable WidgetAnimationData","text":"<pre><code>TArray&lt;TArray&lt;uint8&gt; &gt; FRollbackData::WidgetAnimationData;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_rollback_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/struct_f_rollback_data/#function-serialize","title":"function Serialize","text":"<pre><code>void FRollbackData::Serialize (\n    FArchive &amp; Ar\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyGameState.h</code></p>"},{"location":"NightSkyEngine/struct_f_screen_data/","title":"Struct FScreenData","text":"<p>ClassList &gt; FScreenData</p>"},{"location":"NightSkyEngine/struct_f_screen_data/#public-attributes","title":"Public Attributes","text":"Type Name int CenterXVelocity   = <code>0</code> int CenterYVelocity   = <code>0</code> int DefaultMaxWidth   = <code>1689</code> int DefaultWidth   = <code>1280</code> int FinalScreenWidth   = <code>1280</code> int FinalScreenX   = <code>0</code> int FinalScreenY   = <code>0</code> TEnumAsByte&lt; EScreenFlag &gt; Flags int HigherObjBottom   = <code>0</code> int MaxZoomOutWidth   = <code>1689</code> int ObjBottom   = <code>0</code> int ObjDistanceY   = <code>0</code> int ObjHeight   = <code>0</code> int ObjLeft   = <code>0</code> int ObjLength   = <code>0</code> int ObjRight   = <code>0</code> int ObjTop   = <code>0</code> int ScreenBoundsLeft   = <code>-640</code> int ScreenBoundsRight   = <code>640</code> int ScreenBoundsTop   = <code>0</code> int ScreenWorldCenterX   = <code>0</code> int ScreenWorldCenterY   = <code>0</code> int ScreenWorldWidth   = <code>1280</code> float ScreenYZoom   = <code>0</code> int StageBoundsLeft   = <code>-3200</code> int StageBoundsRight   = <code>3200</code> int StageBoundsTop   = <code>5400</code> int TargetCenterX   = <code>0</code> int TargetCenterY   = <code>0</code> TArray&lt; ABattleObject * &gt; TargetObjects   = <code>{}</code> int TargetOffsetAirYAdd   = <code>3</code> int TargetOffsetAirYDist   = <code>570</code> int TargetOffsetAirYMax   = <code>180</code> int TargetOffsetAirYPos   = <code>400</code> int TargetOffsetLandYAdd   = <code>6</code> int TargetOffsetLandYMax   = <code>250</code> int TargetOffsetY   = <code>350</code> int TargetWidth   = <code>1280</code> int WidthVelocity   = <code>0</code> int ZoomOutBeginH   = <code>360</code> int ZoomOutBeginX   = <code>1280</code> int ZoomOutBeginY   = <code>180</code> bool bTouchingWorldSide"},{"location":"NightSkyEngine/struct_f_screen_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_screen_data/#variable-centerxvelocity","title":"variable CenterXVelocity","text":"<pre><code>int FScreenData::CenterXVelocity;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-centeryvelocity","title":"variable CenterYVelocity","text":"<pre><code>int FScreenData::CenterYVelocity;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-defaultmaxwidth","title":"variable DefaultMaxWidth","text":"<pre><code>int FScreenData::DefaultMaxWidth;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-defaultwidth","title":"variable DefaultWidth","text":"<pre><code>int FScreenData::DefaultWidth;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-finalscreenwidth","title":"variable FinalScreenWidth","text":"<pre><code>int FScreenData::FinalScreenWidth;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-finalscreenx","title":"variable FinalScreenX","text":"<pre><code>int FScreenData::FinalScreenX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-finalscreeny","title":"variable FinalScreenY","text":"<pre><code>int FScreenData::FinalScreenY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-flags","title":"variable Flags","text":"<pre><code>TEnumAsByte&lt;EScreenFlag&gt; FScreenData::Flags;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-higherobjbottom","title":"variable HigherObjBottom","text":"<pre><code>int FScreenData::HigherObjBottom;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-maxzoomoutwidth","title":"variable MaxZoomOutWidth","text":"<pre><code>int FScreenData::MaxZoomOutWidth;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-objbottom","title":"variable ObjBottom","text":"<pre><code>int FScreenData::ObjBottom;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-objdistancey","title":"variable ObjDistanceY","text":"<pre><code>int FScreenData::ObjDistanceY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-objheight","title":"variable ObjHeight","text":"<pre><code>int FScreenData::ObjHeight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-objleft","title":"variable ObjLeft","text":"<pre><code>int FScreenData::ObjLeft;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-objlength","title":"variable ObjLength","text":"<pre><code>int FScreenData::ObjLength;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-objright","title":"variable ObjRight","text":"<pre><code>int FScreenData::ObjRight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-objtop","title":"variable ObjTop","text":"<pre><code>int FScreenData::ObjTop;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-screenboundsleft","title":"variable ScreenBoundsLeft","text":"<pre><code>int FScreenData::ScreenBoundsLeft;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-screenboundsright","title":"variable ScreenBoundsRight","text":"<pre><code>int FScreenData::ScreenBoundsRight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-screenboundstop","title":"variable ScreenBoundsTop","text":"<pre><code>int FScreenData::ScreenBoundsTop;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-screenworldcenterx","title":"variable ScreenWorldCenterX","text":"<pre><code>int FScreenData::ScreenWorldCenterX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-screenworldcentery","title":"variable ScreenWorldCenterY","text":"<pre><code>int FScreenData::ScreenWorldCenterY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-screenworldwidth","title":"variable ScreenWorldWidth","text":"<pre><code>int FScreenData::ScreenWorldWidth;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-screenyzoom","title":"variable ScreenYZoom","text":"<pre><code>float FScreenData::ScreenYZoom;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-stageboundsleft","title":"variable StageBoundsLeft","text":"<pre><code>int FScreenData::StageBoundsLeft;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-stageboundsright","title":"variable StageBoundsRight","text":"<pre><code>int FScreenData::StageBoundsRight;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-stageboundstop","title":"variable StageBoundsTop","text":"<pre><code>int FScreenData::StageBoundsTop;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-targetcenterx","title":"variable TargetCenterX","text":"<pre><code>int FScreenData::TargetCenterX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-targetcentery","title":"variable TargetCenterY","text":"<pre><code>int FScreenData::TargetCenterY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-targetobjects","title":"variable TargetObjects","text":"<pre><code>TArray&lt;ABattleObject*&gt; FScreenData::TargetObjects;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-targetoffsetairyadd","title":"variable TargetOffsetAirYAdd","text":"<pre><code>int FScreenData::TargetOffsetAirYAdd;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-targetoffsetairydist","title":"variable TargetOffsetAirYDist","text":"<pre><code>int FScreenData::TargetOffsetAirYDist;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-targetoffsetairymax","title":"variable TargetOffsetAirYMax","text":"<pre><code>int FScreenData::TargetOffsetAirYMax;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-targetoffsetairypos","title":"variable TargetOffsetAirYPos","text":"<pre><code>int FScreenData::TargetOffsetAirYPos;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-targetoffsetlandyadd","title":"variable TargetOffsetLandYAdd","text":"<pre><code>int FScreenData::TargetOffsetLandYAdd;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-targetoffsetlandymax","title":"variable TargetOffsetLandYMax","text":"<pre><code>int FScreenData::TargetOffsetLandYMax;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-targetoffsety","title":"variable TargetOffsetY","text":"<pre><code>int FScreenData::TargetOffsetY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-targetwidth","title":"variable TargetWidth","text":"<pre><code>int FScreenData::TargetWidth;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-widthvelocity","title":"variable WidthVelocity","text":"<pre><code>int FScreenData::WidthVelocity;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-zoomoutbeginh","title":"variable ZoomOutBeginH","text":"<pre><code>int FScreenData::ZoomOutBeginH;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-zoomoutbeginx","title":"variable ZoomOutBeginX","text":"<pre><code>int FScreenData::ZoomOutBeginX;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-zoomoutbeginy","title":"variable ZoomOutBeginY","text":"<pre><code>int FScreenData::ZoomOutBeginY;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_screen_data/#variable-btouchingworldside","title":"variable bTouchingWorldSide","text":"<pre><code>bool FScreenData::bTouchingWorldSide;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyGameState.h</code></p>"},{"location":"NightSkyEngine/struct_f_sequence_struct/","title":"Struct FSequenceStruct","text":"<p>ClassList &gt; FSequenceStruct</p>"},{"location":"NightSkyEngine/struct_f_sequence_struct/#public-attributes","title":"Public Attributes","text":"Type Name FGameplayTag Name ULevelSequence * Sequence"},{"location":"NightSkyEngine/struct_f_sequence_struct/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_sequence_struct/#variable-name","title":"variable Name","text":"<pre><code>FGameplayTag FSequenceStruct::Name;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_sequence_struct/#variable-sequence","title":"variable Sequence","text":"<pre><code>ULevelSequence* FSequenceStruct::Sequence;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SequenceData.h</code></p>"},{"location":"NightSkyEngine/struct_f_sound_struct/","title":"Struct FSoundStruct","text":"<p>ClassList &gt; FSoundStruct</p>"},{"location":"NightSkyEngine/struct_f_sound_struct/#public-attributes","title":"Public Attributes","text":"Type Name float MaxDuration   = <code>60</code> FGameplayTag Name USoundBase * SoundWave"},{"location":"NightSkyEngine/struct_f_sound_struct/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_sound_struct/#variable-maxduration","title":"variable MaxDuration","text":"<pre><code>float FSoundStruct::MaxDuration;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_sound_struct/#variable-name","title":"variable Name","text":"<pre><code>FGameplayTag FSoundStruct::Name;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_sound_struct/#variable-soundwave","title":"variable SoundWave","text":"<pre><code>USoundBase* FSoundStruct::SoundWave;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SoundData.h</code></p>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/","title":"Struct FStateCPUData","text":"<p>ClassList &gt; FStateCPUData</p> <p>More...</p> <ul> <li><code>#include &lt;State.h&gt;</code></li> </ul>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#public-attributes","title":"Public Attributes","text":"Type Name TEnumAsByte&lt; EAttackSpeed &gt; AttackSpeed int32 AttackXBeginRange   = <code>0</code> int32 AttackXEndRange   = <code>300000</code> int32 AttackYBeginRange   = <code>120000</code> int32 AttackYEndRange   = <code>360000</code> TEnumAsByte&lt; EBlockType &gt; BlockType TEnumAsByte&lt; ERangeType &gt; PunishRange bool bAntiAir bool bAttack bool bBigDamage bool bBlockstring bool bCombo bool bInvuln bool bNoCombo bool bProjectile bool bPunish bool bThrow bool bUsesResource"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#detailed-description","title":"Detailed Description","text":"<p>Data for the CPU to use when deciding which state to enter. </p>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-attackspeed","title":"variable AttackSpeed","text":"<pre><code>TEnumAsByte&lt;EAttackSpeed&gt; FStateCPUData::AttackSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-attackxbeginrange","title":"variable AttackXBeginRange","text":"<pre><code>int32 FStateCPUData::AttackXBeginRange;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-attackxendrange","title":"variable AttackXEndRange","text":"<pre><code>int32 FStateCPUData::AttackXEndRange;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-attackybeginrange","title":"variable AttackYBeginRange","text":"<pre><code>int32 FStateCPUData::AttackYBeginRange;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-attackyendrange","title":"variable AttackYEndRange","text":"<pre><code>int32 FStateCPUData::AttackYEndRange;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-blocktype","title":"variable BlockType","text":"<pre><code>TEnumAsByte&lt;EBlockType&gt; FStateCPUData::BlockType;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-punishrange","title":"variable PunishRange","text":"<pre><code>TEnumAsByte&lt;ERangeType&gt; FStateCPUData::PunishRange;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-bantiair","title":"variable bAntiAir","text":"<pre><code>bool FStateCPUData::bAntiAir;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-battack","title":"variable bAttack","text":"<pre><code>bool FStateCPUData::bAttack;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-bbigdamage","title":"variable bBigDamage","text":"<pre><code>bool FStateCPUData::bBigDamage;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-bblockstring","title":"variable bBlockstring","text":"<pre><code>bool FStateCPUData::bBlockstring;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-bcombo","title":"variable bCombo","text":"<pre><code>bool FStateCPUData::bCombo;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-binvuln","title":"variable bInvuln","text":"<pre><code>bool FStateCPUData::bInvuln;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-bnocombo","title":"variable bNoCombo","text":"<pre><code>bool FStateCPUData::bNoCombo;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-bprojectile","title":"variable bProjectile","text":"<pre><code>bool FStateCPUData::bProjectile;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-bpunish","title":"variable bPunish","text":"<pre><code>bool FStateCPUData::bPunish;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-bthrow","title":"variable bThrow","text":"<pre><code>bool FStateCPUData::bThrow;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_c_p_u_data/#variable-busesresource","title":"variable bUsesResource","text":"<pre><code>bool FStateCPUData::bUsesResource;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/State.h</code></p>"},{"location":"NightSkyEngine/struct_f_state_machine/","title":"Struct FStateMachine","text":"<p>ClassList &gt; FStateMachine</p> <p>The player object's state machine. More...</p> <ul> <li><code>#include &lt;StateMachine.h&gt;</code></li> </ul>"},{"location":"NightSkyEngine/struct_f_state_machine/#public-attributes","title":"Public Attributes","text":"Type Name UState * CurrentState int32 EnableFlags   = <code>0</code> TArray&lt; FGameplayTag &gt; EnabledCustomStateTypes APlayerObject * Parent FGameplayTag StateMachineName TArray&lt; FGameplayTag &gt; StateNames TArray&lt; UState * &gt; States bool bPrimary"},{"location":"NightSkyEngine/struct_f_state_machine/#public-functions","title":"Public Functions","text":"Type Name void AddState (const FGameplayTag &amp; Name, UState * Config)  bool ForceRollbackState (const FGameplayTag Name)  bool ForceSetState (const FGameplayTag Name, bool bIsAlias=false)  bool ForceSetState (TSubclassOf&lt; UState &gt; Class, bool bIsAlias=false)  int GetStateIndex (FGameplayTag Name) const FGameplayTag GetStateName (int Index)  FORCEINLINE bool IsCurrentState (const FGameplayTag &amp; Name) const bool SetState (const FGameplayTag Name, bool bIsAlias=false)  void Update () const"},{"location":"NightSkyEngine/struct_f_state_machine/#public-static-functions","title":"Public Static Functions","text":"Type Name bool CheckStateStanceCondition (const EEntryStance StateStance, const int PlayerStance)"},{"location":"NightSkyEngine/struct_f_state_machine/#detailed-description","title":"Detailed Description","text":"<p>Contains all player states and state names, as well as the currently active state. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_state_machine/#variable-currentstate","title":"variable CurrentState","text":"<pre><code>UState* FStateMachine::CurrentState;\n</code></pre> <p>The currently active state. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#variable-enableflags","title":"variable EnableFlags","text":"<pre><code>int32 FStateMachine::EnableFlags;\n</code></pre> <p>Flags of currently enabled states. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#variable-enabledcustomstatetypes","title":"variable EnabledCustomStateTypes","text":"<pre><code>TArray&lt;FGameplayTag&gt; FStateMachine::EnabledCustomStateTypes;\n</code></pre> <p>Currently enabled custom state types. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#variable-parent","title":"variable Parent","text":"<pre><code>APlayerObject* FStateMachine::Parent;\n</code></pre> <p>The parent of this state machine. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#variable-statemachinename","title":"variable StateMachineName","text":"<pre><code>FGameplayTag FStateMachine::StateMachineName;\n</code></pre> <p>The currently active state. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#variable-statenames","title":"variable StateNames","text":"<pre><code>TArray&lt;FGameplayTag&gt; FStateMachine::StateNames;\n</code></pre> <p>An array of all player state names. Used to lookup states. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#variable-states","title":"variable States","text":"<pre><code>TArray&lt;UState*&gt; FStateMachine::States;\n</code></pre> <p>An array of all player states. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#variable-bprimary","title":"variable bPrimary","text":"<pre><code>bool FStateMachine::bPrimary;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_state_machine/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/struct_f_state_machine/#function-addstate","title":"function AddState","text":"<pre><code>void FStateMachine::AddState (\n    const FGameplayTag &amp; Name,\n    UState * Config\n) \n</code></pre> <p>Adds a state to the state machine. If no current state is set, the input state will be used as the current state. Only call at the beginning of a match! </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#function-forcerollbackstate","title":"function ForceRollbackState","text":"<pre><code>bool FStateMachine::ForceRollbackState (\n    const FGameplayTag Name\n) \n</code></pre> <p>Sets the current state for rollback. Code called when entering a state normally will not be called.</p> <p>Parameters:</p> <ul> <li><code>Name</code> The state to set as current. </li> </ul> <p>Returns:</p> <p>If the state was successfully set, return true. Otherwise return false. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#function-forcesetstate-12","title":"function ForceSetState [1/2]","text":"<pre><code>bool FStateMachine::ForceSetState (\n    const FGameplayTag Name,\n    bool bIsAlias=false\n) \n</code></pre> <p>Sets the current state. If the state to set is the same as the current state, the state will be reset.</p> <p>Parameters:</p> <ul> <li><code>Name</code> The state to set as current. </li> <li><code>bIsAlias</code> If the state is being set via an alias. </li> </ul> <p>Returns:</p> <p>If the state was successfully set, return true. Otherwise return false. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#function-forcesetstate-22","title":"function ForceSetState [2/2]","text":"<pre><code>bool FStateMachine::ForceSetState (\n    TSubclassOf&lt; UState &gt; Class,\n    bool bIsAlias=false\n) \n</code></pre> <p>Sets the current state. If the state to set is the same as the current state, the state will be reset.</p> <p>Parameters:</p> <ul> <li><code>Class</code> The state to set as current. </li> <li><code>bIsAlias</code> If the state is being set via an alias. </li> </ul> <p>Returns:</p> <p>If the state was successfully set, return true. Otherwise return false. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#function-getstateindex","title":"function GetStateIndex","text":"<pre><code>int FStateMachine::GetStateIndex (\n    FGameplayTag Name\n) const\n</code></pre> <p>Gets the current state index. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#function-getstatename","title":"function GetStateName","text":"<pre><code>FGameplayTag FStateMachine::GetStateName (\n    int Index\n) \n</code></pre> <p>Gets the current state name. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#function-iscurrentstate","title":"function IsCurrentState","text":"<pre><code>inline FORCEINLINE bool FStateMachine::IsCurrentState (\n    const FGameplayTag &amp; Name\n) const\n</code></pre> <p>Checks a name against the current state name. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#function-setstate","title":"function SetState","text":"<pre><code>bool FStateMachine::SetState (\n    const FGameplayTag Name,\n    bool bIsAlias=false\n) \n</code></pre> <p>Sets the current state. If attempting to set the state to the same as the current state, nothing will happen.</p> <p>Parameters:</p> <ul> <li><code>Name</code> The state to set as current. </li> <li><code>bIsAlias</code> If the state is being set via an alias. </li> </ul> <p>Returns:</p> <p>If the state was successfully set, return true. Otherwise return false. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#function-update","title":"function Update","text":"<pre><code>void FStateMachine::Update () const\n</code></pre> <p>Calls the current state's exec function. </p>"},{"location":"NightSkyEngine/struct_f_state_machine/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"NightSkyEngine/struct_f_state_machine/#function-checkstatestancecondition","title":"function CheckStateStanceCondition","text":"<pre><code>static bool FStateMachine::CheckStateStanceCondition (\n    const EEntryStance StateStance,\n    const int PlayerStance\n) \n</code></pre> <p>Checks if the state allows the player's current stance.</p> <p>Parameters:</p> <ul> <li><code>StateStance</code> The state's required stance. </li> <li><code>PlayerStance</code> The current player's stance. </li> </ul> <p>Returns:</p> <p>If the state stance allows the player's stance, return true. Otherwise return false. </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/StateMachine.h</code></p>"},{"location":"NightSkyEngine/struct_f_super_armor_data/","title":"Struct FSuperArmorData","text":"<p>ClassList &gt; FSuperArmorData</p>"},{"location":"NightSkyEngine/struct_f_super_armor_data/#public-attributes","title":"Public Attributes","text":"Type Name int32 ArmorDamagePercent int32 ArmorHits TEnumAsByte&lt; ESuperArmorType &gt; Type uint8 bArmorHead uint8 bArmorLow uint8 bArmorMid uint8 bArmorOverhead uint8 bArmorProjectile uint8 bArmorStrike uint8 bArmorTakeChipDamage uint8 bArmorThrow"},{"location":"NightSkyEngine/struct_f_super_armor_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_super_armor_data/#variable-armordamagepercent","title":"variable ArmorDamagePercent","text":"<pre><code>int32 FSuperArmorData::ArmorDamagePercent;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_super_armor_data/#variable-armorhits","title":"variable ArmorHits","text":"<pre><code>int32 FSuperArmorData::ArmorHits;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_super_armor_data/#variable-type","title":"variable Type","text":"<pre><code>TEnumAsByte&lt;ESuperArmorType&gt; FSuperArmorData::Type;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_super_armor_data/#variable-barmorhead","title":"variable bArmorHead","text":"<pre><code>uint8 FSuperArmorData::bArmorHead;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_super_armor_data/#variable-barmorlow","title":"variable bArmorLow","text":"<pre><code>uint8 FSuperArmorData::bArmorLow;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_super_armor_data/#variable-barmormid","title":"variable bArmorMid","text":"<pre><code>uint8 FSuperArmorData::bArmorMid;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_super_armor_data/#variable-barmoroverhead","title":"variable bArmorOverhead","text":"<pre><code>uint8 FSuperArmorData::bArmorOverhead;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_super_armor_data/#variable-barmorprojectile","title":"variable bArmorProjectile","text":"<pre><code>uint8 FSuperArmorData::bArmorProjectile;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_super_armor_data/#variable-barmorstrike","title":"variable bArmorStrike","text":"<pre><code>uint8 FSuperArmorData::bArmorStrike;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_super_armor_data/#variable-barmortakechipdamage","title":"variable bArmorTakeChipDamage","text":"<pre><code>uint8 FSuperArmorData::bArmorTakeChipDamage;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_super_armor_data/#variable-barmorthrow","title":"variable bArmorThrow","text":"<pre><code>uint8 FSuperArmorData::bArmorThrow;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.h</code></p>"},{"location":"NightSkyEngine/struct_f_team_data/","title":"Struct FTeamData","text":"<p>ClassList &gt; FTeamData</p>"},{"location":"NightSkyEngine/struct_f_team_data/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; int32 &gt; CooldownTimer int TeamCount   = <code>0</code>"},{"location":"NightSkyEngine/struct_f_team_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_team_data/#variable-cooldowntimer","title":"variable CooldownTimer","text":"<pre><code>TArray&lt;int32&gt; FTeamData::CooldownTimer;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_team_data/#variable-teamcount","title":"variable TeamCount","text":"<pre><code>int FTeamData::TeamCount;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyGameState.h</code></p>"},{"location":"NightSkyEngine/struct_f_wall_bounce_data/","title":"Struct FWallBounceData","text":"<p>ClassList &gt; FWallBounceData</p>"},{"location":"NightSkyEngine/struct_f_wall_bounce_data/#public-attributes","title":"Public Attributes","text":"Type Name int32 WallBounceCount   = <code>-1</code> int32 WallBounceGravity   = <code>INT\\_MAX</code> bool WallBounceInCornerOnly   = <code>false</code> int32 WallBounceStop   = <code>INT\\_MAX</code> int32 WallBounceUntech   = <code>INT\\_MAX</code> int32 WallBounceXRate   = <code>INT\\_MAX</code> int32 WallBounceXSpeed   = <code>INT\\_MAX</code> int32 WallBounceYRate   = <code>INT\\_MAX</code> int32 WallBounceYSpeed   = <code>INT\\_MAX</code>"},{"location":"NightSkyEngine/struct_f_wall_bounce_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/struct_f_wall_bounce_data/#variable-wallbouncecount","title":"variable WallBounceCount","text":"<pre><code>int32 FWallBounceData::WallBounceCount;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_wall_bounce_data/#variable-wallbouncegravity","title":"variable WallBounceGravity","text":"<pre><code>int32 FWallBounceData::WallBounceGravity;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_wall_bounce_data/#variable-wallbounceincorneronly","title":"variable WallBounceInCornerOnly","text":"<pre><code>bool FWallBounceData::WallBounceInCornerOnly;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_wall_bounce_data/#variable-wallbouncestop","title":"variable WallBounceStop","text":"<pre><code>int32 FWallBounceData::WallBounceStop;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_wall_bounce_data/#variable-wallbounceuntech","title":"variable WallBounceUntech","text":"<pre><code>int32 FWallBounceData::WallBounceUntech;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_wall_bounce_data/#variable-wallbouncexrate","title":"variable WallBounceXRate","text":"<pre><code>int32 FWallBounceData::WallBounceXRate;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_wall_bounce_data/#variable-wallbouncexspeed","title":"variable WallBounceXSpeed","text":"<pre><code>int32 FWallBounceData::WallBounceXSpeed;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_wall_bounce_data/#variable-wallbounceyrate","title":"variable WallBounceYRate","text":"<pre><code>int32 FWallBounceData::WallBounceYRate;\n</code></pre>"},{"location":"NightSkyEngine/struct_f_wall_bounce_data/#variable-wallbounceyspeed","title":"variable WallBounceYSpeed","text":"<pre><code>int32 FWallBounceData::WallBounceYSpeed;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.h</code></p>"},{"location":"NightSkyEngine/class_rpc_connection_manager/","title":"Class RpcConnectionManager","text":"<p>ClassList &gt; RpcConnectionManager</p> <p>Inherits the following classes: ConnectionManager</p>"},{"location":"NightSkyEngine/class_rpc_connection_manager/#public-attributes","title":"Public Attributes","text":"Type Name int playerIndex TDoubleLinkedList&lt; TArray&lt; int8 &gt; &gt; receiveSchedule TDoubleLinkedList&lt; TArray&lt; int8 &gt; &gt; sendSchedule"},{"location":"NightSkyEngine/class_rpc_connection_manager/#public-functions","title":"Public Functions","text":"Type Name virtual int RecvFrom (char * buffer, int len, int flags, int * connection_id)  RpcConnectionManager ()  virtual int SendTo (const char * buffer, int len, int flags, int connection_id)  virtual ~RpcConnectionManager () override"},{"location":"NightSkyEngine/class_rpc_connection_manager/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_rpc_connection_manager/#variable-playerindex","title":"variable playerIndex","text":"<pre><code>int RpcConnectionManager::playerIndex;\n</code></pre>"},{"location":"NightSkyEngine/class_rpc_connection_manager/#variable-receiveschedule","title":"variable receiveSchedule","text":"<pre><code>TDoubleLinkedList&lt;TArray&lt;int8&gt; &gt; RpcConnectionManager::receiveSchedule;\n</code></pre>"},{"location":"NightSkyEngine/class_rpc_connection_manager/#variable-sendschedule","title":"variable sendSchedule","text":"<pre><code>TDoubleLinkedList&lt;TArray&lt;int8&gt; &gt; RpcConnectionManager::sendSchedule;\n</code></pre>"},{"location":"NightSkyEngine/class_rpc_connection_manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_rpc_connection_manager/#function-recvfrom","title":"function RecvFrom","text":"<pre><code>virtual int RpcConnectionManager::RecvFrom (\n    char * buffer,\n    int len,\n    int flags,\n    int * connection_id\n) \n</code></pre>"},{"location":"NightSkyEngine/class_rpc_connection_manager/#function-rpcconnectionmanager","title":"function RpcConnectionManager","text":"<pre><code>RpcConnectionManager::RpcConnectionManager () \n</code></pre>"},{"location":"NightSkyEngine/class_rpc_connection_manager/#function-sendto","title":"function SendTo","text":"<pre><code>virtual int RpcConnectionManager::SendTo (\n    const char * buffer,\n    int len,\n    int flags,\n    int connection_id\n) \n</code></pre>"},{"location":"NightSkyEngine/class_rpc_connection_manager/#function-rpcconnectionmanager_1","title":"function ~RpcConnectionManager","text":"<pre><code>virtual RpcConnectionManager::~RpcConnectionManager () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Network/RpcConnectionManager.h</code></p>"},{"location":"NightSkyEngine/class_u_battle_extension/","title":"Class UBattleExtension","text":"<p>ClassList &gt; UBattleExtension</p> <p>A customizable extension to the battle ruleset. More...</p> <ul> <li><code>#include &lt;BattleExtension.h&gt;</code></li> </ul> <p>Inherits the following classes: USerializableObj</p>"},{"location":"NightSkyEngine/class_u_battle_extension/#public-attributes","title":"Public Attributes","text":"Type Name FGameplayTag Name ANightSkyGameState * Parent"},{"location":"NightSkyEngine/class_u_battle_extension/#public-functions","title":"Public Functions","text":"Type Name void Exec ()"},{"location":"NightSkyEngine/class_u_battle_extension/#public-functions-inherited-from-userializableobj","title":"Public Functions inherited from USerializableObj","text":"<p>See USerializableObj</p> Type Name void LoadForRollback (const TArray&lt; uint8 &gt; &amp; InBytes)  void ResetToCDO ()  TArray&lt; uint8 &gt; SaveForRollback ()"},{"location":"NightSkyEngine/class_u_battle_extension/#detailed-description","title":"Detailed Description","text":"<p>Allows modifying some general battle behavior. </p>"},{"location":"NightSkyEngine/class_u_battle_extension/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_battle_extension/#variable-name","title":"variable Name","text":"<pre><code>FGameplayTag UBattleExtension::Name;\n</code></pre> <p>The name of the subroutine. Used to call the subroutine. </p>"},{"location":"NightSkyEngine/class_u_battle_extension/#variable-parent","title":"variable Parent","text":"<pre><code>ANightSkyGameState* UBattleExtension::Parent;\n</code></pre> <p>The owning game state. </p>"},{"location":"NightSkyEngine/class_u_battle_extension/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_battle_extension/#function-exec","title":"function Exec","text":"<pre><code>void UBattleExtension::Exec () \n</code></pre> <p>The primary function of the subroutine. </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/BattleExtension.h</code></p>"},{"location":"NightSkyEngine/class_u_battle_extension_data/","title":"Class UBattleExtensionData","text":"<p>ClassList &gt; UBattleExtensionData</p> <p>Inherits the following classes: UDataAsset</p>"},{"location":"NightSkyEngine/class_u_battle_extension_data/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; TSubclassOf&lt; UBattleExtension &gt; &gt; ExtensionArray"},{"location":"NightSkyEngine/class_u_battle_extension_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_battle_extension_data/#variable-extensionarray","title":"variable ExtensionArray","text":"<pre><code>TArray&lt;TSubclassOf&lt;UBattleExtension&gt; &gt; UBattleExtensionData::ExtensionArray;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/BattleExtensionData.h</code></p>"},{"location":"NightSkyEngine/class_u_camera_shake_data/","title":"Class UCameraShakeData","text":"<p>ClassList &gt; UCameraShakeData</p> <p>Inherits the following classes: UDataAsset</p>"},{"location":"NightSkyEngine/class_u_camera_shake_data/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; FCameraShakeStruct &gt; CameraShakeStructs"},{"location":"NightSkyEngine/class_u_camera_shake_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_camera_shake_data/#variable-camerashakestructs","title":"variable CameraShakeStructs","text":"<pre><code>TArray&lt;FCameraShakeStruct&gt; UCameraShakeData::CameraShakeStructs;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/CameraShakeData.h</code></p>"},{"location":"NightSkyEngine/class_u_collision_data/","title":"Class UCollisionData","text":"<p>ClassList &gt; UCollisionData</p> <p>Inherits the following classes: UDataAsset</p>"},{"location":"NightSkyEngine/class_u_collision_data/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; FCollisionStruct &gt; CollisionFrames"},{"location":"NightSkyEngine/class_u_collision_data/#public-functions","title":"Public Functions","text":"Type Name FCollisionStruct GetByCelName (const FGameplayTag &amp; CelName)  int32 GetIndexByCelName (const FGameplayTag &amp; CelName) const"},{"location":"NightSkyEngine/class_u_collision_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_collision_data/#variable-collisionframes","title":"variable CollisionFrames","text":"<pre><code>TArray&lt;FCollisionStruct&gt; UCollisionData::CollisionFrames;\n</code></pre>"},{"location":"NightSkyEngine/class_u_collision_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_collision_data/#function-getbycelname","title":"function GetByCelName","text":"<pre><code>inline FCollisionStruct UCollisionData::GetByCelName (\n    const FGameplayTag &amp; CelName\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_collision_data/#function-getindexbycelname","title":"function GetIndexByCelName","text":"<pre><code>inline int32 UCollisionData::GetIndexByCelName (\n    const FGameplayTag &amp; CelName\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/CollisionData.h</code></p>"},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/","title":"Class UExtendedCommonActivatableWidget","text":"<p>ClassList &gt; UExtendedCommonActivatableWidget</p> <p>More...</p> <ul> <li><code>#include &lt;ExtendedCommonActivatableWidget.h&gt;</code></li> </ul> <p>Inherits the following classes: UCommonActivatableWidget</p>"},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#public-functions","title":"Public Functions","text":"Type Name virtual TOptional&lt; FUIInputConfig &gt; GetDesiredInputConfig () override const UExtendedCommonActivatableWidget (const FObjectInitializer &amp; ObjectInitializer=FObjectInitializer::Get())"},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#protected-attributes","title":"Protected Attributes","text":"Type Name ENightSkyWidgetInputMode DefaultInputConfig   = <code>ENightSkyWidgetInputMode::Default</code> EMouseCaptureMode GameMouseCaptureMode   = <code>EMouseCaptureMode::CapturePermanently</code>"},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#protected-functions","title":"Protected Functions","text":"Type Name virtual void NativeDestruct () override void RegisterBinding (FDataTableRowHandle InputAction, const FInputActionExecutedDelegate &amp; Callback, FInputActionBindingHandle &amp; BindingHandle)  void UnregisterAllBindings ()  void UnregisterBinding (FInputActionBindingHandle BindingHandle)"},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#detailed-description","title":"Detailed Description","text":"<p>Extends UCommonActivatableWidget with Blueprint-visible functions for registering additional input action bindings. </p>"},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#function-getdesiredinputconfig","title":"function GetDesiredInputConfig","text":"<pre><code>virtual TOptional&lt; FUIInputConfig &gt; UExtendedCommonActivatableWidget::GetDesiredInputConfig () override const\n</code></pre>"},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#function-uextendedcommonactivatablewidget","title":"function UExtendedCommonActivatableWidget","text":"<pre><code>UExtendedCommonActivatableWidget::UExtendedCommonActivatableWidget (\n    const FObjectInitializer &amp; ObjectInitializer=FObjectInitializer::Get()\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#variable-defaultinputconfig","title":"variable DefaultInputConfig","text":"<pre><code>ENightSkyWidgetInputMode UExtendedCommonActivatableWidget::DefaultInputConfig;\n</code></pre> <p>The desired input mode to use while this UI is activated, for example do you want key presses to still reach the game/player controller? </p>"},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#variable-gamemousecapturemode","title":"variable GameMouseCaptureMode","text":"<pre><code>EMouseCaptureMode UExtendedCommonActivatableWidget::GameMouseCaptureMode;\n</code></pre> <p>The desired mouse behavior when the game gets input. </p>"},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#function-nativedestruct","title":"function NativeDestruct","text":"<pre><code>virtual void UExtendedCommonActivatableWidget::NativeDestruct () override\n</code></pre>"},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#function-registerbinding","title":"function RegisterBinding","text":"<pre><code>void UExtendedCommonActivatableWidget::RegisterBinding (\n    FDataTableRowHandle InputAction,\n    const FInputActionExecutedDelegate &amp; Callback,\n    FInputActionBindingHandle &amp; BindingHandle\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#function-unregisterallbindings","title":"function UnregisterAllBindings","text":"<pre><code>void UExtendedCommonActivatableWidget::UnregisterAllBindings () \n</code></pre>"},{"location":"NightSkyEngine/class_u_extended_common_activatable_widget/#function-unregisterbinding","title":"function UnregisterBinding","text":"<pre><code>void UExtendedCommonActivatableWidget::UnregisterBinding (\n    FInputActionBindingHandle BindingHandle\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/UI/ExtendedCommonActivatableWidget.h</code></p>"},{"location":"NightSkyEngine/class_u_flipbook_data/","title":"Class UFlipbookData","text":"<p>ClassList &gt; UFlipbookData</p> <p>Inherits the following classes: UDataAsset</p>"},{"location":"NightSkyEngine/class_u_flipbook_data/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; FFlipbookStruct &gt; FlipbookStructs"},{"location":"NightSkyEngine/class_u_flipbook_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_flipbook_data/#variable-flipbookstructs","title":"variable FlipbookStructs","text":"<pre><code>TArray&lt;FFlipbookStruct&gt; UFlipbookData::FlipbookStructs;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/FlipbookData.h</code></p>"},{"location":"NightSkyEngine/class_u_link_actor_data/","title":"Class ULinkActorData","text":"<p>ClassList &gt; ULinkActorData</p> <p>Inherits the following classes: UDataAsset</p>"},{"location":"NightSkyEngine/class_u_link_actor_data/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; FLinkActorStruct &gt; LinkedActorStructs"},{"location":"NightSkyEngine/class_u_link_actor_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_link_actor_data/#variable-linkedactorstructs","title":"variable LinkedActorStructs","text":"<pre><code>TArray&lt;FLinkActorStruct&gt; ULinkActorData::LinkedActorStructs;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/LinkActorData.h</code></p>"},{"location":"NightSkyEngine/class_u_material_data/","title":"Class UMaterialData","text":"<p>ClassList &gt; UMaterialData</p> <p>Inherits the following classes: UDataAsset</p>"},{"location":"NightSkyEngine/class_u_material_data/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; FMaterialStruct &gt; MaterialStructs"},{"location":"NightSkyEngine/class_u_material_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_material_data/#variable-materialstructs","title":"variable MaterialStructs","text":"<pre><code>TArray&lt;FMaterialStruct&gt; UMaterialData::MaterialStructs;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/MaterialData.h</code></p>"},{"location":"NightSkyEngine/class_u_n_s_e_enhanced_input_user_settings/","title":"Class UNSEEnhancedInputUserSettings","text":"<p>ClassList &gt; UNSEEnhancedInputUserSettings</p> <p>Inherits the following classes: UEnhancedInputUserSettings</p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEEnhancedInputUserSettings.h</code></p>"},{"location":"NightSkyEngine/class_u_n_s_e_player_mappable_key_profile/","title":"Class UNSEPlayerMappableKeyProfile","text":"<p>ClassList &gt; UNSEPlayerMappableKeyProfile</p> <p>Inherits the following classes: UEnhancedPlayerMappableKeyProfile</p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEPlayerMappableKeyProfile.h</code></p>"},{"location":"NightSkyEngine/class_u_n_s_e_player_mappable_key_settings/","title":"Class UNSEPlayerMappableKeySettings","text":"<p>ClassList &gt; UNSEPlayerMappableKeySettings</p> <p>Inherits the following classes: UPlayerMappableKeySettings</p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEPlayerMappableKeySettings.h</code></p>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/","title":"Class UNSESessionSubsystem","text":"<p>ClassList &gt; UNSESessionSubsystem</p> <p>Inherits the following classes: UGameInstanceSubsystem</p>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#public-attributes","title":"Public Attributes","text":"Type Name FDelegateHandle LoginDelegateHandle FNSEOnCreateSessionComplete OnCreateSessionCompleteDelegate FNSEOnDestroySessionComplete OnDestroySessionCompleteEvent FNSEOnFindSessionsComplete OnFindSessionsCompleteEvent FNSEOnJoinSessionComplete OnJoinGameSessionCompleteEvent FNSEOnStartSessionComplete OnStartSessionCompleteEvent FNSEOnUpdateSessionComplete OnUpdateSessionCompleteEvent"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#public-functions","title":"Public Functions","text":"Type Name void CreateSession (int32 NumPublicConnections, bool bIsLANMatch)  void DestroySession ()  void FindSessions (int32 MaxSearchResults, bool IsLANQuery)  bool IsLoggedIn () const void JoinGameSession (const FOnlineSessionSearchResult &amp; SessionResult)  void JoinGameSession_BP (FNSESessionInfo Info)  void Login ()  void StartSession ()  UNSESessionSubsystem ()  void UpdateSession ()"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#protected-functions","title":"Protected Functions","text":"Type Name void OnCreateSessionComplete (FName SessionName, bool bSuccess)  void OnDestroySessionComplete (FName SessionName, bool bSuccess)  void OnFindSessionsComplete (bool bSuccess)  void OnJoinSessionComplete (FName SessionName, EOnJoinSessionCompleteResult::Type Result)  void OnLoginCompleted (int32 LocalUserNum, bool bWasSuccessful, const FUniqueNetId &amp; UserId, const FString &amp; Error)  void OnSessionInviteAccepted (const bool bSuccess, const int32 ControllerId, FUniqueNetIdPtr UserId, const FOnlineSessionSearchResult &amp; InviteResult)  void OnStartSessionComplete (FName SessionName, bool bSuccess)  void OnUpdateSessionComplete (FName SessionName, bool bSuccess)  bool TryTravelToCurrentSession ()"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#variable-logindelegatehandle","title":"variable LoginDelegateHandle","text":"<pre><code>FDelegateHandle UNSESessionSubsystem::LoginDelegateHandle;\n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#variable-oncreatesessioncompletedelegate","title":"variable OnCreateSessionCompleteDelegate","text":"<pre><code>FNSEOnCreateSessionComplete UNSESessionSubsystem::OnCreateSessionCompleteDelegate;\n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#variable-ondestroysessioncompleteevent","title":"variable OnDestroySessionCompleteEvent","text":"<pre><code>FNSEOnDestroySessionComplete UNSESessionSubsystem::OnDestroySessionCompleteEvent;\n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#variable-onfindsessionscompleteevent","title":"variable OnFindSessionsCompleteEvent","text":"<pre><code>FNSEOnFindSessionsComplete UNSESessionSubsystem::OnFindSessionsCompleteEvent;\n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#variable-onjoingamesessioncompleteevent","title":"variable OnJoinGameSessionCompleteEvent","text":"<pre><code>FNSEOnJoinSessionComplete UNSESessionSubsystem::OnJoinGameSessionCompleteEvent;\n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#variable-onstartsessioncompleteevent","title":"variable OnStartSessionCompleteEvent","text":"<pre><code>FNSEOnStartSessionComplete UNSESessionSubsystem::OnStartSessionCompleteEvent;\n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#variable-onupdatesessioncompleteevent","title":"variable OnUpdateSessionCompleteEvent","text":"<pre><code>FNSEOnUpdateSessionComplete UNSESessionSubsystem::OnUpdateSessionCompleteEvent;\n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-createsession","title":"function CreateSession","text":"<pre><code>void UNSESessionSubsystem::CreateSession (\n    int32 NumPublicConnections,\n    bool bIsLANMatch\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-destroysession","title":"function DestroySession","text":"<pre><code>void UNSESessionSubsystem::DestroySession () \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-findsessions","title":"function FindSessions","text":"<pre><code>void UNSESessionSubsystem::FindSessions (\n    int32 MaxSearchResults,\n    bool IsLANQuery\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-isloggedin","title":"function IsLoggedIn","text":"<pre><code>bool UNSESessionSubsystem::IsLoggedIn () const\n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-joingamesession","title":"function JoinGameSession","text":"<pre><code>void UNSESessionSubsystem::JoinGameSession (\n    const FOnlineSessionSearchResult &amp; SessionResult\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-joingamesession_bp","title":"function JoinGameSession_BP","text":"<pre><code>void UNSESessionSubsystem::JoinGameSession_BP (\n    FNSESessionInfo Info\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-login","title":"function Login","text":"<pre><code>void UNSESessionSubsystem::Login () \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-startsession","title":"function StartSession","text":"<pre><code>void UNSESessionSubsystem::StartSession () \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-unsesessionsubsystem","title":"function UNSESessionSubsystem","text":"<pre><code>UNSESessionSubsystem::UNSESessionSubsystem () \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-updatesession","title":"function UpdateSession","text":"<pre><code>void UNSESessionSubsystem::UpdateSession () \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-oncreatesessioncomplete","title":"function OnCreateSessionComplete","text":"<pre><code>void UNSESessionSubsystem::OnCreateSessionComplete (\n    FName SessionName,\n    bool bSuccess\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-ondestroysessioncomplete","title":"function OnDestroySessionComplete","text":"<pre><code>void UNSESessionSubsystem::OnDestroySessionComplete (\n    FName SessionName,\n    bool bSuccess\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-onfindsessionscomplete","title":"function OnFindSessionsComplete","text":"<pre><code>void UNSESessionSubsystem::OnFindSessionsComplete (\n    bool bSuccess\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-onjoinsessioncomplete","title":"function OnJoinSessionComplete","text":"<pre><code>void UNSESessionSubsystem::OnJoinSessionComplete (\n    FName SessionName,\n    EOnJoinSessionCompleteResult::Type Result\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-onlogincompleted","title":"function OnLoginCompleted","text":"<pre><code>void UNSESessionSubsystem::OnLoginCompleted (\n    int32 LocalUserNum,\n    bool bWasSuccessful,\n    const FUniqueNetId &amp; UserId,\n    const FString &amp; Error\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-onsessioninviteaccepted","title":"function OnSessionInviteAccepted","text":"<pre><code>void UNSESessionSubsystem::OnSessionInviteAccepted (\n    const bool bSuccess,\n    const int32 ControllerId,\n    FUniqueNetIdPtr UserId,\n    const FOnlineSessionSearchResult &amp; InviteResult\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-onstartsessioncomplete","title":"function OnStartSessionComplete","text":"<pre><code>void UNSESessionSubsystem::OnStartSessionComplete (\n    FName SessionName,\n    bool bSuccess\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-onupdatesessioncomplete","title":"function OnUpdateSessionComplete","text":"<pre><code>void UNSESessionSubsystem::OnUpdateSessionComplete (\n    FName SessionName,\n    bool bSuccess\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_n_s_e_session_subsystem/#function-trytraveltocurrentsession","title":"function TryTravelToCurrentSession","text":"<pre><code>bool UNSESessionSubsystem::TryTravelToCurrentSession () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Network/NSESessionSubsystem.h</code></p>"},{"location":"NightSkyEngine/class_u_night_sky_anim_instance/","title":"Class UNightSkyAnimInstance","text":"<p>ClassList &gt; UNightSkyAnimInstance</p> <p>Inherits the following classes: UAnimInstance</p>"},{"location":"NightSkyEngine/class_u_night_sky_anim_instance/#public-attributes","title":"Public Attributes","text":"Type Name float CurrentAnimTime UAnimMontage * RootMontage"},{"location":"NightSkyEngine/class_u_night_sky_anim_instance/#public-functions","title":"Public Functions","text":"Type Name void CreateRootMontage (UAnimSequenceBase * Asset, const FAlphaBlendArgs &amp; BlendIn, const FAlphaBlendArgs &amp; BlendOut)"},{"location":"NightSkyEngine/class_u_night_sky_anim_instance/#protected-functions","title":"Protected Functions","text":"Type Name virtual void Montage_Advance (float DeltaSeconds) override"},{"location":"NightSkyEngine/class_u_night_sky_anim_instance/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_anim_instance/#variable-currentanimtime","title":"variable CurrentAnimTime","text":"<pre><code>float UNightSkyAnimInstance::CurrentAnimTime;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_anim_instance/#variable-rootmontage","title":"variable RootMontage","text":"<pre><code>UAnimMontage* UNightSkyAnimInstance::RootMontage;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_anim_instance/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_anim_instance/#function-createrootmontage","title":"function CreateRootMontage","text":"<pre><code>void UNightSkyAnimInstance::CreateRootMontage (\n    UAnimSequenceBase * Asset,\n    const FAlphaBlendArgs &amp; BlendIn,\n    const FAlphaBlendArgs &amp; BlendOut\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_anim_instance/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_anim_instance/#function-montage_advance","title":"function Montage_Advance","text":"<pre><code>virtual void UNightSkyAnimInstance::Montage_Advance (\n    float DeltaSeconds\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimInstance.h</code></p>"},{"location":"NightSkyEngine/class_u_night_sky_anim_meta_data/","title":"Class UNightSkyAnimMetaData","text":"<p>ClassList &gt; UNightSkyAnimMetaData</p> <p>Inherits the following classes: UAnimMetaData</p>"},{"location":"NightSkyEngine/class_u_night_sky_anim_meta_data/#public-attributes","title":"Public Attributes","text":"Type Name TSet&lt; FName &gt; CachedBoneNames TObjectPtr&lt; UNightSkyAnimSequenceUserData &gt; UserData"},{"location":"NightSkyEngine/class_u_night_sky_anim_meta_data/#public-functions","title":"Public Functions","text":"Type Name UNightSkyAnimMetaData ()"},{"location":"NightSkyEngine/class_u_night_sky_anim_meta_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_anim_meta_data/#variable-cachedbonenames","title":"variable CachedBoneNames","text":"<pre><code>TSet&lt;FName&gt; UNightSkyAnimMetaData::CachedBoneNames;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_anim_meta_data/#variable-userdata","title":"variable UserData","text":"<pre><code>TObjectPtr&lt;UNightSkyAnimSequenceUserData&gt; UNightSkyAnimMetaData::UserData;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_anim_meta_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_anim_meta_data/#function-unightskyanimmetadata","title":"function UNightSkyAnimMetaData","text":"<pre><code>UNightSkyAnimMetaData::UNightSkyAnimMetaData () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimMetaData.h</code></p>"},{"location":"NightSkyEngine/class_u_night_sky_anim_sequence_user_data/","title":"Class UNightSkyAnimSequenceUserData","text":"<p>ClassList &gt; UNightSkyAnimSequenceUserData</p> <p>Inherits the following classes: UAssetUserData</p>"},{"location":"NightSkyEngine/class_u_night_sky_anim_sequence_user_data/#public-functions","title":"Public Functions","text":"Type Name FAnimVector GetCachedBoneLocationAtTime (FName BoneName, int32 Time, bool bRelativeToRoot) const FAnimTransform GetCachedBoneTransformAtTime (FName BoneName, int32 Time, bool bRelativeToRoot) const int32 GetFrameCount () const int32 GetFrameRate () const FAnimVector GetRootTranslationAtTime (int32 Time) const virtual void PostEditChangeOwner (const FPropertyChangedEvent &amp; PropertyChangedEvent) override"},{"location":"NightSkyEngine/class_u_night_sky_anim_sequence_user_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_anim_sequence_user_data/#function-getcachedbonelocationattime","title":"function GetCachedBoneLocationAtTime","text":"<pre><code>FAnimVector UNightSkyAnimSequenceUserData::GetCachedBoneLocationAtTime (\n    FName BoneName,\n    int32 Time,\n    bool bRelativeToRoot\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_anim_sequence_user_data/#function-getcachedbonetransformattime","title":"function GetCachedBoneTransformAtTime","text":"<pre><code>FAnimTransform UNightSkyAnimSequenceUserData::GetCachedBoneTransformAtTime (\n    FName BoneName,\n    int32 Time,\n    bool bRelativeToRoot\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_anim_sequence_user_data/#function-getframecount","title":"function GetFrameCount","text":"<pre><code>inline int32 UNightSkyAnimSequenceUserData::GetFrameCount () const\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_anim_sequence_user_data/#function-getframerate","title":"function GetFrameRate","text":"<pre><code>inline int32 UNightSkyAnimSequenceUserData::GetFrameRate () const\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_anim_sequence_user_data/#function-getroottranslationattime","title":"function GetRootTranslationAtTime","text":"<pre><code>FAnimVector UNightSkyAnimSequenceUserData::GetRootTranslationAtTime (\n    int32 Time\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_anim_sequence_user_data/#function-posteditchangeowner","title":"function PostEditChangeOwner","text":"<pre><code>virtual void UNightSkyAnimSequenceUserData::PostEditChangeOwner (\n    const FPropertyChangedEvent &amp; PropertyChangedEvent\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimSequenceUserData.h</code></p>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/","title":"Class UNightSkyBattleWidget","text":"<p>ClassList &gt; UNightSkyBattleWidget</p> <p>Inherits the following classes: UUserWidget</p>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#public-attributes","title":"Public Attributes","text":"Type Name int P1ComboCounter TArray&lt; float &gt; P1Gauge TArray&lt; float &gt; P1Health float P1Meter TArray&lt; float &gt; P1RecoverableHealth int P1RoundsWon int P2ComboCounter TArray&lt; float &gt; P2Gauge TArray&lt; float &gt; P2Health float P2Meter TArray&lt; float &gt; P2RecoverableHealth int P2RoundsWon int Ping int RollbackFrames float Timer TArray&lt; FRollbackAnimation &gt; WidgetAnimationRollback"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#public-functions","title":"Public Functions","text":"Type Name void LoadForRollback (const TArray&lt; uint8 &gt; &amp; InBytes)  void PlayComboCounterAnim ()  void PlayFadeAnim ()  void PlayFadeOutAnim ()  void PlayGaugeAnim ()  void PlayHealthAnim ()  void PlayMatchWinAnim (bool bIsP1)  void PlayMeterAnim ()  void PlayRecoverableHealthAnim ()  void PlayRoundInitAnim ()  void PlayRoundWinAnim (bool bIsP1)  void PlayStandardAnimations ()  void PlayTimerAnim ()  void RegisterAnimationsForRollback ()  void RollbackAnimations ()  TArray&lt; uint8 &gt; SaveForRollback ()  void SetAnimationRollbackData ()"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-p1combocounter","title":"variable P1ComboCounter","text":"<pre><code>int UNightSkyBattleWidget::P1ComboCounter;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-p1gauge","title":"variable P1Gauge","text":"<pre><code>TArray&lt;float&gt; UNightSkyBattleWidget::P1Gauge;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-p1health","title":"variable P1Health","text":"<pre><code>TArray&lt;float&gt; UNightSkyBattleWidget::P1Health;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-p1meter","title":"variable P1Meter","text":"<pre><code>float UNightSkyBattleWidget::P1Meter;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-p1recoverablehealth","title":"variable P1RecoverableHealth","text":"<pre><code>TArray&lt;float&gt; UNightSkyBattleWidget::P1RecoverableHealth;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-p1roundswon","title":"variable P1RoundsWon","text":"<pre><code>int UNightSkyBattleWidget::P1RoundsWon;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-p2combocounter","title":"variable P2ComboCounter","text":"<pre><code>int UNightSkyBattleWidget::P2ComboCounter;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-p2gauge","title":"variable P2Gauge","text":"<pre><code>TArray&lt;float&gt; UNightSkyBattleWidget::P2Gauge;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-p2health","title":"variable P2Health","text":"<pre><code>TArray&lt;float&gt; UNightSkyBattleWidget::P2Health;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-p2meter","title":"variable P2Meter","text":"<pre><code>float UNightSkyBattleWidget::P2Meter;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-p2recoverablehealth","title":"variable P2RecoverableHealth","text":"<pre><code>TArray&lt;float&gt; UNightSkyBattleWidget::P2RecoverableHealth;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-p2roundswon","title":"variable P2RoundsWon","text":"<pre><code>int UNightSkyBattleWidget::P2RoundsWon;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-ping","title":"variable Ping","text":"<pre><code>int UNightSkyBattleWidget::Ping;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-rollbackframes","title":"variable RollbackFrames","text":"<pre><code>int UNightSkyBattleWidget::RollbackFrames;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-timer","title":"variable Timer","text":"<pre><code>float UNightSkyBattleWidget::Timer;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#variable-widgetanimationrollback","title":"variable WidgetAnimationRollback","text":"<pre><code>TArray&lt;FRollbackAnimation&gt; UNightSkyBattleWidget::WidgetAnimationRollback;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-loadforrollback","title":"function LoadForRollback","text":"<pre><code>void UNightSkyBattleWidget::LoadForRollback (\n    const TArray&lt; uint8 &gt; &amp; InBytes\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-playcombocounteranim","title":"function PlayComboCounterAnim","text":"<pre><code>void UNightSkyBattleWidget::PlayComboCounterAnim () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-playfadeanim","title":"function PlayFadeAnim","text":"<pre><code>void UNightSkyBattleWidget::PlayFadeAnim () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-playfadeoutanim","title":"function PlayFadeOutAnim","text":"<pre><code>void UNightSkyBattleWidget::PlayFadeOutAnim () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-playgaugeanim","title":"function PlayGaugeAnim","text":"<pre><code>void UNightSkyBattleWidget::PlayGaugeAnim () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-playhealthanim","title":"function PlayHealthAnim","text":"<pre><code>void UNightSkyBattleWidget::PlayHealthAnim () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-playmatchwinanim","title":"function PlayMatchWinAnim","text":"<pre><code>void UNightSkyBattleWidget::PlayMatchWinAnim (\n    bool bIsP1\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-playmeteranim","title":"function PlayMeterAnim","text":"<pre><code>void UNightSkyBattleWidget::PlayMeterAnim () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-playrecoverablehealthanim","title":"function PlayRecoverableHealthAnim","text":"<pre><code>void UNightSkyBattleWidget::PlayRecoverableHealthAnim () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-playroundinitanim","title":"function PlayRoundInitAnim","text":"<pre><code>void UNightSkyBattleWidget::PlayRoundInitAnim () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-playroundwinanim","title":"function PlayRoundWinAnim","text":"<pre><code>void UNightSkyBattleWidget::PlayRoundWinAnim (\n    bool bIsP1\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-playstandardanimations","title":"function PlayStandardAnimations","text":"<pre><code>void UNightSkyBattleWidget::PlayStandardAnimations () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-playtimeranim","title":"function PlayTimerAnim","text":"<pre><code>void UNightSkyBattleWidget::PlayTimerAnim () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-registeranimationsforrollback","title":"function RegisterAnimationsForRollback","text":"<pre><code>void UNightSkyBattleWidget::RegisterAnimationsForRollback () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-rollbackanimations","title":"function RollbackAnimations","text":"<pre><code>void UNightSkyBattleWidget::RollbackAnimations () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-saveforrollback","title":"function SaveForRollback","text":"<pre><code>TArray&lt; uint8 &gt; UNightSkyBattleWidget::SaveForRollback () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_battle_widget/#function-setanimationrollbackdata","title":"function SetAnimationRollbackData","text":"<pre><code>void UNightSkyBattleWidget::SetAnimationRollbackData () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/UI/NightSkyBattleWidget.h</code></p>"},{"location":"NightSkyEngine/class_u_night_sky_blueprint_function_library/","title":"Class UNightSkyBlueprintFunctionLibrary","text":"<p>ClassList &gt; UNightSkyBlueprintFunctionLibrary</p> <p>Inherits the following classes: UBlueprintFunctionLibrary</p>"},{"location":"NightSkyEngine/class_u_night_sky_blueprint_function_library/#public-static-functions","title":"Public Static Functions","text":"Type Name int32 Cos_x1000 (int32 Deg_x10)  int32 Sin_x1000 (int32 Deg_x10)  int32 Vec2Angle_x1000 (int32 x, int32 y)"},{"location":"NightSkyEngine/class_u_night_sky_blueprint_function_library/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_blueprint_function_library/#function-cos_x1000","title":"function Cos_x1000","text":"<pre><code>static int32 UNightSkyBlueprintFunctionLibrary::Cos_x1000 (\n    int32 Deg_x10\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_blueprint_function_library/#function-sin_x1000","title":"function Sin_x1000","text":"<pre><code>static int32 UNightSkyBlueprintFunctionLibrary::Sin_x1000 (\n    int32 Deg_x10\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_blueprint_function_library/#function-vec2angle_x1000","title":"function Vec2Angle_x1000","text":"<pre><code>static int32 UNightSkyBlueprintFunctionLibrary::Vec2Angle_x1000 (\n    int32 x,\n    int32 y\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/NightSkyBlueprintFunctionLibrary.h</code></p>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/","title":"Class UNightSkyGameInstance","text":"<p>ClassList &gt; UNightSkyGameInstance</p> <p>Inherits the following classes: UGameInstance</p>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#public-attributes","title":"Public Attributes","text":"Type Name TObjectPtr&lt; USoundData &gt; AnnouncerData FBattleData BattleData FString BattleVersion TEnumAsByte&lt; EFighterRunners &gt; FighterRunner bool FinishedLoadingForNetworkBattle   = <code>false</code> FString GameVersion bool IsCPUBattle   = <code>false</code> bool IsReplay   = <code>false</code> bool IsTraining   = <code>false</code> TObjectPtr&lt; USoundData &gt; MusicData int PlayerIndex TArray&lt; UReplaySaveInfo * &gt; ReplayList TObjectPtr&lt; UNightSkySettingsInfo &gt; SettingsInfo"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#public-functions","title":"Public Functions","text":"Type Name void DeleteReplay (const FString &amp; ReplayName)  void EndRecordReplay () const void FindReplays ()  void LoadReplay ()  void PlayReplayFromBP (FString ReplayName)  void PlayReplayToGameState (int32 FrameNumber, int32 &amp; OutP1Input, int32 &amp; OutP2Input) const void RecordReplay ()  void RollbackReplay (int32 FramesToRollback) const void TravelToBattleMap () const void TravelToVSInfo () const void UpdateReplay (int32 InputsP1, int32 InputsP2) const"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#protected-functions","title":"Protected Functions","text":"Type Name void BP_OnFindReplaysComplete (const TArray&lt; UReplaySaveInfo * &gt; &amp; AllReplays)"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#variable-announcerdata","title":"variable AnnouncerData","text":"<pre><code>TObjectPtr&lt;USoundData&gt; UNightSkyGameInstance::AnnouncerData;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#variable-battledata","title":"variable BattleData","text":"<pre><code>FBattleData UNightSkyGameInstance::BattleData;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#variable-battleversion","title":"variable BattleVersion","text":"<pre><code>FString UNightSkyGameInstance::BattleVersion;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#variable-fighterrunner","title":"variable FighterRunner","text":"<pre><code>TEnumAsByte&lt;EFighterRunners&gt; UNightSkyGameInstance::FighterRunner;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#variable-finishedloadingfornetworkbattle","title":"variable FinishedLoadingForNetworkBattle","text":"<pre><code>bool UNightSkyGameInstance::FinishedLoadingForNetworkBattle;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#variable-gameversion","title":"variable GameVersion","text":"<pre><code>FString UNightSkyGameInstance::GameVersion;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#variable-iscpubattle","title":"variable IsCPUBattle","text":"<pre><code>bool UNightSkyGameInstance::IsCPUBattle;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#variable-isreplay","title":"variable IsReplay","text":"<pre><code>bool UNightSkyGameInstance::IsReplay;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#variable-istraining","title":"variable IsTraining","text":"<pre><code>bool UNightSkyGameInstance::IsTraining;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#variable-musicdata","title":"variable MusicData","text":"<pre><code>TObjectPtr&lt;USoundData&gt; UNightSkyGameInstance::MusicData;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#variable-playerindex","title":"variable PlayerIndex","text":"<pre><code>int UNightSkyGameInstance::PlayerIndex;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#variable-replaylist","title":"variable ReplayList","text":"<pre><code>TArray&lt;UReplaySaveInfo*&gt; UNightSkyGameInstance::ReplayList;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#variable-settingsinfo","title":"variable SettingsInfo","text":"<pre><code>TObjectPtr&lt;UNightSkySettingsInfo&gt; UNightSkyGameInstance::SettingsInfo;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#function-deletereplay","title":"function DeleteReplay","text":"<pre><code>void UNightSkyGameInstance::DeleteReplay (\n    const FString &amp; ReplayName\n) \n</code></pre> <p>Delete a previously recorded replay </p>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#function-endrecordreplay","title":"function EndRecordReplay","text":"<pre><code>void UNightSkyGameInstance::EndRecordReplay () const\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#function-findreplays","title":"function FindReplays","text":"<pre><code>void UNightSkyGameInstance::FindReplays () \n</code></pre> <p>Start looking for/finding replays on the hard drive </p>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#function-loadreplay","title":"function LoadReplay","text":"<pre><code>void UNightSkyGameInstance::LoadReplay () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#function-playreplayfrombp","title":"function PlayReplayFromBP","text":"<pre><code>void UNightSkyGameInstance::PlayReplayFromBP (\n    FString ReplayName\n) \n</code></pre> <p>Start playback for a previously recorded Replay, from blueprint </p>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#function-playreplaytogamestate","title":"function PlayReplayToGameState","text":"<pre><code>void UNightSkyGameInstance::PlayReplayToGameState (\n    int32 FrameNumber,\n    int32 &amp; OutP1Input,\n    int32 &amp; OutP2Input\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#function-recordreplay","title":"function RecordReplay","text":"<pre><code>void UNightSkyGameInstance::RecordReplay () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#function-rollbackreplay","title":"function RollbackReplay","text":"<pre><code>void UNightSkyGameInstance::RollbackReplay (\n    int32 FramesToRollback\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#function-traveltobattlemap","title":"function TravelToBattleMap","text":"<pre><code>void UNightSkyGameInstance::TravelToBattleMap () const\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#function-traveltovsinfo","title":"function TravelToVSInfo","text":"<pre><code>void UNightSkyGameInstance::TravelToVSInfo () const\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#function-updatereplay","title":"function UpdateReplay","text":"<pre><code>void UNightSkyGameInstance::UpdateReplay (\n    int32 InputsP1,\n    int32 InputsP2\n) const\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_game_instance/#function-bp_onfindreplayscomplete","title":"function BP_OnFindReplaysComplete","text":"<pre><code>void UNightSkyGameInstance::BP_OnFindReplaysComplete (\n    const TArray&lt; UReplaySaveInfo * &gt; &amp; AllReplays\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkyGameInstance.h</code></p>"},{"location":"NightSkyEngine/class_u_night_sky_save_info/","title":"Class UNightSkySaveInfo","text":"<p>ClassList &gt; UNightSkySaveInfo</p> <p>Inherits the following classes: USaveGame</p> <p>Inherited by the following classes: UNightSkySettingsInfo,  UReplaySaveInfo</p>"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; uint8 &gt; Data TArray&lt; FObjectRecord &gt; ObjectRecords TArray&lt; UObject * &gt; PersistentOuters TArray&lt; UObject * &gt; TempObjects"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#public-functions","title":"Public Functions","text":"Type Name void ActorArraySaver (UPARAM(ref) TArray&lt; AActor * &gt; &amp; SaveActors)  void ActorPreloader (AActor * WorldActor, FObjectRecord &amp; ActorRecord)  void ActorSaver (AActor * SaveActor)  void LoadData (UObject * Object, UPARAM(ref) TArray&lt; uint8 &gt; &amp; InData)  void SaveData (UObject * Object, TArray&lt; uint8 &gt; &amp; InData)  void UObjectArraySaver (UPARAM(ref) TArray&lt; UObject * &gt; &amp; SaveObjects)  void UObjectDataLoader ()  void UObjectSaver (UObject * SaveObject)  void UObjectsPreloader (AActor * WorldActor)"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_save_info/#variable-data","title":"variable Data","text":"<pre><code>TArray&lt;uint8&gt; UNightSkySaveInfo::Data;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#variable-objectrecords","title":"variable ObjectRecords","text":"<pre><code>TArray&lt;FObjectRecord&gt; UNightSkySaveInfo::ObjectRecords;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#variable-persistentouters","title":"variable PersistentOuters","text":"<pre><code>TArray&lt;UObject*&gt; UNightSkySaveInfo::PersistentOuters;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#variable-tempobjects","title":"variable TempObjects","text":"<pre><code>TArray&lt;UObject*&gt; UNightSkySaveInfo::TempObjects;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_save_info/#function-actorarraysaver","title":"function ActorArraySaver","text":"<pre><code>void UNightSkySaveInfo::ActorArraySaver (\n    UPARAM(ref) TArray&lt; AActor * &gt; &amp; SaveActors\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#function-actorpreloader","title":"function ActorPreloader","text":"<pre><code>void UNightSkySaveInfo::ActorPreloader (\n    AActor * WorldActor,\n    FObjectRecord &amp; ActorRecord\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#function-actorsaver","title":"function ActorSaver","text":"<pre><code>void UNightSkySaveInfo::ActorSaver (\n    AActor * SaveActor\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#function-loaddata","title":"function LoadData","text":"<pre><code>void UNightSkySaveInfo::LoadData (\n    UObject * Object,\n    UPARAM(ref) TArray&lt; uint8 &gt; &amp; InData\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#function-savedata","title":"function SaveData","text":"<pre><code>void UNightSkySaveInfo::SaveData (\n    UObject * Object,\n    TArray&lt; uint8 &gt; &amp; InData\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#function-uobjectarraysaver","title":"function UObjectArraySaver","text":"<pre><code>void UNightSkySaveInfo::UObjectArraySaver (\n    UPARAM(ref) TArray&lt; UObject * &gt; &amp; SaveObjects\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#function-uobjectdataloader","title":"function UObjectDataLoader","text":"<pre><code>void UNightSkySaveInfo::UObjectDataLoader () \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#function-uobjectsaver","title":"function UObjectSaver","text":"<pre><code>void UNightSkySaveInfo::UObjectSaver (\n    UObject * SaveObject\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_save_info/#function-uobjectspreloader","title":"function UObjectsPreloader","text":"<pre><code>void UNightSkySaveInfo::UObjectsPreloader (\n    AActor * WorldActor\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkySaveInfo.h</code></p>"},{"location":"NightSkyEngine/class_u_night_sky_settings_info/","title":"Class UNightSkySettingsInfo","text":"<p>ClassList &gt; UNightSkySettingsInfo</p> <p>Inherits the following classes: UNightSkySaveInfo</p>"},{"location":"NightSkyEngine/class_u_night_sky_settings_info/#public-attributes","title":"Public Attributes","text":"Type Name int32 AntiAliasingMethod int32 GlobalIlluminationMethod"},{"location":"NightSkyEngine/class_u_night_sky_settings_info/#public-attributes-inherited-from-unightskysaveinfo","title":"Public Attributes inherited from UNightSkySaveInfo","text":"<p>See UNightSkySaveInfo</p> Type Name TArray&lt; uint8 &gt; Data TArray&lt; FObjectRecord &gt; ObjectRecords TArray&lt; UObject * &gt; PersistentOuters TArray&lt; UObject * &gt; TempObjects"},{"location":"NightSkyEngine/class_u_night_sky_settings_info/#public-functions-inherited-from-unightskysaveinfo","title":"Public Functions inherited from UNightSkySaveInfo","text":"<p>See UNightSkySaveInfo</p> Type Name void ActorArraySaver (UPARAM(ref) TArray&lt; AActor * &gt; &amp; SaveActors)  void ActorPreloader (AActor * WorldActor, FObjectRecord &amp; ActorRecord)  void ActorSaver (AActor * SaveActor)  void LoadData (UObject * Object, UPARAM(ref) TArray&lt; uint8 &gt; &amp; InData)  void SaveData (UObject * Object, TArray&lt; uint8 &gt; &amp; InData)  void UObjectArraySaver (UPARAM(ref) TArray&lt; UObject * &gt; &amp; SaveObjects)  void UObjectDataLoader ()  void UObjectSaver (UObject * SaveObject)  void UObjectsPreloader (AActor * WorldActor)"},{"location":"NightSkyEngine/class_u_night_sky_settings_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_night_sky_settings_info/#variable-antialiasingmethod","title":"variable AntiAliasingMethod","text":"<pre><code>int32 UNightSkySettingsInfo::AntiAliasingMethod;\n</code></pre>"},{"location":"NightSkyEngine/class_u_night_sky_settings_info/#variable-globalilluminationmethod","title":"variable GlobalIlluminationMethod","text":"<pre><code>int32 UNightSkySettingsInfo::GlobalIlluminationMethod;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkySettingsInfo.h</code></p>"},{"location":"NightSkyEngine/class_u_particle_data/","title":"Class UParticleData","text":"<p>ClassList &gt; UParticleData</p> <p>Inherits the following classes: UDataAsset</p>"},{"location":"NightSkyEngine/class_u_particle_data/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; FParticleStruct &gt; ParticleStructs"},{"location":"NightSkyEngine/class_u_particle_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_particle_data/#variable-particlestructs","title":"variable ParticleStructs","text":"<pre><code>TArray&lt;FParticleStruct&gt; UParticleData::ParticleStructs;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/ParticleData.h</code></p>"},{"location":"NightSkyEngine/class_u_primary_chara_data/","title":"Class UPrimaryCharaData","text":"<p>ClassList &gt; UPrimaryCharaData</p> <p>Inherits the following classes: UPrimaryDataAsset</p>"},{"location":"NightSkyEngine/class_u_primary_chara_data/#public-attributes","title":"Public Attributes","text":"Type Name FText CharaDescription FText CharaFriendlyName UTexture2D * CharaHUDIcon FName CharaName UTexture2D * CharaSelectIcon UTexture2D * CharaSplashIcon TSubclassOf&lt; APlayerObject &gt; PlayerClass"},{"location":"NightSkyEngine/class_u_primary_chara_data/#public-functions","title":"Public Functions","text":"Type Name virtual FPrimaryAssetId GetPrimaryAssetId () override const"},{"location":"NightSkyEngine/class_u_primary_chara_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_primary_chara_data/#variable-charadescription","title":"variable CharaDescription","text":"<pre><code>FText UPrimaryCharaData::CharaDescription;\n</code></pre>"},{"location":"NightSkyEngine/class_u_primary_chara_data/#variable-charafriendlyname","title":"variable CharaFriendlyName","text":"<pre><code>FText UPrimaryCharaData::CharaFriendlyName;\n</code></pre>"},{"location":"NightSkyEngine/class_u_primary_chara_data/#variable-charahudicon","title":"variable CharaHUDIcon","text":"<pre><code>UTexture2D* UPrimaryCharaData::CharaHUDIcon;\n</code></pre>"},{"location":"NightSkyEngine/class_u_primary_chara_data/#variable-charaname","title":"variable CharaName","text":"<pre><code>FName UPrimaryCharaData::CharaName;\n</code></pre>"},{"location":"NightSkyEngine/class_u_primary_chara_data/#variable-charaselecticon","title":"variable CharaSelectIcon","text":"<pre><code>UTexture2D* UPrimaryCharaData::CharaSelectIcon;\n</code></pre>"},{"location":"NightSkyEngine/class_u_primary_chara_data/#variable-charasplashicon","title":"variable CharaSplashIcon","text":"<pre><code>UTexture2D* UPrimaryCharaData::CharaSplashIcon;\n</code></pre>"},{"location":"NightSkyEngine/class_u_primary_chara_data/#variable-playerclass","title":"variable PlayerClass","text":"<pre><code>TSubclassOf&lt;APlayerObject&gt; UPrimaryCharaData::PlayerClass;\n</code></pre>"},{"location":"NightSkyEngine/class_u_primary_chara_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_primary_chara_data/#function-getprimaryassetid","title":"function GetPrimaryAssetId","text":"<pre><code>inline virtual FPrimaryAssetId UPrimaryCharaData::GetPrimaryAssetId () override const\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/PrimaryCharaData.h</code></p>"},{"location":"NightSkyEngine/class_u_primary_stage_data/","title":"Class UPrimaryStageData","text":"<p>ClassList &gt; UPrimaryStageData</p> <p>Inherits the following classes: UPrimaryDataAsset</p>"},{"location":"NightSkyEngine/class_u_primary_stage_data/#public-attributes","title":"Public Attributes","text":"Type Name FText StageDescription FText StageFriendlyName FName StageName UTexture2D * StageSelectIcon UTexture2D * StageSplashIcon FString StageURL"},{"location":"NightSkyEngine/class_u_primary_stage_data/#public-functions","title":"Public Functions","text":"Type Name virtual FPrimaryAssetId GetPrimaryAssetId () override const"},{"location":"NightSkyEngine/class_u_primary_stage_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_primary_stage_data/#variable-stagedescription","title":"variable StageDescription","text":"<pre><code>FText UPrimaryStageData::StageDescription;\n</code></pre>"},{"location":"NightSkyEngine/class_u_primary_stage_data/#variable-stagefriendlyname","title":"variable StageFriendlyName","text":"<pre><code>FText UPrimaryStageData::StageFriendlyName;\n</code></pre>"},{"location":"NightSkyEngine/class_u_primary_stage_data/#variable-stagename","title":"variable StageName","text":"<pre><code>FName UPrimaryStageData::StageName;\n</code></pre>"},{"location":"NightSkyEngine/class_u_primary_stage_data/#variable-stageselecticon","title":"variable StageSelectIcon","text":"<pre><code>UTexture2D* UPrimaryStageData::StageSelectIcon;\n</code></pre>"},{"location":"NightSkyEngine/class_u_primary_stage_data/#variable-stagesplashicon","title":"variable StageSplashIcon","text":"<pre><code>UTexture2D* UPrimaryStageData::StageSplashIcon;\n</code></pre>"},{"location":"NightSkyEngine/class_u_primary_stage_data/#variable-stageurl","title":"variable StageURL","text":"<pre><code>FString UPrimaryStageData::StageURL;\n</code></pre>"},{"location":"NightSkyEngine/class_u_primary_stage_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_primary_stage_data/#function-getprimaryassetid","title":"function GetPrimaryAssetId","text":"<pre><code>inline virtual FPrimaryAssetId UPrimaryStageData::GetPrimaryAssetId () override const\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/PrimaryStageData.h</code></p>"},{"location":"NightSkyEngine/class_u_replay_save_info/","title":"Class UReplaySaveInfo","text":"<p>ClassList &gt; UReplaySaveInfo</p> <p>Inherits the following classes: UNightSkySaveInfo</p>"},{"location":"NightSkyEngine/class_u_replay_save_info/#public-attributes","title":"Public Attributes","text":"Type Name FBattleData BattleData TArray&lt; int32 &gt; InputsP1 TArray&lt; int32 &gt; InputsP2 int32 LengthInFrames int32 ReplayIndex FDateTime Timestamp FString Version bool bIsTraining"},{"location":"NightSkyEngine/class_u_replay_save_info/#public-attributes-inherited-from-unightskysaveinfo","title":"Public Attributes inherited from UNightSkySaveInfo","text":"<p>See UNightSkySaveInfo</p> Type Name TArray&lt; uint8 &gt; Data TArray&lt; FObjectRecord &gt; ObjectRecords TArray&lt; UObject * &gt; PersistentOuters TArray&lt; UObject * &gt; TempObjects"},{"location":"NightSkyEngine/class_u_replay_save_info/#public-functions","title":"Public Functions","text":"Type Name UReplaySaveInfo ()"},{"location":"NightSkyEngine/class_u_replay_save_info/#public-functions-inherited-from-unightskysaveinfo","title":"Public Functions inherited from UNightSkySaveInfo","text":"<p>See UNightSkySaveInfo</p> Type Name void ActorArraySaver (UPARAM(ref) TArray&lt; AActor * &gt; &amp; SaveActors)  void ActorPreloader (AActor * WorldActor, FObjectRecord &amp; ActorRecord)  void ActorSaver (AActor * SaveActor)  void LoadData (UObject * Object, UPARAM(ref) TArray&lt; uint8 &gt; &amp; InData)  void SaveData (UObject * Object, TArray&lt; uint8 &gt; &amp; InData)  void UObjectArraySaver (UPARAM(ref) TArray&lt; UObject * &gt; &amp; SaveObjects)  void UObjectDataLoader ()  void UObjectSaver (UObject * SaveObject)  void UObjectsPreloader (AActor * WorldActor)"},{"location":"NightSkyEngine/class_u_replay_save_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_replay_save_info/#variable-battledata","title":"variable BattleData","text":"<pre><code>FBattleData UReplaySaveInfo::BattleData;\n</code></pre>"},{"location":"NightSkyEngine/class_u_replay_save_info/#variable-inputsp1","title":"variable InputsP1","text":"<pre><code>TArray&lt;int32&gt; UReplaySaveInfo::InputsP1;\n</code></pre>"},{"location":"NightSkyEngine/class_u_replay_save_info/#variable-inputsp2","title":"variable InputsP2","text":"<pre><code>TArray&lt;int32&gt; UReplaySaveInfo::InputsP2;\n</code></pre>"},{"location":"NightSkyEngine/class_u_replay_save_info/#variable-lengthinframes","title":"variable LengthInFrames","text":"<pre><code>int32 UReplaySaveInfo::LengthInFrames;\n</code></pre>"},{"location":"NightSkyEngine/class_u_replay_save_info/#variable-replayindex","title":"variable ReplayIndex","text":"<pre><code>int32 UReplaySaveInfo::ReplayIndex;\n</code></pre>"},{"location":"NightSkyEngine/class_u_replay_save_info/#variable-timestamp","title":"variable Timestamp","text":"<pre><code>FDateTime UReplaySaveInfo::Timestamp;\n</code></pre>"},{"location":"NightSkyEngine/class_u_replay_save_info/#variable-version","title":"variable Version","text":"<pre><code>FString UReplaySaveInfo::Version;\n</code></pre>"},{"location":"NightSkyEngine/class_u_replay_save_info/#variable-bistraining","title":"variable bIsTraining","text":"<pre><code>bool UReplaySaveInfo::bIsTraining;\n</code></pre>"},{"location":"NightSkyEngine/class_u_replay_save_info/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_replay_save_info/#function-ureplaysaveinfo","title":"function UReplaySaveInfo","text":"<pre><code>inline UReplaySaveInfo::UReplaySaveInfo () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/ReplayInfo.h</code></p>"},{"location":"NightSkyEngine/class_u_sequence_data/","title":"Class USequenceData","text":"<p>ClassList &gt; USequenceData</p> <p>Inherits the following classes: UDataAsset</p>"},{"location":"NightSkyEngine/class_u_sequence_data/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; FSequenceStruct &gt; SequenceStructs"},{"location":"NightSkyEngine/class_u_sequence_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_sequence_data/#variable-sequencestructs","title":"variable SequenceStructs","text":"<pre><code>TArray&lt;FSequenceStruct&gt; USequenceData::SequenceStructs;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SequenceData.h</code></p>"},{"location":"NightSkyEngine/class_u_serializable_obj/","title":"Class USerializableObj","text":"<p>ClassList &gt; USerializableObj</p> <p>Inherits the following classes: UObject</p> <p>Inherited by the following classes: UBattleExtension,  UState,  USubroutine</p>"},{"location":"NightSkyEngine/class_u_serializable_obj/#public-functions","title":"Public Functions","text":"Type Name void LoadForRollback (const TArray&lt; uint8 &gt; &amp; InBytes)  void ResetToCDO ()  TArray&lt; uint8 &gt; SaveForRollback ()"},{"location":"NightSkyEngine/class_u_serializable_obj/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_serializable_obj/#function-loadforrollback","title":"function LoadForRollback","text":"<pre><code>void USerializableObj::LoadForRollback (\n    const TArray&lt; uint8 &gt; &amp; InBytes\n) \n</code></pre>"},{"location":"NightSkyEngine/class_u_serializable_obj/#function-resettocdo","title":"function ResetToCDO","text":"<pre><code>void USerializableObj::ResetToCDO () \n</code></pre>"},{"location":"NightSkyEngine/class_u_serializable_obj/#function-saveforrollback","title":"function SaveForRollback","text":"<pre><code>TArray&lt; uint8 &gt; USerializableObj::SaveForRollback () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/SerializableObj.h</code></p>"},{"location":"NightSkyEngine/class_u_sound_data/","title":"Class USoundData","text":"<p>ClassList &gt; USoundData</p> <p>Inherits the following classes: UDataAsset</p>"},{"location":"NightSkyEngine/class_u_sound_data/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; FSoundStruct &gt; SoundDatas"},{"location":"NightSkyEngine/class_u_sound_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_sound_data/#variable-sounddatas","title":"variable SoundDatas","text":"<pre><code>TArray&lt;FSoundStruct&gt; USoundData::SoundDatas;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SoundData.h</code></p>"},{"location":"NightSkyEngine/class_u_state/","title":"Class UState","text":"<p>ClassList &gt; UState</p> <p>A character state that determines behavior. More...</p> <ul> <li><code>#include &lt;State.h&gt;</code></li> </ul> <p>Inherits the following classes: USerializableObj</p> <p>Inherited by the following classes: UStateAlias,  USubroutineState</p>"},{"location":"NightSkyEngine/class_u_state/#public-attributes","title":"Public Attributes","text":"Type Name FStateCPUData CPUData int32 CelIndex FGameplayTag CustomStateType EEntryStance EntryStance TArray&lt; FInputConditionList &gt; InputConditionLists bool IsFollowupState int32 MaxChain   = <code>-1</code> int32 MaxInstances   = <code>1</code> FGameplayTag Name int32 ObjectID ABattleObject * Parent FGameplayTag ShareChainName TArray&lt; EStateCondition &gt; StateConditions EStateType StateType bool bCPUUsable   = <code>true</code> bool bEnableReverseBeat   = <code>true</code> bool bHumanUsable   = <code>true</code>"},{"location":"NightSkyEngine/class_u_state/#public-functions","title":"Public Functions","text":"Type Name virtual void CallExec ()  bool CanEnterState ()  void Exec ()  void Init ()"},{"location":"NightSkyEngine/class_u_state/#public-functions-inherited-from-userializableobj","title":"Public Functions inherited from USerializableObj","text":"<p>See USerializableObj</p> Type Name void LoadForRollback (const TArray&lt; uint8 &gt; &amp; InBytes)  void ResetToCDO ()  TArray&lt; uint8 &gt; SaveForRollback ()"},{"location":"NightSkyEngine/class_u_state/#detailed-description","title":"Detailed Description","text":"<p>Provides functionality for the current character behavior, such as frame data, animations, and more. </p>"},{"location":"NightSkyEngine/class_u_state/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_state/#variable-cpudata","title":"variable CPUData","text":"<pre><code>FStateCPUData UState::CPUData;\n</code></pre> <p>Data for the CPU to determine when to enter the state. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-celindex","title":"variable CelIndex","text":"<pre><code>int32 UState::CelIndex;\n</code></pre> <p>The current cel index. Used in Blueprint macros to determine which code to execute. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-customstatetype","title":"variable CustomStateType","text":"<pre><code>FGameplayTag UState::CustomStateType;\n</code></pre> <p>The custom state type. Only used if the base state type is set to Custom. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-entrystance","title":"variable EntryStance","text":"<pre><code>EEntryStance UState::EntryStance;\n</code></pre> <p>The required stance to enter this state. Only used on player states. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-inputconditionlists","title":"variable InputConditionLists","text":"<pre><code>TArray&lt;FInputConditionList&gt; UState::InputConditionLists;\n</code></pre> <p>An array of input condition lists. Only the success of one input condition list is required to enter the state. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-isfollowupstate","title":"variable IsFollowupState","text":"<pre><code>bool UState::IsFollowupState;\n</code></pre> <p>A value that determines if this state can be entered directly, or must be canceled into. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-maxchain","title":"variable MaxChain","text":"<pre><code>int32 UState::MaxChain;\n</code></pre> <p>The maximum number of times this state can be used in a chain. For use with moves used in a combo that you wish to prevent cancelling into multiple times in sequence. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-maxinstances","title":"variable MaxInstances","text":"<pre><code>int32 UState::MaxInstances;\n</code></pre> <p>Determines how many of this state will be spawned. Only used on object states. Player states will ignore this value and always spawn one instance. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-name","title":"variable Name","text":"<pre><code>FGameplayTag UState::Name;\n</code></pre> <p>The name of this state. For player states, this is used to jump to states directly. For object states, this is used to create an object by name. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-objectid","title":"variable ObjectID","text":"<pre><code>int32 UState::ObjectID;\n</code></pre> <p>A value that's set to match with spawned objects. If an owned object with this ID is active, this state can't be entered. For use with states that you do not wish to enter while the projectile is active. Only used on player states. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-parent","title":"variable Parent","text":"<pre><code>ABattleObject* UState::Parent;\n</code></pre> <p>The object that owns this state instance. For player states, this will always be the owning player. For object states, this value will change when a new object is activated and takes over this state. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-sharechainname","title":"variable ShareChainName","text":"<pre><code>FGameplayTag UState::ShareChainName;\n</code></pre> <p>The state name to share a max chain with. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-stateconditions","title":"variable StateConditions","text":"<pre><code>TArray&lt;EStateCondition&gt; UState::StateConditions;\n</code></pre> <p>An array of state conditions. All state conditions must be successful to enter this state. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-statetype","title":"variable StateType","text":"<pre><code>EStateType UState::StateType;\n</code></pre> <p>The type of this state. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-bcpuusable","title":"variable bCPUUsable","text":"<pre><code>bool UState::bCPUUsable;\n</code></pre> <p>If a CPU player should be able to enter the state. Not used with object states. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-benablereversebeat","title":"variable bEnableReverseBeat","text":"<pre><code>bool UState::bEnableReverseBeat;\n</code></pre> <p>The maximum number of times this state can be used in a reverse beat chain. For use with normal attacks that you don't want to use in reverse beat. </p>"},{"location":"NightSkyEngine/class_u_state/#variable-bhumanusable","title":"variable bHumanUsable","text":"<pre><code>bool UState::bHumanUsable;\n</code></pre> <p>If a human player should be able to enter the state. Not used with object states. </p>"},{"location":"NightSkyEngine/class_u_state/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_state/#function-callexec","title":"function CallExec","text":"<pre><code>virtual void UState::CallExec () \n</code></pre> <p>Wrapper for Exec function that sets CelIndex to zero. </p>"},{"location":"NightSkyEngine/class_u_state/#function-canenterstate","title":"function CanEnterState","text":"<pre><code>bool UState::CanEnterState () \n</code></pre> <p>Called to check if the state may be entered. </p>"},{"location":"NightSkyEngine/class_u_state/#function-exec","title":"function Exec","text":"<pre><code>void UState::Exec () \n</code></pre> <p>Called every frame to update the state. </p>"},{"location":"NightSkyEngine/class_u_state/#function-init","title":"function Init","text":"<pre><code>void UState::Init () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/State.h</code></p>"},{"location":"NightSkyEngine/class_u_state_alias/","title":"Class UStateAlias","text":"<p>ClassList &gt; UStateAlias</p> <p>More...</p> <ul> <li><code>#include &lt;StateAlias.h&gt;</code></li> </ul> <p>Inherits the following classes: UState</p>"},{"location":"NightSkyEngine/class_u_state_alias/#public-attributes","title":"Public Attributes","text":"Type Name FGameplayTag StateToEnter"},{"location":"NightSkyEngine/class_u_state_alias/#public-attributes-inherited-from-ustate","title":"Public Attributes inherited from UState","text":"<p>See UState</p> Type Name FStateCPUData CPUData int32 CelIndex FGameplayTag CustomStateType EEntryStance EntryStance TArray&lt; FInputConditionList &gt; InputConditionLists bool IsFollowupState int32 MaxChain   = <code>-1</code> int32 MaxInstances   = <code>1</code> FGameplayTag Name int32 ObjectID ABattleObject * Parent FGameplayTag ShareChainName TArray&lt; EStateCondition &gt; StateConditions EStateType StateType bool bCPUUsable   = <code>true</code> bool bEnableReverseBeat   = <code>true</code> bool bHumanUsable   = <code>true</code>"},{"location":"NightSkyEngine/class_u_state_alias/#public-functions","title":"Public Functions","text":"Type Name virtual void CallExec () override"},{"location":"NightSkyEngine/class_u_state_alias/#public-functions-inherited-from-ustate","title":"Public Functions inherited from UState","text":"<p>See UState</p> Type Name virtual void CallExec ()  bool CanEnterState ()  void Exec ()  void Init ()"},{"location":"NightSkyEngine/class_u_state_alias/#public-functions-inherited-from-userializableobj","title":"Public Functions inherited from USerializableObj","text":"<p>See USerializableObj</p> Type Name void LoadForRollback (const TArray&lt; uint8 &gt; &amp; InBytes)  void ResetToCDO ()  TArray&lt; uint8 &gt; SaveForRollback ()"},{"location":"NightSkyEngine/class_u_state_alias/#detailed-description","title":"Detailed Description","text":"<p>An \"alias\" for an existing state. Allows giving different conditions for entering an existing state. </p>"},{"location":"NightSkyEngine/class_u_state_alias/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_state_alias/#variable-statetoenter","title":"variable StateToEnter","text":"<pre><code>FGameplayTag UStateAlias::StateToEnter;\n</code></pre>"},{"location":"NightSkyEngine/class_u_state_alias/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_state_alias/#function-callexec","title":"function CallExec","text":"<pre><code>inline virtual void UStateAlias::CallExec () override\n</code></pre> <p>Wrapper for Exec function that sets CelIndex to zero. </p> <p>Implements UState::CallExec</p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/StateAlias.h</code></p>"},{"location":"NightSkyEngine/class_u_state_data/","title":"Class UStateData","text":"<p>ClassList &gt; UStateData</p> <p>Inherits the following classes: UDataAsset</p>"},{"location":"NightSkyEngine/class_u_state_data/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; TSubclassOf&lt; UState &gt; &gt; StateArray"},{"location":"NightSkyEngine/class_u_state_data/#public-functions","title":"Public Functions","text":"Type Name const UState * GetByStateName (const FGameplayTag &amp; StateName) const"},{"location":"NightSkyEngine/class_u_state_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_state_data/#variable-statearray","title":"variable StateArray","text":"<pre><code>TArray&lt;TSubclassOf&lt;UState&gt; &gt; UStateData::StateArray;\n</code></pre>"},{"location":"NightSkyEngine/class_u_state_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_state_data/#function-getbystatename","title":"function GetByStateName","text":"<pre><code>inline const UState * UStateData::GetByStateName (\n    const FGameplayTag &amp; StateName\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/StateData.h</code></p>"},{"location":"NightSkyEngine/class_u_subroutine/","title":"Class USubroutine","text":"<p>ClassList &gt; USubroutine</p> <p>A subroutine callable from any player or object state. More...</p> <ul> <li><code>#include &lt;Subroutine.h&gt;</code></li> </ul> <p>Inherits the following classes: USerializableObj</p>"},{"location":"NightSkyEngine/class_u_subroutine/#public-attributes","title":"Public Attributes","text":"Type Name FGameplayTag Name ABattleObject * Parent"},{"location":"NightSkyEngine/class_u_subroutine/#public-functions","title":"Public Functions","text":"Type Name void Exec ()"},{"location":"NightSkyEngine/class_u_subroutine/#public-functions-inherited-from-userializableobj","title":"Public Functions inherited from USerializableObj","text":"<p>See USerializableObj</p> Type Name void LoadForRollback (const TArray&lt; uint8 &gt; &amp; InBytes)  void ResetToCDO ()  TArray&lt; uint8 &gt; SaveForRollback ()"},{"location":"NightSkyEngine/class_u_subroutine/#detailed-description","title":"Detailed Description","text":"<p>Allows encapsulating commonly used code that can be reused in states. </p>"},{"location":"NightSkyEngine/class_u_subroutine/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_subroutine/#variable-name","title":"variable Name","text":"<pre><code>FGameplayTag USubroutine::Name;\n</code></pre> <p>The name of the subroutine. Used to call the subroutine. </p>"},{"location":"NightSkyEngine/class_u_subroutine/#variable-parent","title":"variable Parent","text":"<pre><code>ABattleObject* USubroutine::Parent;\n</code></pre> <p>The object that currently owns this subroutine instance. The last object to use this subroutine will be the owner. </p>"},{"location":"NightSkyEngine/class_u_subroutine/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_subroutine/#function-exec","title":"function Exec","text":"<pre><code>void USubroutine::Exec () \n</code></pre> <p>The primary function of the subroutine. </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/Subroutine.h</code></p>"},{"location":"NightSkyEngine/class_u_subroutine_data/","title":"Class USubroutineData","text":"<p>ClassList &gt; USubroutineData</p> <p>Inherits the following classes: UDataAsset</p>"},{"location":"NightSkyEngine/class_u_subroutine_data/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; TSubclassOf&lt; USubroutine &gt; &gt; SubroutineArray"},{"location":"NightSkyEngine/class_u_subroutine_data/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_subroutine_data/#variable-subroutinearray","title":"variable SubroutineArray","text":"<pre><code>TArray&lt;TSubclassOf&lt;USubroutine&gt; &gt; USubroutineData::SubroutineArray;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SubroutineData.h</code></p>"},{"location":"NightSkyEngine/class_u_subroutine_state/","title":"Class USubroutineState","text":"<p>ClassList &gt; USubroutineState</p> <p>More...</p> <ul> <li><code>#include &lt;SubroutineState.h&gt;</code></li> </ul> <p>Inherits the following classes: UState</p>"},{"location":"NightSkyEngine/class_u_subroutine_state/#public-attributes","title":"Public Attributes","text":"Type Name FGameplayTag SubroutineName"},{"location":"NightSkyEngine/class_u_subroutine_state/#public-attributes-inherited-from-ustate","title":"Public Attributes inherited from UState","text":"<p>See UState</p> Type Name FStateCPUData CPUData int32 CelIndex FGameplayTag CustomStateType EEntryStance EntryStance TArray&lt; FInputConditionList &gt; InputConditionLists bool IsFollowupState int32 MaxChain   = <code>-1</code> int32 MaxInstances   = <code>1</code> FGameplayTag Name int32 ObjectID ABattleObject * Parent FGameplayTag ShareChainName TArray&lt; EStateCondition &gt; StateConditions EStateType StateType bool bCPUUsable   = <code>true</code> bool bEnableReverseBeat   = <code>true</code> bool bHumanUsable   = <code>true</code>"},{"location":"NightSkyEngine/class_u_subroutine_state/#public-functions","title":"Public Functions","text":"Type Name virtual void CallExec () override"},{"location":"NightSkyEngine/class_u_subroutine_state/#public-functions-inherited-from-ustate","title":"Public Functions inherited from UState","text":"<p>See UState</p> Type Name virtual void CallExec ()  bool CanEnterState ()  void Exec ()  void Init ()"},{"location":"NightSkyEngine/class_u_subroutine_state/#public-functions-inherited-from-userializableobj","title":"Public Functions inherited from USerializableObj","text":"<p>See USerializableObj</p> Type Name void LoadForRollback (const TArray&lt; uint8 &gt; &amp; InBytes)  void ResetToCDO ()  TArray&lt; uint8 &gt; SaveForRollback ()"},{"location":"NightSkyEngine/class_u_subroutine_state/#detailed-description","title":"Detailed Description","text":"<p>Attempting to enter the state will actually call a subroutine instead. </p>"},{"location":"NightSkyEngine/class_u_subroutine_state/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/class_u_subroutine_state/#variable-subroutinename","title":"variable SubroutineName","text":"<pre><code>FGameplayTag USubroutineState::SubroutineName;\n</code></pre>"},{"location":"NightSkyEngine/class_u_subroutine_state/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/class_u_subroutine_state/#function-callexec","title":"function CallExec","text":"<pre><code>inline virtual void USubroutineState::CallExec () override\n</code></pre> <p>Wrapper for Exec function that sets CelIndex to zero. </p> <p>Implements UState::CallExec</p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/SubroutineState.h</code></p>"},{"location":"NightSkyEngine/dir_0b4eaef40a1fe20bedafe9e8e719ce66/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins","text":"<p>FileList &gt; Plugins</p>"},{"location":"NightSkyEngine/dir_0b4eaef40a1fe20bedafe9e8e719ce66/#directories","title":"Directories","text":"Type Name dir NightSkyEngine <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/</code></p>"},{"location":"NightSkyEngine/dir_01309b4faf1ec48651014f612e2b32bb/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine","text":"<p>FileList &gt; NightSkyEngine</p>"},{"location":"NightSkyEngine/dir_01309b4faf1ec48651014f612e2b32bb/#directories","title":"Directories","text":"Type Name dir Source <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/</code></p>"},{"location":"NightSkyEngine/dir_d32ee28216ed342fa25c01ae9dcd9cc4/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source","text":"<p>FileList &gt; NightSkyEngine &gt; Source</p>"},{"location":"NightSkyEngine/dir_d32ee28216ed342fa25c01ae9dcd9cc4/#directories","title":"Directories","text":"Type Name dir NightSkyEngine <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/</code></p>"},{"location":"NightSkyEngine/dir_a12a4fa09c295aab9e164f44221961f1/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine</p>"},{"location":"NightSkyEngine/dir_a12a4fa09c295aab9e164f44221961f1/#files","title":"Files","text":"Type Name file NightSkyEngine.cpp file NightSkyEngine.h"},{"location":"NightSkyEngine/dir_a12a4fa09c295aab9e164f44221961f1/#directories","title":"Directories","text":"Type Name dir Battle dir CharaSelect dir Data dir Input dir Miscellaneous dir Network dir UI dir VSInfo dir WT <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/</code></p>"},{"location":"NightSkyEngine/dir_59b3558fc0091a3111c9e7dd8d94b2ea/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle","text":"<p>FileList &gt; Battle</p>"},{"location":"NightSkyEngine/dir_59b3558fc0091a3111c9e7dd8d94b2ea/#files","title":"Files","text":"Type Name file NightSkyGameState.cpp file NightSkyGameState.h file NightSkyPlayerController.cpp file NightSkyPlayerController.h"},{"location":"NightSkyEngine/dir_59b3558fc0091a3111c9e7dd8d94b2ea/#directories","title":"Directories","text":"Type Name dir Actors dir Animation dir CPU dir FighterRunners dir Misc dir Objects dir Script <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/</code></p>"},{"location":"NightSkyEngine/dir_51f67430d2b061bf5371397678dcec7e/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors","text":"<p>FileList &gt; Actors</p>"},{"location":"NightSkyEngine/dir_51f67430d2b061bf5371397678dcec7e/#files","title":"Files","text":"Type Name file AudioManager.cpp file AudioManager.h file LinkActor.cpp file LinkActor.h file ParticleManager.cpp file ParticleManager.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/</code></p>"},{"location":"NightSkyEngine/_audio_manager_8cpp/","title":"File AudioManager.cpp","text":"<p>FileList &gt; Actors &gt; AudioManager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AudioManager.h\"</code></li> <li><code>#include \"Components/AudioComponent.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/AudioManager.cpp</code></p>"},{"location":"NightSkyEngine/_audio_manager_8cpp_source/","title":"File AudioManager.cpp","text":"<p>File List &gt; Actors &gt; AudioManager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"AudioManager.h\"\n\n#include \"Components/AudioComponent.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(AudioManager)\n\n// Sets default values\nAAudioManager::AAudioManager()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = false;\n\n    RootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(FName(\"RootComponent\"));\n    for (int i = 0; i &lt; CommonAudioChannelCount; i++)\n    {\n        FString Name = \"CommonAudioPlayer\";\n        Name.AppendInt(i);\n        CommonAudioPlayers[i] = CreateDefaultSubobject&lt;UAudioComponent&gt;(FName(Name));\n        CommonAudioPlayers[i]-&gt;AutoAttachParent = RootComponent;\n    }\n    for (int i = 0; i &lt; CharaAudioChannelCount; i++)\n    {\n        FString Name = \"CharaAudioPlayer\";\n        Name.AppendInt(i);\n        CharaAudioPlayers[i] = CreateDefaultSubobject&lt;UAudioComponent&gt;(FName(Name));\n        CharaAudioPlayers[i]-&gt;AutoAttachParent = RootComponent;\n    }\n    for (int i = 0; i &lt; CharaVoiceChannelCount; i++)\n    {\n        FString Name = \"CharaVoicePlayer\";\n        Name.AppendInt(i);\n        CharaVoicePlayers[i] = CreateDefaultSubobject&lt;UAudioComponent&gt;(FName(Name));\n        CharaVoicePlayers[i]-&gt;AutoAttachParent = RootComponent;\n    }\n    AnnouncerVoicePlayer = CreateDefaultSubobject&lt;UAudioComponent&gt;(TEXT(\"AnnouncerVoicePlayer\"));\n    AnnouncerVoicePlayer-&gt;bAutoActivate = false;\n    AnnouncerVoicePlayer-&gt;AutoAttachParent = RootComponent;\n    MusicPlayer = CreateDefaultSubobject&lt;UAudioComponent&gt;(TEXT(\"MusicPlayer\"));\n    MusicPlayer-&gt;bAutoActivate = true;\n    MusicPlayer-&gt;AutoAttachParent = RootComponent;\n}\n\n// Called when the game starts or when spawned\nvoid AAudioManager::BeginPlay()\n{\n    Super::BeginPlay();\n\n}\n\n// Called every frame\nvoid AAudioManager::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AAudioManager::PauseAllAudio()\n{\n    for (const auto Player : CommonAudioPlayers)\n    {\n        Player-&gt;Stop();\n    }\n    for (const auto Player : CharaAudioPlayers)\n    {\n        Player-&gt;Stop();\n    }\n    for (const auto Player : CharaVoicePlayers)\n    {\n        Player-&gt;Stop();\n    }\n    AnnouncerVoicePlayer-&gt;Stop();\n}\n</code></pre>"},{"location":"NightSkyEngine/_audio_manager_8h/","title":"File AudioManager.h","text":"<p>FileList &gt; Actors &gt; AudioManager.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameFramework/Actor.h\"</code></li> <li><code>#include \"AudioManager.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_audio_manager_8h/#classes","title":"Classes","text":"Type Name class AAudioManager"},{"location":"NightSkyEngine/_audio_manager_8h/#public-attributes","title":"Public Attributes","text":"Type Name int CharaAudioChannelCount   = <code>32</code> int CharaVoiceChannelCount   = <code>6</code> int CommonAudioChannelCount   = <code>32</code>"},{"location":"NightSkyEngine/_audio_manager_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/_audio_manager_8h/#variable-charaaudiochannelcount","title":"variable CharaAudioChannelCount","text":"<pre><code>int CharaAudioChannelCount;\n</code></pre>"},{"location":"NightSkyEngine/_audio_manager_8h/#variable-charavoicechannelcount","title":"variable CharaVoiceChannelCount","text":"<pre><code>int CharaVoiceChannelCount;\n</code></pre>"},{"location":"NightSkyEngine/_audio_manager_8h/#variable-commonaudiochannelcount","title":"variable CommonAudioChannelCount","text":"<pre><code>int CommonAudioChannelCount;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/AudioManager.h</code></p>"},{"location":"NightSkyEngine/_audio_manager_8h_source/","title":"File AudioManager.h","text":"<p>File List &gt; Actors &gt; AudioManager.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"AudioManager.generated.h\"\n\nconstexpr int CommonAudioChannelCount = 32;\nconstexpr int CharaAudioChannelCount = 32;\nconstexpr int CharaVoiceChannelCount = 6;\n\nUCLASS()\nclass NIGHTSKYENGINE_API AAudioManager : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AAudioManager();\n\n    UPROPERTY()\n    UAudioComponent* CommonAudioPlayers[CommonAudioChannelCount];\n    UPROPERTY()\n    UAudioComponent* CharaAudioPlayers[CharaAudioChannelCount];\n    UPROPERTY()\n    UAudioComponent* CharaVoicePlayers[CharaVoiceChannelCount];\n    UPROPERTY()\n    UAudioComponent* AnnouncerVoicePlayer;\n    UPROPERTY()\n    UAudioComponent* MusicPlayer;\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n    void PauseAllAudio();\n};\n</code></pre>"},{"location":"NightSkyEngine/_link_actor_8cpp/","title":"File LinkActor.cpp","text":"<p>FileList &gt; Actors &gt; LinkActor.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"LinkActor.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/LinkActor.cpp</code></p>"},{"location":"NightSkyEngine/_link_actor_8cpp_source/","title":"File LinkActor.cpp","text":"<p>File List &gt; Actors &gt; LinkActor.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"LinkActor.h\"\n\n\n// Sets default values\nALinkActor::ALinkActor()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ALinkActor::BeginPlay()\n{\n    Super::BeginPlay();\n\n}\n\n// Called every frame\nvoid ALinkActor::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n</code></pre>"},{"location":"NightSkyEngine/_link_actor_8h/","title":"File LinkActor.h","text":"<p>FileList &gt; Actors &gt; LinkActor.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameFramework/Actor.h\"</code></li> <li><code>#include \"LinkActor.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_link_actor_8h/#classes","title":"Classes","text":"Type Name class ALinkActor <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/LinkActor.h</code></p>"},{"location":"NightSkyEngine/_link_actor_8h_source/","title":"File LinkActor.h","text":"<p>File List &gt; Actors &gt; LinkActor.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"LinkActor.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API ALinkActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ALinkActor();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void Init();\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void Update();\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void Exit();\n};\n</code></pre>"},{"location":"NightSkyEngine/_particle_manager_8cpp/","title":"File ParticleManager.cpp","text":"<p>FileList &gt; Actors &gt; ParticleManager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ParticleManager.h\"</code></li> <li><code>#include \"NiagaraComponent.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/NightSkyGameState.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/ParticleManager.cpp</code></p>"},{"location":"NightSkyEngine/_particle_manager_8cpp_source/","title":"File ParticleManager.cpp","text":"<p>File List &gt; Actors &gt; ParticleManager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"ParticleManager.h\"\n#include \"NiagaraComponent.h\"\n#include \"NightSkyEngine/Battle/NightSkyGameState.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(ParticleManager)\n\n// Sets default values\nAParticleManager::AParticleManager()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = false;\n}\n\n// Called when the game starts or when spawned\nvoid AParticleManager::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid AParticleManager::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\nvoid AParticleManager::UpdateParticles()\n{\n    BattleParticles.RemoveAll([=](const FBattleParticle&amp; Particle)\n    {\n        return !IsValid(Particle.NiagaraComponent);\n    });\n    for (const auto [NiagaraComponent, ParticleOwner] : BattleParticles)\n    {\n        if (IsValid(ParticleOwner) &amp;&amp; ParticleOwner-&gt;IsStopped())\n        {\n            NiagaraComponent-&gt;SetPaused(false);\n            NiagaraComponent-&gt;AdvanceSimulation(1, OneFrame / 1000);\n            NiagaraComponent-&gt;SetDesiredAge(NiagaraComponent-&gt;GetDesiredAge());\n            if (NiagaraComponent-&gt;IsComplete())\n                NiagaraComponent-&gt;Deactivate();\n            continue;\n        }\n        NiagaraComponent-&gt;SetPaused(false);\n        NiagaraComponent-&gt;AdvanceSimulation(1, OneFrame);\n        NiagaraComponent-&gt;SetDesiredAge(NiagaraComponent-&gt;GetDesiredAge() + OneFrame);\n        if (NiagaraComponent-&gt;IsComplete())\n            NiagaraComponent-&gt;Deactivate();\n    }\n}\n\nvoid AParticleManager::PauseParticles()\n{\n    BattleParticles.RemoveAll([=](const FBattleParticle&amp; Particle)\n    {\n        return !IsValid(Particle.NiagaraComponent);\n    });\n    for (const auto BattleParticle : BattleParticles)\n    {\n        BattleParticle.NiagaraComponent-&gt;SetPaused(true);\n    }\n}\n\nvoid AParticleManager::RollbackParticles(int RollbackFrames)\n{\n    for (const auto BattleParticle : BattleParticles)\n    {\n        const auto NiagaraComponent = BattleParticle.NiagaraComponent;\n        const int32 RollbackTime = NiagaraComponent-&gt;GetDesiredAge() * (1 / OneFrame) - RollbackFrames;\n        if (RollbackTime &lt; 0)\n        {\n            NiagaraComponent-&gt;Deactivate();\n            continue;\n        }\n        NiagaraComponent-&gt;ResetSystem();\n        NiagaraComponent-&gt;AdvanceSimulation(RollbackTime, OneFrame);\n    }\n}\n</code></pre>"},{"location":"NightSkyEngine/_particle_manager_8h/","title":"File ParticleManager.h","text":"<p>FileList &gt; Actors &gt; ParticleManager.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameFramework/Actor.h\"</code></li> <li><code>#include \"ParticleManager.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_particle_manager_8h/#classes","title":"Classes","text":"Type Name class AParticleManager struct FBattleParticle <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Actors/ParticleManager.h</code></p>"},{"location":"NightSkyEngine/_particle_manager_8h_source/","title":"File ParticleManager.h","text":"<p>File List &gt; Actors &gt; ParticleManager.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"ParticleManager.generated.h\"\n\nclass UNiagaraComponent;\nclass ABattleObject;\n\nUSTRUCT()\nstruct FBattleParticle\n{\n    GENERATED_BODY()\n\n    FBattleParticle()\n    {\n        NiagaraComponent = nullptr;\n        ParticleOwner = nullptr;\n    }\n\n    FBattleParticle(UNiagaraComponent* InNiagaraComponent, ABattleObject* InOwner)\n        : NiagaraComponent(InNiagaraComponent), ParticleOwner(InOwner) {}\n\n    UPROPERTY()\n    UNiagaraComponent* NiagaraComponent;\n    UPROPERTY()\n    ABattleObject* ParticleOwner;\n};\n\nUCLASS()\nclass NIGHTSKYENGINE_API AParticleManager : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY()\n    TArray&lt;FBattleParticle&gt; BattleParticles;\n\n    // Sets default values for this actor's properties\n    AParticleManager();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n    void UpdateParticles();\n    void PauseParticles();\n    void RollbackParticles(int RollbackFrames);\n};\n</code></pre>"},{"location":"NightSkyEngine/dir_9a82c917abb4553e2c2738125a0d5751/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation","text":"<p>FileList &gt; Animation</p>"},{"location":"NightSkyEngine/dir_9a82c917abb4553e2c2738125a0d5751/#files","title":"Files","text":"Type Name file NightSkyAnimInstance.cpp file NightSkyAnimInstance.h file NightSkyAnimMetaData.cpp file NightSkyAnimMetaData.h file NightSkyAnimSequenceUserData.cpp file NightSkyAnimSequenceUserData.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/</code></p>"},{"location":"NightSkyEngine/_night_sky_anim_instance_8cpp/","title":"File NightSkyAnimInstance.cpp","text":"<p>FileList &gt; Animation &gt; NightSkyAnimInstance.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyAnimInstance.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimInstance.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_anim_instance_8cpp_source/","title":"File NightSkyAnimInstance.cpp","text":"<p>File List &gt; Animation &gt; NightSkyAnimInstance.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyAnimInstance.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyAnimInstance)\n\nvoid UNightSkyAnimInstance::Montage_Advance(float DeltaSeconds)\n{\n    if (!RootMontage)\n    {\n        Super::Montage_Advance(DeltaSeconds);\n        return;\n    }\n\n    Montage_SetPosition(RootMontage, CurrentAnimTime);\n}\n\nvoid UNightSkyAnimInstance::CreateRootMontage(UAnimSequenceBase* Asset, const FAlphaBlendArgs&amp; BlendIn, const FAlphaBlendArgs&amp; BlendOut)\n{\n    if (!Asset) return;\n    RootMontage = PlaySlotAnimationAsDynamicMontage_WithBlendArgs(Asset, \"Root\", BlendIn, BlendOut, 1, 1, -1,\n                                                                  CurrentAnimTime);\n    Montage_SetNextSection(\"Default\", \"Default\", RootMontage);\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_anim_instance_8h/","title":"File NightSkyAnimInstance.h","text":"<p>FileList &gt; Animation &gt; NightSkyAnimInstance.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Animation/AnimInstance.h\"</code></li> <li><code>#include \"NightSkyAnimInstance.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_anim_instance_8h/#classes","title":"Classes","text":"Type Name class UNightSkyAnimInstance <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimInstance.h</code></p>"},{"location":"NightSkyEngine/_night_sky_anim_instance_8h_source/","title":"File NightSkyAnimInstance.h","text":"<p>File List &gt; Animation &gt; NightSkyAnimInstance.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Animation/AnimInstance.h\"\n#include \"NightSkyAnimInstance.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API UNightSkyAnimInstance : public UAnimInstance\n{\n    GENERATED_BODY()\n\nprotected:\n    virtual void Montage_Advance(float DeltaSeconds) override;\n\npublic:\n    UPROPERTY(BlueprintReadWrite)\n    UAnimMontage* RootMontage;\n\n    UPROPERTY(BlueprintReadWrite)\n    float CurrentAnimTime;\n\n    UFUNCTION(BlueprintCallable, meta = (BlueprintThreadSafe))\n    void CreateRootMontage(UAnimSequenceBase* Asset, const FAlphaBlendArgs&amp; BlendIn, const FAlphaBlendArgs&amp; BlendOut);\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_anim_meta_data_8cpp/","title":"File NightSkyAnimMetaData.cpp","text":"<p>FileList &gt; Animation &gt; NightSkyAnimMetaData.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyAnimMetaData.h\"</code></li> <li><code>#include \"NightSkyAnimSequenceUserData.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimMetaData.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_anim_meta_data_8cpp_source/","title":"File NightSkyAnimMetaData.cpp","text":"<p>File List &gt; Animation &gt; NightSkyAnimMetaData.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyAnimMetaData.h\"\n\n#include \"NightSkyAnimSequenceUserData.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyAnimMetaData)\n\nUNightSkyAnimMetaData::UNightSkyAnimMetaData()\n{\n    const auto AnimSequence = Cast&lt;UAnimSequence&gt;(GetOuter());\n\n    if (!AnimSequence) return;\n    if (IsValid(AnimSequence-&gt;GetAssetUserData&lt;UNightSkyAnimSequenceUserData&gt;())) return;\n\n    AnimSequence-&gt;AddAssetUserDataOfClass(UNightSkyAnimSequenceUserData::StaticClass());\n    UserData = static_cast&lt;UNightSkyAnimSequenceUserData*&gt;(AnimSequence-&gt;GetAssetUserDataOfClass(\n        UNightSkyAnimSequenceUserData::StaticClass()));\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_anim_meta_data_8h/","title":"File NightSkyAnimMetaData.h","text":"<p>FileList &gt; Animation &gt; NightSkyAnimMetaData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Animation/AnimMetaData.h\"</code></li> <li><code>#include \"NightSkyAnimMetaData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_anim_meta_data_8h/#classes","title":"Classes","text":"Type Name class UNightSkyAnimMetaData <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimMetaData.h</code></p>"},{"location":"NightSkyEngine/_night_sky_anim_meta_data_8h_source/","title":"File NightSkyAnimMetaData.h","text":"<p>File List &gt; Animation &gt; NightSkyAnimMetaData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Animation/AnimMetaData.h\"\n#include \"NightSkyAnimMetaData.generated.h\"\n\nclass UNightSkyAnimSequenceUserData;\nUCLASS(CollapseCategories, EditInlineNew)\nclass NIGHTSKYENGINE_API UNightSkyAnimMetaData : public UAnimMetaData\n{\n    GENERATED_BODY()\n\npublic:\n    UNightSkyAnimMetaData();\n\n    UPROPERTY(EditAnywhere, Category = \"Baked Animation\")\n    TSet&lt;FName&gt; CachedBoneNames;\n\n    UPROPERTY(BlueprintReadOnly, Category = \"Baked Animation\")\n    TObjectPtr&lt;UNightSkyAnimSequenceUserData&gt; UserData;\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_anim_sequence_user_data_8cpp/","title":"File NightSkyAnimSequenceUserData.cpp","text":"<p>FileList &gt; Animation &gt; NightSkyAnimSequenceUserData.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyAnimSequenceUserData.h\"</code></li> <li><code>#include \"NightSkyAnimMetaData.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Misc/Globals.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimSequenceUserData.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_anim_sequence_user_data_8cpp_source/","title":"File NightSkyAnimSequenceUserData.cpp","text":"<p>File List &gt; Animation &gt; NightSkyAnimSequenceUserData.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyAnimSequenceUserData.h\"\n\n#include \"NightSkyAnimMetaData.h\"\n#include \"NightSkyEngine/Battle/Misc/Globals.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyAnimSequenceUserData)\n\nvoid UNightSkyAnimSequenceUserData::Serialize(FArchive&amp; Ar)\n{\n    Super::Serialize(Ar);\n\n    Ar &lt;&lt; MeshSpaceBoneTransforms;\n    Ar &lt;&lt; RootTranslation;\n}\n\nvoid UNightSkyAnimSequenceUserData::PostEditChangeOwner(const FPropertyChangedEvent&amp; PropertyChangedEvent)\n{\n    Super::PostEditChangeOwner(PropertyChangedEvent);\n\n    // We can't call blueprint implemented functions while routing post load\n    if (FUObjectThreadContext::Get().IsRoutingPostLoad)\n    {\n        return;\n    }\n\n    // Skip interactive changes\n    if (PropertyChangedEvent.ChangeType == EPropertyChangeType::Interactive)\n    {\n        return;\n    }\n\n    MeshSpaceBoneTransforms.Empty();\n    RootTranslation.Empty();\n\n    auto AnimSequence = Cast&lt;UAnimSequence&gt;(GetOuter());\n    if (!IsValid(AnimSequence)) return;\n\n    UNightSkyAnimMetaData* AnimMetaData = nullptr;\n\n    for (auto&amp; MetaData : AnimSequence-&gt;GetMetaData())\n    {\n        AnimMetaData = Cast&lt;UNightSkyAnimMetaData&gt;(MetaData);\n        if (IsValid(MetaData)) break;\n    }\n\n    if (!IsValid(AnimMetaData))\n    {\n        ConditionalBeginDestroy();\n        return;\n    }\n\n    FrameCount = AnimSequence-&gt;GetPlayLength() * AnimSequence-&gt;GetSamplingFrameRate().AsDecimal();\n    FrameRate = AnimSequence-&gt;GetSamplingFrameRate().AsDecimal();\n\n    auto ReferenceSkeleton = AnimSequence-&gt;GetSkeleton()-&gt;GetReferenceSkeleton();\n\n    for (auto&amp; BoneName : AnimMetaData-&gt;CachedBoneNames)\n    {\n        if (ReferenceSkeleton.FindBoneIndex(BoneName) == INDEX_NONE) continue;\n        TMap&lt;int32, FAnimTransform&gt; BoneTransforms;\n\n        for (int i = 0; i &lt; FrameCount; i++)\n        {\n            FTransform Transform;\n            FAnimExtractContext Context{\n                static_cast&lt;double&gt;(i) / AnimSequence-&gt;GetSamplingFrameRate().AsDecimal()\n            };\n            AnimSequence-&gt;GetBoneTransform(\n                Transform, FSkeletonPoseBoneIndex(ReferenceSkeleton.FindBoneIndex(BoneName)),\n                Context, true);\n\n            FAnimTransform AnimTransform;\n            AnimTransform.Position.X = Transform.GetTranslation().X * COORD_SCALE;\n            AnimTransform.Position.Y = Transform.GetTranslation().Y * COORD_SCALE;\n            AnimTransform.Position.Z = Transform.GetTranslation().Z * COORD_SCALE;\n\n            auto Rotation = Transform.GetRotation().Rotator();\n            AnimTransform.Rotation.Pitch = Rotation.Pitch * 1000;\n            AnimTransform.Rotation.Yaw = Rotation.Yaw * 1000;\n            AnimTransform.Rotation.Roll = Rotation.Roll * 1000;\n\n            AnimTransform.Scale.X = Transform.GetScale3D().X * 1000;\n            AnimTransform.Scale.Y = Transform.GetScale3D().Y * 1000;\n            AnimTransform.Scale.Z = Transform.GetScale3D().Z * 1000;\n\n            BoneTransforms.Add(i, AnimTransform);\n        }\n\n        MeshSpaceBoneTransforms.Add(BoneName, BoneTransforms);\n    }\n\n    for (int i = 0; i &lt; FrameCount; i++)\n    {\n        FAnimExtractContext Context{\n            static_cast&lt;double&gt;(i) / AnimSequence-&gt;GetSamplingFrameRate().AsDecimal(),\n            true,\n        };\n\n        FVector Translation = AnimSequence-&gt;ExtractRootTrackTransform(Context, nullptr).GetTranslation();\n        FAnimVector AnimTranslation;\n\n        AnimTranslation.X = Translation.X * COORD_SCALE;\n        AnimTranslation.Y = Translation.Y * COORD_SCALE;\n        AnimTranslation.Z = Translation.Z * COORD_SCALE;\n\n        RootTranslation.Add(i, AnimTranslation);\n    }\n}\n\nFAnimVector UNightSkyAnimSequenceUserData::GetRootTranslationAtTime(int32 Time) const\n{\n    if (!RootTranslation.Contains(Time)) return FAnimVector{};\n    return RootTranslation[Time];\n}\n\nFAnimTransform UNightSkyAnimSequenceUserData::GetCachedBoneTransformAtTime(FName BoneName, int32 Time,\n                                                                           bool bRelativeToRoot) const\n{\n    if (!MeshSpaceBoneTransforms.Contains(BoneName)) return FAnimTransform{};\n    if (!MeshSpaceBoneTransforms[BoneName].Contains(Time)) return FAnimTransform{};\n    auto Transform = MeshSpaceBoneTransforms[BoneName][Time];\n\n    if (!bRelativeToRoot) return Transform;\n    if (!RootTranslation.Contains(Time)) return Transform;\n\n    auto Root = RootTranslation[Time];\n    Transform.Position.X += Root.X;\n    Transform.Position.Y += Root.Y;\n    Transform.Position.Z += Root.Z;\n    return Transform;\n}\n\nFAnimVector UNightSkyAnimSequenceUserData::GetCachedBoneLocationAtTime(FName BoneName, int32 Time,\n    bool bRelativeToRoot) const\n{\n    if (!MeshSpaceBoneTransforms.Contains(BoneName)) return FAnimVector{};\n    if (!MeshSpaceBoneTransforms[BoneName].Contains(Time)) return FAnimVector{};\n    auto Transform = MeshSpaceBoneTransforms[BoneName][Time];\n\n    if (!bRelativeToRoot) return Transform.Position;\n    if (!RootTranslation.Contains(Time)) return Transform.Position;\n\n    auto Root = RootTranslation[Time];\n    Transform.Position.X += Root.X;\n    Transform.Position.Y += Root.Y;\n    Transform.Position.Z += Root.Z;\n    return Transform.Position;\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_anim_sequence_user_data_8h/","title":"File NightSkyAnimSequenceUserData.h","text":"<p>FileList &gt; Animation &gt; NightSkyAnimSequenceUserData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Engine/AssetUserData.h\"</code></li> <li><code>#include \"NightSkyAnimSequenceUserData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_anim_sequence_user_data_8h/#classes","title":"Classes","text":"Type Name struct FAnimRotator struct FAnimTransform struct FAnimVector class UNightSkyAnimSequenceUserData"},{"location":"NightSkyEngine/_night_sky_anim_sequence_user_data_8h/#public-functions","title":"Public Functions","text":"Type Name FORCEINLINE FArchive operator&lt;&lt; (FArchive &amp; Ar, FAnimVector &amp; InVal)  FORCEINLINE FArchive operator&lt;&lt; (FArchive &amp; Ar, FAnimRotator &amp; InVal)  FORCEINLINE FArchive operator&lt;&lt; (FArchive &amp; Ar, FAnimTransform &amp; InVal)"},{"location":"NightSkyEngine/_night_sky_anim_sequence_user_data_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_night_sky_anim_sequence_user_data_8h/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>FORCEINLINE FArchive operator&lt;&lt; (\n    FArchive &amp; Ar,\n    FAnimVector &amp; InVal\n) \n</code></pre>"},{"location":"NightSkyEngine/_night_sky_anim_sequence_user_data_8h/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>FORCEINLINE FArchive operator&lt;&lt; (\n    FArchive &amp; Ar,\n    FAnimRotator &amp; InVal\n) \n</code></pre>"},{"location":"NightSkyEngine/_night_sky_anim_sequence_user_data_8h/#function-operator_2","title":"function operator&lt;&lt;","text":"<pre><code>FORCEINLINE FArchive operator&lt;&lt; (\n    FArchive &amp; Ar,\n    FAnimTransform &amp; InVal\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Animation/NightSkyAnimSequenceUserData.h</code></p>"},{"location":"NightSkyEngine/_night_sky_anim_sequence_user_data_8h_source/","title":"File NightSkyAnimSequenceUserData.h","text":"<p>File List &gt; Animation &gt; NightSkyAnimSequenceUserData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Engine/AssetUserData.h\"\n#include \"NightSkyAnimSequenceUserData.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FAnimVector\n{\n    GENERATED_BODY()\n\n    int32 X;\n    int32 Y;\n    int32 Z;\n};\n\nFORCEINLINE FArchive operator &lt;&lt;(FArchive&amp; Ar, FAnimVector&amp; InVal)\n{\n    Ar &lt;&lt; InVal.X;\n    Ar &lt;&lt; InVal.Y;\n    Ar &lt;&lt; InVal.Z;\n    return Ar;\n}\n\nUSTRUCT(BlueprintType)\nstruct FAnimRotator\n{\n    GENERATED_BODY()\n\n    int32 Pitch;\n    int32 Yaw;\n    int32 Roll;\n};\n\nFORCEINLINE FArchive operator &lt;&lt;(FArchive&amp; Ar, FAnimRotator&amp; InVal)\n{\n    Ar &lt;&lt; InVal.Pitch;\n    Ar &lt;&lt; InVal.Yaw;\n    Ar &lt;&lt; InVal.Roll;\n    return Ar;\n}\n\nUSTRUCT(BlueprintType)\nstruct FAnimTransform\n{\n    GENERATED_BODY()\n\n    FAnimVector Position;\n    FAnimRotator Rotation;\n    FAnimVector Scale;\n};\n\nFORCEINLINE FArchive operator &lt;&lt;(FArchive&amp; Ar, FAnimTransform&amp; InVal)\n{\n    Ar &lt;&lt; InVal.Position;\n    Ar &lt;&lt; InVal.Rotation;\n    Ar &lt;&lt; InVal.Scale;\n    return Ar;\n}\n\nUCLASS(EditInlineNew)\nclass NIGHTSKYENGINE_API UNightSkyAnimSequenceUserData : public UAssetUserData\n{\n    GENERATED_BODY()\n\nprivate:\n    UPROPERTY()\n    int32 FrameCount;\n\n    UPROPERTY()\n    int32 FrameRate;\n\n    TMap&lt;FName, TMap&lt;int32, FAnimTransform&gt;&gt; MeshSpaceBoneTransforms;\n    TMap&lt;int32, FAnimVector&gt; RootTranslation;\n\n    virtual void Serialize(FArchive&amp; Ar) override;\n\npublic:\n    virtual void PostEditChangeOwner(const FPropertyChangedEvent&amp; PropertyChangedEvent) override;\n\n    UFUNCTION(BlueprintPure)\n    int32 GetFrameCount() const\n    {\n        return FrameCount;\n    }\n\n    UFUNCTION(BlueprintPure)\n    int32 GetFrameRate() const\n    {\n        return FrameRate;\n    }\n\n    UFUNCTION(BlueprintPure)\n    FAnimVector GetRootTranslationAtTime(int32 Time) const;\n\n    UFUNCTION(BlueprintPure)\n    FAnimTransform GetCachedBoneTransformAtTime(FName BoneName, int32 Time, bool bRelativeToRoot) const;\n\n    UFUNCTION(BlueprintPure)\n    FAnimVector GetCachedBoneLocationAtTime(FName BoneName, int32 Time, bool bRelativeToRoot) const;\n};\n</code></pre>"},{"location":"NightSkyEngine/dir_0ffcc5e5c4d1b043480363e839fe227d/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/CPU","text":"<p>FileList &gt; Battle &gt; CPU</p>"},{"location":"NightSkyEngine/dir_0ffcc5e5c4d1b043480363e839fe227d/#files","title":"Files","text":"Type Name file NightSkyAIController.cpp file NightSkyAIController.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/CPU/</code></p>"},{"location":"NightSkyEngine/_night_sky_a_i_controller_8cpp/","title":"File NightSkyAIController.cpp","text":"<p>FileList &gt; Battle &gt; CPU &gt; NightSkyAIController.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyAIController.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/NightSkyGameState.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Objects/PlayerObject.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/CPU/NightSkyAIController.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_a_i_controller_8cpp_source/","title":"File NightSkyAIController.cpp","text":"<p>File List &gt; Battle &gt; CPU &gt; NightSkyAIController.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyAIController.h\"\n\n#include \"NightSkyEngine/Battle/NightSkyGameState.h\"\n#include \"NightSkyEngine/Battle/Objects/PlayerObject.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyAIController)\n\n// Sets default values\nANightSkyAIController::ANightSkyAIController()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ANightSkyAIController::BeginPlay()\n{\n    Super::BeginPlay();\n\n    GameState = Cast&lt;ANightSkyGameState&gt;(GetWorld()-&gt;GetGameState());\n}\n\nvoid ANightSkyAIController::Update()\n{\n    if (!Player) Player = GetPawn&lt;APlayerObject&gt;();\n\n    if (GameState-&gt;BattleState.TimeUntilRoundStart || Player-&gt;PlayerFlags &amp; PLF_RoundWinInputLock || !Player-&gt;IsOnScreen())\n    {\n        Player-&gt;StoredInputBuffer.Update(INP_Neutral, Player-&gt;IsStopped());\n        return;\n    }\n\n    if (Player-&gt;CurrentHealth &lt;= 0) return;\n\n    bBlock = false;\n\n    bool bDefendOnly = false;\n\n    if (Player-&gt;Enemy-&gt;CheckIsAttacking()\n        &amp;&amp; Player-&gt;Enemy-&gt;CheckEnemyInRange(\n            Player-&gt;Enemy-&gt;PrimaryStateMachine.CurrentState-&gt;CPUData.AttackXBeginRange, \n            Player-&gt;Enemy-&gt;PrimaryStateMachine.CurrentState-&gt;CPUData.AttackXEndRange,\n            Player-&gt;Enemy-&gt;PrimaryStateMachine.CurrentState-&gt;CPUData.AttackYBeginRange, \n            Player-&gt;Enemy-&gt;PrimaryStateMachine.CurrentState-&gt;CPUData.AttackYEndRange)\n        &amp;&amp; WaitCount &lt;= WaitLimit)\n    {\n        bDefendOnly = true;\n    }\n    else\n    {\n        WaitCount++;\n        if (WaitCount &lt;= WaitLimit) return;\n    }\n\n    TArray&lt;UState*&gt; AvailableStates{};\n    for (auto State : Player-&gt;PrimaryStateMachine.States)\n    {\n        if (!Player-&gt;CanEnterState(State, StateMachine_Primary)) continue;\n        AvailableStates.Add(State);\n    }\n\n    if (AvailableStates.Num() == 1)\n    {\n        ResetParams();\n        TargetState = AvailableStates[0];\n    }\n    else\n    {\n        auto MaxWeight = GameState-&gt;BattleState.RandomManager.RandRange(25, 75);;\n        UState* CurState = nullptr;\n        for (const auto State : AvailableStates)\n        {\n            int Weight;\n            if (bDefendOnly)\n            {\n                if (!State-&gt;CPUData.bAttack)\n                {\n                    Weight = CheckDefenseWeight(State);\n                    if (Weight &gt; MaxWeight)\n                    {\n                        MaxWeight = Weight;\n                        CurState = State;\n                    }\n                }\n                else\n                {\n                    Weight = CheckAttackWeight(State);\n                    if (Weight &gt; MaxWeight)\n                    {\n                        MaxWeight = Weight;\n                        CurState = State;\n                    }\n                }\n            }\n            else if (!State-&gt;CPUData.bAttack)\n            {\n                Weight = CheckBasicWeight(State);\n                if (Weight &gt; MaxWeight)\n                {\n                    MaxWeight = Weight;\n                    CurState = State;\n                }\n            }\n            else\n            {\n                Weight = CheckAttackWeight(State);\n                if (Weight &gt; MaxWeight)\n                {\n                    MaxWeight = Weight;\n                    CurState = State;\n                }\n            }\n        }\n        if (TargetState != CurState)\n        {\n            ResetParams();\n            TargetState = CurState;\n        }\n    }\n\n    InputCount = FMath::Max(InputCount - InputCountLimit, 0);\n    if (SetInputs()) ResetParams();\n}\n\nvoid ANightSkyAIController::ResetParams()\n{\n    WaitCount = 0;\n    InputCount = 0;\n    WaitLimit = 7;\n    if (Player-&gt;CheckIsAttacking()) WaitLimit = 0;\n    TargetState = nullptr;\n}\n\nbool ANightSkyAIController::SetInputs()\n{\n    if (!TargetState || TargetState-&gt;InputConditionLists.Num() == 0) return false;\n    for (auto Condition : TargetState-&gt;InputConditionLists[0].InputConditions)\n    {\n        if (InputCount &gt; InputCountLimit) return false;\n\n        Player-&gt;StoredInputBuffer.WriteInputCondition(Condition);\n        InputCount += Condition.Sequence.Num();\n    }\n\n    if (bBlock)\n    {\n        Player-&gt;StoredInputBuffer.InputBufferInternal[InputBufferSize - 1] |= INP_Left;\n    }\n\n    TargetState = nullptr;\n    return true;\n}\n\nint32 ANightSkyAIController::GetEnemyDistanceX() const\n{\n    if (!IsValid(Player)) return 0;\n    return Player-&gt;CalculateDistanceBetweenPoints(DIST_DistanceX, OBJ_Self, POS_Player, OBJ_Enemy, POS_Player);\n}\n\nint32 ANightSkyAIController::GetEnemyDistanceY() const\n{\n    if (!IsValid(Player)) return 0;\n    return Player-&gt;CalculateDistanceBetweenPoints(DIST_DistanceY, OBJ_Self, POS_Player, OBJ_Enemy, POS_Player);\n}\n\nint32 ANightSkyAIController::CheckBasicWeight(const UState* State) const\n{\n    if (!IsValid(Player)) return 0;\n\n    int Weight = 25;\n\n    switch (State-&gt;StateType)\n    {\n    case EStateType::Standing:\n    case EStateType::Crouching:\n        break;\n    case EStateType::NeutralJump:\n    case EStateType::ForwardJump:\n        if (GetEnemyDistanceY() &gt; 105000 &amp;&amp; Player-&gt;PosY &lt; Player-&gt;Enemy-&gt;PosY)\n        {\n            Weight += GameState-&gt;BattleState.RandomManager.RandRange(10, 25);\n        }\n        break;\n    case EStateType::ForwardAirDash:\n        if (GetEnemyDistanceX() &gt; 360000)\n        {\n            Weight += GameState-&gt;BattleState.RandomManager.RandRange(25, 50);\n        }\n        break;\n    case EStateType::BackwardJump:\n    case EStateType::BackwardAirDash:\n        Weight = GameState-&gt;BattleState.RandomManager.RandRange(10, 15);\n        if (Player-&gt;Enemy-&gt;CheckIsAttacking() &amp;&amp; GetEnemyDistanceX() &lt; 360000)\n        {\n            Weight += GameState-&gt;BattleState.RandomManager.RandRange(25, 50);\n        }\n        break;\n    case EStateType::ForwardWalk:\n        Weight += GameState-&gt;BattleState.RandomManager.RandRange(25, 80);\n        if (GetEnemyDistanceX() &gt; 420000)\n        {\n            Weight += GameState-&gt;BattleState.RandomManager.RandRange(30, 50);\n        }\n        if (Player-&gt;Enemy-&gt;CheckIsStunned())\n        {\n            Weight += GameState-&gt;BattleState.RandomManager.RandRange(15, 30);\n        }\n        break;\n    case EStateType::ForwardDash:\n        Weight += GameState-&gt;BattleState.RandomManager.RandRange(50, 100);\n        if (GetEnemyDistanceX() &gt; 640000)\n        {\n            Weight += GameState-&gt;BattleState.RandomManager.RandRange(15, 30);\n        }\n        if (Player-&gt;Enemy-&gt;CheckIsAttacking() &amp;&amp; GetEnemyDistanceX() &lt; 480000)\n        {\n            Weight -= GameState-&gt;BattleState.RandomManager.RandRange(25, 50);\n        }\n        if (Player-&gt;Enemy-&gt;CheckIsStunned())\n        {\n            Weight += GameState-&gt;BattleState.RandomManager.RandRange(15, 30);\n        }\n        if (Player-&gt;Direction == Player-&gt;Enemy-&gt;Direction)\n        {\n            Weight = 0;\n        }\n        break;\n    case EStateType::BackwardWalk:\n        Weight += GameState-&gt;BattleState.RandomManager.RandRange(10, 65);\n        if (Player-&gt;Enemy-&gt;CheckIsAttacking() &amp;&amp; GetEnemyDistanceX() &lt; 540000)\n        {\n            Weight += GameState-&gt;BattleState.RandomManager.RandRange(15, 35);\n        }\n        if (Player-&gt;Enemy-&gt;CheckIsStunned())\n        {\n            Weight -= GameState-&gt;BattleState.RandomManager.RandRange(10, 20);\n        }\n        break;\n    case EStateType::BackwardDash:\n        Weight += GameState-&gt;BattleState.RandomManager.RandRange(5, 30);\n        if (Player-&gt;Enemy-&gt;CheckIsAttacking() &amp;&amp; GetEnemyDistanceX() &lt; 540000)\n        {\n            Weight += GameState-&gt;BattleState.RandomManager.RandRange(10, 20);\n        }\n        if (Player-&gt;Enemy-&gt;CheckIsStunned())\n        {\n            Weight -= GameState-&gt;BattleState.RandomManager.RandRange(25, 50);\n        }\n        break;\n    case EStateType::Tech:\n        // TODO tech weight\n        Weight = 250;\n        break;\n    default:\n        break;\n    }\n\n    Weight += GameState-&gt;BattleState.RandomManager.RandRange(-50, 50);\n\n    return Weight;\n}\n\nint32 ANightSkyAIController::CheckAttackWeight(const UState* State) const\n{\n    if (!IsValid(Player)) return 0;\n\n    int32 Weight = GameState-&gt;BattleState.RandomManager.RandRange(25, 125);\n\n    if (!Player-&gt;CheckEnemyInRange(State-&gt;CPUData.AttackXBeginRange, State-&gt;CPUData.AttackXEndRange,\n                                   State-&gt;CPUData.AttackYBeginRange, State-&gt;CPUData.AttackYEndRange))\n        Weight -= 50;\n\n    if (Player-&gt;PosY &lt; Player-&gt;Enemy-&gt;PosY &amp;&amp; State-&gt;CPUData.bAntiAir) Weight += GameState-&gt;BattleState.RandomManager.RandRange(15, 40);\n\n    if (State-&gt;CPUData.bUsesResource) Weight -= GameState-&gt;BattleState.RandomManager.RandRange(15, 40);\n    if (State-&gt;CPUData.bBigDamage) Weight += GameState-&gt;BattleState.RandomManager.RandRange(15, 40);\n    if (State-&gt;CPUData.bNoCombo &amp;&amp; Player-&gt;ComboCounter) Weight -= GameState-&gt;BattleState.RandomManager.RandRange(15, 40);\n\n    switch (State-&gt;CPUData.AttackSpeed)\n    {\n    case ASPD_Fast:\n        Weight += GameState-&gt;BattleState.RandomManager.RandRange(15, 30);\n        break;\n    case ASPD_Medium:\n        break;\n    case ASPD_Slow:\n        Weight -= GameState-&gt;BattleState.RandomManager.RandRange(15, 30);\n        break;\n    default: break;\n    }\n\n    if (Player-&gt;Enemy-&gt;PrimaryStateMachine.CurrentState-&gt;StateType == EStateType::Hitstun)\n    {\n        if (State-&gt;CPUData.bThrow &amp;&amp; !State-&gt;CPUData.bCombo) Weight = 0;\n        if (State-&gt;CPUData.bCombo) Weight += GameState-&gt;BattleState.RandomManager.RandRange(80, 250);\n    }\n    else if (Player-&gt;IsEnemyBlocking())\n    {\n        if (State-&gt;CPUData.bBlockstring) Weight += GameState-&gt;BattleState.RandomManager.RandRange(15, 40);\n        if (Player-&gt;Enemy-&gt;GetCurrentStateName(StateMachine_Primary) == State_Universal_StandBlock)\n        {\n            if (State-&gt;CPUData.BlockType == BLK_Low) Weight += GameState-&gt;BattleState.RandomManager.RandRange(15, 40);\n        }\n        else if (Player-&gt;Enemy-&gt;GetCurrentStateName(StateMachine_Primary) == State_Universal_CrouchBlock)\n        {\n            if (State-&gt;CPUData.BlockType == BLK_High) Weight += GameState-&gt;BattleState.RandomManager.RandRange(15, 40);\n        }\n        else if (State-&gt;CPUData.BlockType == BLK_None) Weight += GameState-&gt;BattleState.RandomManager.RandRange(15, 40);\n\n        if (State-&gt;CPUData.bThrow)\n        {\n            if (Player-&gt;Enemy-&gt;CheckIsStunned()) Weight = 0;\n            else Weight += GameState-&gt;BattleState.RandomManager.RandRange(15, 40);\n        }\n    }\n    else\n    {\n        if (Player-&gt;Enemy-&gt;IsEnemyAttackState() &amp;&amp; State-&gt;CPUData.bPunish)\n        {\n            bool bInPunishRange = false;\n            switch (State-&gt;CPUData.PunishRange)\n            {\n            case RAN_Near:\n                bInPunishRange = GetEnemyDistanceX() &lt;= 360000;\n                break;\n            case RAN_Mid:\n                bInPunishRange = GetEnemyDistanceX() &gt; 360000 &amp;&amp; GetEnemyDistanceX() &lt;= 720000;\n                break;\n            case RAN_Far:\n                bInPunishRange = GetEnemyDistanceX() &gt; 720000;\n                break;\n            default:\n                break;\n            }\n\n            Weight += bInPunishRange ? GameState-&gt;BattleState.RandomManager.RandRange(15, 40) : 0;\n        }\n\n        if (State-&gt;CPUData.bInvuln) Weight += GameState-&gt;BattleState.RandomManager.RandRange(15, 40);\n    }\n    Weight += GameState-&gt;BattleState.RandomManager.RandRange(-25, 25);\n\n    return Weight;\n}\n\nint32 ANightSkyAIController::CheckDefenseWeight(const UState* State)\n{\n    if (!IsValid(Player)) return 0;\n\n    int Weight = 0;\n\n    switch (State-&gt;StateType)\n    {\n    case EStateType::Crouching:\n        Weight += GameState-&gt;BattleState.RandomManager.RandRange(50, 80);\n        if (Player-&gt;Enemy-&gt;GetAttackBlockType() == BLK_High)\n        {\n            Weight += GameState-&gt;BattleState.RandomManager.RandRange(25, 50);\n        }\n        break;\n    case EStateType::BackwardJump:\n    case EStateType::BackwardAirDash:\n        Weight += GameState-&gt;BattleState.RandomManager.RandRange(25, 50);\n        if (Player-&gt;Enemy-&gt;CheckIsAttacking() &amp;&amp; GetEnemyDistanceX() &lt; 360000)\n        {\n            Weight += GameState-&gt;BattleState.RandomManager.RandRange(25, 50);\n        }\n        break;\n    case EStateType::BackwardWalk:\n        Weight += GameState-&gt;BattleState.RandomManager.RandRange(25, 100);\n        if (Player-&gt;Enemy-&gt;CheckIsAttacking() &amp;&amp; GetEnemyDistanceX() &lt; 360000)\n        {\n            Weight += GameState-&gt;BattleState.RandomManager.RandRange(15, 35);\n        }\n        if (Player-&gt;Enemy-&gt;GetAttackBlockType() == BLK_Low)\n        {\n            Weight -= GameState-&gt;BattleState.RandomManager.RandRange(25, 50);\n        }\n        break;\n    case EStateType::BackwardDash:\n        Weight += GameState-&gt;BattleState.RandomManager.RandRange(50, 80);\n        if (Player-&gt;Enemy-&gt;CheckIsAttacking() &amp;&amp; GetEnemyDistanceX() &lt; 360000)\n        {\n            Weight += GameState-&gt;BattleState.RandomManager.RandRange(10, 20);\n        }\n        if (Player-&gt;Enemy-&gt;CheckIsStunned())\n        {\n            Weight -= GameState-&gt;BattleState.RandomManager.RandRange(25, 50);\n        }\n        break;\n    case EStateType::Tech:\n        // TODO tech weight\n        Weight = 250;\n        break;\n    default:\n        break;\n    }\n\n    bBlock = true;\n\n    Weight += GameState-&gt;BattleState.RandomManager.RandRange(-25, 50);\n\n    return Weight;\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_a_i_controller_8h/","title":"File NightSkyAIController.h","text":"<p>FileList &gt; Battle &gt; CPU &gt; NightSkyAIController.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Script/State.h\"</code></li> <li><code>#include \"Runtime/AIModule/Classes/AIController.h\"</code></li> <li><code>#include \"NightSkyAIController.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_a_i_controller_8h/#classes","title":"Classes","text":"Type Name class ANightSkyAIController <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/CPU/NightSkyAIController.h</code></p>"},{"location":"NightSkyEngine/_night_sky_a_i_controller_8h_source/","title":"File NightSkyAIController.h","text":"<p>File List &gt; Battle &gt; CPU &gt; NightSkyAIController.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NightSkyEngine/Battle/Script/State.h\"\n#include \"Runtime/AIModule/Classes/AIController.h\"\n#include \"NightSkyAIController.generated.h\"\n\nclass ANightSkyGameState;\nclass UState;\nclass APlayerObject;\n\nUCLASS()\nclass NIGHTSKYENGINE_API ANightSkyAIController : public AAIController\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ANightSkyAIController();\n\n    UPROPERTY(BlueprintReadOnly)\n    TObjectPtr&lt;APlayerObject&gt; Player = nullptr;\n    UPROPERTY(BlueprintReadOnly)\n    TObjectPtr&lt;ANightSkyGameState&gt; GameState = nullptr;\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\nprivate:\n    static constexpr int InputCountLimit = 2;\n\n    UPROPERTY()\n    UState* TargetState{};\n    int WaitCount = 0;\n    int WaitLimit = 7;\n    int InputCount = 0;\n    bool bBlock = false;\n\npublic:\n    // Called every frame\n    void Update();\n    void ResetParams();\n    bool SetInputs();\n\n    UFUNCTION(BlueprintCallable)\n    int32 GetEnemyDistanceX() const;\n    UFUNCTION(BlueprintCallable)\n    int32 GetEnemyDistanceY() const;\n\n    UFUNCTION(BlueprintCallable)\n    int32 CheckBasicWeight(const UState* State) const;\n    UFUNCTION(BlueprintCallable)\n    int32 CheckAttackWeight(const UState* State) const;\n    UFUNCTION(BlueprintCallable)\n    int32 CheckDefenseWeight(const UState* State);\n};\n</code></pre>"},{"location":"NightSkyEngine/dir_55fd23ec9dd9ced1aa4a37204be9832d/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners","text":"<p>FileList &gt; Battle &gt; FighterRunners</p>"},{"location":"NightSkyEngine/dir_55fd23ec9dd9ced1aa4a37204be9832d/#files","title":"Files","text":"Type Name file FighterLocalRunner.cpp file FighterLocalRunner.h file FighterMultiplayerRunner.cpp file FighterMultiplayerRunner.h file FighterReplayRunner.cpp file FighterReplayRunner.h file FighterSynctestRunner.cpp file FighterSynctestRunner.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/</code></p>"},{"location":"NightSkyEngine/_fighter_local_runner_8cpp/","title":"File FighterLocalRunner.cpp","text":"<p>FileList &gt; Battle &gt; FighterRunners &gt; FighterLocalRunner.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FighterLocalRunner.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/NightSkyGameState.h\"</code></li> <li><code>#include \"Kismet/GameplayStatics.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterLocalRunner.cpp</code></p>"},{"location":"NightSkyEngine/_fighter_local_runner_8cpp_source/","title":"File FighterLocalRunner.cpp","text":"<p>File List &gt; Battle &gt; FighterRunners &gt; FighterLocalRunner.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"FighterLocalRunner.h\"\n\n#include \"NightSkyEngine/Battle/NightSkyGameState.h\"\n#include \"Kismet/GameplayStatics.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(FighterLocalRunner)\n\n// Sets default values\nAFighterLocalRunner::AFighterLocalRunner()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = false;\n    bReplicates = false;\n}\n\n// Called when the game starts or when spawned\nvoid AFighterLocalRunner::BeginPlay()\n{\n    Super::BeginPlay();\n    TArray&lt;AActor*&gt; FoundFighterGameStates;\n    UGameplayStatics::GetAllActorsOfClass(GetWorld(), ANightSkyGameState::StaticClass(), FoundFighterGameStates);\n    if (FoundFighterGameStates.Num() &gt; 0)\n    {\n        GameState = Cast&lt;ANightSkyGameState&gt;(FoundFighterGameStates[0]);\n    }\n}\n\nvoid AFighterLocalRunner::Update(float DeltaTime)\n{\n    if (GameState-&gt;bPauseGame)\n        return;\n    ElapsedTime += DeltaTime;\n    while (ElapsedTime &gt;= OneFrame)\n    {\n        //while elapsed time is greater than one frame...\n        GameState-&gt;UpdateGameState();\n        ElapsedTime -= OneFrame;\n    }\n}\n</code></pre>"},{"location":"NightSkyEngine/_fighter_local_runner_8h/","title":"File FighterLocalRunner.h","text":"<p>FileList &gt; Battle &gt; FighterRunners &gt; FighterLocalRunner.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameFramework/Actor.h\"</code></li> <li><code>#include \"FighterLocalRunner.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_fighter_local_runner_8h/#classes","title":"Classes","text":"Type Name class AFighterLocalRunner <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterLocalRunner.h</code></p>"},{"location":"NightSkyEngine/_fighter_local_runner_8h_source/","title":"File FighterLocalRunner.h","text":"<p>File List &gt; Battle &gt; FighterRunners &gt; FighterLocalRunner.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"FighterLocalRunner.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API AFighterLocalRunner : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AFighterLocalRunner();\n\nprotected:\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Update(float DeltaTime);\n\nprotected:\n    float ElapsedTime = 0;\n\n    UPROPERTY()\n    class ANightSkyGameState* GameState;\n};\n</code></pre>"},{"location":"NightSkyEngine/_fighter_multiplayer_runner_8cpp/","title":"File FighterMultiplayerRunner.cpp","text":"<p>FileList &gt; Battle &gt; FighterRunners &gt; FighterMultiplayerRunner.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FighterMultiplayerRunner.h\"</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include \"Kismet/GameplayStatics.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/NightSkyGameState.h\"</code></li> <li><code>#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"</code></li> <li><code>#include \"NightSkyEngine/Network/RpcConnectionManager.h\"</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include \"Serialization/BufferArchive.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterMultiplayerRunner.cpp</code></p>"},{"location":"NightSkyEngine/_fighter_multiplayer_runner_8cpp_source/","title":"File FighterMultiplayerRunner.cpp","text":"<p>File List &gt; Battle &gt; FighterRunners &gt; FighterMultiplayerRunner.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"FighterMultiplayerRunner.h\"\n\n#include &lt;fstream&gt;\n\n#include \"Kismet/GameplayStatics.h\"\n#include \"NightSkyEngine/Battle/NightSkyGameState.h\"\n#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"\n#include \"NightSkyEngine/Network/RpcConnectionManager.h\"\n#include &lt;iostream&gt;\n\n#include \"Serialization/BufferArchive.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(FighterMultiplayerRunner)\n\n// Sets default values\nAFighterMultiplayerRunner::AFighterMultiplayerRunner()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = false;\n    bReplicates = false;\n    connectionManager = nullptr;\n}\n\n// Called when the game starts or when spawned\nvoid AFighterMultiplayerRunner::BeginPlay()\n{\n    Super::BeginPlay();\n    GGPOSessionCallbacks cb = CreateCallbacks();\n    connectionManager = new RpcConnectionManager();\n    GGPONet::ggpo_start_session(&amp;ggpo, &amp;cb, connectionManager, \"\", 2, sizeof(int));\n    GGPONet::ggpo_set_disconnect_timeout(ggpo, 45000);\n    GGPONet::ggpo_set_disconnect_notify_start(ggpo, 15000);\n    for (int i = 0; i &lt; 2; i++)\n    {\n        GGPOPlayerHandle handle;\n        GGPOPlayer* player = new GGPOPlayer();\n        player-&gt;type = GGPO_PLAYERTYPE_REMOTE;\n        if (i == GameState-&gt;GameInstance-&gt;PlayerIndex)\n        {\n            player-&gt;type = GGPO_PLAYERTYPE_LOCAL;\n            connectionManager-&gt;playerIndex = i == 0 ? 1 : 0;\n        }\n        player-&gt;player_num = i + 1;\n        player-&gt;connection_id = i;\n        GGPONet::ggpo_add_player(ggpo, player, &amp;handle);\n        if (player-&gt;type == GGPO_PLAYERTYPE_LOCAL)\n            GGPONet::ggpo_set_frame_delay(ggpo, handle, 2);\n        // TODO: Logic for framedelay (based on ping? or make user choose?)\n        Players.Add(player);\n        PlayerInputIndex.Add(-1);\n        PlayerHandles.Add(handle);\n    }\n    GGPONet::ggpo_try_synchronize_local(ggpo);\n}\n\nvoid AFighterMultiplayerRunner::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n    Super::EndPlay(EndPlayReason);\n\n    delete connectionManager;\n}\n\n\nGGPOSessionCallbacks AFighterMultiplayerRunner::CreateCallbacks()\n{\n    GGPOSessionCallbacks cb = {0};\n\n    cb.begin_game = std::bind(&amp;AFighterMultiplayerRunner::BeginGameCallback, this, std::placeholders::_1);\n    cb.save_game_state = std::bind(&amp;AFighterMultiplayerRunner::SaveGameStateCallback, this,\n                                   std::placeholders::_1, std::placeholders::_2, std::placeholders::_3,\n                                   std::placeholders::_4);\n    cb.load_game_state = std::bind(&amp;AFighterMultiplayerRunner::LoadGameStateCallback, this,\n                                   std::placeholders::_1, std::placeholders::_2);\n    cb.log_game_state = std::bind(&amp;AFighterMultiplayerRunner::LogGameState, this,\n                                  std::placeholders::_1, std::placeholders::_2, std::placeholders::_3);\n    cb.free_buffer = std::bind(&amp;AFighterMultiplayerRunner::FreeBuffer, this, std::placeholders::_1);\n    cb.advance_frame = std::bind(&amp;AFighterMultiplayerRunner::AdvanceFrameCallback, this, std::placeholders::_1);\n    cb.on_event = std::bind(&amp;AFighterMultiplayerRunner::OnEventCallback, this, std::placeholders::_1);\n\n    return cb;\n}\n\nbool AFighterMultiplayerRunner::BeginGameCallback(const char*)\n{\n    return true;\n}\n\nbool AFighterMultiplayerRunner::SaveGameStateCallback(unsigned char** buffer, int32* len, int32* checksum, int32)\n{\n    FRollbackData RollbackData = FRollbackData();\n    GameState-&gt;SaveGameState(RollbackData, checksum);\n    FBufferArchive Ar(false);\n    Ar.SetWantBinaryPropertySerialization(true);\n    RollbackData.Serialize(Ar);\n\n    *len = Ar.Num();\n    *buffer = new unsigned char[*len];\n\n    FMemory::Memcpy(*buffer, Ar.GetData(), Ar.Num());\n    return true;\n}\n\nbool AFighterMultiplayerRunner::LoadGameStateCallback(unsigned char* buffer, int32 len)\n{\n    FRollbackData RollbackData = FRollbackData();\n\n    const TArray BPArray(buffer, len);\n    FMemoryReader Ar(BPArray);\n    Ar.SetWantBinaryPropertySerialization(true);\n    RollbackData.Serialize(Ar);\n\n    GameState-&gt;LoadGameState(RollbackData);\n    return true;\n}\n\nbool AFighterMultiplayerRunner::LogGameState(const char* filename, unsigned char* buffer, int len)\n{\n    FString savedDir = FPaths::ConvertRelativePathToFull(FPaths::ProjectSavedDir());\n\n    savedDir.Append(filename);\n    std::ofstream file;\n    file.open(TCHAR_TO_ANSI(*savedDir));\n    if (file.is_open())\n    {\n        FRollbackData RollbackData = FRollbackData();\n        const TArray BPArray(buffer, len);\n        FMemoryReader Ar(BPArray);\n        Ar.SetWantBinaryPropertySerialization(true);\n        RollbackData.Serialize(Ar);\n\n        file &lt;&lt; \"GameState:\\n\";\n        FBattleState BattleState = FBattleState();\n        FMemory::Memcpy(&amp;BattleState.BattleStateSync, RollbackData.BattleStateBuffer.GetData(), SizeOfBattleState);\n        file &lt;&lt; \"\\tFrameNumber: \" &lt;&lt; BattleState.FrameNumber &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tActiveObjectCount: \" &lt;&lt; BattleState.ActiveObjectCount &lt;&lt; std::endl;\n        for (int i = 0; i &lt; GameState-&gt;MaxBattleObjects; i++)\n        {\n            if (RollbackData.ObjActive[i])\n            {\n                FBattleObjectLog BattleObject = FBattleObjectLog();\n                FMemory::Memcpy(reinterpret_cast&lt;char*&gt;(&amp;BattleObject) + offsetof(FBattleObjectLog, ObjSync),\n                                RollbackData.ObjBuffer[i].GetData(), SizeOfBattleObject);\n                BattleObject.LogForSyncTestFile(file);\n            }\n        }\n        for (int i = GameState-&gt;MaxBattleObjects; i &lt; GameState-&gt;MaxBattleObjects + GameState-&gt;Players.Num(); i++)\n        {\n            FPlayerObjectLog PlayerObject = FPlayerObjectLog();\n            FMemory::Memcpy(reinterpret_cast&lt;char*&gt;(&amp;PlayerObject) + offsetof(FBattleObjectLog, ObjSync),\n                            RollbackData.ObjBuffer[i].GetData(), SizeOfBattleObject);\n            FMemory::Memcpy(reinterpret_cast&lt;char*&gt;(&amp;PlayerObject) + offsetof(FPlayerObjectLog, PlayerSync),\n                            RollbackData.CharBuffer[i - GameState-&gt;MaxBattleObjects].GetData(), SizeOfPlayerObject);\n            PlayerObject.LogForSyncTestFile(file);\n        }\n\n        file &lt;&lt; \"RawRollbackData:\\n\";\n        file &lt;&lt; \"\\tStateBuffer:\\n\";\n        file &lt;&lt; \"\\n\\t0: \";\n        for (int x = 0; x &lt; SizeOfBattleState; x++)\n        {\n            file &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; static_cast&lt;int&gt;(RollbackData.BattleStateBuffer[x]) &lt;&lt; \" \";\n            if ((x + 1) % 16 == 0)\n            {\n                file &lt;&lt; \"\\n\\t\" &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; x + 1 &lt;&lt; \": \";\n            }\n        }\n        file &lt;&lt; \"\\n\";\n        file &lt;&lt; \"\\tStateData:\\n\";\n        file &lt;&lt; \"\\n\\t0: \";\n        for (int x = 0; x &lt; RollbackData.BattleStateData.Num(); x++)\n        {\n            file &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; static_cast&lt;int&gt;(RollbackData.BattleStateData[x]) &lt;&lt; \" \";\n            if ((x + 1) % 16 == 0)\n            {\n                file &lt;&lt; \"\\n\\t\" &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; x + 1 &lt;&lt; \": \";\n            }\n        }\n        file &lt;&lt; \"\\n\";\n        file &lt;&lt; \"\\tObjBuffer:\\n\";\n        for (int i = 0; i &lt; GameState-&gt;MaxBattleObjects + GameState-&gt;Players.Num(); i++)\n        {\n            file &lt;&lt; \"Object \" &lt;&lt; i &lt;&lt; \":\\n\";\n            file &lt;&lt; \"\\n\\t0: \";\n            for (int x = 0; x &lt; SizeOfBattleObject; x++)\n            {\n                if (RollbackData.ObjBuffer[i].IsEmpty()) continue;\n                file &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; static_cast&lt;int&gt;(RollbackData.ObjBuffer[i][x]) &lt;&lt; \" \";\n                if ((x + 1) % 16 == 0)\n                {\n                    file &lt;&lt; \"\\n\\t\" &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; x + 1 &lt;&lt; \": \";\n                }\n            }\n            file &lt;&lt; \"\\n\";\n        }\n        file &lt;&lt; \"\\n\";\n        file &lt;&lt; \"\\tObjActive:\\n\";\n        for (int i = 0; i &lt; GameState-&gt;MaxBattleObjects; i++)\n        {\n            file &lt;&lt; RollbackData.ObjActive[i] &lt;&lt; \" \";\n        }\n        file &lt;&lt; \"\\n\";\n        file &lt;&lt; \"\\tPlayerBuffer:\\n\";\n        for (int i = 0; i &lt; GameState-&gt;Players.Num(); i++)\n        {\n            file &lt;&lt; \"Player \" &lt;&lt; i &lt;&lt; \":\\n\";\n            file &lt;&lt; \"\\n\\t0: \";\n            for (int x = 0; x &lt; SizeOfPlayerObject; x++)\n            {\n                file &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; static_cast&lt;int&gt;(RollbackData.CharBuffer[i][x]) &lt;&lt; \" \";\n                if ((x + 1) % 16 == 0)\n                {\n                    file &lt;&lt; \"\\n\\t\" &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; x + 1 &lt;&lt; \": \";\n                }\n            }\n            file &lt;&lt; \"\\n\";\n        }\n        file &lt;&lt; \"\\tPlayerData:\\n\";\n        file &lt;&lt; \"\\n\\t0: \";\n        for (int i = 0; i &lt; GameState-&gt;Players.Num(); i++)\n        {\n            file &lt;&lt; \"Player \" &lt;&lt; i &lt;&lt; \":\\n\";\n            file &lt;&lt; \"\\n\\t0: \";\n            for (int x = 0; x &lt; RollbackData.PlayerData[i].Num(); x++)\n            {\n                file &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; static_cast&lt;int&gt;(RollbackData.PlayerData[i][x]) &lt;&lt; \" \";\n                if ((x + 1) % 16 == 0)\n                {\n                    file &lt;&lt; \"\\n\\t\" &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; x + 1 &lt;&lt; \": \";\n                }\n            }\n            file &lt;&lt; \"\\n\";\n        }\n        file &lt;&lt; \"\\n\";\n\n        file.close();\n    }\n    return true;\n}\n\nvoid AFighterMultiplayerRunner::FreeBuffer(void* buffer)\n{\n    delete[] static_cast&lt;char*&gt;(buffer);\n}\n\nbool AFighterMultiplayerRunner::AdvanceFrameCallback(int flag)\n{\n    int inputs[2] = {0};\n    int disconnect_flags;\n    GGPONet::ggpo_synchronize_input(ggpo, (void*)inputs, sizeof(int) * 2, &amp;disconnect_flags);\n    GameState-&gt;UpdateGameState(inputs[0], inputs[1], true);\n    GGPONet::ggpo_advance_frame(ggpo);\n    return true;\n}\n\nbool AFighterMultiplayerRunner::OnEventCallback(GGPOEvent* info)\n{\n    int progress;\n    switch (info-&gt;code)\n    {\n    case GGPO_EVENTCODE_CONNECTED_TO_PEER:\n        UE_LOG(LogTemp, Warning, TEXT(\"GGPO_EVENTCODE_CONNECTED_TO_PEER\"));\n        break;\n    case GGPO_EVENTCODE_SYNCHRONIZING_WITH_PEER:\n        UE_LOG(LogTemp, Warning, TEXT(\"GGPO_EVENTCODE_SYNCHRONIZING_WITH_PEER\"));\n    //synchronized = false;\n        progress = 100 * info-&gt;u.synchronizing.count / info-&gt;u.synchronizing.total;\n        break;\n    case GGPO_EVENTCODE_SYNCHRONIZED_WITH_PEER:\n        UE_LOG(LogTemp, Warning, TEXT(\"GGPO_EVENTCODE_SYNCHRONIZED_WITH_PEER\"));\n        if (GameState-&gt;GameInstance-&gt;FighterRunner == Multiplayer &amp;&amp; !GameState-&gt;GameInstance-&gt;IsReplay)\n        {\n            GameState-&gt;GameInstance-&gt;EndRecordReplay();\n            GameState-&gt;GameInstance-&gt;RecordReplay();\n        }\n    //synchronized = true;\n        break;\n    case GGPO_EVENTCODE_RUNNING:\n        UE_LOG(LogTemp, Warning, TEXT(\"GGPO_EVENTCODE_RUNNING\"));\n\n        break;\n    case GGPO_EVENTCODE_CONNECTION_INTERRUPTED:\n        UE_LOG(LogTemp, Warning, TEXT(\"GGPO_EVENTCODE_CONNECTION_INTERRUPTED\"));\n    // connectionLost = true;\n    // FightGameInstance-&gt;ErrorMessage = FString(\"Connection interrupted\");\n    // EndOnline(true);\n        UGameplayStatics::OpenLevel(GetGameInstance(), FName(TEXT(\"MainMenu_PL\")));\n        break;\n    case GGPO_EVENTCODE_CONNECTION_RESUMED:\n        //connectionLost = false;\n        UE_LOG(LogTemp, Warning, TEXT(\"GGPO_EVENTCODE_CONNECTION_RESUMED\"));\n\n        break;\n    case GGPO_EVENTCODE_DISCONNECTED_FROM_PEER:\n        UE_LOG(LogTemp, Warning, TEXT(\"GGPO_EVENTCODE_DISCONNECTED_FROM_PEER\"));\n        UGameplayStatics::OpenLevel(GetGameInstance(), FName(TEXT(\"MainMenu_PL\")));\n    //FightGameInstance-&gt;ErrorMessage = FString(\"Enemy disconnected\");\n    //EndOnline(true);\n        break;\n    case GGPO_EVENTCODE_TIMESYNC:\n        UE_LOG(LogTemp, Warning, TEXT(\"GGPO_EVENTCODE_TIMESYNC\"));\n    //if(MultipliedFramesAhead&gt;3)\n        {\n            MultipliedFramesAhead = info-&gt;u.timesync.frames_ahead * TimesyncMultiplier;\n        }\n        break;\n    case GGPO_EVENTCODE_TIMESYNC_BEHIND:\n        UE_LOG(LogTemp, Warning, TEXT(\"GGPO_EVENTCODE_TIMESYNC_BEHIND\"));\n    //MultipliedFramesBehind=info-&gt;u.timesync.frames_ahead*TimesyncMultiplier;\n        break;\n    }\n    return true;\n}\n\n\nvoid AFighterMultiplayerRunner::GgpoUpdate()\n{\n    GGPOErrorCode result = GGPOErrorCode::GGPO_OK;\n    int disconnect_flags;\n    int inputs[2] = {0};\n    for (int i = 0; i &lt; 2; ++i)\n    {\n        if (Players[i]-&gt;type == GGPO_PLAYERTYPE_LOCAL)\n        {\n            int input = 0;\n            if (PlayerInputIndex[i] == -1)\n            {\n                for (int index = 0; index &lt; 4; index++)\n                {\n                    input |= GameState-&gt;GetLocalInputs(index);\n                }\n            }\n            else\n            {\n                input = GameState-&gt;GetLocalInputs(PlayerInputIndex[i]);\n            }\n\n            result = GGPONet::ggpo_add_local_input(ggpo, PlayerHandles[i], &amp;input, sizeof(input));\n        }\n    }\n    if (GGPO_SUCCEEDED(result))\n    {\n        result = GGPONet::ggpo_synchronize_input(ggpo, (void*)inputs, sizeof(int) * 2, &amp;disconnect_flags);\n        if (GGPO_SUCCEEDED(result))\n        {\n            GameState-&gt;UpdateGameState(inputs[0], inputs[1], false);\n            GGPONet::ggpo_advance_frame(ggpo);\n        }\n    }\n}\n\nvoid AFighterMultiplayerRunner::Update(float DeltaTime)\n{\n    ElapsedTime += DeltaTime;\n\n    while (ElapsedTime &gt;= OneFrame)\n    {\n        if (MultipliedFramesAhead &gt; 0)\n        {\n            int ahead = MultipliedFramesAhead;\n            MultipliedFramesAhead--;\n            if (ahead % TimesyncMultiplier == 0)\n            {\n                ElapsedTime = 0;\n                break;\n            }\n        }\n        GgpoUpdate();\n        ElapsedTime -= OneFrame;\n        // if(MultipliedFramesBehind&gt;0)\n        // {\n        //  MultipliedFramesBehind--;\n        //  if(MultipliedFramesBehind%TimesyncMultiplier)\n        //  {\n        //      accumulatorBreaker=0;\n        //      ElapsedTime += OneFrame;\n        //  }   \n        // }\n        //\n    }\n    GGPONet::ggpo_idle(ggpo, 1);\n}\n\n\n//TODO refactor to a static libaray\nint\nAFighterMultiplayerRunner::fletcher32_checksum(short* data, size_t len)\n{\n    int sum1 = 0xffff, sum2 = 0xffff;\n\n    while (len)\n    {\n        size_t tlen = len &gt; 360 ? 360 : len;\n        len -= tlen;\n        do\n        {\n            sum1 += *data++;\n            sum2 += sum1;\n        }\n        while (--tlen);\n        sum1 = (sum1 &amp; 0xffff) + (sum1 &gt;&gt; 16);\n        sum2 = (sum2 &amp; 0xffff) + (sum2 &gt;&gt; 16);\n    }\n\n    /* Second reduction step to reduce sums to 16 bits */\n    sum1 = (sum1 &amp; 0xffff) + (sum1 &gt;&gt; 16);\n    sum2 = (sum2 &amp; 0xffff) + (sum2 &gt;&gt; 16);\n    return sum2 &lt;&lt; 16 | sum1;\n}\n</code></pre>"},{"location":"NightSkyEngine/_fighter_multiplayer_runner_8h/","title":"File FighterMultiplayerRunner.h","text":"<p>FileList &gt; Battle &gt; FighterRunners &gt; FighterMultiplayerRunner.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"FighterLocalRunner.h\"</code></li> <li><code>#include \"include/ggponet.h\"</code></li> <li><code>#include \"FighterMultiplayerRunner.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_fighter_multiplayer_runner_8h/#classes","title":"Classes","text":"Type Name class AFighterMultiplayerRunner"},{"location":"NightSkyEngine/_fighter_multiplayer_runner_8h/#public-attributes","title":"Public Attributes","text":"Type Name int TimesyncMultiplier   = <code>4</code>"},{"location":"NightSkyEngine/_fighter_multiplayer_runner_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/_fighter_multiplayer_runner_8h/#variable-timesyncmultiplier","title":"variable TimesyncMultiplier","text":"<pre><code>int TimesyncMultiplier;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterMultiplayerRunner.h</code></p>"},{"location":"NightSkyEngine/_fighter_multiplayer_runner_8h_source/","title":"File FighterMultiplayerRunner.h","text":"<p>File List &gt; Battle &gt; FighterRunners &gt; FighterMultiplayerRunner.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"FighterLocalRunner.h\"\n#include \"include/ggponet.h\"\n#include \"FighterMultiplayerRunner.generated.h\"\n\nconstexpr int TimesyncMultiplier = 4;\n\nUCLASS()\nclass NIGHTSKYENGINE_API AFighterMultiplayerRunner : public AFighterLocalRunner\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AFighterMultiplayerRunner();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n    virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n\n    GGPOSessionCallbacks CreateCallbacks();\n    bool __cdecl BeginGameCallback(const char*);\n    bool __cdecl SaveGameStateCallback(unsigned char** buffer, int32* len, int32* checksum, int32);\n    bool __cdecl LoadGameStateCallback(unsigned char* buffer, int32 len);\n    bool __cdecl LogGameState(const char* filename, unsigned char* buffer, int len);\n    void __cdecl FreeBuffer(void* buffer);\n    bool __cdecl AdvanceFrameCallback(int32);\n    bool __cdecl OnEventCallback(GGPOEvent* info);\n\npublic:\n    GGPOSession* ggpo = nullptr;\n    TArray&lt;GGPOPlayerHandle&gt; PlayerHandles;\n    TArray&lt;GGPOPlayer*&gt; Players;\n\nprotected:\n    TArray&lt;int&gt; PlayerInputIndex;\n    void GgpoUpdate();\n\n    int MultipliedFramesAhead = 0;\n    int MultipliedFramesBehind = 0;\n\npublic:\n    virtual void Update(float DeltaTime) override;\n    class RpcConnectionManager* connectionManager;\n\n    static int fletcher32_checksum(short* data, size_t len);\n};\n</code></pre>"},{"location":"NightSkyEngine/_fighter_replay_runner_8cpp/","title":"File FighterReplayRunner.cpp","text":"<p>FileList &gt; Battle &gt; FighterRunners &gt; FighterReplayRunner.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FighterReplayRunner.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/NightSkyGameState.h\"</code></li> <li><code>#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterReplayRunner.cpp</code></p>"},{"location":"NightSkyEngine/_fighter_replay_runner_8cpp_source/","title":"File FighterReplayRunner.cpp","text":"<p>File List &gt; Battle &gt; FighterRunners &gt; FighterReplayRunner.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"FighterReplayRunner.h\"\n\n#include \"NightSkyEngine/Battle/NightSkyGameState.h\"\n#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(FighterReplayRunner)\n\n// Sets default values\nAFighterReplayRunner::AFighterReplayRunner()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AFighterReplayRunner::BeginPlay()\n{\n    Super::BeginPlay();\n    GameInstance = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance());\n}\n\nvoid AFighterReplayRunner::Update(float DeltaTime)\n{\n    if (GameState-&gt;bPauseGame)\n        return;\n    ElapsedTime += DeltaTime;\n    while (ElapsedTime &gt;= OneFrame)\n    {\n        //while elapsed time is greater than one frame...\n        int32 P1Input = 0;\n        int32 P2Input = 0;\n\n        GameInstance-&gt;PlayReplayToGameState(GameState-&gt;LocalFrame, P1Input, P2Input);\n\n        GameState-&gt;UpdateGameState(P1Input, P2Input, false);\n        ElapsedTime -= OneFrame;\n    }\n}\n</code></pre>"},{"location":"NightSkyEngine/_fighter_replay_runner_8h/","title":"File FighterReplayRunner.h","text":"<p>FileList &gt; Battle &gt; FighterRunners &gt; FighterReplayRunner.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"FighterLocalRunner.h\"</code></li> <li><code>#include \"FighterReplayRunner.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_fighter_replay_runner_8h/#classes","title":"Classes","text":"Type Name class AFighterReplayRunner <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterReplayRunner.h</code></p>"},{"location":"NightSkyEngine/_fighter_replay_runner_8h_source/","title":"File FighterReplayRunner.h","text":"<p>File List &gt; Battle &gt; FighterRunners &gt; FighterReplayRunner.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"FighterLocalRunner.h\"\n#include \"FighterReplayRunner.generated.h\"\n\nclass UNightSkyGameInstance;\n\nUCLASS()\nclass NIGHTSKYENGINE_API AFighterReplayRunner : public AFighterLocalRunner\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AFighterReplayRunner();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\n    UPROPERTY()\n    UNightSkyGameInstance* GameInstance;\n\npublic:\n    // Called every frame\n    virtual void Update(float DeltaTime) override;\n};\n</code></pre>"},{"location":"NightSkyEngine/_fighter_synctest_runner_8cpp/","title":"File FighterSynctestRunner.cpp","text":"<p>FileList &gt; Battle &gt; FighterRunners &gt; FighterSynctestRunner.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"FighterSynctestRunner.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/NightSkyGameState.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterSynctestRunner.cpp</code></p>"},{"location":"NightSkyEngine/_fighter_synctest_runner_8cpp_source/","title":"File FighterSynctestRunner.cpp","text":"<p>File List &gt; Battle &gt; FighterRunners &gt; FighterSynctestRunner.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"FighterSynctestRunner.h\"\n#include \"NightSkyEngine/Battle/NightSkyGameState.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(FighterSynctestRunner)\n\n// Sets default values\nAFighterSynctestRunner::AFighterSynctestRunner()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = false;\n    bReplicates = false;\n}\n\n// Called when the game starts or when spawned\nvoid AFighterSynctestRunner::BeginPlay()\n{\n    AFighterLocalRunner::BeginPlay();\n    GGPOSessionCallbacks cb = CreateCallbacks();\n    GGPONet::ggpo_start_synctest(&amp;ggpo, &amp;cb, \"\", 2, sizeof(int), 6);\n    GGPONet::ggpo_set_disconnect_timeout(ggpo, 45000);\n    GGPONet::ggpo_set_disconnect_notify_start(ggpo, 15000);\n    for (int i = 0; i &lt; 2; i++)\n    {\n        GGPOPlayerHandle handle;\n        GGPOPlayer* player = new GGPOPlayer();\n        player-&gt;type = GGPO_PLAYERTYPE_LOCAL;\n        player-&gt;player_num = i + 1;\n        GGPONet::ggpo_add_player(ggpo, player, &amp;handle);\n        Players.Add(player);\n        PlayerInputIndex.Add(i);\n        PlayerHandles.Add(handle);\n    }\n    GGPONet::ggpo_try_synchronize_local(ggpo);\n}\n\nvoid AFighterSynctestRunner::Update(float DeltaTime)\n{\n    ElapsedTime += DeltaTime;\n    while (ElapsedTime &gt;= OneFrame)\n    {\n        GgpoUpdate();\n        ElapsedTime -= OneFrame;\n    }\n    GGPONet::ggpo_idle(ggpo, 1);\n}\n</code></pre>"},{"location":"NightSkyEngine/_fighter_synctest_runner_8h/","title":"File FighterSynctestRunner.h","text":"<p>FileList &gt; Battle &gt; FighterRunners &gt; FighterSynctestRunner.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"FighterMultiplayerRunner.h\"</code></li> <li><code>#include \"FighterSynctestRunner.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_fighter_synctest_runner_8h/#classes","title":"Classes","text":"Type Name class AFighterSynctestRunner <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/FighterRunners/FighterSynctestRunner.h</code></p>"},{"location":"NightSkyEngine/_fighter_synctest_runner_8h_source/","title":"File FighterSynctestRunner.h","text":"<p>File List &gt; Battle &gt; FighterRunners &gt; FighterSynctestRunner.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"FighterMultiplayerRunner.h\"\n#include \"FighterSynctestRunner.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API AFighterSynctestRunner : public AFighterMultiplayerRunner\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    AFighterSynctestRunner();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void Update(float DeltaTime) override;\n};\n</code></pre>"},{"location":"NightSkyEngine/dir_4fd921e402b7a240656c31e280e3875c/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc","text":"<p>FileList &gt; Battle &gt; Misc</p>"},{"location":"NightSkyEngine/dir_4fd921e402b7a240656c31e280e3875c/#files","title":"Files","text":"Type Name file Bitflags.h file CollisionBox.h file Globals.cpp file Globals.h file InputBuffer.cpp file InputBuffer.h file NightSkyBlueprintFunctionLibrary.cpp file NightSkyBlueprintFunctionLibrary.h file RandomManager.cpp file RandomManager.h file SerializableObj.cpp file SerializableObj.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/</code></p>"},{"location":"NightSkyEngine/_bitflags_8h/","title":"File Bitflags.h","text":"<p>FileList &gt; Battle &gt; Misc &gt; Bitflags.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_bitflags_8h/#public-types","title":"Public Types","text":"Type Name enum EAttackFlags enum ECancelFlags enum EEnableFlags enum EInputFlags enum EInvulnFlags enum EMiscFlags enum EPlayerFlags"},{"location":"NightSkyEngine/_bitflags_8h/#public-functions","title":"Public Functions","text":"Type Name ENUM_CLASS_FLAGS (EInputFlags)  ENUM_CLASS_FLAGS (EEnableFlags)"},{"location":"NightSkyEngine/_bitflags_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"NightSkyEngine/_bitflags_8h/#enum-eattackflags","title":"enum EAttackFlags","text":"<pre><code>enum EAttackFlags {\n    ATK_HitActive = 0x1 UMETA(DisplayName = \"Hit Active\"),\n    ATK_IsAttacking = 0x2 UMETA(DisplayName = \"Is Attacking\"),\n    ATK_AttackHeadAttribute = 0x4 UMETA(DisplayName = \"Head Attribute\"),\n    ATK_AttackProjectileAttribute = 0x8 UMETA(DisplayName = \"Projectile Attribute\"),\n    ATK_HasHit = 0x10 UMETA(DisplayName = \"Has Hit\"),\n    ATK_ProrateOnce = 0x20 UMETA(DisplayName = \"Prorate Once\"),\n    ATK_IgnoreOTG = 0x40 UMETA(DisplayName = \"Ignore OTG\"),\n    ATK_IgnorePushbackScaling = 0x80 UMETA(DisplayName = \"Ignore Pushback Scaling\"),\n    ATK_IgnoreHitstunScaling = 0x100 UMETA(DisplayName = \"Ignore Hitstun Scaling\"),\n    ATK_SetPlayerHit = 0x200 UMETA(DisplayName = \"Ignore Hitstun Scaling\"),\n    ATK_HitOTG = 0x400 UMETA(DisplayName = \"Hit OTG\")\n};\n</code></pre> <p>Object attack flags. </p>"},{"location":"NightSkyEngine/_bitflags_8h/#enum-ecancelflags","title":"enum ECancelFlags","text":"<pre><code>enum ECancelFlags {\n    CNC_ChainCancelEnabled = 0x1 UMETA(DisplayName = \"Is Chain Cancel Enabled\"),\n    CNC_WhiffCancelEnabled = 0x2 UMETA(DisplayName = \"Is Whiff Cancel Enabled\"),\n    CNC_SpecialCancel = 0x4 UMETA(DisplayName = \"Is Special Cancel Enabled\"),\n    CNC_SuperCancel = 0x8 UMETA(DisplayName = \"Is Super Cancel Enabled\"),\n    CNC_JumpCancel = 0x10 UMETA(DisplayName = \"Is Jump Cancel Enabled\"),\n    CNC_FAirDashCancel = 0x20 UMETA(DisplayName = \"Is Forward Air Dash Cancel Enabled\"),\n    CNC_BAirDashCancel = 0x40 UMETA(DisplayName = \"Is Backward Air Dash Cancel Enabled\"),\n    CNC_EnableKaraCancel = 0x80 UMETA(DisplayName = \"Is Kara Cancel Enabled\"),\n    CNC_CancelIntoSelf = 0x100 UMETA(DisplayName = \"Is Cancel Into Self Enabled\"),\n    CNC_EnableReverseBeat = 0x200 UMETA(DisplayName = \"Is Reverse Beat Enabled\")\n};\n</code></pre> <p>Player cancel flags. </p>"},{"location":"NightSkyEngine/_bitflags_8h/#enum-eenableflags","title":"enum EEnableFlags","text":"<pre><code>enum EEnableFlags {\n    ENB_None = 0x0 UMETA(Hidden),\n    ENB_Standing = 0x1 UMETA(DisplayName = \"Standing\"),\n    ENB_Crouching = 0x2 UMETA(DisplayName = \"Crouching\"),\n    ENB_Jumping = 0x4 UMETA(DisplayName = \"Jumping\"),\n    ENB_ForwardWalk = 0x8 UMETA(DisplayName = \"Forward Walk\"),\n    ENB_BackWalk = 0x10 UMETA(DisplayName = \"Backward Walk\"),\n    ENB_ForwardDash = 0x20 UMETA(DisplayName = \"Forward Dash\"),\n    ENB_BackDash = 0x40 UMETA(DisplayName = \"Backward Dash\"),\n    ENB_ForwardAirDash = 0x80 UMETA(DisplayName = \"Forward Air Dash\"),\n    ENB_BackAirDash = 0x100 UMETA(DisplayName = \"Backward Air Dash\"),\n    ENB_NormalAttack = 0x200 UMETA(DisplayName = \"Normal Attack\"),\n    ENB_SpecialAttack = 0x400 UMETA(DisplayName = \"Special Attack\"),\n    ENB_SuperAttack = 0x800 UMETA(DisplayName = \"Super Attack\"),\n    ENB_Block = 0x1000 UMETA(DisplayName = \"Block\"),\n    ENB_ProximityBlock = 0x2000 UMETA(DisplayName = \"Proximity Block\"),\n    ENB_Tech = 0x4000 UMETA(DisplayName = \"Tech\"),\n    ENB_Burst = 0x8000 UMETA(DisplayName = \"Burst\"),\n    ENB_Tag = 0x10000 UMETA(DisplayName = \"Tag\"),\n    ENB_Assist = 0x20000 UMETA(DisplayName = \"Assist\")\n};\n</code></pre> <p>Flags used to enable or disable specific states or actions. </p>"},{"location":"NightSkyEngine/_bitflags_8h/#enum-einputflags","title":"enum EInputFlags","text":"<pre><code>enum EInputFlags {\n    INP_None = 0x0 UMETA(DisplayName = \"None\"),\n    INP_Up = 0x1 UMETA(DisplayName = \"Up\"),\n    INP_Down = 0x2 UMETA(DisplayName = \"Down\"),\n    INP_Left = 0x4 UMETA(DisplayName = \"Left\"),\n    INP_Right = 0x8 UMETA(DisplayName = \"Right\"),\n    INP_UpLeft = INP_Up + INP_Left UMETA(Hidden),\n    INP_UpRight = INP_Up + INP_Right UMETA(Hidden),\n    INP_DownLeft = INP_Down + INP_Left UMETA(Hidden),\n    INP_DownRight = INP_Down + INP_Right UMETA(Hidden),\n    INP_Neutral = 0x10 UMETA(DisplayName = \"Neutral\"),\n    INP_A = 0x20 UMETA(DisplayName = \"A\"),\n    INP_B = 0x40 UMETA(DisplayName = \"B\"),\n    INP_C = 0x80 UMETA(DisplayName = \"C\"),\n    INP_D = 0x100 UMETA(DisplayName = \"D\"),\n    INP_E = 0x200 UMETA(DisplayName = \"E\"),\n    INP_F = 0x400 UMETA(DisplayName = \"F\"),\n    INP_G = 0x800 UMETA(DisplayName = \"G\"),\n    INP_H = 0x1000 UMETA(DisplayName = \"H\"),\n    INP_ResetTraining = 0x40000000 UMETA(Hidden),\n    INP_Rematch = 0x80000000 UMETA(Hidden)\n};\n</code></pre> <p>Input bitmasks. A layer of abstraction between the physical controller and the internal battle state. </p>"},{"location":"NightSkyEngine/_bitflags_8h/#enum-einvulnflags","title":"enum EInvulnFlags","text":"<pre><code>enum EInvulnFlags {\n    INV_StrikeInvulnerable = 0x1 UMETA(DisplayName = \"Is Strike Invulnerable\"),\n    INV_ThrowInvulnerable = 0x2 UMETA(DisplayName = \"Is Throw Invulnerable\"),\n    INV_ProjectileInvulnerable = 0x4 UMETA(DisplayName = \"Is Projectile Invulnerable\"),\n    INV_HeadInvulnerable = 0x8 UMETA(DisplayName = \"Is Head Invulnerable\")\n};\n</code></pre> <p>Player invulnerability flags. </p>"},{"location":"NightSkyEngine/_bitflags_8h/#enum-emiscflags","title":"enum EMiscFlags","text":"<pre><code>enum EMiscFlags {\n    MISC_InertiaEnable = 0x1 UMETA(DisplayName = \"Inertia Enabled\"),\n    MISC_FlipEnable = 0x2 UMETA(DisplayName = \"Flip Enabled\"),\n    MISC_WallCollisionActive = 0x4 UMETA(DisplayName = \"Wall Collision Active\"),\n    MISC_FloorCollisionActive = 0x8 UMETA(DisplayName = \"Floor Collision Active\"),\n    MISC_PushCollisionActive = 0x10 UMETA(DisplayName = \"Push Collision Active\"),\n    MISC_DeactivateOnNextUpdate = 0x20 UMETA(DisplayName = \"Deactivate On Next Update\"),\n    MISC_DeactivateIfBeyondBounds = 0x40 UMETA(DisplayName = \"Deactivate If Beyond Bounds\"),\n    MISC_DeactivateOnStateChange = 0x80 UMETA(DisplayName = \"Deactivate On State Change\"),\n    MISC_DeactivateOnReceiveHit = 0x100 UMETA(DisplayName = \"Deactivate On Receive Hit\"),\n    MISC_IgnoreSuperFreeze = 0x200 UMETA(DisplayName = \"Ignore Super Freeze\")\n};\n</code></pre> <p>Miscellaneous object flags. </p>"},{"location":"NightSkyEngine/_bitflags_8h/#enum-eplayerflags","title":"enum EPlayerFlags","text":"<pre><code>enum EPlayerFlags {\n    PLF_IsDead = 0x1 UMETA(DisplayName = \"Is Dead\"),\n    PLF_ThrowActive = 0x2 UMETA(DisplayName = \"Throw Active\"),\n    PLF_IsStunned = 0x4 UMETA(DisplayName = \"Is Stunned\"),\n    PLF_IsThrowLock = 0x8 UMETA(DisplayName = \"Is In Throw Lock\"),\n    PLF_IsOnScreen = 0x10 UMETA(DisplayName = \"Is On Screen\"),\n    PLF_DeathCamOverride = 0x20 UMETA(DisplayName = \"Override Death Camera Animation\"),\n    PLF_IsKnockedDown = 0x40 UMETA(DisplayName = \"Is Knocked Down\"),\n    PLF_IsHardKnockedDown = 0x80 UMETA(DisplayName = \"Is Hard Knocked Down\"),\n    PLF_RoundWinInputLock = 0x100 UMETA(DisplayName = \"Is Round Win Input Lock\"),\n    PLF_LockOpponentBurst = 0x200 UMETA(DisplayName = \"Is Opponent Burst Locked\"),\n    PLF_DefaultLandingAction = 0x400 UMETA(DisplayName = \"Is Default Landing Action\"),\n    PLF_ForceEnableFarNormal = 0x800 UMETA(DisplayName = \"Force Enable Far Proximity Normal\"),\n    PLF_TouchingWall = 0x1000 UMETA(DisplayName = \"Is Touching Wall\"),\n    PLF_HitgrabActive = 0x2000 UMETA(DisplayName = \"Hitgrab Active\"),\n    PLF_ReceivedCounterHit = 0x4000 UMETA(DisplayName = \"Received Counter Hit\"),\n    PLF_DidKaraCancel = 0x8000 UMETA(DisplayName = \"Did Kara Cancel\")\n};\n</code></pre> <p>Miscellaneous player flags. </p>"},{"location":"NightSkyEngine/_bitflags_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_bitflags_8h/#function-enum_class_flags","title":"function ENUM_CLASS_FLAGS","text":"<pre><code>ENUM_CLASS_FLAGS (\n    EInputFlags\n) \n</code></pre>"},{"location":"NightSkyEngine/_bitflags_8h/#function-enum_class_flags_1","title":"function ENUM_CLASS_FLAGS","text":"<pre><code>ENUM_CLASS_FLAGS (\n    EEnableFlags\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/Bitflags.h</code></p>"},{"location":"NightSkyEngine/_bitflags_8h_source/","title":"File Bitflags.h","text":"<p>File List &gt; Battle &gt; Misc &gt; Bitflags.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n\nUENUM(Meta = (Bitflags, UseEnumValuesAsMaskValuesInEditor = \"true\"))\nenum EInputFlags\n{\n    INP_None = 0x0 UMETA(DisplayName = \"None\"),\n    INP_Up = 0x1 UMETA(DisplayName = \"Up\"),\n    INP_Down = 0x2 UMETA(DisplayName = \"Down\"),\n    INP_Left = 0x4 UMETA(DisplayName = \"Left\"),\n    INP_Right = 0x8 UMETA(DisplayName = \"Right\"),\n    INP_UpLeft = INP_Up + INP_Left UMETA(Hidden),\n    INP_UpRight = INP_Up + INP_Right UMETA(Hidden),\n    INP_DownLeft = INP_Down + INP_Left UMETA(Hidden),\n    INP_DownRight = INP_Down + INP_Right UMETA(Hidden),\n    INP_Neutral = 0x10 UMETA(DisplayName = \"Neutral\"),\n    INP_A = 0x20 UMETA(DisplayName = \"A\"),\n    INP_B = 0x40 UMETA(DisplayName = \"B\"),\n    INP_C = 0x80 UMETA(DisplayName = \"C\"),\n    INP_D = 0x100 UMETA(DisplayName = \"D\"),\n    INP_E = 0x200 UMETA(DisplayName = \"E\"),\n    INP_F = 0x400 UMETA(DisplayName = \"F\"),\n    INP_G = 0x800 UMETA(DisplayName = \"G\"),\n    INP_H = 0x1000 UMETA(DisplayName = \"H\"),\n    INP_ResetTraining = 0x40000000 UMETA(Hidden),\n    INP_Rematch = 0x80000000 UMETA(Hidden),\n};\n\nENUM_CLASS_FLAGS(EInputFlags);\n\nUENUM(Meta = (Bitflags, UseEnumValuesAsMaskValuesInEditor = \"true\"))\nenum EEnableFlags\n{\n    ENB_None = 0x0 UMETA(Hidden),\n    ENB_Standing = 0x1 UMETA(DisplayName = \"Standing\"),\n    ENB_Crouching = 0x2 UMETA(DisplayName = \"Crouching\"),\n    ENB_Jumping = 0x4 UMETA(DisplayName = \"Jumping\"),\n    ENB_ForwardWalk = 0x8 UMETA(DisplayName = \"Forward Walk\"),\n    ENB_BackWalk = 0x10 UMETA(DisplayName = \"Backward Walk\"),\n    ENB_ForwardDash = 0x20 UMETA(DisplayName = \"Forward Dash\"),\n    ENB_BackDash = 0x40 UMETA(DisplayName = \"Backward Dash\"),\n    ENB_ForwardAirDash = 0x80 UMETA(DisplayName = \"Forward Air Dash\"),\n    ENB_BackAirDash = 0x100 UMETA(DisplayName = \"Backward Air Dash\"),\n    ENB_NormalAttack = 0x200 UMETA(DisplayName = \"Normal Attack\"),\n    ENB_SpecialAttack = 0x400 UMETA(DisplayName = \"Special Attack\"),\n    ENB_SuperAttack = 0x800 UMETA(DisplayName = \"Super Attack\"),\n    ENB_Block = 0x1000 UMETA(DisplayName = \"Block\"),\n    ENB_ProximityBlock = 0x2000 UMETA(DisplayName = \"Proximity Block\"),\n    ENB_Tech = 0x4000 UMETA(DisplayName = \"Tech\"),\n    ENB_Burst = 0x8000 UMETA(DisplayName = \"Burst\"),\n    ENB_Tag = 0x10000 UMETA(DisplayName = \"Tag\"),\n    ENB_Assist = 0x20000 UMETA(DisplayName = \"Assist\"),\n};\n\nENUM_CLASS_FLAGS(EEnableFlags);\n\nUENUM()\nenum EMiscFlags\n{\n    MISC_InertiaEnable = 0x1 UMETA(DisplayName = \"Inertia Enabled\"),\n    MISC_FlipEnable = 0x2 UMETA(DisplayName = \"Flip Enabled\"),\n    MISC_WallCollisionActive = 0x4 UMETA(DisplayName = \"Wall Collision Active\"),\n    MISC_FloorCollisionActive = 0x8 UMETA(DisplayName = \"Floor Collision Active\"),\n    MISC_PushCollisionActive = 0x10 UMETA(DisplayName = \"Push Collision Active\"),\n    MISC_DeactivateOnNextUpdate = 0x20 UMETA(DisplayName = \"Deactivate On Next Update\"),\n    MISC_DeactivateIfBeyondBounds = 0x40 UMETA(DisplayName = \"Deactivate If Beyond Bounds\"),\n    MISC_DeactivateOnStateChange = 0x80 UMETA(DisplayName = \"Deactivate On State Change\"),\n    MISC_DeactivateOnReceiveHit = 0x100 UMETA(DisplayName = \"Deactivate On Receive Hit\"),\n    MISC_IgnoreSuperFreeze = 0x200 UMETA(DisplayName = \"Ignore Super Freeze\"),\n};\n\nUENUM()\nenum EAttackFlags\n{\n    ATK_HitActive = 0x1 UMETA(DisplayName = \"Hit Active\"),\n    ATK_IsAttacking = 0x2 UMETA(DisplayName = \"Is Attacking\"),\n    ATK_AttackHeadAttribute = 0x4 UMETA(DisplayName = \"Head Attribute\"),\n    ATK_AttackProjectileAttribute = 0x8 UMETA(DisplayName = \"Projectile Attribute\"),\n    ATK_HasHit = 0x10 UMETA(DisplayName = \"Has Hit\"),\n    ATK_ProrateOnce = 0x20 UMETA(DisplayName = \"Prorate Once\"),\n    ATK_IgnoreOTG = 0x40 UMETA(DisplayName = \"Ignore OTG\"),\n    ATK_IgnorePushbackScaling = 0x80 UMETA(DisplayName = \"Ignore Pushback Scaling\"),\n    ATK_IgnoreHitstunScaling = 0x100 UMETA(DisplayName = \"Ignore Hitstun Scaling\"),\n    ATK_SetPlayerHit = 0x200 UMETA(DisplayName = \"Ignore Hitstun Scaling\"),\n    ATK_HitOTG = 0x400 UMETA(DisplayName = \"Hit OTG\"),\n};\n\nUENUM()\nenum EPlayerFlags\n{\n    PLF_IsDead = 0x1 UMETA(DisplayName = \"Is Dead\"),\n    PLF_ThrowActive = 0x2 UMETA(DisplayName = \"Throw Active\"),\n    PLF_IsStunned = 0x4 UMETA(DisplayName = \"Is Stunned\"),\n    PLF_IsThrowLock = 0x8 UMETA(DisplayName = \"Is In Throw Lock\"),\n    PLF_IsOnScreen = 0x10 UMETA(DisplayName = \"Is On Screen\"),\n    PLF_DeathCamOverride = 0x20 UMETA(DisplayName = \"Override Death Camera Animation\"),\n    PLF_IsKnockedDown = 0x40 UMETA(DisplayName = \"Is Knocked Down\"),\n    PLF_IsHardKnockedDown = 0x80 UMETA(DisplayName = \"Is Hard Knocked Down\"),\n    PLF_RoundWinInputLock = 0x100 UMETA(DisplayName = \"Is Round Win Input Lock\"),\n    PLF_LockOpponentBurst = 0x200 UMETA(DisplayName = \"Is Opponent Burst Locked\"),\n    PLF_DefaultLandingAction = 0x400 UMETA(DisplayName = \"Is Default Landing Action\"),\n    PLF_ForceEnableFarNormal = 0x800 UMETA(DisplayName = \"Force Enable Far Proximity Normal\"),\n    PLF_TouchingWall = 0x1000 UMETA(DisplayName = \"Is Touching Wall\"),\n    PLF_HitgrabActive = 0x2000 UMETA(DisplayName = \"Hitgrab Active\"),\n    PLF_ReceivedCounterHit = 0x4000 UMETA(DisplayName = \"Received Counter Hit\"),\n    PLF_DidKaraCancel = 0x8000 UMETA(DisplayName = \"Did Kara Cancel\"),\n};\n\nUENUM()\nenum ECancelFlags\n{\n    CNC_ChainCancelEnabled = 0x1 UMETA(DisplayName = \"Is Chain Cancel Enabled\"),\n    CNC_WhiffCancelEnabled = 0x2 UMETA(DisplayName = \"Is Whiff Cancel Enabled\"),\n    CNC_SpecialCancel = 0x4 UMETA(DisplayName = \"Is Special Cancel Enabled\"),\n    CNC_SuperCancel = 0x8 UMETA(DisplayName = \"Is Super Cancel Enabled\"),\n    CNC_JumpCancel = 0x10 UMETA(DisplayName = \"Is Jump Cancel Enabled\"),\n    CNC_FAirDashCancel = 0x20 UMETA(DisplayName = \"Is Forward Air Dash Cancel Enabled\"), \n    CNC_BAirDashCancel = 0x40 UMETA(DisplayName = \"Is Backward Air Dash Cancel Enabled\"),\n    CNC_EnableKaraCancel = 0x80 UMETA(DisplayName = \"Is Kara Cancel Enabled\"),\n    CNC_CancelIntoSelf = 0x100 UMETA(DisplayName = \"Is Cancel Into Self Enabled\"),\n    CNC_EnableReverseBeat = 0x200 UMETA(DisplayName = \"Is Reverse Beat Enabled\"),\n};\n\nUENUM()\nenum EInvulnFlags\n{\n    INV_StrikeInvulnerable = 0x1 UMETA(DisplayName = \"Is Strike Invulnerable\"),\n    INV_ThrowInvulnerable = 0x2 UMETA(DisplayName = \"Is Throw Invulnerable\"),\n    INV_ProjectileInvulnerable = 0x4 UMETA(DisplayName = \"Is Projectile Invulnerable\"),\n    INV_HeadInvulnerable = 0x8 UMETA(DisplayName = \"Is Head Invulnerable\"),\n};\n</code></pre>"},{"location":"NightSkyEngine/_collision_box_8h/","title":"File CollisionBox.h","text":"<p>FileList &gt; Battle &gt; Misc &gt; CollisionBox.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Globals.h\"</code></li> <li><code>#include \"CollisionBox.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_collision_box_8h/#classes","title":"Classes","text":"Type Name struct FCollisionBox A collision box."},{"location":"NightSkyEngine/_collision_box_8h/#public-types","title":"Public Types","text":"Type Name enum EBoxType"},{"location":"NightSkyEngine/_collision_box_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"NightSkyEngine/_collision_box_8h/#enum-eboxtype","title":"enum EBoxType","text":"<pre><code>enum EBoxType {\n    UMETA =(DisplayName=\"Pushbox\"),\n    UMETA =(DisplayName=\"Pushbox\"),\n    UMETA =(DisplayName=\"Pushbox\"),\n    UMETA =(DisplayName=\"Pushbox\"),\n    UMETA =(DisplayName=\"Pushbox\")\n};\n</code></pre> <p>The type of collision box. </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/CollisionBox.h</code></p>"},{"location":"NightSkyEngine/_collision_box_8h_source/","title":"File CollisionBox.h","text":"<p>File List &gt; Battle &gt; Misc &gt; CollisionBox.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"Globals.h\"\n\n#include \"CollisionBox.generated.h\"\n\nUENUM(BlueprintType)\nenum EBoxType\n{\n    BOX_Push UMETA(DisplayName=\"Pushbox\"),\n    BOX_Hurt UMETA(DisplayName=\"Hurtbox\"),\n    BOX_Hit UMETA(DisplayName=\"Hitbox\"),\n    BOX_Offset UMETA(DisplayName=\"Offset\"),\n    BOX_Custom UMETA(DisplayName=\"Custom\"),\n};\n\nUSTRUCT(BlueprintType)\nstruct FCollisionBox\n{\n    GENERATED_BODY()\n\n\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, SaveGame)\n    TEnumAsByte&lt;EBoxType&gt; Type = BOX_Hurt;\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, SaveGame)\n    FGameplayTag CustomType;\n    UPROPERTY(BlueprintReadOnly, SaveGame)\n    int32 PosX = 0;\n    UPROPERTY(BlueprintReadOnly, SaveGame)\n    int32 PosY = 0;\n    UPROPERTY(BlueprintReadOnly, SaveGame)\n    int32 SizeX = 0;\n    UPROPERTY(BlueprintReadOnly, SaveGame)\n    int32 SizeY = 0;\n\n#if WITH_EDITORONLY_DATA\n    // Values for editor only, used for easy editing/display\n\n    UPROPERTY(EditAnywhere, meta=(DisplayName=\"X Position\"))\n    float PosXEdit = 0;\n    UPROPERTY(EditAnywhere, meta=(DisplayName=\"Y Position\"))\n    float PosYEdit = 0;\n    UPROPERTY(EditAnywhere, meta=(DisplayName=\"X Size\"))\n    float SizeXEdit = 0;\n    UPROPERTY(EditAnywhere, meta=(DisplayName=\"Y Size\"))\n    float SizeYEdit = 0;\n    UPROPERTY(EditAnywhere, meta=(DisplayName=\"X Position (Unreal)\", Units = \"cm\"))\n    float UEPosX = 0;\n    UPROPERTY(EditAnywhere, meta=(DisplayName=\"Y Position (Unreal)\", Units = \"cm\"))\n    float UEPosY = 0;\n    UPROPERTY(EditAnywhere, meta=(DisplayName=\"X Size (Unreal)\", Units = \"cm\"))\n    float UESizeX = 0;\n    UPROPERTY(EditAnywhere, meta=(DisplayName=\"Y Size (Unreal)\", Units = \"cm\"))\n    float UESizeY = 0;\n\n    void EditorInit()\n    {\n        PosXEdit = static_cast&lt;float&gt;(PosX) / 1000;\n        PosYEdit = static_cast&lt;float&gt;(PosY) / 1000;\n        SizeXEdit = static_cast&lt;float&gt;(SizeX) / 1000;\n        SizeYEdit = static_cast&lt;float&gt;(SizeY) / 1000;\n        UEPosX = static_cast&lt;float&gt;(PosX) / COORD_SCALE;\n        UEPosY = static_cast&lt;float&gt;(PosY) / COORD_SCALE;\n        UESizeX = static_cast&lt;float&gt;(SizeX) / COORD_SCALE;\n        UESizeY = static_cast&lt;float&gt;(SizeY) / COORD_SCALE;\n    }\n\n    void PostEditChangeProperty()\n    {\n        if (static_cast&lt;float&gt;(PosX) / 1000 != PosXEdit)\n        {\n            PosX = PosXEdit * 1000;\n            UEPosX = static_cast&lt;float&gt;(PosX) / COORD_SCALE;\n        }\n        if (static_cast&lt;float&gt;(PosY) / 1000 != PosYEdit)\n        {\n            PosY = PosYEdit * 1000;\n            UEPosY = static_cast&lt;float&gt;(PosY) / COORD_SCALE;\n        }\n        if (static_cast&lt;float&gt;(SizeX) / 1000 != SizeXEdit)\n        {\n            SizeX = SizeXEdit * 1000;\n            UESizeX = static_cast&lt;float&gt;(SizeX) / COORD_SCALE;\n        }\n        if (static_cast&lt;float&gt;(SizeY) / 1000 != SizeYEdit)\n        {\n            SizeY = SizeYEdit * 1000;\n            UESizeY = static_cast&lt;float&gt;(SizeY) / COORD_SCALE;\n        }\n        if (static_cast&lt;float&gt;(PosX) / COORD_SCALE != UEPosX)\n        {\n            PosX = UEPosX * COORD_SCALE;\n            PosXEdit = static_cast&lt;float&gt;(PosX) / 1000;\n        }\n        if (static_cast&lt;float&gt;(PosY) / COORD_SCALE != UEPosY)\n        {\n            PosY = UEPosY * COORD_SCALE;\n            PosYEdit = static_cast&lt;float&gt;(PosY) / 1000;\n        }\n        if (static_cast&lt;float&gt;(SizeX) / COORD_SCALE != UESizeX)\n        {\n            SizeX = UESizeX * COORD_SCALE;\n            SizeXEdit = static_cast&lt;float&gt;(SizeX) / 1000;\n        }\n        if (static_cast&lt;float&gt;(SizeY) / COORD_SCALE != UESizeY)\n        {\n            SizeY = UESizeY * COORD_SCALE;\n            SizeYEdit = static_cast&lt;float&gt;(SizeY) / 1000;\n        }\n    }\n#endif\n\n    bool operator!=(const FCollisionBox&amp; OtherBox) const\n    {\n        return this-&gt;Type != OtherBox.Type || this-&gt;CustomType != OtherBox.CustomType || this-&gt;PosX != OtherBox.PosX\n            || this-&gt;PosY != OtherBox.PosY || this-&gt;SizeX != OtherBox.SizeX || this-&gt;SizeY != OtherBox.SizeY;\n    }\n};\n</code></pre>"},{"location":"NightSkyEngine/_globals_8cpp/","title":"File Globals.cpp","text":"<p>FileList &gt; Battle &gt; Misc &gt; Globals.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Globals.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_globals_8cpp/#public-functions","title":"Public Functions","text":"Type Name uint32 isqrt (uint64 const n)  uint32 isqrt_impl (uint64 const n, uint64 const xk)"},{"location":"NightSkyEngine/_globals_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_globals_8cpp/#function-isqrt","title":"function isqrt","text":"<pre><code>uint32 isqrt (\n    uint64 const n\n) \n</code></pre> <p>Takes the square root of an integer n without floats.</p> <p>Parameters:</p> <ul> <li><code>n</code> The integer to take the square root of. </li> </ul> <p>Returns:</p> <p>Returns the square root of n. </p>"},{"location":"NightSkyEngine/_globals_8cpp/#function-isqrt_impl","title":"function isqrt_impl","text":"<pre><code>uint32 isqrt_impl (\n    uint64 const n,\n    uint64 const xk\n) \n</code></pre> <p>Implementation of integer square root. </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/Globals.cpp</code></p>"},{"location":"NightSkyEngine/_globals_8cpp_source/","title":"File Globals.cpp","text":"<p>File List &gt; Battle &gt; Misc &gt; Globals.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Globals.h\"\n\nuint32 isqrt_impl(\n    uint64 const n,\n    uint64 const xk)\n{\n    uint64 const xk1 = (xk + n / xk) / 2;\n    return (xk1 &gt;= xk) ? xk : isqrt_impl(n, xk1);\n}\n\nuint32 isqrt(uint64 const n)\n{\n    if (n == 0) return 0;\n    if (n == 18446744073709551615ULL) return 4294967295U;\n    return isqrt_impl(n, n);\n}\n</code></pre>"},{"location":"NightSkyEngine/_globals_8h/","title":"File Globals.h","text":"<p>FileList &gt; Battle &gt; Misc &gt; Globals.h</p> <p>Go to the source code of this file</p>"},{"location":"NightSkyEngine/_globals_8h/#public-attributes","title":"Public Attributes","text":"Type Name int gSinTable"},{"location":"NightSkyEngine/_globals_8h/#public-functions","title":"Public Functions","text":"Type Name uint32 isqrt (uint64 const n)  uint32 isqrt_impl (uint64 const n, uint64 const xk)"},{"location":"NightSkyEngine/_globals_8h/#macros","title":"Macros","text":"Type Name define COORD_SCALE <code>((double)1000 / 0.43)</code>"},{"location":"NightSkyEngine/_globals_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/_globals_8h/#variable-gsintable","title":"variable gSinTable","text":"<pre><code>int gSinTable[900];\n</code></pre>"},{"location":"NightSkyEngine/_globals_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_globals_8h/#function-isqrt","title":"function isqrt","text":"<pre><code>uint32 isqrt (\n    uint64 const n\n) \n</code></pre> <p>Takes the square root of an integer n without floats.</p> <p>Parameters:</p> <ul> <li><code>n</code> The integer to take the square root of. </li> </ul> <p>Returns:</p> <p>Returns the square root of n. </p>"},{"location":"NightSkyEngine/_globals_8h/#function-isqrt_impl","title":"function isqrt_impl","text":"<pre><code>uint32 isqrt_impl (\n    uint64 const n,\n    uint64 const xk\n) \n</code></pre> <p>Implementation of integer square root. </p>"},{"location":"NightSkyEngine/_globals_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"NightSkyEngine/_globals_8h/#define-coord_scale","title":"define COORD_SCALE","text":"<pre><code>#define COORD_SCALE `((double)1000 / 0.43)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/Globals.h</code></p>"},{"location":"NightSkyEngine/_globals_8h_source/","title":"File Globals.h","text":"<p>File List &gt; Battle &gt; Misc &gt; Globals.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#define COORD_SCALE ((double)1000 / 0.43)\n\nuint32 isqrt_impl(uint64 const n, uint64 const xk);\n\nuint32 isqrt(uint64 const n);\n\nconstexpr int gSinTable[900] =\n{\n  0,\n  1,\n  3,\n  5,\n  6,\n  8,\n  10,\n  12,\n  13,\n  15,\n  17,\n  19,\n  20,\n  22,\n  24,\n  26,\n  27,\n  29,\n  31,\n  33,\n  34,\n  36,\n  38,\n  40,\n  41,\n  43,\n  45,\n  47,\n  48,\n  50,\n  52,\n  54,\n  55,\n  57,\n  59,\n  61,\n  62,\n  64,\n  66,\n  68,\n  69,\n  71,\n  73,\n  74,\n  76,\n  78,\n  80,\n  81,\n  83,\n  85,\n  87,\n  88,\n  90,\n  92,\n  94,\n  95,\n  97,\n  99,\n  101,\n  102,\n  104,\n  106,\n  107,\n  109,\n  111,\n  113,\n  114,\n  116,\n  118,\n  120,\n  121,\n  123,\n  125,\n  127,\n  128,\n  130,\n  132,\n  133,\n  135,\n  137,\n  139,\n  140,\n  142,\n  144,\n  146,\n  147,\n  149,\n  151,\n  152,\n  154,\n  156,\n  158,\n  159,\n  161,\n  163,\n  165,\n  166,\n  168,\n  170,\n  171,\n  173,\n  175,\n  177,\n  178,\n  180,\n  182,\n  183,\n  185,\n  187,\n  189,\n  190,\n  192,\n  194,\n  195,\n  197,\n  199,\n  201,\n  202,\n  204,\n  206,\n  207,\n  209,\n  211,\n  213,\n  214,\n  216,\n  218,\n  219,\n  221,\n  223,\n  224,\n  226,\n  228,\n  230,\n  231,\n  233,\n  235,\n  236,\n  238,\n  240,\n  241,\n  243,\n  245,\n  246,\n  248,\n  250,\n  252,\n  253,\n  255,\n  257,\n  258,\n  260,\n  262,\n  263,\n  265,\n  267,\n  268,\n  270,\n  272,\n  273,\n  275,\n  277,\n  278,\n  280,\n  282,\n  284,\n  285,\n  287,\n  289,\n  290,\n  292,\n  294,\n  295,\n  297,\n  299,\n  300,\n  302,\n  304,\n  305,\n  307,\n  309,\n  310,\n  312,\n  313,\n  315,\n  317,\n  318,\n  320,\n  322,\n  323,\n  325,\n  327,\n  328,\n  330,\n  332,\n  333,\n  335,\n  337,\n  338,\n  340,\n  342,\n  343,\n  345,\n  346,\n  348,\n  350,\n  351,\n  353,\n  355,\n  356,\n  358,\n  359,\n  361,\n  363,\n  364,\n  366,\n  368,\n  369,\n  371,\n  372,\n  374,\n  376,\n  377,\n  379,\n  381,\n  382,\n  384,\n  385,\n  387,\n  389,\n  390,\n  392,\n  393,\n  395,\n  397,\n  398,\n  400,\n  401,\n  403,\n  405,\n  406,\n  408,\n  409,\n  411,\n  413,\n  414,\n  416,\n  417,\n  419,\n  421,\n  422,\n  424,\n  425,\n  427,\n  428,\n  430,\n  432,\n  433,\n  435,\n  436,\n  438,\n  439,\n  441,\n  443,\n  444,\n  446,\n  447,\n  449,\n  450,\n  452,\n  453,\n  455,\n  457,\n  458,\n  460,\n  461,\n  463,\n  464,\n  466,\n  467,\n  469,\n  471,\n  472,\n  474,\n  475,\n  477,\n  478,\n  480,\n  481,\n  483,\n  484,\n  486,\n  487,\n  489,\n  490,\n  492,\n  493,\n  495,\n  496,\n  498,\n  500,\n  501,\n  503,\n  504,\n  506,\n  507,\n  509,\n  510,\n  512,\n  513,\n  515,\n  516,\n  518,\n  519,\n  521,\n  522,\n  523,\n  525,\n  526,\n  528,\n  529,\n  531,\n  532,\n  534,\n  535,\n  537,\n  538,\n  540,\n  541,\n  543,\n  544,\n  546,\n  547,\n  549,\n  550,\n  551,\n  553,\n  554,\n  556,\n  557,\n  559,\n  560,\n  562,\n  563,\n  564,\n  566,\n  567,\n  569,\n  570,\n  572,\n  573,\n  575,\n  576,\n  577,\n  579,\n  580,\n  582,\n  583,\n  584,\n  586,\n  587,\n  589,\n  590,\n  592,\n  593,\n  594,\n  596,\n  597,\n  599,\n  600,\n  601,\n  603,\n  604,\n  605,\n  607,\n  608,\n  610,\n  611,\n  612,\n  614,\n  615,\n  617,\n  618,\n  619,\n  621,\n  622,\n  623,\n  625,\n  626,\n  627,\n  629,\n  630,\n  632,\n  633,\n  634,\n  636,\n  637,\n  638,\n  640,\n  641,\n  642,\n  644,\n  645,\n  646,\n  648,\n  649,\n  650,\n  652,\n  653,\n  654,\n  656,\n  657,\n  658,\n  660,\n  661,\n  662,\n  663,\n  665,\n  666,\n  667,\n  669,\n  670,\n  671,\n  673,\n  674,\n  675,\n  676,\n  678,\n  679,\n  680,\n  681,\n  683,\n  684,\n  685,\n  687,\n  688,\n  689,\n  690,\n  692,\n  693,\n  694,\n  695,\n  697,\n  698,\n  699,\n  700,\n  702,\n  703,\n  704,\n  705,\n  707,\n  708,\n  709,\n  710,\n  712,\n  713,\n  714,\n  715,\n  716,\n  718,\n  719,\n  720,\n  721,\n  722,\n  724,\n  725,\n  726,\n  727,\n  728,\n  730,\n  731,\n  732,\n  733,\n  734,\n  736,\n  737,\n  738,\n  739,\n  740,\n  741,\n  743,\n  744,\n  745,\n  746,\n  747,\n  748,\n  750,\n  751,\n  752,\n  753,\n  754,\n  755,\n  756,\n  758,\n  759,\n  760,\n  761,\n  762,\n  763,\n  764,\n  766,\n  767,\n  768,\n  769,\n  770,\n  771,\n  772,\n  773,\n  774,\n  776,\n  777,\n  778,\n  779,\n  780,\n  781,\n  782,\n  783,\n  784,\n  785,\n  786,\n  788,\n  789,\n  790,\n  791,\n  792,\n  793,\n  794,\n  795,\n  796,\n  797,\n  798,\n  799,\n  800,\n  801,\n  802,\n  803,\n  804,\n  805,\n  806,\n  807,\n  809,\n  810,\n  811,\n  812,\n  813,\n  814,\n  815,\n  816,\n  817,\n  818,\n  819,\n  820,\n  821,\n  822,\n  823,\n  824,\n  825,\n  826,\n  827,\n  828,\n  829,\n  830,\n  830,\n  831,\n  832,\n  833,\n  834,\n  835,\n  836,\n  837,\n  838,\n  839,\n  840,\n  841,\n  842,\n  843,\n  844,\n  845,\n  846,\n  847,\n  848,\n  848,\n  849,\n  850,\n  851,\n  852,\n  853,\n  854,\n  855,\n  856,\n  857,\n  858,\n  858,\n  859,\n  860,\n  861,\n  862,\n  863,\n  864,\n  865,\n  866,\n  866,\n  867,\n  868,\n  869,\n  870,\n  871,\n  872,\n  872,\n  873,\n  874,\n  875,\n  876,\n  877,\n  877,\n  878,\n  879,\n  880,\n  881,\n  882,\n  882,\n  883,\n  884,\n  885,\n  886,\n  887,\n  887,\n  888,\n  889,\n  890,\n  891,\n  891,\n  892,\n  893,\n  894,\n  894,\n  895,\n  896,\n  897,\n  898,\n  898,\n  899,\n  900,\n  901,\n  901,\n  902,\n  903,\n  904,\n  904,\n  905,\n  906,\n  907,\n  907,\n  908,\n  909,\n  909,\n  910,\n  911,\n  912,\n  912,\n  913,\n  914,\n  914,\n  915,\n  916,\n  917,\n  917,\n  918,\n  919,\n  919,\n  920,\n  921,\n  921,\n  922,\n  923,\n  923,\n  924,\n  925,\n  925,\n  926,\n  927,\n  927,\n  928,\n  929,\n  929,\n  930,\n  931,\n  931,\n  932,\n  932,\n  933,\n  934,\n  934,\n  935,\n  936,\n  936,\n  937,\n  937,\n  938,\n  939,\n  939,\n  940,\n  940,\n  941,\n  942,\n  942,\n  943,\n  943,\n  944,\n  944,\n  945,\n  946,\n  946,\n  947,\n  947,\n  948,\n  948,\n  949,\n  949,\n  950,\n  951,\n  951,\n  952,\n  952,\n  953,\n  953,\n  954,\n  954,\n  955,\n  955,\n  956,\n  956,\n  957,\n  957,\n  958,\n  958,\n  959,\n  959,\n  960,\n  960,\n  961,\n  961,\n  962,\n  962,\n  963,\n  963,\n  964,\n  964,\n  965,\n  965,\n  965,\n  966,\n  966,\n  967,\n  967,\n  968,\n  968,\n  969,\n  969,\n  969,\n  970,\n  970,\n  971,\n  971,\n  971,\n  972,\n  972,\n  973,\n  973,\n  973,\n  974,\n  974,\n  975,\n  975,\n  975,\n  976,\n  976,\n  977,\n  977,\n  977,\n  978,\n  978,\n  978,\n  979,\n  979,\n  979,\n  980,\n  980,\n  980,\n  981,\n  981,\n  981,\n  982,\n  982,\n  982,\n  983,\n  983,\n  983,\n  984,\n  984,\n  984,\n  985,\n  985,\n  985,\n  985,\n  986,\n  986,\n  986,\n  987,\n  987,\n  987,\n  987,\n  988,\n  988,\n  988,\n  989,\n  989,\n  989,\n  989,\n  990,\n  990,\n  990,\n  990,\n  990,\n  991,\n  991,\n  991,\n  991,\n  992,\n  992,\n  992,\n  992,\n  992,\n  993,\n  993,\n  993,\n  993,\n  993,\n  994,\n  994,\n  994,\n  994,\n  994,\n  995,\n  995,\n  995,\n  995,\n  995,\n  995,\n  996,\n  996,\n  996,\n  996,\n  996,\n  996,\n  996,\n  997,\n  997,\n  997,\n  997,\n  997,\n  997,\n  997,\n  997,\n  998,\n  998,\n  998,\n  998,\n  998,\n  998,\n  998,\n  998,\n  998,\n  998,\n  998,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999,\n  999\n};\n</code></pre>"},{"location":"NightSkyEngine/_input_buffer_8cpp/","title":"File InputBuffer.cpp","text":"<p>FileList &gt; Battle &gt; Misc &gt; InputBuffer.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"InputBuffer.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/InputBuffer.cpp</code></p>"},{"location":"NightSkyEngine/_input_buffer_8cpp_source/","title":"File InputBuffer.cpp","text":"<p>File List &gt; Battle &gt; Misc &gt; InputBuffer.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"InputBuffer.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(InputBuffer)\n\nvoid FInputBuffer::WriteInputCondition(const FInputCondition&amp; InputCondition)\n{\n    switch (InputCondition.Method)\n    {\n    case EInputMethod::Normal:\n    case EInputMethod::Strict:\n        {\n            for (int i = 0; i &lt; InputCondition.Sequence.Num(); i++)\n            {\n                Update(InputCondition.Sequence[i].InputFlag);\n            }\n            break;\n        }\n    case EInputMethod::Once:\n    case EInputMethod::OnceStrict:\n        {\n            Update(INP_Neutral);\n            for (int i = 0; i &lt; InputCondition.Sequence.Num(); i++)\n            {\n                Update(InputCondition.Sequence[i].InputFlag);\n            }\n            break;\n        }\n    case EInputMethod::PressAndRelease:\n    case EInputMethod::PressAndReleaseStrict:\n        {\n            for (int i = 0; i &lt; InputCondition.Sequence.Num(); i++)\n            {\n                for (int j = 0; j &lt; InputCondition.Sequence[i].Hold; j++)\n                {\n                    Update(InputCondition.Sequence[i].InputFlag);\n                }\n            }\n            break;\n        }\n    case EInputMethod::Negative:\n    case EInputMethod::NegativeStrict:\n        {\n            for (int i = 0; i &lt; InputCondition.Sequence.Num(); i++)\n            {\n                Update(InputCondition.Sequence[i].InputFlag);\n                Update(INP_Neutral);\n            }\n            break;\n        }\n    default:\n        break;\n    }\n}\n\nvoid FInputBuffer::Update(int32 Input, bool bStopped)\n{\n    if (!bStopped)\n    {\n        for (auto&amp; Window : InputTime)\n        {\n            Window++;\n        }\n    }\n\n    if (Input == InputBufferInternal[InputBufferSize - 1]) \n        return;\n\n    for (int32 i = 0; i &lt; InputBufferSize - 1; i++)\n    {\n        InputBufferInternal[i] = InputBufferInternal[i + 1];\n        InputTime[i] = InputTime[i + 1];\n    }\n    InputBufferInternal[InputBufferSize - 1] = Input;\n    InputTime[InputBufferSize - 1] = 0;\n}\n\nvoid FInputBuffer::Emplace(int32 Input, uint32 Index)\n{\n    if (Index &gt; InputBufferSize - 1) return;\n\n    InputBufferInternal[Index] |= Input;\n}\n\nbool FInputBuffer::CheckInputCondition(const FInputCondition&amp; InputCondition)\n{\n    for (int i = 0; i &lt; InputSequenceSize; i++)\n    {\n        if (i &gt;= InputCondition.Sequence.Num())\n        {\n            InputSequence[i].InputFlag = -1;\n            continue;\n        }\n        InputSequence[i] = InputCondition.Sequence[i];\n    }\n    DisallowedInputs = InputCondition.DisallowedInputs;\n    ImpreciseInputCount = InputCondition.ImpreciseInputCount;\n    switch (InputCondition.Method)\n    {\n    case EInputMethod::Normal:\n        return CheckInputSequence();\n    case EInputMethod::Strict:\n        return CheckInputSequenceStrict();\n    case EInputMethod::Once:\n        return CheckInputSequenceOnce();\n    case EInputMethod::OnceStrict:\n        return CheckInputSequenceOnceStrict();\n    case EInputMethod::PressAndRelease:\n        return CheckInputSequencePressAndRelease();\n    case EInputMethod::PressAndReleaseStrict:\n        return CheckInputSequencePressAndReleaseStrict();\n    case EInputMethod::Negative:\n        return CheckInputSequenceNegative();\n    case EInputMethod::NegativeStrict:\n        return CheckInputSequenceNegativeStrict();\n    default:\n        return false;\n    }\n}\n\nbool FInputBuffer::CheckInputSequence() const\n{\n    int32 InputIndex = -10;\n    for (int32 i = InputSequenceSize - 1; i &gt; -1; i--)\n    {\n        if (InputSequence[i].InputFlag != -1)\n        {\n            InputIndex = i;\n            break;\n        }\n    }\n    int32 FramesSinceLastMatch = 0; //how long it's been since last input match\n\n    for (int32 i = InputBufferSize - 1; i &gt;= 0;)\n    {\n        if (InputIndex == -1) //check if input sequence has been fully read\n            return true;\n\n        const int32 NeededInput = InputSequence[InputIndex].InputFlag;\n        if (FramesSinceLastMatch &gt; InputSequence[InputIndex].Lenience)\n            return false;\n\n        FramesSinceLastMatch += InputTime[i];\n\n        for (auto DisallowedInput : DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        if ((InputBufferInternal[i] &amp; NeededInput) == NeededInput || NeededInput == INP_None) //if input matches...\n        {\n            if (InputSequence[InputIndex].Hold &gt; 0 &amp;&amp; FramesSinceLastMatch &lt; InputSequence[InputIndex].Hold) //if button held for less than required...\n            {\n                i--;\n                continue;\n            }\n            FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match\n            InputIndex--; //advance sequence\n        }\n        i--;\n    }\n\n    return false;\n}\n\nbool FInputBuffer::CheckInputSequenceStrict() const\n{\n    int32 InputIndex = -10;\n    for (int32 i = InputSequenceSize - 1; i &gt; -1; i--)\n    {\n        if (InputSequence[i].InputFlag != -1)\n        {\n            InputIndex = i;\n            break;\n        }\n    }\n    int32 FramesSinceLastMatch = 0; //how long it's been since last input match\n    int32 ImpreciseMatches = 0;\n\n    for (int32 i = InputBufferSize - 1; i &gt;= 0;)\n    {\n        if (InputIndex == -1) //check if input sequence has been fully read\n            return true;\n\n        const int32 NeededInput = InputSequence[InputIndex].InputFlag;\n        if (FramesSinceLastMatch &gt; InputSequence[InputIndex].Lenience)\n            return false;\n\n        FramesSinceLastMatch += InputTime[i];\n\n        for (auto DisallowedInput : DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        if ((InputBufferInternal[i] ^ NeededInput) &lt;&lt; 27 == 0 || NeededInput == INP_None) //if input matches...\n        {\n            if (InputSequence[InputIndex].Hold &gt; 0 &amp;&amp; FramesSinceLastMatch &lt; InputSequence[InputIndex].Hold) //if button held for less than required...\n            {\n                i--;\n                continue;\n            }\n            FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match\n            InputIndex--; //advance sequence\n            i--;\n            continue;\n        }\n        if ((InputBufferInternal[i] &amp; NeededInput) == NeededInput || NeededInput == INP_None) //if input doesn't match precisely...\n        {\n            if (ImpreciseMatches &gt;= ImpreciseInputCount)\n            {\n                FramesSinceLastMatch += InputTime[i];\n                i--;\n                continue;\n            }\n            if (InputSequence[InputIndex].Hold &gt; 0 &amp;&amp; FramesSinceLastMatch &lt; InputSequence[InputIndex].Hold) //if button held for less than required...\n            {\n                i--;\n                continue;\n            }\n            ImpreciseMatches++;\n            FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match\n            InputIndex--; //advance sequence\n        }\n        i--;\n    }\n\n    return false;\n}\n\nbool FInputBuffer::CheckInputSequenceOnce() const\n{\n    int32 InputIndex = -10;\n    for (int32 i = InputSequenceSize - 1; i &gt; -1; i--)\n    {\n        if (InputSequence[i].InputFlag != -1)\n        {\n            InputIndex = i;\n            break;\n        }\n    }\n    int32 FramesSinceLastMatch = 0; //how long it's been since last input match\n\n    for (int32 i = InputBufferSize - 1; i &gt;= 0;)\n    {\n        if (InputIndex &lt; 0) //check if input sequence has been fully read\n        {\n            FramesSinceLastMatch += InputTime[i + 1];\n            if (FramesSinceLastMatch &gt; InputSequence[0].Lenience + InputSequence[InputIndex + 1].Hold) return false;\n            if (!(InputBufferInternal[i] &amp; InputSequence[0].InputFlag))\n                return true;\n            i--;\n            continue;\n        }\n\n        if (FramesSinceLastMatch &gt; InputSequence[InputIndex].Lenience)\n            return false;\n\n        FramesSinceLastMatch += InputTime[i];\n\n        const int32 NeededInput = InputSequence[InputIndex].InputFlag;\n\n        for (auto DisallowedInput : DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        if ((InputBufferInternal[i] &amp; NeededInput) == NeededInput || NeededInput == INP_None) //if input matches...\n        {\n            if (InputSequence[InputIndex].Hold &gt; 0 &amp;&amp; FramesSinceLastMatch &lt; InputSequence[InputIndex].Hold) //if button held for less than required...\n            {\n                i--;\n                continue;\n            }\n            FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match\n            InputIndex--; //advance sequence\n        }\n        i--;\n    }\n\n    return false;\n}\n\nbool FInputBuffer::CheckInputSequenceOnceStrict() const\n{\n    int32 InputIndex = -10;\n    for (int32 i = InputSequenceSize - 1; i &gt; -1; i--)\n    {\n        if (InputSequence[i].InputFlag!= -1)\n        {\n            InputIndex = i;\n            break;\n        }\n    }\n    int32 FramesSinceLastMatch = 0; //how long it's been since last input match\n    int32 ImpreciseMatches = 0;\n\n    for (int32 i = InputBufferSize - 1; i &gt;= 0;)\n    {\n        if (InputIndex &lt; 0) //check if input sequence has been fully read\n        {\n            FramesSinceLastMatch += InputTime[i + 1];\n            if (FramesSinceLastMatch &gt; InputSequence[0].Lenience + InputSequence[InputIndex + 1].Hold) return false;\n            if ((InputBufferInternal[i] ^ InputSequence[0].InputFlag) &lt;&lt; 27 == 0)\n                return true;\n            i--;\n            continue;\n        }\n\n        if (FramesSinceLastMatch &gt; InputSequence[InputIndex].Lenience)\n            return false;\n\n        FramesSinceLastMatch += InputTime[i];\n\n        const int32 NeededInput = InputSequence[InputIndex].InputFlag;\n\n        for (auto DisallowedInput : DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        if ((InputBufferInternal[i] ^ NeededInput) &lt;&lt; 27 == 0 || NeededInput == INP_None) //if input matches...\n        {\n            if (InputSequence[InputIndex].Hold &gt; 0 &amp;&amp; FramesSinceLastMatch &lt; InputSequence[InputIndex].Hold) //if button held for less than required...\n            {\n                i--;\n                continue;\n            }\n            FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match\n            InputIndex--; //advance sequence\n            i--;\n            continue;\n        }\n        if ((InputBufferInternal[i] &amp; NeededInput) == NeededInput || NeededInput == INP_None) //if input matches...\n        {\n            if (ImpreciseMatches &gt;= ImpreciseInputCount)\n            {\n                FramesSinceLastMatch += InputTime[i];\n                i--;\n                continue;\n            }\n            if (InputSequence[InputIndex].Hold &gt; 0 &amp;&amp; FramesSinceLastMatch &lt; InputSequence[InputIndex].Hold) //if button held for less than required...\n            {\n                i--;\n                continue;\n            }\n            ImpreciseMatches++;\n            FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match\n            InputIndex--; //advance sequence\n        }\n        i--;\n    }\n\n    return false;\n}\n\nbool FInputBuffer::CheckInputSequencePressAndRelease() const\n{\n    int32 InputIndex = -10;\n    for (int32 i = InputSequenceSize - 1; i &gt; -1; i--)\n    {\n        if (InputSequence[i].InputFlag != -1)\n        {\n            InputIndex = i;\n            break;\n        }\n    }\n    int32 FramesSinceLastMatch = 0; //how long it's been since last input match\n    int32 FirstMatch = -1;\n    const int32 LastInputIndex = InputIndex;\n\n    for (int32 i = InputBufferSize - 2; i &gt;= 0;)\n    {\n        if (InputIndex &lt; 0) //check if input sequence has been fully read\n        {\n            if (FramesSinceLastMatch &gt; InputSequence[0].Lenience + InputSequence[InputIndex + 1].Hold) return false;\n            if (!(InputBufferInternal[i] &amp; InputSequence[0].InputFlag))\n                break;\n            FramesSinceLastMatch += InputTime[i] - InputTime[i + 1];\n            i--;\n            continue;\n        }\n\n        const int32 NeededInput = InputSequence[InputIndex].InputFlag;\n        if (FramesSinceLastMatch &gt; InputSequence[InputIndex].Lenience)\n            return false;\n\n        FramesSinceLastMatch += InputTime[i];\n\n        for (auto DisallowedInput : DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        if ((InputBufferInternal[i] &amp; NeededInput) == NeededInput || NeededInput == INP_None) //if input matches...\n        {\n            if (InputSequence[InputIndex].Hold &gt; 0 &amp;&amp; FramesSinceLastMatch &lt; InputSequence[InputIndex].Hold) //if button held for less than required...\n            {\n                i--;\n                continue;\n            }\n            if (FirstMatch == -1) FirstMatch = i;\n            FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match\n            InputIndex--; //advance sequence\n        }\n        i--;\n    }\n\n    if (FirstMatch == -1) return false;\n    for (int i = FirstMatch + 1; i &lt; InputBufferSize; i++)\n    {\n        if ((InputBufferInternal[i] &amp; InputSequence[LastInputIndex].InputFlag) != InputSequence[LastInputIndex].InputFlag) return true;\n    }\n\n    return false;\n}\n\nbool FInputBuffer::CheckInputSequencePressAndReleaseStrict() const\n{\n    int32 InputIndex = -10;\n    for (int32 i = InputSequenceSize - 1; i &gt; -1; i--)\n    {\n        if (InputSequence[i].InputFlag!= -1)\n        {\n            InputIndex = i;\n            break;\n        }\n    }\n    int32 FramesSinceLastMatch = 0; //how long it's been since last input match\n    int32 ImpreciseMatches = 0;\n    int32 FirstMatch = -1;\n    const int32 LastInputIndex = InputIndex;\n\n    for (int32 i = InputBufferSize - 2; i &gt;= 0;)\n    {\n        if (InputIndex &lt; 0) //check if input sequence has been fully read\n        {\n            if (FramesSinceLastMatch &gt; InputSequence[0].Lenience + InputSequence[InputIndex + 1].Hold) return false;\n            if ((InputBufferInternal[i] ^ InputSequence[0].InputFlag) &lt;&lt; 27 != 0)\n                break;\n            FramesSinceLastMatch += InputTime[i] - InputTime[i + 1];\n            i--;\n            continue;\n        }\n\n        const int32 NeededInput = InputSequence[InputIndex].InputFlag;\n        FramesSinceLastMatch += InputTime[i];\n\n        for (auto DisallowedInput : DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        if ((InputBufferInternal[i] ^ NeededInput) &lt;&lt; 27 == 0 || NeededInput == INP_None) //if input matches...\n        {\n            if (InputSequence[InputIndex].Hold &gt; 0 &amp;&amp; FramesSinceLastMatch &lt; InputSequence[InputIndex].Hold) //if button held for less than required...\n            {\n                i--;\n                continue;\n            }\n            if (FirstMatch == -1) FirstMatch = i;\n            FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match\n            InputIndex--; //advance sequence\n            i--;\n            continue;\n        }\n        if ((InputBufferInternal[i] &amp; NeededInput) == NeededInput || NeededInput == INP_None) //if input matches...\n        {\n            if (ImpreciseMatches &gt;= ImpreciseInputCount)\n            {\n                FramesSinceLastMatch += InputTime[i];\n                i--;\n                continue;\n            }\n            if (InputSequence[InputIndex].Hold &gt; 0 &amp;&amp; FramesSinceLastMatch &lt; InputSequence[InputIndex].Hold) //if button held for less than required...\n            {\n                i--;\n                continue;\n            }\n            if (FirstMatch == -1) FirstMatch = i;\n            ImpreciseMatches++;\n            FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match\n            InputIndex--; //advance sequence\n        }\n        i--;\n    }\n\n    if (FirstMatch == -1) return false;\n    for (int i = FirstMatch + 1; i &lt; InputBufferSize; i++)\n    {\n        if ((InputBufferInternal[i] &amp; InputSequence[LastInputIndex].InputFlag) != InputSequence[LastInputIndex].InputFlag) return true;\n    }\n\n    return false;\n}\n\nbool FInputBuffer::CheckInputSequenceNegative() const\n{\n    int32 InputIndex = -10;\n    for (int32 i = InputSequenceSize - 1; i &gt; -1; i--)\n    {\n        if (InputSequence[i].InputFlag != -1)\n        {\n            InputIndex = i;\n            break;\n        }\n    }\n    int32 FramesSinceLastMatch = 0; //how long it's been since last input match\n\n    for (int32 i = InputBufferSize - 2; i &gt;= 0;)\n    {\n        if (InputIndex == -1) //check if input sequence has been fully read\n            return true;\n\n        const int32 NeededInput = InputSequence[InputIndex].InputFlag;\n\n        if (FramesSinceLastMatch &gt; InputSequence[InputIndex].Lenience)\n            return false;\n\n        FramesSinceLastMatch += InputTime[i];\n\n        for (auto DisallowedInput : DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        if ((InputBufferInternal[i] &amp; NeededInput) == NeededInput || NeededInput == INP_None) //if input matches...\n        {\n            if ((InputBufferInternal[i + 1] &amp; NeededInput) == NeededInput || NeededInput == INP_None) continue;\n            FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match\n            InputIndex--; //advance sequence\n        }\n        i--;\n    }\n\n    return false;\n}\n\nbool FInputBuffer::CheckInputSequenceNegativeStrict() const\n{\n    int32 InputIndex = -10;\n    for (int32 i = InputSequenceSize - 1; i &gt; -1; i--)\n    {\n        if (InputSequence[i].InputFlag!= -1)\n        {\n            InputIndex = i;\n            break;\n        }\n    }\n    int32 FramesSinceLastMatch = 0; //how long it's been since last input match\n    int32 ImpreciseMatches = 0;\n\n    for (int32 i = InputBufferSize - 2; i &gt;= 0;)\n    {\n        if (InputIndex == -1) //check if input sequence has been fully read\n            return true;\n\n        const int32 NeededInput = InputSequence[InputIndex].InputFlag;\n\n        if (FramesSinceLastMatch &gt; InputSequence[InputIndex].Lenience)\n            return false;\n\n        FramesSinceLastMatch += InputTime[i];\n\n        for (auto DisallowedInput : DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        for (auto DisallowedInput : InputSequence[InputIndex].DisallowedInputs)\n        {\n            if ((InputBufferInternal[i] &amp; DisallowedInput) == DisallowedInput) return false;\n        }\n\n        if ((InputBufferInternal[i] ^ NeededInput) &lt;&lt; 27 == 0 || NeededInput == INP_None) //if input matches...\n        {\n            if ((InputBufferInternal[i + 1] &amp; NeededInput) == NeededInput || NeededInput == INP_None) continue;\n            FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match\n            InputIndex--; //advance sequence\n            i--;\n            continue;\n        }\n        if ((InputBufferInternal[i] &amp; NeededInput) == NeededInput || NeededInput == INP_None) //if input matches...\n        {\n            if (ImpreciseMatches &gt;= ImpreciseInputCount)\n            {\n                FramesSinceLastMatch += InputTime[i];\n                i--;\n                continue;\n            }\n            if ((InputBufferInternal[i + 1] &amp; NeededInput) == NeededInput || NeededInput == INP_None) continue;\n            ImpreciseMatches++;\n            FramesSinceLastMatch = FMath::Min(0, FramesSinceLastMatch - InputSequence[InputIndex].Lenience - InputSequence[InputIndex].Hold); //reset last match\n            InputIndex--; //advance sequence\n        }\n        i--;\n    }\n\n    return false;\n}\n\nvoid FInputBuffer::FlipInputsInBuffer()\n{\n    for (int i = 0; i &lt; InputBufferSize; i++)\n    {\n        const unsigned int Bit1 = (InputBufferInternal[i] &gt;&gt; 2) &amp; 1;\n        const unsigned int Bit2 = (InputBufferInternal[i] &gt;&gt; 3) &amp; 1;\n        unsigned int x = (Bit1 ^ Bit2);\n\n        x = x &lt;&lt; 2 | x &lt;&lt; 3;\n\n        InputBufferInternal[i] = InputBufferInternal[i] ^ x;\n    }\n}\n</code></pre>"},{"location":"NightSkyEngine/_input_buffer_8h/","title":"File InputBuffer.h","text":"<p>FileList &gt; Battle &gt; Misc &gt; InputBuffer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Script/State.h\"</code></li> <li><code>#include \"InputBuffer.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_input_buffer_8h/#classes","title":"Classes","text":"Type Name struct FInputBuffer The input buffer for a player object."},{"location":"NightSkyEngine/_input_buffer_8h/#public-attributes","title":"Public Attributes","text":"Type Name int32 InputBufferSize   = <code>0x20</code> int32 InputSequenceSize   = <code>0x10</code>"},{"location":"NightSkyEngine/_input_buffer_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/_input_buffer_8h/#variable-inputbuffersize","title":"variable InputBufferSize","text":"<pre><code>int32 InputBufferSize;\n</code></pre>"},{"location":"NightSkyEngine/_input_buffer_8h/#variable-inputsequencesize","title":"variable InputSequenceSize","text":"<pre><code>int32 InputSequenceSize;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/InputBuffer.h</code></p>"},{"location":"NightSkyEngine/_input_buffer_8h_source/","title":"File InputBuffer.h","text":"<p>File List &gt; Battle &gt; Misc &gt; InputBuffer.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NightSkyEngine/Battle/Script/State.h\"\n#include \"InputBuffer.generated.h\"\n\nconstexpr int32 InputSequenceSize = 0x10;\nconstexpr int32 InputBufferSize = 0x20;\n\nUSTRUCT()\nstruct FInputBuffer\n{\n    GENERATED_BODY()\n\nprivate:\n    FInputBitmask InputSequence[InputSequenceSize] = {  };\n    int32 ImpreciseInputCount = 0;\n    TArray&lt;TEnumAsByte&lt;EInputFlags&gt;&gt; DisallowedInputs{};\n\n\npublic:\n    int32 InputBufferInternal[InputBufferSize] = { 16 };\n    int32 InputTime[InputBufferSize] = {};\n\n    void WriteInputCondition(const FInputCondition&amp; InputCondition);\n\n    void Update(int32 Input, bool bStopped = false);\n    void Emplace(int32 Input, uint32 Index);\n    bool CheckInputCondition(const FInputCondition&amp; InputCondition);\n\n    bool CheckInputSequence() const;\n    bool CheckInputSequenceStrict() const;\n    bool CheckInputSequenceOnce() const;\n    bool CheckInputSequenceOnceStrict() const;\n    bool CheckInputSequencePressAndRelease() const;\n    bool CheckInputSequencePressAndReleaseStrict() const;\n    bool CheckInputSequenceNegative() const;\n    bool CheckInputSequenceNegativeStrict() const;\n    void FlipInputsInBuffer();\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_blueprint_function_library_8cpp/","title":"File NightSkyBlueprintFunctionLibrary.cpp","text":"<p>FileList &gt; Battle &gt; Misc &gt; NightSkyBlueprintFunctionLibrary.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyBlueprintFunctionLibrary.h\"</code></li> <li><code>#include \"Globals.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/NightSkyBlueprintFunctionLibrary.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_blueprint_function_library_8cpp_source/","title":"File NightSkyBlueprintFunctionLibrary.cpp","text":"<p>File List &gt; Battle &gt; Misc &gt; NightSkyBlueprintFunctionLibrary.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyBlueprintFunctionLibrary.h\"\n\n#include \"Globals.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyBlueprintFunctionLibrary)\n\nint32 UNightSkyBlueprintFunctionLibrary::Vec2Angle_x1000(int32 x, int32 y)\n{\n    int32 Angle = static_cast&lt;int&gt;(atan2(y, x) * 57295.77791868204) % 360000;\n    if (Angle &lt; 0)\n        Angle += 360000;\n    return Angle;\n}\n\nint32 UNightSkyBlueprintFunctionLibrary::Cos_x1000(int32 Deg_x10)\n{\n    int32 Tmp1 = (Deg_x10 + 900) % 3600;\n    int32 Tmp2 = Deg_x10 + 3600;\n    if (Tmp1 &gt;= 0)\n        Tmp2 = Tmp1;\n    if (Tmp2 &lt; 900)\n        return gSinTable[Tmp2];\n    if (Tmp2 &lt; 1800)\n        return gSinTable[1799 - Tmp2];\n    if (Tmp2 &gt;= 2700)\n        return -gSinTable[3599 - Tmp2];\n    return -gSinTable[Tmp2 - 1800];\n}\n\nint32 UNightSkyBlueprintFunctionLibrary::Sin_x1000(int32 Deg_x10)\n{\n    int32 Tmp1 = Deg_x10 % 3600;\n    int32 Tmp2 = Deg_x10 + 3600;\n    if (Tmp1 &gt;= 0)\n        Tmp2 = Tmp1;\n    if (Tmp2 &lt; 900)\n        return gSinTable[Tmp2];\n    if (Tmp2 &lt; 1800)\n        return gSinTable[1799 - Tmp2];\n    if (Tmp2 &gt;= 2700)\n        return -gSinTable[3599 - Tmp2];\n    return -gSinTable[Tmp2 - 1800];\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_blueprint_function_library_8h/","title":"File NightSkyBlueprintFunctionLibrary.h","text":"<p>FileList &gt; Battle &gt; Misc &gt; NightSkyBlueprintFunctionLibrary.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Kismet/BlueprintFunctionLibrary.h\"</code></li> <li><code>#include \"NightSkyBlueprintFunctionLibrary.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_blueprint_function_library_8h/#classes","title":"Classes","text":"Type Name class UNightSkyBlueprintFunctionLibrary <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/NightSkyBlueprintFunctionLibrary.h</code></p>"},{"location":"NightSkyEngine/_night_sky_blueprint_function_library_8h_source/","title":"File NightSkyBlueprintFunctionLibrary.h","text":"<p>File List &gt; Battle &gt; Misc &gt; NightSkyBlueprintFunctionLibrary.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Kismet/BlueprintFunctionLibrary.h\"\n#include \"NightSkyBlueprintFunctionLibrary.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API UNightSkyBlueprintFunctionLibrary : public UBlueprintFunctionLibrary\n{\n    GENERATED_BODY()\n\npublic:\n    UFUNCTION(BlueprintPure)\n    static int32 Vec2Angle_x1000(int32 x, int32 y);\n    UFUNCTION(BlueprintPure)\n    static int32 Cos_x1000(int32 Deg_x10);\n    UFUNCTION(BlueprintPure)\n    static int32 Sin_x1000(int32 Deg_x10);\n};\n</code></pre>"},{"location":"NightSkyEngine/_random_manager_8cpp/","title":"File RandomManager.cpp","text":"<p>FileList &gt; Battle &gt; Misc &gt; RandomManager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"RandomManager.h\"</code></li> <li><code>#include \"GenericPlatform/GenericPlatformMath.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/RandomManager.cpp</code></p>"},{"location":"NightSkyEngine/_random_manager_8cpp_source/","title":"File RandomManager.cpp","text":"<p>File List &gt; Battle &gt; Misc &gt; RandomManager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"RandomManager.h\"\n#include \"GenericPlatform/GenericPlatformMath.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(RandomManager)\n\nint32 FRandomManager::GenerateRandomNumber()\n{\n    return FGenericPlatformMath::Rand();\n}\n</code></pre>"},{"location":"NightSkyEngine/_random_manager_8h/","title":"File RandomManager.h","text":"<p>FileList &gt; Battle &gt; Misc &gt; RandomManager.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"RandomManager.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_random_manager_8h/#classes","title":"Classes","text":"Type Name struct FRandomManager <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/RandomManager.h</code></p>"},{"location":"NightSkyEngine/_random_manager_8h_source/","title":"File RandomManager.h","text":"<p>File List &gt; Battle &gt; Misc &gt; RandomManager.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"CoreMinimal.h\"\n#include \"RandomManager.generated.h\"\n\nUSTRUCT()\nstruct FRandomManager\n{\n    GENERATED_BODY()\nprivate:\n    uint32 Seed = 1;\npublic:\n    FRandomManager() {}\n    FRandomManager(uint32 InSeed) : Seed(InSeed) {}\n\n    int Rand()\n    {\n        Seed = Seed * 1103515245 + 12345;\n        return Seed / 65536 % 32768;\n    }\n\n    int RandRange(int Min, int Max)\n    {\n        if (Min &gt; Max)\n        {\n            const int32 Temp = Max;\n            Max = Min;\n            Min = Temp;\n        }\n        int32 Result = Rand();\n        Result = Result % (Max - Min + 1) + Min;\n        return Result;\n    }\n\n    void Reseed(uint32 InSeed)\n    {\n        Seed = InSeed;\n    }\n\n    uint32 GetSeed() const\n    {\n        return Seed;\n    }\n\n    int32 GenerateRandomNumber();\n};\n</code></pre>"},{"location":"NightSkyEngine/_serializable_obj_8cpp/","title":"File SerializableObj.cpp","text":"<p>FileList &gt; Battle &gt; Misc &gt; SerializableObj.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"SerializableObj.h\"</code></li> <li><code>#include \"Serialization/ObjectReader.h\"</code></li> <li><code>#include \"Serialization/ObjectWriter.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/SerializableObj.cpp</code></p>"},{"location":"NightSkyEngine/_serializable_obj_8cpp_source/","title":"File SerializableObj.cpp","text":"<p>File List &gt; Battle &gt; Misc &gt; SerializableObj.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"SerializableObj.h\"\n\n#include \"Serialization/ObjectReader.h\"\n#include \"Serialization/ObjectWriter.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(SerializableObj)\n\nTArray&lt;uint8&gt; USerializableObj::SaveForRollback()\n{\n    TArray&lt;uint8&gt; SaveData;\n    FObjectWriter Writer(SaveData);\n    Writer.ArIsSaveGame = true;\n    GetClass()-&gt;SerializeBin(Writer, this);\n    return SaveData;\n}\n\nvoid USerializableObj::LoadForRollback(const TArray&lt;uint8&gt;&amp; InBytes)\n{\n    if (InBytes.Num() &lt;= 1) return;\n    FObjectReader Reader(InBytes);\n    Reader.ArIsSaveGame = true;\n    GetClass()-&gt;SerializeBin(Reader, this);\n}\n\nvoid USerializableObj::ResetToCDO()\n{\n    const auto CDO = Cast&lt;USerializableObj&gt;(GetClass()-&gt;GetDefaultObject());\n    LoadForRollback(CDO-&gt;SaveForRollback());\n}\n</code></pre>"},{"location":"NightSkyEngine/_serializable_obj_8h/","title":"File SerializableObj.h","text":"<p>FileList &gt; Battle &gt; Misc &gt; SerializableObj.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"UObject/Object.h\"</code></li> <li><code>#include \"SerializableObj.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_serializable_obj_8h/#classes","title":"Classes","text":"Type Name class USerializableObj <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Misc/SerializableObj.h</code></p>"},{"location":"NightSkyEngine/_serializable_obj_8h_source/","title":"File SerializableObj.h","text":"<p>File List &gt; Battle &gt; Misc &gt; SerializableObj.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UObject/Object.h\"\n#include \"SerializableObj.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API USerializableObj : public UObject\n{\n    GENERATED_BODY()\n\npublic:\n    TArray&lt;uint8&gt; SaveForRollback();\n    void LoadForRollback(const TArray&lt;uint8&gt;&amp; InBytes);\n    void ResetToCDO();\n};\n</code></pre>"},{"location":"NightSkyEngine/dir_e62046f165ace41a1907d5ab434ac45b/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects","text":"<p>FileList &gt; Battle &gt; Objects</p>"},{"location":"NightSkyEngine/dir_e62046f165ace41a1907d5ab434ac45b/#files","title":"Files","text":"Type Name file BattleObject.cpp file BattleObject.h file PlayerObject.cpp file PlayerObject.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/</code></p>"},{"location":"NightSkyEngine/_battle_object_8cpp/","title":"File BattleObject.cpp","text":"<p>FileList &gt; Battle &gt; Objects &gt; BattleObject.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"BattleObject.h\"</code></li> <li><code>#include \"NiagaraComponent.h\"</code></li> <li><code>#include \"NiagaraFunctionLibrary.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Misc/NightSkyBlueprintFunctionLibrary.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/NightSkyGameState.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Actors/ParticleManager.h\"</code></li> <li><code>#include \"PlayerObject.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Actors/LinkActor.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Animation/NightSkyAnimMetaData.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Animation/NightSkyAnimSequenceUserData.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Misc/Bitflags.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Misc/Globals.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Script/Subroutine.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/CameraShakeData.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/ParticleData.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Misc/RandomManager.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_battle_object_8cpp/#public-functions","title":"Public Functions","text":"Type Name bool line_box_intersection (const FVector2D &amp; box_min, const FVector2D &amp; box_max, const FVector2D &amp; line_a, const FVector2D &amp; line_b, float * entry_fraction, float * exit_fraction)  auto max (T a, T b)  auto min (T a, T b)"},{"location":"NightSkyEngine/_battle_object_8cpp/#public-static-functions","title":"Public Static Functions","text":"Type Name void clip_line_y (const FVector2D &amp; line_a, const FVector2D &amp; line_b, float min_x, float max_x, float * min_y, float * max_y)"},{"location":"NightSkyEngine/_battle_object_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_battle_object_8cpp/#function-line_box_intersection","title":"function line_box_intersection","text":"<pre><code>bool line_box_intersection (\n    const FVector2D &amp; box_min,\n    const FVector2D &amp; box_max,\n    const FVector2D &amp; line_a,\n    const FVector2D &amp; line_b,\n    float * entry_fraction,\n    float * exit_fraction\n) \n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8cpp/#function-max","title":"function max","text":"<pre><code>template&lt;typename T&gt;\nauto max (\n    T a,\n    T b\n) \n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8cpp/#function-min","title":"function min","text":"<pre><code>template&lt;typename T&gt;\nauto min (\n    T a,\n    T b\n) \n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8cpp/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"NightSkyEngine/_battle_object_8cpp/#function-clip_line_y","title":"function clip_line_y","text":"<pre><code>static void clip_line_y (\n    const FVector2D &amp; line_a,\n    const FVector2D &amp; line_b,\n    float min_x,\n    float max_x,\n    float * min_y,\n    float * max_y\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.cpp</code></p>"},{"location":"NightSkyEngine/_battle_object_8cpp_source/","title":"File BattleObject.cpp","text":"<p>File List &gt; Battle &gt; Objects &gt; BattleObject.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"BattleObject.h\"\n#include \"NiagaraComponent.h\"\n#include \"NiagaraFunctionLibrary.h\"\n#include \"NightSkyEngine/Battle/Misc/NightSkyBlueprintFunctionLibrary.h\"\n#include \"NightSkyEngine/Battle/NightSkyGameState.h\"\n#include \"NightSkyEngine/Battle/Actors/ParticleManager.h\"\n#include \"PlayerObject.h\"\n#include \"NightSkyEngine/Battle/Actors/LinkActor.h\"\n#include \"NightSkyEngine/Battle/Animation/NightSkyAnimMetaData.h\"\n#include \"NightSkyEngine/Battle/Animation/NightSkyAnimSequenceUserData.h\"\n#include \"NightSkyEngine/Battle/Misc/Bitflags.h\"\n#include \"NightSkyEngine/Battle/Misc/Globals.h\"\n#include \"NightSkyEngine/Battle/Script/Subroutine.h\"\n#include \"NightSkyEngine/Data/CameraShakeData.h\"\n#include \"NightSkyEngine/Data/ParticleData.h\"\n#include \"NightSkyEngine/Battle/Misc/RandomManager.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(BattleObject)\n\n// Sets default values\nABattleObject::ABattleObject()\n{\n    // Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n    RootComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(\"RootComponent\");\n\n    bReplicates = false;\n}\n\n// Called when the game starts or when spawned\nvoid ABattleObject::BeginPlay()\n{\n    Super::BeginPlay();\n    if (IsPlayer)\n    {\n        Player = Cast&lt;APlayerObject&gt;(this);\n    }\n}\n\nvoid ABattleObject::Move()\n{\n    if (IsPlayer)\n    {\n        if (Player-&gt;PlayerFlags &amp; PLF_IsThrowLock)\n            return;\n        Player-&gt;SetHitValuesOverTime();\n    }\n    else\n    {\n        PositionLinkUpdate();\n    }\n\n    // Set previous pos values\n    PrevPosX = PosX;\n    PrevPosY = PosY;\n    CalculateHoming();\n\n    if (BlendOffset &amp;&amp; BlendCelName != FGameplayTag::EmptyTag &amp;&amp; MaxCelTime)\n    {\n        const int32 TmpOffsetX = (NextOffsetX - PrevOffsetX) * (MaxCelTime - TimeUntilNextCel) / MaxCelTime;\n        const int32 TmpOffsetY = (NextOffsetY - PrevOffsetY) * (MaxCelTime - TimeUntilNextCel) / MaxCelTime;\n\n        AddPosXWithDir(TmpOffsetX);\n        PosY += TmpOffsetY;\n    }\n\n    // Root motion\n    if (const auto BodyAnimUserData = GetAnimSequenceUserData(\"Body\"))\n    {\n        if (!MaxCelTime) return;\n\n        const auto Frame60 = AnimFrame + (BlendAnimFrame - AnimFrame) * (MaxCelTime - TimeUntilNextCel) / MaxCelTime;\n        const auto FrameAnim = Frame60 * BodyAnimUserData-&gt;GetFrameRate() / 60;\n        const auto RootMotion = BodyAnimUserData-&gt;GetRootTranslationAtTime(FrameAnim);\n\n        AddPosXWithDir(RootMotion.X - PrevRootMotionX);\n        PosY += RootMotion.Y - PrevRootMotionY;\n        PosZ += RootMotion.Z - PrevRootMotionZ;\n\n        return;\n    }\n\n    PrevRootMotionX = 0;\n    PrevRootMotionY = 0;\n    PrevRootMotionZ = 0;\n\n    SpeedX = SpeedX * SpeedXRatePerFrame / 100;\n    SpeedY = SpeedY * SpeedYRatePerFrame / 100;\n    SpeedZ = SpeedZ * SpeedZRatePerFrame / 100;\n    SpeedX = SpeedX * SpeedXRate / 100;\n    SpeedY = SpeedY * SpeedYRate / 100;\n    SpeedZ = SpeedZ * SpeedZRate / 100;\n\n    SpeedXRate = SpeedYRate = SpeedZRate = 100;\n\n    if (MiscFlags &amp; MISC_InertiaEnable) //only use inertia if enabled\n    {\n        if (PosY &lt;= GroundHeight &amp;&amp; MiscFlags &amp; MISC_FloorCollisionActive) //only decrease inertia if grounded\n        {\n            Inertia = Inertia - Inertia / 10;\n        }\n        if (Inertia &gt; -875 &amp;&amp; Inertia &lt; 875) //if inertia small enough, set to zero\n        {\n            Inertia = 0;\n        }\n        AddPosXWithDir(Inertia);\n    }\n\n    if (IsPlayer)\n    {\n        int32 ModifiedPushback;\n        if (PosY &gt; GroundHeight)\n            ModifiedPushback = Player-&gt;Pushback * 84;\n        else if (Player-&gt;Stance == ACT_Crouching)\n            ModifiedPushback = Player-&gt;Pushback * 86;\n        else\n            ModifiedPushback = Player-&gt;Pushback * 88;\n\n        Player-&gt;Pushback = ModifiedPushback / 100;\n\n        if (PosY &lt;= GroundHeight || !(Player-&gt;PlayerFlags &amp; PLF_IsStunned))\n            AddPosXWithDir(Player-&gt;Pushback);\n    }\n\n    AddPosXWithDir(SpeedX); //apply speed\n\n    if (IsPlayer &amp;&amp; Player != nullptr)\n    {\n        if (Player-&gt;AirDashTimer == 0 || (SpeedY &gt; 0 &amp;&amp; ActionTime &lt; 5))\n        // only set y speed if not airdashing/airdash startup not done\n        {\n            PosY += SpeedY;\n            if (PosY &gt; GroundHeight || !(MiscFlags &amp; MISC_FloorCollisionActive))\n                SpeedY -= Gravity;\n        }\n        else\n        {\n            SpeedY = 0;\n        }\n    }\n    else\n    {\n        PosY += SpeedY;\n        if (PosY &gt; GroundHeight || !(MiscFlags &amp; MISC_FloorCollisionActive))\n            SpeedY -= Gravity;\n    }\n\n    if (PosY &lt; GroundHeight &amp;&amp; MiscFlags &amp; MISC_FloorCollisionActive) //if on ground, force y values to zero\n    {\n        PosY = GroundHeight;\n    }\n\n    PosZ += SpeedZ;\n}\n\nvoid ABattleObject::PositionLinkUpdate()\n{\n    if (PositionLinkObj)\n    {\n        PrevPosX = PositionLinkObj-&gt;PrevPosX;\n        PrevPosY = PositionLinkObj-&gt;PrevPosY;\n        PosX = PositionLinkObj-&gt;PosX;\n        PosY = PositionLinkObj-&gt;PosY;\n    }\n}\n\nvoid ABattleObject::CalculateHoming()\n{\n    if (HomingParams.Target != OBJ_Null)\n    {\n        ABattleObject* Target = GetBattleObject(HomingParams.Target);\n\n        if (Target != nullptr)\n        {\n            int32 TargetPosX = 0;\n            int32 TargetPosY = 0;\n\n            Target-&gt;PosTypeToPosition(HomingParams.Pos, TargetPosX, TargetPosY);\n\n            const bool TargetFacingRight = Target-&gt;Direction == DIR_Right;\n            int32 HomingOffsetX = -HomingParams.OffsetX;\n            if (!TargetFacingRight)\n                HomingOffsetX = HomingParams.OffsetX;\n\n            if (HomingParams.Type == HOMING_DistanceAccel)\n            {\n                int32 TmpPosY = TargetPosY + HomingParams.OffsetY - PosY;\n                int32 TmpPosX = TargetPosX + HomingOffsetX - PosX;\n                if (Direction == DIR_Left) TmpPosX *= -1;\n                SpeedXRatePerFrame = HomingParams.ParamB;\n                SpeedYRatePerFrame = HomingParams.ParamB;\n                SpeedX += HomingParams.ParamA * TmpPosX / 100;\n                SpeedY += HomingParams.ParamA * TmpPosY / 100;\n            }\n            else if (HomingParams.Type == HOMING_FixAccel)\n            {\n                int32 TmpPosY = TargetPosY + HomingParams.OffsetY - PosY;\n                int32 TmpPosX = TargetPosX + HomingOffsetX - PosX;\n                if (Direction == DIR_Left) TmpPosX *= -1;\n                int32 Angle = UNightSkyBlueprintFunctionLibrary::Vec2Angle_x1000(TmpPosX, TmpPosY) / 100;\n                SpeedXRate = HomingParams.ParamB;\n                SpeedYRate = HomingParams.ParamB;\n                int32 CosParamA = HomingParams.ParamA * UNightSkyBlueprintFunctionLibrary::Cos_x1000(Angle) / 1000;\n                int32 SinParamA = HomingParams.ParamA * UNightSkyBlueprintFunctionLibrary::Sin_x1000(Angle) / 1000;\n                SpeedX += CosParamA;\n                SpeedY += SinParamA;\n            }\n            else if (HomingParams.Type == HOMING_ToSpeed)\n            {\n                int32 TmpPosY = TargetPosY + HomingParams.OffsetY - PosY;\n                int32 TmpPosX = TargetPosX + HomingOffsetX - PosX;\n                if (Direction == DIR_Left) TmpPosX *= -1;\n                int32 Angle = UNightSkyBlueprintFunctionLibrary::Vec2Angle_x1000(TmpPosX, TmpPosY) / 100;\n                int32 CosParamA = HomingParams.ParamA * UNightSkyBlueprintFunctionLibrary::Cos_x1000(Angle) / 1000;\n                int32 SinParamA = HomingParams.ParamA * UNightSkyBlueprintFunctionLibrary::Sin_x1000(Angle) / 1000;\n                int32 TmpParamB = HomingParams.ParamB;\n                int32 TmpSpeedX = SpeedX;\n                if (TmpParamB &lt;= 0)\n                {\n                    if (TmpParamB &gt;= 0)\n                    {\n                        CosParamA = TmpSpeedX;\n                    }\n                    else if (TmpSpeedX &lt; CosParamA &amp;&amp; -TmpSpeedX &gt; CosParamA)\n                    {\n                        CosParamA = TmpParamB + TmpSpeedX;\n                    }\n                    while (TmpSpeedX - CosParamA &lt;= TmpParamB || -TmpSpeedX + CosParamA &gt;= TmpParamB)\n                    {\n                        SpeedX = -CosParamA;\n                        if (HomingParams.ParamB &lt;= 0)\n                        {\n                            if (HomingParams.ParamB &gt;= 0)\n                            {\n                                return;\n                            }\n                            if (SpeedY &lt; SinParamA)\n                            {\n                                SinParamA = SpeedY + HomingParams.ParamB;\n                            }\n                            SpeedY = SinParamA;\n                            return;\n                        }\n                        if (SpeedY &lt; SinParamA)\n                        {\n                            if (SinParamA - SpeedY &gt; HomingParams.ParamB)\n                            {\n                                SinParamA = SpeedY + HomingParams.ParamB;\n                            }\n                        }\n                        if (SpeedY - SinParamA &lt;= HomingParams.ParamB)\n                        {\n                            SpeedY = SinParamA;\n                            return;\n                        }\n                        SinParamA = SpeedY - HomingParams.ParamB;\n                        SpeedY = SinParamA;\n                        return;\n                    }\n                }\n                else\n                {\n                    if (TmpSpeedX &lt; CosParamA)\n                    {\n                        if (CosParamA - TmpSpeedX &gt; TmpParamB)\n                        {\n                            CosParamA = TmpParamB + TmpSpeedX;\n                        }\n                        while (TmpSpeedX - CosParamA &lt;= TmpParamB || -TmpSpeedX + CosParamA &gt;= TmpParamB)\n                        {\n                            SpeedX = CosParamA;\n                            if (HomingParams.ParamB &lt;= 0)\n                            {\n                                if (HomingParams.ParamB &gt;= 0)\n                                {\n                                    SinParamA = SpeedY;\n                                }\n                                if (SpeedY &lt; SinParamA)\n                                {\n                                    SinParamA = SpeedY + HomingParams.ParamB;\n                                }\n                                SpeedY = SinParamA;\n                                return;\n                            }\n                            if (SpeedY &lt; SinParamA)\n                            {\n                                if (SinParamA - SpeedY &gt; HomingParams.ParamB)\n                                {\n                                    SinParamA = SpeedY + HomingParams.ParamB;\n                                }\n                            }\n                            if (SpeedY - SinParamA &lt;= HomingParams.ParamB)\n                            {\n                                SpeedY = SinParamA;\n                                return;\n                            }\n                            SinParamA = SpeedY - HomingParams.ParamB;\n                            SpeedY = SinParamA;\n                            return;\n                        }\n                    }\n                    if (TmpSpeedX - CosParamA &lt;= TmpParamB)\n                    {\n                        while (TmpSpeedX - CosParamA &lt;= TmpParamB || -TmpSpeedX + CosParamA &gt;= TmpParamB)\n                        {\n                            SpeedX = CosParamA;\n                            if (HomingParams.ParamB &lt;= 0)\n                            {\n                                if (HomingParams.ParamB &gt;= 0)\n                                {\n                                    SinParamA = SpeedY;\n                                }\n                                if (SpeedY &lt; SinParamA)\n                                {\n                                    SinParamA = SpeedY + HomingParams.ParamB;\n                                }\n                                SpeedY = SinParamA;\n                                return;\n                            }\n                            if (SpeedY &lt; SinParamA)\n                            {\n                                if (SinParamA - SpeedY &gt; HomingParams.ParamB)\n                                {\n                                    SinParamA = SpeedY + HomingParams.ParamB;\n                                }\n                            }\n                            if (SpeedY - SinParamA &lt;= HomingParams.ParamB)\n                            {\n                                SpeedY = SinParamA;\n                                return;\n                            }\n                            SinParamA = SpeedY - HomingParams.ParamB;\n                            SpeedY = SinParamA;\n                            return;\n                        }\n                    }\n                }\n                while (TmpSpeedX - CosParamA &lt;= TmpParamB || -TmpSpeedX + CosParamA &gt;= TmpParamB)\n                {\n                    SpeedX = CosParamA;\n                    if (HomingParams.ParamB &lt;= 0)\n                    {\n                        if (HomingParams.ParamB &gt;= 0)\n                        {\n                            SinParamA = SpeedY;\n                        }\n                        if (SpeedY &lt; SinParamA)\n                        {\n                            SinParamA = SpeedY + HomingParams.ParamB;\n                        }\n                        SpeedY = SinParamA;\n                        return;\n                    }\n                    if (SpeedY &lt; SinParamA)\n                    {\n                        if (SinParamA - SpeedY &gt; HomingParams.ParamB)\n                        {\n                            SinParamA = SpeedY + HomingParams.ParamB;\n                        }\n                    }\n                    if (SpeedY - SinParamA &lt;= HomingParams.ParamB)\n                    {\n                        SpeedY = SinParamA;\n                        return;\n                    }\n                    SinParamA = SpeedY - HomingParams.ParamB;\n                    SpeedY = SinParamA;\n                    return;\n                }\n            }\n        }\n    }\n}\n\nbool ABattleObject::SuperArmorSuccess(const ABattleObject* Attacker) const\n{\n    if (SuperArmorData.Type == ARM_None) return false;\n    if (SuperArmorData.ArmorHits == 0) return false;\n\n    if (SuperArmorData.bArmorMid &amp;&amp; Attacker-&gt;HitCommon.BlockType == BLK_Mid) return true;\n    if (SuperArmorData.bArmorOverhead &amp;&amp; Attacker-&gt;HitCommon.BlockType == BLK_High) return true;\n    if (SuperArmorData.bArmorLow &amp;&amp; Attacker-&gt;HitCommon.BlockType == BLK_Low) return true;\n    if (SuperArmorData.bArmorStrike &amp;&amp; Attacker-&gt;AttackFlags &amp; ATK_HitActive &amp;&amp; !(Attacker-&gt;AttackFlags &amp;\n        ATK_AttackProjectileAttribute))\n        return true;\n    if (SuperArmorData.bArmorThrow &amp;&amp; Attacker-&gt;IsPlayer &amp;&amp; Attacker-&gt;Player-&gt;PlayerFlags &amp; PLF_ThrowActive)\n        return\n            true;\n    if (SuperArmorData.bArmorHead &amp;&amp; Attacker-&gt;AttackFlags &amp; ATK_HitActive &amp;&amp; Attacker-&gt;AttackFlags &amp;\n        ATK_AttackHeadAttribute)\n        return true;\n    if (SuperArmorData.bArmorProjectile &amp;&amp; Attacker-&gt;AttackFlags &amp; ATK_HitActive &amp;&amp; Attacker-&gt;AttackFlags &amp;\n        ATK_AttackProjectileAttribute)\n        return true;\n\n    return false;\n}\n\n// Called every frame\nvoid ABattleObject::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    if (!GameState)\n    {\n        ScreenSpaceDepthOffset = 0;\n        OrthoBlendActive = 1;\n    }\n}\n\nvoid ABattleObject::CalculatePushbox()\n{\n    if (Direction == DIR_Right)\n    {\n        R = PosX + (PushWidth / 2 + PushWidthExtend);\n        L = PosX - PushWidth / 2;\n    }\n    else\n    {\n        R = PosX + PushWidth / 2;\n        L = PosX - (PushWidth / 2 + PushWidthExtend);\n    }\n    T = PosY + PushHeight;\n    B = PosY - PushHeightLow;\n}\n\nvoid ABattleObject::HandlePushCollision(ABattleObject* OtherObj)\n{\n    CalculatePushbox();\n    OtherObj-&gt;CalculatePushbox();\n\n    if (GameState-&gt;BattleState.SuperFreezeDuration &amp;&amp; this != GameState-&gt;BattleState.SuperFreezeCaller) return;\n    if (GameState-&gt;BattleState.SuperFreezeSelfDuration &amp;&amp; this == GameState-&gt;BattleState.SuperFreezeCaller) return;\n\n    if (MiscFlags &amp; MISC_PushCollisionActive &amp;&amp; OtherObj-&gt;MiscFlags &amp; MISC_PushCollisionActive)\n    {\n        if (Hitstop &lt;= 0 &amp;&amp; ((!OtherObj-&gt;IsPlayer || OtherObj-&gt;Player-&gt;PlayerFlags &amp; PLF_IsThrowLock) == 0 || (!IsPlayer\n            || Player-&gt;PlayerFlags &amp; PLF_IsThrowLock) == 0))\n        {\n            if (T &gt;= OtherObj-&gt;B &amp;&amp; B &lt;= OtherObj-&gt;T &amp;&amp; R &gt;= OtherObj-&gt;L &amp;&amp; L &lt;= OtherObj-&gt;R)\n            {\n                bool IsPushLeft;\n                int32 CollisionDepth;\n\n                GameState-&gt;SetScreenBounds();\n\n                if (PosX == OtherObj-&gt;PosX)\n                {\n                    if (PrevPosX == OtherObj-&gt;PrevPosX)\n                    {\n                        if (IsPlayer == OtherObj-&gt;IsPlayer)\n                        {\n                            if (Player-&gt;WallTouchTimer == OtherObj-&gt;Player-&gt;WallTouchTimer)\n                            {\n                                IsPushLeft = Player-&gt;PlayerIndex &gt; 0;\n                            }\n                            else\n                            {\n                                IsPushLeft = Player-&gt;WallTouchTimer &gt; OtherObj-&gt;Player-&gt;WallTouchTimer;\n                                if (PosX &gt; 0)\n                                {\n                                    IsPushLeft = Player-&gt;WallTouchTimer &lt;= OtherObj-&gt;Player-&gt;WallTouchTimer;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            IsPushLeft = IsPlayer &gt; OtherObj-&gt;IsPlayer;\n                        }\n                    }\n                    else\n                    {\n                        IsPushLeft = PrevPosX &lt; OtherObj-&gt;PrevPosX;\n                    }\n                }\n                else\n                {\n                    IsPushLeft = PosX &lt; OtherObj-&gt;PosX;\n                }\n                if (IsPushLeft)\n                {\n                    CollisionDepth = OtherObj-&gt;L - R;\n                }\n                else\n                {\n                    CollisionDepth = OtherObj-&gt;R - L;\n                }\n\n                if (IsPlayer &amp;&amp; Player-&gt;PlayerFlags &amp; PLF_TouchingWall \n                    || OtherObj-&gt;IsPlayer &amp;&amp; OtherObj-&gt;Player-&gt;PlayerFlags &amp; PLF_TouchingWall)\n                {\n                    OtherObj-&gt;PosX -= CollisionDepth;\n                    PosX += CollisionDepth;\n                }\n                else\n                {\n                    OtherObj-&gt;PosX -= CollisionDepth / 2;\n                    PosX += CollisionDepth / 2;\n                }\n\n                CalculatePushbox();\n                OtherObj-&gt;CalculatePushbox();\n            }\n        }\n    }\n}\n\nvoid ABattleObject::HandleHitCollision(ABattleObject* AttackedObj)\n{\n    if (AttackFlags &amp; ATK_IsAttacking &amp;&amp; AttackFlags &amp; ATK_HitActive &amp;&amp; AttackedObj-&gt;ObjectsToIgnoreHitsFrom.Find(this)\n        == INDEX_NONE &amp;&amp; !AttackedObj-&gt;Player-&gt;IsInvulnerable(this))\n    {\n        auto AttackedPlayer = Cast&lt;APlayerObject&gt;(AttackedObj);\n        if (!AttackedPlayer) return;\n        if (CheckBoxOverlap(AttackedObj, BOX_Hit, FGameplayTag::EmptyTag, BOX_Hurt, FGameplayTag::EmptyTag))\n        {\n            AttackedPlayer-&gt;AttackOwner = this;\n            AttackedPlayer-&gt;ObjectsToIgnoreHitsFrom.AddUnique(this);\n            AttackedPlayer-&gt;FaceOpponent();\n            AttackedPlayer-&gt;HaltMomentum();\n            AttackedPlayer-&gt;PlayerFlags |= PLF_IsStunned;\n            AttackFlags |= ATK_HasHit;\n            if (AttackFlags &amp; ATK_SetPlayerHit) Player-&gt;AttackFlags |= ATK_HasHit;\n            AttackTarget = AttackedPlayer;\n\n            TriggerEvent(EVT_HitOrBlock, StateMachine_Primary);\n            if (AttackedPlayer-&gt;IsMainPlayer())\n            {\n                TriggerEvent(EVT_HitOrBlockMainPlayer, StateMachine_Primary);\n            }\n\n            AttackedPlayer-&gt;CallSubroutine(Subroutine_Cmn_HitCollision);\n            if (AttackedPlayer-&gt;SubroutineReturnVal1) return;\n\n            if (AttackedPlayer-&gt;IsCorrectBlock(HitCommon.BlockType)) //check blocking\n            {\n                CallSubroutine(Subroutine_Cmn_OnBlock);\n\n                CreateCommonParticle(Particle_Guard, POS_Enemy,\n                                     FVector(0, 100, 0),\n                                     FRotator(HitCommon.HitAngle, 0, 0));\n                TriggerEvent(EVT_Block, StateMachine_Primary);\n                if (AttackedPlayer-&gt;IsMainPlayer())\n                {\n                    TriggerEvent(EVT_BlockMainPlayer, StateMachine_Primary);\n                }\n\n                const int32 ChipDamage = NormalHit.Damage * HitCommon.ChipDamagePercent / 100;\n                AttackedPlayer-&gt;CurrentHealth -= ChipDamage;\n\n                const FHitData Data = InitHitDataByAttackLevel(false);\n                AttackedPlayer-&gt;ReceivedHitCommon = HitCommon;\n                AttackedPlayer-&gt;ReceivedHit = Data;\n\n                if (AttackedPlayer-&gt;CurrentHealth &lt;= 0)\n                {\n                    EHitAction HACT;\n\n                    if (AttackedPlayer-&gt;PosY == AttackedPlayer-&gt;GroundHeight &amp;&amp; !(AttackedPlayer-&gt;\n                        PlayerFlags &amp; PLF_IsKnockedDown))\n                        HACT = NormalHit.GroundHitAction;\n                    else\n                        HACT = NormalHit.AirHitAction;\n\n                    AttackedPlayer-&gt;HandleHitAction(HACT);\n                }\n                else\n                {\n                    AttackedPlayer-&gt;HandleBlockAction();\n                    AttackedPlayer-&gt;AirDashTimer = 0;\n                    if (AttackedPlayer-&gt;PlayerFlags &amp; PLF_TouchingWall)\n                    {\n                        Pushback = AttackedPlayer-&gt;Pushback;\n                        AttackedPlayer-&gt;Pushback = 0;\n                    }\n                }\n                AttackedPlayer-&gt;AddMeter(\n                    NormalHit.Damage * AttackedPlayer-&gt;MeterPercentOnReceiveHitGuard / 100);\n                Player-&gt;AddMeter(NormalHit.Damage * Player-&gt;MeterPercentOnHitGuard / 100);\n            }\n            else if (AttackedPlayer-&gt;SuperArmorSuccess(this))\n            {\n                TriggerEvent(EVT_Hit, StateMachine_Primary);\n                if (AttackedPlayer-&gt;IsMainPlayer())\n                {\n                    TriggerEvent(EVT_HitMainPlayer, StateMachine_Primary);\n                }\n\n                if (AttackedPlayer-&gt;SuperArmorData.ArmorHits &gt; 0)\n                    AttackedPlayer-&gt;SuperArmorData.\n                                    ArmorHits--;\n                switch (AttackedPlayer-&gt;SuperArmorData.Type)\n                {\n                case ARM_Guard:\n                    {\n                        if (AttackedPlayer-&gt;SuperArmorData.bArmorTakeChipDamage)\n                        {\n                            const int32 ChipDamage = NormalHit.Damage * HitCommon.ChipDamagePercent /\n                                100;\n                            AttackedPlayer-&gt;CurrentHealth -= ChipDamage;\n                            AttackedPlayer-&gt;AddMeter(\n                                NormalHit.Damage * AttackedPlayer-&gt;MeterPercentOnReceiveHitGuard / 100);\n                            Player-&gt;AddMeter(NormalHit.Damage * Player-&gt;MeterPercentOnHitGuard / 100);\n                        }\n                        if (AttackedPlayer-&gt;SuperArmorData.ArmorDamagePercent)\n                        {\n                            const int32 ArmorDamage = NormalHit.Damage * AttackedPlayer-&gt;SuperArmorData.\n                                ArmorDamagePercent / 100;\n                            AttackedPlayer-&gt;CurrentHealth -= ArmorDamage;\n                            AttackedPlayer-&gt;AddMeter(\n                                NormalHit.Damage * AttackedPlayer-&gt;MeterPercentOnReceiveHit *\n                                AttackedPlayer-&gt;\n                                SuperArmorData.ArmorDamagePercent / 10000);\n                            Player-&gt;AddMeter(\n                                NormalHit.Damage * Player-&gt;MeterPercentOnHit * AttackedPlayer-&gt;\n                                                                               SuperArmorData.ArmorDamagePercent /\n                                10000);\n                        }\n                        else\n                        {\n                            CreateCommonParticle(Particle_Guard, POS_Enemy,\n                                                 FVector(0, 100, 0),\n                                                 FRotator(HitCommon.HitAngle, 0, 0));\n                        }\n\n                        const FHitData Data = InitHitDataByAttackLevel(false);\n                        AttackedPlayer-&gt;ReceivedHitCommon = HitCommon;\n                        AttackedPlayer-&gt;ReceivedHit = Data;\n\n                        if (AttackedPlayer-&gt;CurrentHealth &lt;= 0)\n                        {\n                            EHitAction HACT;\n\n                            if (AttackedPlayer-&gt;PosY == AttackedPlayer-&gt;GroundHeight &amp;&amp; !(AttackedPlayer\n                                -&gt;PlayerFlags &amp; PLF_IsKnockedDown))\n                                HACT = NormalHit.GroundHitAction;\n                            else\n                                HACT = NormalHit.AirHitAction;\n\n                            AttackedPlayer-&gt;HandleHitAction(HACT);\n                        }\n                        else\n                        {\n                            Hitstop = Data.Hitstop;\n                            AttackedPlayer-&gt;Hitstop = Data.Hitstop;\n                        }\n                    }\n                    break;\n                case ARM_Dodge:\n                default:\n                    break;\n                }\n            }\n            else if ((AttackedPlayer-&gt;AttackFlags &amp; ATK_IsAttacking) == 0)\n            {\n                AttackedPlayer-&gt;PlayerFlags &amp;= ~PLF_ReceivedCounterHit;\n\n                CallSubroutine(Subroutine_Cmn_OnHit);\n\n                TriggerEvent(EVT_Hit, StateMachine_Primary);\n                AttackedPlayer-&gt;TriggerEvent(EVT_ReceiveHit, StateMachine_Primary);\n                if (AttackedPlayer-&gt;IsMainPlayer())\n                {\n                    TriggerEvent(EVT_HitMainPlayer, StateMachine_Primary);\n                    AttackedPlayer-&gt;TriggerEvent(EVT_ReceiveHitMainPlayer, StateMachine_Primary);\n                }\n\n                if (IsPlayer &amp;&amp; Player-&gt;PlayerFlags &amp; PLF_HitgrabActive)\n                {\n                    AttackedPlayer-&gt;JumpToStatePrimary(State_Universal_ThrowLock);\n                    AttackedPlayer-&gt;PlayerFlags |= PLF_IsThrowLock;\n                    AttackedPlayer-&gt;StunTime = 0x7FFFFFFF;\n                    AttackedPlayer-&gt;AttackOwner = Player;\n                    Player-&gt;ThrowExe();\n                    return;\n                }\n\n                const FHitData Data = InitHitDataByAttackLevel(false);\n                CreateCommonParticle(HitCommon.HitVFX, POS_Col,\n                                     FVector(0, 0, 0),\n                                     FRotator(HitCommon.HitAngle, 0, 0));\n                PlayCommonSound(HitCommon.HitSFX);\n                AttackedPlayer-&gt;ReceivedHitCommon = HitCommon;\n                AttackedPlayer-&gt;ReceivedHit = Data;\n                EHitAction HACT;\n\n                if (AttackedPlayer-&gt;PosY == AttackedPlayer-&gt;GroundHeight &amp;&amp; !(AttackedPlayer-&gt;\n                    PlayerFlags &amp; PLF_IsKnockedDown))\n                    HACT = NormalHit.GroundHitAction;\n                else\n                    HACT = NormalHit.AirHitAction;\n\n                AttackedPlayer-&gt;HandleHitAction(HACT);\n                Hitstop = Data.Hitstop;\n            }\n            else\n            {\n                AttackedPlayer-&gt;PlayerFlags |= PLF_ReceivedCounterHit;\n\n                CallSubroutine(Subroutine_Cmn_OnHit);\n                CallSubroutine(Subroutine_Cmn_OnCounterHit);\n\n                TriggerEvent(EVT_Hit, StateMachine_Primary);\n                TriggerEvent(EVT_CounterHit, StateMachine_Primary);\n                AttackedPlayer-&gt;TriggerEvent(EVT_ReceiveHit, StateMachine_Primary);\n                if (AttackedPlayer-&gt;IsMainPlayer())\n                {\n                    TriggerEvent(EVT_HitMainPlayer, StateMachine_Primary);\n                    TriggerEvent(EVT_CounterHitMainPlayer, StateMachine_Primary);\n                    AttackedPlayer-&gt;TriggerEvent(EVT_ReceiveHitMainPlayer, StateMachine_Primary);\n                }\n\n                AttackedPlayer-&gt;AddColor = FLinearColor(1, 0, 0.0, 1);\n                AttackedPlayer-&gt;MulColor = FLinearColor(2.5, 0.1, 0.1, 1);\n                AttackedPlayer-&gt;AddFadeSpeed = 0.1;\n                AttackedPlayer-&gt;MulFadeSpeed = 0.1;\n\n                if (IsPlayer &amp;&amp; Player-&gt;PlayerFlags &amp; PLF_HitgrabActive)\n                {\n                    AttackedPlayer-&gt;JumpToStatePrimary(State_Universal_ThrowLock);\n                    AttackedPlayer-&gt;PlayerFlags |= PLF_IsThrowLock;\n                    AttackedPlayer-&gt;AttackOwner = Player;\n                    Player-&gt;ThrowExe();\n                    return;\n                }\n\n                const FHitData Data = InitHitDataByAttackLevel(false);\n                const FHitData CounterData = InitHitDataByAttackLevel(true);\n                CreateCommonParticle(HitCommon.HitVFX, POS_Col, FVector(0, 0, 0),\n                                     FRotator(HitCommon.HitAngle, 0, 0));\n                PlayCommonSound(HitCommon.HitSFX);\n                AttackedPlayer-&gt;ReceivedHitCommon = HitCommon;\n                AttackedPlayer-&gt;ReceivedHit = CounterData;\n                EHitAction HACT;\n\n                if (AttackedPlayer-&gt;PosY == AttackedPlayer-&gt;GroundHeight &amp;&amp; !(AttackedPlayer-&gt;\n                    PlayerFlags &amp; PLF_IsKnockedDown))\n                    HACT = CounterHit.GroundHitAction;\n                else\n                    HACT = CounterHit.AirHitAction;\n\n                AttackedPlayer-&gt;HandleHitAction(HACT);\n                Hitstop = Data.Hitstop;\n            }\n        }\n    }\n}\n\nFHitData ABattleObject::InitHitDataByAttackLevel(bool IsCounter)\n{\n    if (HitCommon.AttackLevel &lt; 0)\n        HitCommon.AttackLevel = 0;\n    if (HitCommon.AttackLevel &gt; 5)\n        HitCommon.AttackLevel = 5;\n\n    switch (HitCommon.AttackLevel)\n    {\n    case 0:\n    default:\n        if (HitCommon.BlockstopModifier == INT_MAX)\n            HitCommon.BlockstopModifier = 0;\n        if (HitCommon.Blockstun == INT_MAX)\n            HitCommon.Blockstun = 9;\n        if (HitCommon.GroundGuardPushbackX == INT_MAX)\n            HitCommon.GroundGuardPushbackX = 15000;\n        if (HitCommon.AirGuardPushbackX == INT_MAX)\n            HitCommon.AirGuardPushbackX = 7500;\n        if (HitCommon.AirGuardPushbackY == INT_MAX)\n            HitCommon.AirGuardPushbackY = 15000;\n        if (HitCommon.GuardGravity == INT_MAX)\n            HitCommon.GuardGravity = 1900;\n        if (NormalHit.Hitstop == INT_MAX)\n            NormalHit.Hitstop = 11;\n        if (NormalHit.Hitstun == INT_MAX)\n            NormalHit.Hitstun = 10;\n        if (NormalHit.Untech == INT_MAX)\n            NormalHit.Untech = 10;\n        if (NormalHit.Damage == INT_MAX)\n            NormalHit.Damage = 300;\n        if (NormalHit.GroundPushbackX == INT_MAX)\n            NormalHit.GroundPushbackX = 20000;\n        if (NormalHit.AirPushbackX == INT_MAX)\n            NormalHit.AirPushbackX = 10500;\n        if (NormalHit.AirPushbackY == INT_MAX)\n            NormalHit.AirPushbackY = 21000;\n        if (NormalHit.Gravity == INT_MAX)\n            NormalHit.Gravity = 1900;\n        if (CounterHit.Hitstop == INT_MAX)\n            CounterHit.Hitstop = NormalHit.Hitstop;\n        switch (HitCommon.VFXType)\n        {\n        case EHitVFXType::VFX_Strike:\n        case EHitVFXType::VFX_Slash:\n            HitCommon.HitVFX = Particle_Hit_S;\n            break;\n        case EHitVFXType::VFX_Special:\n            HitCommon.HitVFX = Particle_Hit_SP;\n            break;\n        }\n        switch (HitCommon.SFXType)\n        {\n        case EHitSFXType::SFX_Punch:\n            HitCommon.HitSFX = Sound_Hit_Punch_S;\n            break;\n        case EHitSFXType::SFX_Kick:\n            HitCommon.HitSFX = Sound_Hit_Kick_S;\n            break;\n        case EHitSFXType::SFX_Slash:\n            HitCommon.HitSFX = Sound_Hit_Slash_S;\n            break;\n        }\n        break;\n    case 1:\n        if (HitCommon.BlockstopModifier == INT_MAX)\n            HitCommon.BlockstopModifier = 0;\n        if (HitCommon.Blockstun == INT_MAX)\n            HitCommon.Blockstun = 11;\n        if (HitCommon.GroundGuardPushbackX == INT_MAX)\n            HitCommon.GroundGuardPushbackX = 17500;\n        if (HitCommon.AirGuardPushbackX == INT_MAX)\n            HitCommon.AirGuardPushbackX = 7500;\n        if (HitCommon.AirGuardPushbackY == INT_MAX)\n            HitCommon.AirGuardPushbackY = 15025;\n        if (HitCommon.GuardGravity == INT_MAX)\n            HitCommon.GuardGravity = 1900;\n        if (NormalHit.Hitstop == INT_MAX)\n            NormalHit.Hitstop = 12;\n        if (NormalHit.Hitstun == INT_MAX)\n            NormalHit.Hitstun = 12;\n        if (NormalHit.Untech == INT_MAX)\n            NormalHit.Untech = 12;\n        if (NormalHit.Damage == INT_MAX)\n            NormalHit.Damage = 400;\n        if (NormalHit.GroundPushbackX == INT_MAX)\n            NormalHit.GroundPushbackX = 22500;\n        if (NormalHit.AirPushbackX == INT_MAX)\n            NormalHit.AirPushbackX = 10500;\n        if (NormalHit.AirPushbackY == INT_MAX)\n            NormalHit.AirPushbackY = 21500;\n        if (NormalHit.Gravity == INT_MAX)\n            NormalHit.Gravity = 1900;\n        if (CounterHit.Hitstop == INT_MAX)\n            CounterHit.Hitstop = NormalHit.Hitstop + 2;\n        switch (HitCommon.VFXType)\n        {\n        case EHitVFXType::VFX_Strike:\n        case EHitVFXType::VFX_Slash:\n            HitCommon.HitVFX = Particle_Hit_S;\n            break;\n        case EHitVFXType::VFX_Special:\n            HitCommon.HitVFX = Particle_Hit_SP;\n            break;\n        }\n        switch (HitCommon.SFXType)\n        {\n        case EHitSFXType::SFX_Punch:\n            HitCommon.HitSFX = Sound_Hit_Punch_S;\n            break;\n        case EHitSFXType::SFX_Kick:\n            HitCommon.HitSFX = Sound_Hit_Kick_S;\n            break;\n        case EHitSFXType::SFX_Slash:\n            HitCommon.HitSFX = Sound_Hit_Slash_S;\n            break;\n        }\n        break;\n    case 2:\n        if (HitCommon.BlockstopModifier == INT_MAX)\n            HitCommon.BlockstopModifier = 0;\n        if (HitCommon.Blockstun == INT_MAX)\n            HitCommon.Blockstun = 13;\n        if (HitCommon.GroundGuardPushbackX == INT_MAX)\n            HitCommon.GroundGuardPushbackX = 20000;\n        if (HitCommon.AirGuardPushbackX == INT_MAX)\n            HitCommon.AirGuardPushbackX = 7500;\n        if (HitCommon.AirGuardPushbackY == INT_MAX)\n            HitCommon.AirGuardPushbackY = 15050;\n        if (HitCommon.GuardGravity == INT_MAX)\n            HitCommon.GuardGravity = 1900;\n        if (NormalHit.Hitstop == INT_MAX)\n            NormalHit.Hitstop = 13;\n        if (NormalHit.Hitstun == INT_MAX)\n            NormalHit.Hitstun = 14;\n        if (NormalHit.Untech == INT_MAX)\n            NormalHit.Untech = 14;\n        if (NormalHit.Damage == INT_MAX)\n            NormalHit.Damage = 600;\n        if (NormalHit.GroundPushbackX == INT_MAX)\n            NormalHit.GroundPushbackX = 25000;\n        if (NormalHit.AirPushbackX == INT_MAX)\n            NormalHit.AirPushbackX = 10500;\n        if (NormalHit.AirPushbackY == INT_MAX)\n            NormalHit.AirPushbackY = 22000;\n        if (NormalHit.Gravity == INT_MAX)\n            NormalHit.Gravity = 1900;\n        if (CounterHit.Hitstop == INT_MAX)\n            CounterHit.Hitstop = NormalHit.Hitstop + 4;\n        switch (HitCommon.VFXType)\n        {\n        case EHitVFXType::VFX_Strike:\n        case EHitVFXType::VFX_Slash:\n            HitCommon.HitVFX = Particle_Hit_M;\n            break;\n        case EHitVFXType::VFX_Special:\n            HitCommon.HitVFX = Particle_Hit_SP;\n            break;\n        }\n        switch (HitCommon.SFXType)\n        {\n        case EHitSFXType::SFX_Punch:\n            HitCommon.HitSFX = Sound_Hit_Punch_M;\n            break;\n        case EHitSFXType::SFX_Kick:\n            HitCommon.HitSFX = Sound_Hit_Kick_M;\n            break;\n        case EHitSFXType::SFX_Slash:\n            HitCommon.HitSFX = Sound_Hit_Slash_M;\n            break;\n        }\n        break;\n    case 3:\n        if (HitCommon.BlockstopModifier == INT_MAX)\n            HitCommon.BlockstopModifier = 0;\n        if (HitCommon.Blockstun == INT_MAX)\n            HitCommon.Blockstun = 16;\n        if (HitCommon.GroundGuardPushbackX == INT_MAX)\n            HitCommon.GroundGuardPushbackX = 22500;\n        if (HitCommon.AirGuardPushbackX == INT_MAX)\n            HitCommon.AirGuardPushbackX = 7500;\n        if (HitCommon.AirGuardPushbackY == INT_MAX)\n            HitCommon.AirGuardPushbackY = 15075;\n        if (HitCommon.GuardGravity == INT_MAX)\n            HitCommon.GuardGravity = 1900;\n        if (NormalHit.Hitstop == INT_MAX)\n            NormalHit.Hitstop = 14;\n        if (NormalHit.Hitstun == INT_MAX)\n            NormalHit.Hitstun = 17;\n        if (NormalHit.Untech == INT_MAX)\n            NormalHit.Untech = 16;\n        if (NormalHit.Damage == INT_MAX)\n            NormalHit.Damage = 800;\n        if (NormalHit.GroundPushbackX == INT_MAX)\n            NormalHit.GroundPushbackX = 27500;\n        if (NormalHit.AirPushbackX == INT_MAX)\n            NormalHit.AirPushbackX = 10500;\n        if (NormalHit.AirPushbackY == INT_MAX)\n            NormalHit.AirPushbackY = 22500;\n        if (NormalHit.Gravity == INT_MAX)\n            NormalHit.Gravity = 1900;\n        if (CounterHit.Hitstop == INT_MAX)\n            CounterHit.Hitstop = NormalHit.Hitstop + 8;\n        switch (HitCommon.VFXType)\n        {\n        case EHitVFXType::VFX_Strike:\n        case EHitVFXType::VFX_Slash:\n            HitCommon.HitVFX = Particle_Hit_M;\n            break;\n        case EHitVFXType::VFX_Special:\n            HitCommon.HitVFX = Particle_Hit_SP;\n            break;\n        }\n        switch (HitCommon.SFXType)\n        {\n        case EHitSFXType::SFX_Punch:\n            HitCommon.HitSFX = Sound_Hit_Punch_M;\n            break;\n        case EHitSFXType::SFX_Kick:\n            HitCommon.HitSFX = Sound_Hit_Kick_M;\n            break;\n        case EHitSFXType::SFX_Slash:\n            HitCommon.HitSFX = Sound_Hit_Slash_M;\n            break;\n        }\n        break;\n    case 4:\n        if (HitCommon.BlockstopModifier == INT_MAX)\n            HitCommon.BlockstopModifier = 0;\n        if (HitCommon.Blockstun == INT_MAX)\n            HitCommon.Blockstun = 18;\n        if (HitCommon.GroundGuardPushbackX == INT_MAX)\n            HitCommon.GroundGuardPushbackX = 25000;\n        if (HitCommon.AirGuardPushbackX == INT_MAX)\n            HitCommon.AirGuardPushbackX = 7500;\n        if (HitCommon.AirGuardPushbackY == INT_MAX)\n            HitCommon.AirGuardPushbackY = 15100;\n        if (HitCommon.GuardGravity == INT_MAX)\n            HitCommon.GuardGravity = 1900;\n        if (NormalHit.Hitstop == INT_MAX)\n            NormalHit.Hitstop = 15;\n        if (NormalHit.Hitstun == INT_MAX)\n            NormalHit.Hitstun = 19;\n        if (NormalHit.Untech == INT_MAX)\n            NormalHit.Untech = 18;\n        if (NormalHit.Damage == INT_MAX)\n            NormalHit.Damage = 1000;\n        if (NormalHit.GroundPushbackX == INT_MAX)\n            NormalHit.GroundPushbackX = 30000;\n        if (NormalHit.AirPushbackX == INT_MAX)\n            NormalHit.AirPushbackX = 10500;\n        if (NormalHit.AirPushbackY == INT_MAX)\n            NormalHit.AirPushbackY = 23000;\n        if (NormalHit.Gravity == INT_MAX)\n            NormalHit.Gravity = 1900;\n        if (CounterHit.Hitstop == INT_MAX)\n            CounterHit.Hitstop = NormalHit.Hitstop + 12;\n        switch (HitCommon.VFXType)\n        {\n        case EHitVFXType::VFX_Strike:\n        case EHitVFXType::VFX_Slash:\n            HitCommon.HitVFX = Particle_Hit_L;\n            break;\n        case EHitVFXType::VFX_Special:\n            HitCommon.HitVFX = Particle_Hit_SP;\n            break;\n        }\n        switch (HitCommon.SFXType)\n        {\n        case EHitSFXType::SFX_Punch:\n            HitCommon.HitSFX = Sound_Hit_Punch_L;\n            break;\n        case EHitSFXType::SFX_Kick:\n            HitCommon.HitSFX = Sound_Hit_Kick_L;\n            break;\n        case EHitSFXType::SFX_Slash:\n            HitCommon.HitSFX = Sound_Hit_Slash_L;\n            break;\n        }\n        break;\n    case 5:\n        if (HitCommon.BlockstopModifier == INT_MAX)\n            HitCommon.BlockstopModifier = 0;\n        if (HitCommon.Blockstun == INT_MAX)\n            HitCommon.Blockstun = 20;\n        if (HitCommon.GroundGuardPushbackX == INT_MAX)\n            HitCommon.GroundGuardPushbackX = 30000;\n        if (HitCommon.AirGuardPushbackX == INT_MAX)\n            HitCommon.AirGuardPushbackX = 7500;\n        if (HitCommon.AirGuardPushbackY == INT_MAX)\n            HitCommon.AirGuardPushbackY = 15125;\n        if (HitCommon.GuardGravity == INT_MAX)\n            HitCommon.GuardGravity = 1900;\n        if (NormalHit.Hitstop == INT_MAX)\n            NormalHit.Hitstop = 18;\n        if (NormalHit.Hitstun == INT_MAX)\n            NormalHit.Hitstun = 22;\n        if (NormalHit.Untech == INT_MAX)\n            NormalHit.Untech = 21;\n        if (NormalHit.Damage == INT_MAX)\n            NormalHit.Damage = 1250;\n        if (NormalHit.GroundPushbackX == INT_MAX)\n            NormalHit.GroundPushbackX = 40000;\n        if (NormalHit.AirPushbackX == INT_MAX)\n            NormalHit.AirPushbackX = 10500;\n        if (NormalHit.AirPushbackY == INT_MAX)\n            NormalHit.AirPushbackY = 23500;\n        if (NormalHit.Gravity == INT_MAX)\n            NormalHit.Gravity = 1900;\n        if (CounterHit.Hitstop == INT_MAX)\n            CounterHit.Hitstop = NormalHit.Hitstop + 16;\n        switch (HitCommon.VFXType)\n        {\n        case EHitVFXType::VFX_Strike:\n        case EHitVFXType::VFX_Slash:\n            HitCommon.HitVFX = Particle_Hit_L;\n            break;\n        case EHitVFXType::VFX_Special:\n            HitCommon.HitVFX = Particle_Hit_SP;\n            break;\n        }\n        switch (HitCommon.SFXType)\n        {\n        case EHitSFXType::SFX_Punch:\n            HitCommon.HitSFX = Sound_Hit_Punch_L;\n            break;\n        case EHitSFXType::SFX_Kick:\n            HitCommon.HitSFX = Sound_Hit_Kick_L;\n            break;\n        case EHitSFXType::SFX_Slash:\n            HitCommon.HitSFX = Sound_Hit_Slash_L;\n            break;\n        }\n        break;\n    }\n\n    if (NormalHit.EnemyHitstopModifier == INT_MAX)\n        NormalHit.EnemyHitstopModifier = 0;\n    if (NormalHit.RecoverableDamagePercent == INT_MAX)\n        NormalHit.RecoverableDamagePercent = 40;\n    if (NormalHit.MinimumDamagePercent == INT_MAX)\n        NormalHit.MinimumDamagePercent = 0;\n    if (NormalHit.InitialProration == INT_MAX)\n        NormalHit.InitialProration = 100;\n    if (NormalHit.ForcedProration == INT_MAX)\n        NormalHit.ForcedProration = 90;\n\n    if (CounterHit.EnemyHitstopModifier == INT_MAX)\n        CounterHit.EnemyHitstopModifier = NormalHit.EnemyHitstopModifier;\n    if (CounterHit.MinimumDamagePercent == INT_MAX)\n        CounterHit.MinimumDamagePercent = NormalHit.MinimumDamagePercent;\n    if (CounterHit.InitialProration == INT_MAX)\n        CounterHit.InitialProration = NormalHit.InitialProration;\n    if (CounterHit.ForcedProration == INT_MAX)\n        CounterHit.ForcedProration = NormalHit.ForcedProration;\n\n    if (CounterHit.Hitstun == INT_MAX)\n        CounterHit.Hitstun = NormalHit.Hitstun;\n    if (CounterHit.Untech == INT_MAX)\n        CounterHit.Untech = NormalHit.Untech * 2;\n    if (CounterHit.Damage == INT_MAX)\n        CounterHit.Damage = NormalHit.Damage * 110 / 100;\n    if (CounterHit.GroundPushbackX == INT_MAX)\n        CounterHit.GroundPushbackX = NormalHit.GroundPushbackX;\n    if (CounterHit.AirPushbackX == INT_MAX)\n        CounterHit.AirPushbackX = NormalHit.AirPushbackX;\n    if (CounterHit.AirPushbackY == INT_MAX)\n        CounterHit.AirPushbackY = NormalHit.AirPushbackY;\n    if (CounterHit.Gravity == INT_MAX)\n        CounterHit.Gravity = NormalHit.Gravity;\n    if (CounterHit.AirPushbackXOverTime.Value == INT_MAX)\n        CounterHit.AirPushbackXOverTime.Value = NormalHit.AirPushbackXOverTime.Value;\n    if (CounterHit.AirPushbackXOverTime.BeginFrame == INT_MAX)\n        CounterHit.AirPushbackXOverTime.BeginFrame = NormalHit.AirPushbackXOverTime.BeginFrame;\n    if (CounterHit.AirPushbackXOverTime.EndFrame == INT_MAX)\n        CounterHit.AirPushbackXOverTime.EndFrame = NormalHit.AirPushbackXOverTime.EndFrame;\n    if (CounterHit.AirPushbackYOverTime.Value == INT_MAX)\n        CounterHit.AirPushbackYOverTime.Value = NormalHit.AirPushbackYOverTime.Value;\n    if (CounterHit.AirPushbackYOverTime.BeginFrame == INT_MAX)\n        CounterHit.AirPushbackYOverTime.BeginFrame = NormalHit.AirPushbackYOverTime.BeginFrame;\n    if (CounterHit.AirPushbackYOverTime.EndFrame == INT_MAX)\n        CounterHit.AirPushbackYOverTime.EndFrame = NormalHit.AirPushbackYOverTime.EndFrame;\n    if (CounterHit.GravityOverTime.Value == INT_MAX)\n        CounterHit.GravityOverTime.Value = NormalHit.GravityOverTime.Value;\n    if (CounterHit.GravityOverTime.BeginFrame == INT_MAX)\n        CounterHit.GravityOverTime.BeginFrame = NormalHit.GravityOverTime.BeginFrame;\n    if (CounterHit.GravityOverTime.EndFrame == INT_MAX)\n        CounterHit.GravityOverTime.EndFrame = NormalHit.GravityOverTime.EndFrame;\n    if (CounterHit.BlowbackLevel == INT_MAX)\n        CounterHit.BlowbackLevel = NormalHit.BlowbackLevel;\n    if (CounterHit.FloatingCrumpleType == FLT_None)\n        CounterHit.FloatingCrumpleType = NormalHit.FloatingCrumpleType;\n\n    if (CounterHit.Position.Type == HPT_Non)\n        CounterHit.Position.Type = NormalHit.Position.Type;\n    if (CounterHit.Position.PosX == INT_MAX)\n        CounterHit.Position.PosX = NormalHit.Position.PosX;\n    if (CounterHit.Position.PosY == INT_MAX)\n        CounterHit.Position.PosY = NormalHit.Position.PosY;\n\n    if (CounterHit.GroundHitAction == HACT_GroundNormal)\n        CounterHit.GroundHitAction = NormalHit.GroundHitAction;\n    if (CounterHit.AirHitAction == HACT_AirNormal)\n        CounterHit.AirHitAction = NormalHit.AirHitAction;\n    if (CounterHit.CustomHitAction == FGameplayTag::EmptyTag)\n        CounterHit.CustomHitAction = NormalHit.CustomHitAction;\n\n    if (NormalHit.KnockdownTime == INT_MAX)\n        NormalHit.KnockdownTime = 12;\n    if (CounterHit.KnockdownTime == INT_MAX)\n        CounterHit.KnockdownTime = NormalHit.KnockdownTime;\n\n    if (NormalHit.HardKnockdown == INT_MAX)\n        NormalHit.HardKnockdown = 0;\n    if (CounterHit.HardKnockdown == INT_MAX)\n        CounterHit.HardKnockdown = NormalHit.HardKnockdown;\n\n    if (NormalHit.WallBounce.WallBounceStop == INT_MAX)\n        NormalHit.WallBounce.WallBounceStop = 6;\n    if (NormalHit.WallBounce.WallBounceXSpeed == INT_MAX)\n        NormalHit.WallBounce.WallBounceXSpeed = NormalHit.AirPushbackX;\n    if (NormalHit.WallBounce.WallBounceXRate == INT_MAX)\n        NormalHit.WallBounce.WallBounceXRate = 33;\n    if (NormalHit.WallBounce.WallBounceYSpeed == INT_MAX)\n        NormalHit.WallBounce.WallBounceYSpeed = NormalHit.AirPushbackY;\n    if (NormalHit.WallBounce.WallBounceYRate == INT_MAX)\n        NormalHit.WallBounce.WallBounceYRate = 100;\n    if (NormalHit.WallBounce.WallBounceGravity == INT_MAX)\n        NormalHit.WallBounce.WallBounceGravity = NormalHit.Gravity;\n\n    if (CounterHit.WallBounce.WallBounceStop == INT_MAX)\n        CounterHit.WallBounce.WallBounceStop = NormalHit.WallBounce.WallBounceStop;\n    if (CounterHit.WallBounce.WallBounceCount == -1)\n        CounterHit.WallBounce.WallBounceCount = NormalHit.WallBounce.WallBounceCount;\n    if (CounterHit.WallBounce.WallBounceXSpeed == INT_MAX)\n        CounterHit.WallBounce.WallBounceXSpeed = NormalHit.WallBounce.WallBounceXSpeed;\n    if (CounterHit.WallBounce.WallBounceXRate == INT_MAX)\n        CounterHit.WallBounce.WallBounceXRate = NormalHit.WallBounce.WallBounceXRate;\n    if (CounterHit.WallBounce.WallBounceYSpeed == INT_MAX)\n        CounterHit.WallBounce.WallBounceYSpeed = NormalHit.WallBounce.WallBounceYSpeed;\n    if (CounterHit.WallBounce.WallBounceYRate == INT_MAX)\n        CounterHit.WallBounce.WallBounceYRate = NormalHit.WallBounce.WallBounceYRate;\n    if (CounterHit.WallBounce.WallBounceGravity == INT_MAX)\n        CounterHit.WallBounce.WallBounceGravity = NormalHit.WallBounce.WallBounceGravity;\n\n    if (NormalHit.GroundBounce.GroundBounceStop == INT_MAX)\n        NormalHit.GroundBounce.GroundBounceStop = 6;\n    if (NormalHit.GroundBounce.GroundBounceXSpeed == INT_MAX)\n        NormalHit.GroundBounce.GroundBounceXSpeed = NormalHit.AirPushbackX;\n    if (NormalHit.GroundBounce.GroundBounceXRate == INT_MAX)\n        NormalHit.GroundBounce.GroundBounceXRate = 100;\n    if (NormalHit.GroundBounce.GroundBounceYSpeed == INT_MAX)\n        NormalHit.GroundBounce.GroundBounceYSpeed = FMath::Abs(NormalHit.AirPushbackY);\n    if (NormalHit.GroundBounce.GroundBounceYRate == INT_MAX)\n        NormalHit.GroundBounce.GroundBounceYRate = 100;\n    if (NormalHit.GroundBounce.GroundBounceGravity == INT_MAX)\n        NormalHit.GroundBounce.GroundBounceGravity = NormalHit.Gravity;\n\n    if (CounterHit.GroundBounce.GroundBounceStop == INT_MAX)\n        CounterHit.GroundBounce.GroundBounceStop = NormalHit.GroundBounce.GroundBounceStop;\n    if (CounterHit.GroundBounce.GroundBounceCount == -1)\n        CounterHit.GroundBounce.GroundBounceCount = NormalHit.GroundBounce.GroundBounceCount;\n    if (CounterHit.GroundBounce.GroundBounceXSpeed == INT_MAX)\n        CounterHit.GroundBounce.GroundBounceXSpeed = NormalHit.GroundBounce.GroundBounceXSpeed;\n    if (CounterHit.GroundBounce.GroundBounceXRate == INT_MAX)\n        CounterHit.GroundBounce.GroundBounceXRate = NormalHit.GroundBounce.GroundBounceXRate;\n    if (CounterHit.GroundBounce.GroundBounceYSpeed == INT_MAX)\n        CounterHit.GroundBounce.GroundBounceYSpeed = NormalHit.GroundBounce.GroundBounceYSpeed;\n    if (CounterHit.GroundBounce.GroundBounceYRate == INT_MAX)\n        CounterHit.GroundBounce.GroundBounceYRate = NormalHit.GroundBounce.GroundBounceYRate;\n    if (CounterHit.GroundBounce.GroundBounceGravity == INT_MAX)\n        CounterHit.GroundBounce.GroundBounceGravity = NormalHit.GroundBounce.GroundBounceGravity;\n\n    FHitData Data;\n    if (!IsCounter)\n        Data = NormalHit;\n    else\n        Data = CounterHit;\n\n    return Data;\n}\n\nvoid ABattleObject::HandleClashCollision(ABattleObject* OtherObj)\n{\n    if (AttackFlags &amp; ATK_IsAttacking &amp;&amp; AttackFlags &amp; ATK_HitActive &amp;&amp; OtherObj-&gt;Player-&gt;PlayerIndex != Player-&gt;\n        PlayerIndex\n        &amp;&amp; OtherObj-&gt;AttackFlags &amp; ATK_IsAttacking &amp;&amp; OtherObj-&gt;AttackFlags &amp; ATK_HitActive)\n    {\n        if (CheckBoxOverlap(OtherObj, BOX_Hit, FGameplayTag::EmptyTag, BOX_Hit, FGameplayTag::EmptyTag))\n        {\n            if (IsPlayer &amp;&amp; OtherObj-&gt;IsPlayer)\n            {\n                Hitstop = 16;\n                OtherObj-&gt;Hitstop = 16;\n                AttackFlags &amp;= ~ATK_HitActive;\n                OtherObj-&gt;AttackFlags &amp;= ~ATK_HitActive;\n                Player-&gt;EnableAttacks();\n                Player-&gt;EnableCancelIntoSelf(true);\n                Player-&gt;EnableState(ENB_ForwardDash, StateMachine_Primary);\n                OtherObj-&gt;Player-&gt;EnableAttacks();\n                OtherObj-&gt;Player-&gt;EnableCancelIntoSelf(true);\n                OtherObj-&gt;Player-&gt;EnableState(ENB_ForwardDash, StateMachine_Primary);\n                TriggerEvent(EVT_HitOrBlock, StateMachine_Primary);\n                OtherObj-&gt;TriggerEvent(EVT_HitOrBlock, StateMachine_Primary);\n                CreateCommonParticle(Particle_Hit_Clash, POS_Col, FVector(0, 0, 0));\n                PlayCommonSound(Sound_Hit_Clash);\n            }\n            else if (!IsPlayer &amp;&amp; !OtherObj-&gt;IsPlayer)\n            {\n                OtherObj-&gt;Hitstop = 16;\n                Hitstop = 16;\n                AttackFlags &amp;= ~ATK_HitActive;\n                OtherObj-&gt;AttackFlags &amp;= ~ATK_HitActive;\n                TriggerEvent(EVT_HitOrBlock, StateMachine_Primary);\n                OtherObj-&gt;TriggerEvent(EVT_HitOrBlock, StateMachine_Primary);\n                CreateCommonParticle(Particle_Hit_Clash, POS_Col, FVector(0, 0, 0));\n                PlayCommonSound(Sound_Hit_Clash);\n            }\n        }\n    }\n}\n\nvoid ABattleObject::HandleFlip()\n{\n    if (!Player-&gt;Enemy) return;\n\n    GameState-&gt;SetScreenBounds();\n\n    FaceOpponent();\n}\n\nvoid ABattleObject::PosTypeToPosition(EPosType Type, int32&amp; OutPosX, int32&amp; OutPosY) const\n{\n    switch (Type)\n    {\n    case POS_Self:\n        OutPosX = PosX;\n        OutPosY = PosY;\n        break;\n    case POS_Player:\n        OutPosX = Player-&gt;PosX;\n        OutPosY = Player-&gt;PosY;\n        break;\n    case POS_Center:\n        OutPosX = PosX;\n        if (!IsPlayer)\n        {\n            OutPosY = PosY;\n            break;\n        }\n        {\n            int32 CenterPosY = PosY;\n            switch (Player-&gt;Stance)\n            {\n            case ACT_Standing:\n            case ACT_Jumping:\n            default:\n                CenterPosY += 200000;\n                break;\n            case ACT_Crouching:\n                CenterPosY += 90000;\n                break;\n            }\n            OutPosY = CenterPosY;\n        }\n        break;\n    case POS_Ground:\n        OutPosX = PosX;\n        OutPosY = GroundHeight;\n        break;\n    case POS_Enemy:\n        OutPosX = Player-&gt;Enemy-&gt;PosX;\n        OutPosY = Player-&gt;Enemy-&gt;PosY;\n        break;\n    case POS_Col:\n        OutPosX = ColPosX;\n        OutPosY = ColPosY;\n        break;\n    default:\n        break;\n    }\n}\n\nvoid ABattleObject::ScreenPosToWorldPos(const int32 X, const int32 Y, int32&amp; OutX, int32&amp; OutY) const\n{\n    if (!GameState) return;\n\n    GameState-&gt;ScreenPosToWorldPos(X, Y, OutX, OutY);\n}\n\nvoid ABattleObject::TriggerEvent(EEventType EventType, FGameplayTag StateMachineName)\n{\n    if (EventType == EVT_Update) UpdateTime++;\n    if (const auto SubroutineName = EventHandlers[EventType].SubroutineName; SubroutineName != FGameplayTag::EmptyTag)\n    {\n        USubroutine* Subroutine = nullptr;\n\n        if (const auto CommonIndex = Player-&gt;CommonSubroutineNames.Find(SubroutineName); CommonIndex != INDEX_NONE)\n            Subroutine = Player-&gt;CommonSubroutines[CommonIndex];\n\n        else if (const auto Index = Player-&gt;SubroutineNames.Find(SubroutineName); Index != INDEX_NONE)\n            Subroutine = Player-&gt;Subroutines[Index];\n\n        if (!Subroutine) return;\n\n        UFunction* const Func = Subroutine-&gt;FindFunction(EventHandlers[EventType].FunctionName);\n        if (IsValid(Func) &amp;&amp; Func-&gt;ParmsSize == 0)\n        {\n            Subroutine-&gt;Parent = this;\n            Subroutine-&gt;ProcessEvent(Func, nullptr);\n        }\n        return;\n    }\n\n    UState* State = ObjectState;\n    if (IsPlayer)\n        State = Player-&gt;GetStateMachine(StateMachineName).CurrentState;\n    if (!IsValid(State))\n        return;\n    UFunction* const Func = State-&gt;FindFunction(EventHandlers[EventType].FunctionName);\n    if (IsValid(Func) &amp;&amp; Func-&gt;ParmsSize == 0)\n    {\n        State-&gt;ProcessEvent(Func, nullptr);\n    }\n}\n\n//for collision viewer\n\ntemplate &lt;typename T&gt;\nconstexpr auto min(T a, T b)\n{\n    return a &lt; b ? a : b;\n}\n\ntemplate &lt;typename T&gt;\nconstexpr auto max(T a, T b)\n{\n    return a &gt; b ? a : b;\n}\n\nstatic void clip_line_y(\n    const FVector2D&amp; line_a, const FVector2D&amp; line_b,\n    float min_x, float max_x,\n    float* min_y, float* max_y)\n{\n    const auto delta = line_b - line_a;\n\n    if (abs(delta.X) &gt; FLT_EPSILON)\n    {\n        const auto slope = delta.Y / delta.X;\n        const auto intercept = line_a.Y - slope * line_a.X;\n        *min_y = slope * min_x + intercept;\n        *max_y = slope * max_x + intercept;\n    }\n    else\n    {\n        *min_y = line_a.Y;\n        *max_y = line_b.Y;\n    }\n\n    if (*min_y &gt; *max_y)\n        std::swap(*min_y, *max_y);\n}\n\nbool line_box_intersection(\n    const FVector2D&amp; box_min, const FVector2D&amp; box_max,\n    const FVector2D&amp; line_a, const FVector2D&amp; line_b,\n    float* entry_fraction, float* exit_fraction)\n{\n    // No intersection if line runs along the edge of the box\n    if (line_a.X == line_b.X &amp;&amp; (line_a.X == box_min.X || line_a.X == box_max.X))\n        return false;\n\n    if (line_a.Y == line_b.Y &amp;&amp; (line_a.Y == box_min.Y || line_a.Y == box_max.Y))\n        return false;\n\n    // Clip X values to segment within box_min.X and box_max.X\n    const auto min_x = max(min(line_a.X, line_b.X), box_min.X);\n    const auto max_x = min(max(line_a.X, line_b.X), box_max.X);\n\n    // Check if the line is in the bounds of the box on the X axis\n    if (min_x &gt; max_x)\n        return false;\n\n    // Clip Y values to segment within min_x and max_x\n    float min_y, max_y;\n    clip_line_y(line_a, line_b, min_x, max_x, &amp;min_y, &amp;max_y);\n\n    // Clip Y values to segment within box_min.Y and box_max.Y\n    min_y = max(min_y, (float)box_min.Y);\n    max_y = min(max_y, (float)box_max.Y);\n\n    // Check if the clipped line is in the bounds of the box on the Y axis\n    if (min_y &gt; max_y)\n        return false;\n\n    const FVector2D entry(\n        line_a.X &lt; line_b.X ? min_x : max_x,\n        line_a.Y &lt; line_b.Y ? min_y : max_y);\n\n    const FVector2D exit(\n        line_a.X &gt; line_b.X ? min_x : max_x,\n        line_a.Y &gt; line_b.Y ? min_y : max_y);\n\n    const auto length = (line_b - line_a).Size();\n    *entry_fraction = (entry - line_a).Size() / length;\n    *exit_fraction = (exit - line_a).Size() / length;\n\n    return true;\n}\n\nvoid ABattleObject::CollisionView()\n{\n    TArray&lt;TArray&lt;FVector2D&gt;&gt; Corners;\n    TArray&lt;TArray&lt;TArray&lt;FVector2D&gt;&gt;&gt; Lines;\n    for (auto Box : Boxes)\n    {\n        TArray&lt;FVector2D&gt; CurrentCorners;\n        if (Direction == DIR_Right)\n        {\n            CurrentCorners.Add(FVector2D(float(Box.PosX) / COORD_SCALE - float(Box.SizeX) / COORD_SCALE / 2,\n                                         float(Box.PosY) / COORD_SCALE - float(Box.SizeY) / COORD_SCALE / 2).\n                GetRotated((float)AnglePitch_x1000 / 1000));\n            CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);\n            CurrentCorners.Add(FVector2D(float(Box.PosX) / COORD_SCALE + float(Box.SizeX) / COORD_SCALE / 2,\n                                         float(Box.PosY) / COORD_SCALE - float(Box.SizeY) / COORD_SCALE / 2).\n                GetRotated((float)AnglePitch_x1000 / 1000));\n            CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);\n            CurrentCorners.Add(FVector2D(float(Box.PosX) / COORD_SCALE + float(Box.SizeX) / COORD_SCALE / 2,\n                                         float(Box.PosY) / COORD_SCALE + float(Box.SizeY) / COORD_SCALE / 2).\n                GetRotated((float)AnglePitch_x1000 / 1000));\n            CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);\n            CurrentCorners.Add(FVector2D(float(Box.PosX) / COORD_SCALE - float(Box.SizeX) / COORD_SCALE / 2,\n                                         float(Box.PosY) / COORD_SCALE + float(Box.SizeY) / COORD_SCALE / 2).\n                GetRotated((float)AnglePitch_x1000 / 1000));\n            CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);\n        }\n        else\n        {\n            CurrentCorners.Add(FVector2D(float(-Box.PosX) / COORD_SCALE - float(Box.SizeX) / COORD_SCALE / 2,\n                                         float(Box.PosY) / COORD_SCALE - float(Box.SizeY) / COORD_SCALE / 2).\n                GetRotated(180 - (float)AnglePitch_x1000 / 1000 + 180));\n            CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);\n            CurrentCorners.Add(FVector2D(float(-Box.PosX) / COORD_SCALE + float(Box.SizeX) / COORD_SCALE / 2,\n                                         float(Box.PosY) / COORD_SCALE - float(Box.SizeY) / COORD_SCALE / 2).\n                GetRotated(180 - (float)AnglePitch_x1000 / 1000 + 180));\n            CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);\n            CurrentCorners.Add(FVector2D(float(-Box.PosX) / COORD_SCALE + float(Box.SizeX) / COORD_SCALE / 2,\n                                         float(Box.PosY) / COORD_SCALE + float(Box.SizeY) / COORD_SCALE / 2).\n                GetRotated(180 - (float)AnglePitch_x1000 / 1000 + 180));\n            CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);\n            CurrentCorners.Add(FVector2D(float(-Box.PosX) / COORD_SCALE - float(Box.SizeX) / COORD_SCALE / 2,\n                                         float(Box.PosY) / COORD_SCALE + float(Box.SizeY) / COORD_SCALE / 2).\n                GetRotated(180 - (float)AnglePitch_x1000 / 1000 + 180));\n            CurrentCorners.Last() += FVector2D(PosX / COORD_SCALE, PosY / COORD_SCALE);\n        }\n        Corners.Add(CurrentCorners);\n        TArray&lt;TArray&lt;FVector2D&gt;&gt; CurrentLines;\n        for (int j = 0; j &lt; 4; j++)\n        {\n            CurrentLines.Add(TArray{CurrentCorners[j], CurrentCorners[(j + 1) % 4]});\n        }\n        Lines.Add(CurrentLines);\n        FLinearColor color;\n        if (Box.Type == BOX_Hit)\n            color = FLinearColor(1.f, 0.f, 0.f, .25f);\n        else if (AttackFlags &amp; ATK_IsAttacking)\n            color = FLinearColor(0.f, 1.f, 1.f, .25f);\n        else\n            color = FLinearColor(0.f, 1.f, 0.f, .25f);\n        for (const auto&amp; LineSet : Lines.Last())\n        {\n            auto start = LineSet[0];\n            auto end = LineSet[1];\n            DrawDebugLine(GetWorld(), FVector(start.X, 0, start.Y), FVector(end.X, 0, end.Y), color.ToFColor(false),\n                          false, 1 / 60, 255, 2.f);\n        }\n    }\n    TArray&lt;FVector2D&gt; CurrentCorners;\n    CurrentCorners.Add(FVector2D(L / COORD_SCALE, B / COORD_SCALE));\n    CurrentCorners.Add(FVector2D(R / COORD_SCALE, B / COORD_SCALE));\n    CurrentCorners.Add(FVector2D(R / COORD_SCALE, T / COORD_SCALE));\n    CurrentCorners.Add(FVector2D(L / COORD_SCALE, T / COORD_SCALE));\n    TArray&lt;TArray&lt;FVector2D&gt;&gt; CurrentLines;\n    for (int j = 0; j &lt; 4; j++)\n    {\n        CurrentLines.Add(TArray{CurrentCorners[j], CurrentCorners[(j + 1) % 4]});\n    }\n    FLinearColor color = FLinearColor(1.f, 1.f, 0.f, .2f);\n\n    for (const auto&amp; LineSet : CurrentLines)\n    {\n        auto start = LineSet[0];\n        auto end = LineSet[1];\n        DrawDebugLine(GetWorld(), FVector(start.X, 0, start.Y), FVector(end.X, 0, end.Y), color.ToFColor(false), false,\n                      1 / 60, 255, 2.f);\n    }\n}\n\nvoid ABattleObject::SaveForRollback(unsigned char* Buffer) const\n{\n    FMemory::Memcpy(Buffer, &amp;ObjSync, SizeOfBattleObject);\n}\n\nvoid ABattleObject::LoadForRollback(const unsigned char* Buffer)\n{\n    FMemory::Memcpy(&amp;ObjSync, Buffer, SizeOfBattleObject);\n    if (!IsPlayer)\n    {\n        const int StateIndex = Player-&gt;ObjectStateNames.Find(ObjectStateName);\n        if (StateIndex != INDEX_NONE)\n        {\n            ObjectState = Player-&gt;ObjectStates[StateIndex];\n            ObjectState-&gt;Parent = this;\n        }\n    }\n}\n\nvoid FBattleObjectLog::LogForSyncTestFile(std::ofstream&amp; file)\n{\n    if (file)\n    {\n        file &lt;&lt; \"BattleObject:\\n\";\n        file &lt;&lt; \"\\tPosX: \" &lt;&lt; PosX &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tPosY: \" &lt;&lt; PosY &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tPosZ: \" &lt;&lt; PosZ &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tPrevPosX: \" &lt;&lt; PrevPosX &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tPrevPosY: \" &lt;&lt; PrevPosY &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tPrevPosZ: \" &lt;&lt; PrevPosZ &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tSpeedX: \" &lt;&lt; SpeedX &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tSpeedY: \" &lt;&lt; SpeedY &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tSpeedZ: \" &lt;&lt; SpeedZ &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tGravity: \" &lt;&lt; Gravity &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tInertia: \" &lt;&lt; Inertia &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tActionTime: \" &lt;&lt; ActionTime &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tPushHeight: \" &lt;&lt; PushHeight &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tPushHeightLow: \" &lt;&lt; PushHeightLow &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tPushWidth: \" &lt;&lt; PushWidth &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tStunTime: \" &lt;&lt; StunTime &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tStunTimeMax: \" &lt;&lt; StunTimeMax &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tHitstop: \" &lt;&lt; Hitstop &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tCelName: \" &lt;&lt; TCHAR_TO_ANSI(*CelName.ToString()) &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tAttackFlags: \" &lt;&lt; AttackFlags &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tDirection: \" &lt;&lt; Direction &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tMiscFlags: \" &lt;&lt; MiscFlags &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tCelIndex: \" &lt;&lt; CelIndex &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tTimeUntilNextCel: \" &lt;&lt; TimeUntilNextCel &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tAnimFrame: \" &lt;&lt; AnimFrame &lt;&lt; std::endl;\n    }\n}\n\nvoid ABattleObject::UpdateVisuals()\n{\n    if (IsValid(GameState))\n    {\n        if (GameState-&gt;BattleState.CurrentSequenceTime &gt;= 0)\n        {\n            ScreenSpaceDepthOffset = 0;\n            if (DrawPriorityLinkObj)\n                ScreenSpaceDepthOffset = DrawPriorityLinkObj-&gt;ScreenSpaceDepthOffset;\n            OrthoBlendActive = FMath::Lerp(OrthoBlendActive, 0, 0.2);\n        }\n        else\n        {\n            if (DrawPriorityLinkObj)\n                ScreenSpaceDepthOffset = DrawPriorityLinkObj-&gt;ScreenSpaceDepthOffset;\n            else\n                ScreenSpaceDepthOffset = (MaxDrawPriority - DrawPriority) * 50;\n            OrthoBlendActive = FMath::Lerp(OrthoBlendActive, 1, 0.2);\n        }\n    }\n    else\n    {\n        ScreenSpaceDepthOffset = 0;\n        OrthoBlendActive = 1;\n    }\n\n    AddColor = FMath::Lerp(AddColor, AddFadeColor, AddFadeSpeed);\n    MulColor = FMath::Lerp(MulColor, MulFadeColor, MulFadeSpeed);\n    Transparency = FMath::Lerp(Transparency, FadeTransparency, TransparencySpeed);\n}\n\nvoid ABattleObject::UpdateVisualsNoRollback()\n{\n    UpdateVisuals_BP();\n\n    if (!bRender)\n    {\n        SetActorHiddenInGame(true);\n        return;\n    }\n\n    if (IsPlayer)\n    {\n        if ((Player-&gt;PlayerFlags &amp; PLF_IsOnScreen) == 0)\n        {\n            SetActorHiddenInGame(true);\n            return;\n        }\n    }\n    else\n    {\n        if (!IsActive)\n        {\n            SetActorHiddenInGame(true);\n            return;\n        }\n    }\n    SetActorHiddenInGame(false);\n    if (LinkedParticle)\n    {\n        if (Direction == DIR_Left)\n        {\n            LinkedParticle-&gt;SetVariableFloat(FName(\"SpriteRotate\"), AnglePitch_x1000 / 1000);\n        }\n        else\n        {\n            LinkedParticle-&gt;SetVariableFloat(FName(\"SpriteRotate\"), -AnglePitch_x1000 / 1000);\n        }\n    }\n    if (LinkedActor)\n    {\n        TArray&lt;USkeletalMeshComponent*&gt; SkeletalMeshComponents;\n        GetComponents(USkeletalMeshComponent::StaticClass(), SkeletalMeshComponents);\n\n        for (auto SkeletalMeshComponent : SkeletalMeshComponents)\n        {\n            if (!SkeletalMeshComponent-&gt;IsVisible()) continue;\n            if (!SkeletalMeshComponent-&gt;IsVisible() || !IsValid(SkeletalMeshComponent-&gt;GetAnimInstance())) continue;\n            SkeletalMeshComponent-&gt;GetAnimInstance()-&gt;UpdateAnimation(OneFrame, false); \n            SkeletalMeshComponent-&gt;TickAnimation(OneFrame, false); \n            SkeletalMeshComponent-&gt;TickPose(OneFrame, true);  \n        }\n    }\n\n    FRotator FlipRotation = FRotator::ZeroRotator;\n    if (Direction == DIR_Left)\n    {\n        if (Player-&gt;bMirrorWhenFlip &amp;&amp; IsPlayer)\n        {\n            FlipRotation = FRotator(0, 180, 0);\n            SetActorScale3D(FVector(1, 1, 1) * ObjectScale);\n            if (!GameState) SetActorRotation(FlipRotation);\n        }\n        else\n            SetActorScale3D(FVector(-1, 1, 1) * ObjectScale);\n    }\n    else\n    {\n        SetActorScale3D(FVector(1, 1, 1) * ObjectScale);\n    }\n\n    if (GameState)\n    {\n        if (SocketName == NAME_None) //only set visual location if not attached to socket\n        {\n            FRotator Rotation = FRotator(AnglePitch_x1000 / 1000, AngleYaw_x1000 / 1000, AngleRoll_x1000 / 1000);\n            if (Direction == DIR_Left)\n                Rotation.Pitch = 180 - Rotation.Pitch + 180;\n            SetActorRotation(\n                GameState-&gt;BattleSceneTransform.GetRotation() * (Rotation.Quaternion() * FlipRotation.\n                    Quaternion() * ObjectRotation.Quaternion()));\n            FVector Location = FVector(static_cast&lt;float&gt;(PosX) / COORD_SCALE, static_cast&lt;float&gt;(PosZ) / COORD_SCALE,\n                                       static_cast&lt;float&gt;(PosY) / COORD_SCALE) + ObjectOffset;\n            Location = GameState-&gt;BattleSceneTransform.GetRotation().RotateVector(Location) + GameState-&gt;\n                BattleSceneTransform.GetLocation();\n            SetActorLocation(Location);\n        }\n        else\n        {\n            FVector FinalSocketOffset = SocketOffset;\n            if (Direction != DIR_Right)\n                FinalSocketOffset.Y = -SocketOffset.Y;\n            const auto Obj = GetBattleObject(SocketObj);\n            TArray&lt;USkeletalMeshComponent*&gt; SocketSkeletalMeshComponents;\n            Obj-&gt;GetComponents(USkeletalMeshComponent::StaticClass(), SocketSkeletalMeshComponents);\n            for (const auto Component : SocketSkeletalMeshComponents)\n            {\n                if (!Component-&gt;DoesSocketExist(SocketName)) continue;\n                FVector SocketLocation;\n                FRotator SocketRotation;\n                Component-&gt;GetSocketWorldLocationAndRotation(SocketName, SocketLocation, SocketRotation);\n                SetActorLocation(FinalSocketOffset + SocketLocation);\n                SetActorRotation(SocketRotation);\n            }\n        }\n    }\n\n    if (LinkedActor)\n    {\n        LinkedActor-&gt;SetActorScale3D(GetActorScale3D());\n        LinkedActor-&gt;SetActorRotation(GetActorRotation());\n        LinkedActor-&gt;SetActorLocation(GetActorLocation());\n    }\n    if (LinkedParticle)\n    {\n        LinkedParticle-&gt;SetVariableFloat(FName(\"ScreenSpaceDepthOffset\"), ScreenSpaceDepthOffset);\n        LinkedParticle-&gt;SetVariableFloat(FName(\"OrthoBlendActive\"), OrthoBlendActive);\n    }\n\n    TInlineComponentArray&lt;UPrimitiveComponent*&gt; Components(this);\n    GetComponents(Components);\n    for (const auto Component : Components)\n    {\n        for (int64 i = 0; i &lt; Component-&gt;GetNumMaterials(); i++)\n        {\n            if (const auto MIDynamic = Cast&lt;UMaterialInstanceDynamic&gt;(Component-&gt;GetMaterial(i)); IsValid(MIDynamic))\n            {\n                MIDynamic-&gt;SetScalarParameterValue(FName(TEXT(\"Transparency\")), Transparency);\n                MIDynamic-&gt;SetScalarParameterValue(FName(TEXT(\"ScreenSpaceDepthOffset\")), ScreenSpaceDepthOffset);\n                MIDynamic-&gt;SetScalarParameterValue(FName(TEXT(\"OrthoBlendActive\")), OrthoBlendActive);\n                MIDynamic-&gt;SetVectorParameterValue(FName(TEXT(\"AddColor\")), AddColor);\n                MIDynamic-&gt;SetVectorParameterValue(FName(TEXT(\"MulColor\")), MulColor);\n                MIDynamic-&gt;SetVectorParameterValue(FName(TEXT(\"DamageColor\")), DamageColor);\n                MIDynamic-&gt;SetVectorParameterValue(FName(TEXT(\"DamageColor2\")), DamageColor2);\n            }\n        }\n        if (const auto Mesh = Cast&lt;USkeletalMeshComponent&gt;(Component); IsValid(Mesh))\n        {\n            if (const auto MIDynamic = Cast&lt;UMaterialInstanceDynamic&gt;(Mesh-&gt;OverlayMaterial); IsValid(MIDynamic))\n            {\n                MIDynamic-&gt;SetScalarParameterValue(FName(TEXT(\"Transparency\")), Transparency);\n                MIDynamic-&gt;SetScalarParameterValue(FName(TEXT(\"ScreenSpaceDepthOffset\")), ScreenSpaceDepthOffset);\n                MIDynamic-&gt;SetScalarParameterValue(FName(TEXT(\"OrthoBlendActive\")), OrthoBlendActive);\n                MIDynamic-&gt;SetVectorParameterValue(FName(TEXT(\"DamageColor\")), DamageColor);\n                MIDynamic-&gt;SetVectorParameterValue(FName(TEXT(\"DamageColor2\")), DamageColor2);\n            }\n        }\n    }\n\n    FrameBlendPosition = static_cast&lt;float&gt;(MaxCelTime - TimeUntilNextCel) / static_cast&lt;float&gt;(MaxCelTime);\n    MarkComponentsRenderStateDirty();\n}\n\nvoid ABattleObject::FuncCall(const FName&amp; FuncName) const\n{\n    UState* CurrentState = ObjectState;\n    if (IsPlayer)\n        CurrentState = Player-&gt;PrimaryStateMachine.CurrentState;\n\n    UFunction* const Func = CurrentState-&gt;FindFunction(FuncName);\n    if (IsValid(Func) &amp;&amp; Func-&gt;ParmsSize == 0)\n    {\n        CurrentState-&gt;ProcessEvent(Func, nullptr);\n    }\n}\n\nUNightSkyAnimSequenceUserData* ABattleObject::GetAnimSequenceUserData(const FName PartName) const\n{\n    TInlineComponentArray&lt;UPrimitiveComponent*&gt; Components;\n    GetComponents(Components);\n    for (int i = 0; i &lt; Components.Num(); i++)\n    {\n        const auto Component = Components[i];\n        if (Component-&gt;GetName() != PartName) continue;\n\n        const auto AnimSequence = GetAnimSequenceForPart(*Component-&gt;GetName());\n        if (!AnimSequence) return nullptr;\n\n        if (!AnimSequence-&gt;FindMetaDataByClass(UNightSkyAnimMetaData::StaticClass())) return nullptr;\n        return AnimSequence-&gt;GetAssetUserData&lt;UNightSkyAnimSequenceUserData&gt;();\n    }\n\n    return nullptr;\n}\n\nTArray&lt;UNightSkyAnimSequenceUserData*&gt; ABattleObject::GetAnimSequenceUserDatas() const\n{\n    TArray&lt;UNightSkyAnimSequenceUserData*&gt; UserDatas;\n\n    TInlineComponentArray&lt;UPrimitiveComponent*&gt; Components;\n    GetComponents(Components);\n    for (int i = 0; i &lt; Components.Num(); i++)\n    {\n        const auto Component = Components[i];\n        const auto AnimSequence = GetAnimSequenceForPart(*Component-&gt;GetName());\n        if (!AnimSequence) continue;\n\n        auto UserData = AnimSequence-&gt;GetAssetUserData&lt;UNightSkyAnimSequenceUserData&gt;();\n        if (!UserData) continue;\n\n        UserDatas.Add(UserData);\n    }\n\n    return UserDatas;\n}\n\nvoid ABattleObject::GetBoxes()\n{\n    Boxes.Empty();\n    if (Player-&gt;CommonCollisionData != nullptr)\n    {\n        for (int i = 0; i &lt; Player-&gt;CommonCollisionData-&gt;CollisionFrames.Num(); i++)\n        {\n            if (Player-&gt;CommonCollisionData-&gt;CollisionFrames[i].CelName == CelName)\n            {\n                AnimStructs = Player-&gt;CommonCollisionData-&gt;CollisionFrames[i].Anim;\n                AnimBlendIn = Player-&gt;CommonCollisionData-&gt;CollisionFrames[i].AnimBlendIn;\n                AnimBlendOut = Player-&gt;CommonCollisionData-&gt;CollisionFrames[i].AnimBlendOut;\n                AnimFrame = Player-&gt;CommonCollisionData-&gt;CollisionFrames[i].AnimFrame;\n                if (BlendCelName == FGameplayTag::EmptyTag) BlendAnimFrame = AnimFrame;\n                Boxes = Player-&gt;CommonCollisionData-&gt;CollisionFrames[i].Boxes;\n            }\n            if (Player-&gt;CommonCollisionData-&gt;CollisionFrames[i].CelName == BlendCelName)\n            {\n                BlendAnimFrame = Player-&gt;CommonCollisionData-&gt;CollisionFrames[i].AnimFrame;\n                for (auto&amp; Box : Player-&gt;CommonCollisionData-&gt;CollisionFrames[i].Boxes)\n                {\n                    if (Box.Type != BOX_Offset) continue;\n\n                    NextOffsetX = Box.PosX;\n                    NextOffsetY = Box.PosY;\n                }\n            }\n        }\n    }\n    if (Player-&gt;CollisionData != nullptr)\n    {\n        for (int i = 0; i &lt; Player-&gt;CollisionData-&gt;CollisionFrames.Num(); i++)\n        {\n            if (Player-&gt;CollisionData-&gt;CollisionFrames[i].CelName == CelName)\n            {\n                AnimStructs = Player-&gt;CollisionData-&gt;CollisionFrames[i].Anim;\n                AnimBlendIn = Player-&gt;CollisionData-&gt;CollisionFrames[i].AnimBlendIn;\n                AnimBlendOut = Player-&gt;CollisionData-&gt;CollisionFrames[i].AnimBlendOut;\n                AnimFrame = Player-&gt;CollisionData-&gt;CollisionFrames[i].AnimFrame;\n                if (BlendCelName == FGameplayTag::EmptyTag) BlendAnimFrame = AnimFrame;\n                Boxes = Player-&gt;CollisionData-&gt;CollisionFrames[i].Boxes;\n            }\n            if (Player-&gt;CollisionData-&gt;CollisionFrames[i].CelName == BlendCelName)\n            {\n                BlendAnimFrame = Player-&gt;CollisionData-&gt;CollisionFrames[i].AnimFrame;\n                for (auto&amp; Box : Player-&gt;CollisionData-&gt;CollisionFrames[i].Boxes)\n                {\n                    if (Box.Type != BOX_Offset) continue;\n\n                    NextOffsetX = Box.PosX;\n                    NextOffsetY = Box.PosY;\n                }\n            }\n        }\n    }\n}\n\nvoid ABattleObject::InitObject()\n{\n    if (IsPlayer)\n        return;\n    if (IsValid(LinkedParticle))\n    {\n        LinkedParticle-&gt;Deactivate();\n    }\n    ObjectState-&gt;Parent = this;\n    ObjectState-&gt;Init();\n    FVector Location = FVector(static_cast&lt;float&gt;(PosX) / COORD_SCALE, static_cast&lt;float&gt;(PosZ) / COORD_SCALE,\n                               static_cast&lt;float&gt;(PosY) / COORD_SCALE);\n    Location = GameState-&gt;BattleSceneTransform.GetRotation().RotateVector(Location) + GameState-&gt;BattleSceneTransform.\n        GetLocation();\n    SetActorLocation(Location);\n    SetActorRotation(GameState-&gt;BattleSceneTransform.GetRotation());\n    if (Direction == DIR_Left)\n    {\n        SetActorScale3D(FVector(-1, 1, 1));\n    }\n    else\n    {\n        SetActorScale3D(FVector(1, 1, 1));\n    }\n}\n\nvoid ABattleObject::Update()\n{\n    CalculatePushbox();\n\n    if (!IsPlayer)\n    {\n        PositionLinkUpdate();\n\n        if (StopLinkObj)\n            Hitstop = StopLinkObj-&gt;Hitstop;\n    }\n\n    if (Hitstop &gt; 0) //break if hitstop active.\n    {\n        Hitstop--;\n        return;\n    }\n\n    if (!IsPlayer &amp;&amp; MiscFlags &amp; MISC_DeactivateOnNextUpdate)\n    {\n        ResetObject();\n        return;\n    }\n\n    if (IsPlayer)\n        if (Player-&gt;PlayerFlags &amp; PLF_IsThrowLock)\n            return;\n\n    if (Timer0 &gt; 0)\n    {\n        --Timer0;\n        if (Timer0 == 0) TriggerEvent(EVT_Timer0, StateMachine_Primary);\n    }\n    if (Timer1 &gt; 0)\n    {\n        --Timer1;\n        if (Timer1 == 0) TriggerEvent(EVT_Timer1, StateMachine_Primary);\n    }\n\n    if (MiscFlags &amp; MISC_FlipEnable)\n        HandleFlip();\n\n    if (PosY == GroundHeight &amp;&amp; PrevPosY != GroundHeight)\n    {\n        if (!IsPlayer)\n        {\n            TriggerEvent(EVT_Landing, StateMachine_Primary);\n            SpeedX = 0;\n        }\n    }\n\n    if (!IsPlayer)\n    {\n        if (ActionTime == 0)\n        {\n            ObjectState-&gt;Init();\n        }\n\n        ObjectState-&gt;CallExec();\n        TriggerEvent(EVT_Update, StateMachine_Primary);\n\n        if (LinkedActor)\n            LinkedActor-&gt;Update();\n\n        if (TimeUntilNextCel &gt; 0)\n            TimeUntilNextCel--;\n        if (TimeUntilNextCel == 0)\n            CelIndex++;\n\n        Move();\n\n        GameState-&gt;SetScreenBounds();\n        ActionTime++;\n\n        if (MiscFlags &amp; MISC_DeactivateIfBeyondBounds)\n        {\n            if (PosX &gt; GameState-&gt;BattleState.ScreenData.ScreenBoundsRight * 1000 + 105000\n                || PosX &lt; GameState-&gt;BattleState.ScreenData.ScreenBoundsLeft * 1000 - 105000)\n                DeactivateObject();\n        }\n    }\n}\n\nvoid ABattleObject::ResetObject()\n{\n    if (IsPlayer)\n        return;\n\n    if (IsValid(LinkedParticle))\n    {\n        LinkedParticle-&gt;SetVisibility(false);\n        LinkedParticle-&gt;Deactivate();\n    }\n    RemoveLinkActor();\n    OrthoBlendActive = 1;\n\n    IsActive = false;\n    PosX = 0;\n    PosY = 0;\n    PosZ = 0;\n    PrevPosX = 0;\n    PrevPosY = 0;\n    PrevPosZ = 0;\n    PrevOffsetX = 0;\n    PrevOffsetY = 0;\n    NextOffsetX = 0;\n    NextOffsetY = 0;\n    PrevRootMotionX = 0;\n    PrevRootMotionY = 0;\n    PrevRootMotionZ = 0;\n    AnglePitch_x1000 = 0;\n    AngleYaw_x1000 = 0;\n    AngleRoll_x1000 = 0;\n    SpeedX = 0;\n    SpeedY = 0;\n    SpeedZ = 0;\n    Gravity = 0;\n    Inertia = 0;\n    ActionTime = 0;\n    PushHeight = 0;\n    PushHeightLow = 0;\n    PushWidth = 0;\n    PushWidthExtend = 0;\n    Hitstop = 0;\n    L = 0;\n    R = 0;\n    T = 0;\n    B = 0;\n    HitCommon = FHitDataCommon();\n    NormalHit = FHitData();\n    CounterHit = FHitData();\n    ReceivedHitCommon = FHitDataCommon();\n    ReceivedHit = FHitData();\n    AttackFlags = ATK_AttackProjectileAttribute;\n    StunTime = 0;\n    StunTimeMax = 0;\n    Hitstop = 0;\n    MiscFlags = 0;\n    Direction = DIR_Right;\n    SpeedXRate = 100;\n    SpeedXRatePerFrame = 100;\n    SpeedYRate = 100;\n    SpeedYRatePerFrame = 100;\n    SpeedZRate = 100;\n    SpeedZRatePerFrame = 100;\n    GroundHeight = 0;\n    ActionReg1 = 0;\n    ActionReg2 = 0;\n    ActionReg3 = 0;\n    ActionReg4 = 0;\n    ActionReg5 = 0;\n    ActionReg6 = 0;\n    ActionReg7 = 0;\n    ActionReg8 = 0;\n    ObjectReg1 = 0;\n    ObjectReg2 = 0;\n    ObjectReg3 = 0;\n    ObjectReg4 = 0;\n    ObjectReg5 = 0;\n    ObjectReg6 = 0;\n    ObjectReg7 = 0;\n    ObjectReg8 = 0;\n    SubroutineReg1 = 0;\n    SubroutineReg2 = 0;\n    SubroutineReg3 = 0;\n    SubroutineReg4 = 0;\n    SubroutineReturnVal1 = 0;\n    SubroutineReturnVal2 = 0;\n    SubroutineReturnVal3 = 0;\n    SubroutineReturnVal4 = 0;\n    Timer0 = 0;\n    Timer1 = 0;\n    DrawPriority = 0;\n    HomingParams = FHomingParams();\n    SuperArmorData = FSuperArmorData();\n    UpdateTime = 0;\n    ObjectOffset = FVector::ZeroVector;\n    ObjectRotation = FRotator::ZeroRotator;\n    ObjectScale = FVector::OneVector;\n    CelName = FGameplayTag();\n    BlendCelName = FGameplayTag();\n    AnimFrame = 0;\n    BlendAnimFrame = 0;\n    FrameBlendPosition = 0;\n    CelIndex = 0;\n    TimeUntilNextCel = 0;\n    MaxCelTime = 0;\n    for (auto&amp; Handler : EventHandlers)\n        Handler = FEventHandler();\n    ColPosX = 0;\n    ColPosY = 0;\n    for (auto&amp; Box : Boxes)\n    {\n        Box = FCollisionBox();\n    }\n    ObjectStateName = FGameplayTag();\n    ObjectID = 0;\n    Player = nullptr;\n    AttackTarget = nullptr;\n    StopLinkObj = nullptr;\n    PositionLinkObj = nullptr;\n    MaterialLinkObj = nullptr;\n    SocketName = NAME_None;\n    SocketObj = OBJ_Self;\n    SocketOffset = FVector::ZeroVector;\n    AddColor = FLinearColor(0, 0, 0, 1);\n    MulColor = FLinearColor(1, 1, 1, 1);\n    AddFadeColor = FLinearColor(0, 0, 0, 1);\n    MulFadeColor = FLinearColor(1, 1, 1, 1);\n    AddFadeSpeed = 0;\n    MulFadeSpeed = 0;\n    Transparency = 1;\n    FadeTransparency = 1;\n    TransparencySpeed = 0;\n    DamageColor = FLinearColor(1, 1, 1, 1);\n    DamageColor2 = FLinearColor(1, 1, 1, 1);\n    bRender = true;\n    ObjectsToIgnoreHitsFrom.Empty();\n    for (const auto Object : GameState-&gt;SortedObjects)\n    {\n        Object-&gt;ObjectsToIgnoreHitsFrom.Remove(this);\n    }\n}\n\nUAnimSequenceBase* ABattleObject::GetAnimSequenceForPart(const FName Part) const\n{\n    for (auto [PartName, AnimSequence, Flipbook] : AnimStructs)\n    {\n        if (PartName == Part) return AnimSequence;\n    }\n\n    return nullptr;\n}\n\nUPaperFlipbook* ABattleObject::GetFlipbookForPart(const FName Part) const\n{\n    for (auto [PartName, AnimSequence, Flipbook] : AnimStructs)\n    {\n        if (PartName == Part) return Flipbook;\n    }\n\n    return nullptr;\n}\n\nbool ABattleObject::IsStopped() const\n{\n    if (!GameState) return false;\n    if (!IsPlayer &amp;&amp; IsValid(StopLinkObj) &amp;&amp; StopLinkObj-&gt;IsStopped()) return true;\n    if (GameState-&gt;BattleState.SuperFreezeDuration &amp;&amp; this != GameState-&gt;BattleState.SuperFreezeCaller &amp;&amp; !(MiscFlags &amp; MISC_IgnoreSuperFreeze)) return true;\n    if (GameState-&gt;BattleState.SuperFreezeSelfDuration &amp;&amp; this == GameState-&gt;BattleState.SuperFreezeCaller &amp;&amp; !(MiscFlags &amp; MISC_IgnoreSuperFreeze)) return true;\n    return Hitstop &gt; 0 || (IsPlayer &amp;&amp; Player-&gt;PlayerFlags &amp; PLF_IsThrowLock);\n}\n\nbool ABattleObject::IsTimerPaused() const\n{\n    if (!GameState) return false;\n    return GameState-&gt;BattleState.PauseTimer;\n}\n\nvoid ABattleObject::CallSubroutine(FGameplayTag Name)\n{\n    SubroutineReturnVal1 = 0;\n    SubroutineReturnVal2 = 0;\n    SubroutineReturnVal3 = 0;\n    SubroutineReturnVal4 = 0;\n\n    if (Player-&gt;CommonSubroutineNames.Find(Name) != INDEX_NONE)\n    {\n        Player-&gt;CommonSubroutines[Player-&gt;CommonSubroutineNames.Find(Name)]-&gt;Parent = this;\n        Player-&gt;CommonSubroutines[Player-&gt;CommonSubroutineNames.Find(Name)]-&gt;Exec();\n        return;\n    }\n\n    if (Player-&gt;SubroutineNames.Find(Name) != INDEX_NONE)\n    {\n        Player-&gt;Subroutines[Player-&gt;SubroutineNames.Find(Name)]-&gt;Parent = this;\n        Player-&gt;Subroutines[Player-&gt;SubroutineNames.Find(Name)]-&gt;Exec();\n    }\n}\n\nvoid ABattleObject::CallSubroutineWithArgs(FGameplayTag Name, int32 Arg1, int32 Arg2, int32 Arg3, int32 Arg4)\n{\n    SubroutineReg1 = Arg1;\n    SubroutineReg2 = Arg2;\n    SubroutineReg3 = Arg3;\n    SubroutineReg4 = Arg4;\n    CallSubroutine(Name);\n}\n\nvoid ABattleObject::InitEventHandler(EEventType EventType, FName FuncName, int32 Value, FGameplayTag SubroutineName)\n{\n    switch (EventType)\n    {\n    case EVT_Timer0:\n        Timer0 = Value;\n        break;\n    case EVT_Timer1:\n        Timer1 = Value;\n        break;\n    case EVT_Update:\n        UpdateTime = 0;\n    default: break;\n    }\n    EventHandlers[EventType].FunctionName = FuncName;\n    EventHandlers[EventType].SubroutineName = SubroutineName;\n}\n\nvoid ABattleObject::RemoveEventHandler(EEventType EventType)\n{\n    EventHandlers[EventType].FunctionName = NAME_None;\n    EventHandlers[EventType].SubroutineName = FGameplayTag();\n    if (EventType == EVT_Update)\n        UpdateTime = 0;\n}\n\nFGameplayTag ABattleObject::GetCelName() const\n{\n    return CelName;\n}\n\nFGameplayTag ABattleObject::GetLabelName() const\n{\n    return LabelName;\n}\n\nvoid ABattleObject::SetCelName(FGameplayTag InName)\n{\n    CelName = InName;\n    SetBlendCelName(FGameplayTag::EmptyTag);\n    BlendAnimFrame = 0;\n\n    GetBoxes();\n\n    // Get position offset from boxes\n    if (!GameState) return;\n    for (auto Box : Boxes)\n    {\n        if (Box.Type == BOX_Offset)\n        {\n            PosY += Box.PosY - PrevOffsetY;\n            AddPosXWithDir(Box.PosX - PrevOffsetX);\n\n            PrevOffsetX = Box.PosX;\n            PrevOffsetY = Box.PosY;\n        }\n    }\n}\n\nvoid ABattleObject::SetBlendCelName(FGameplayTag InName)\n{\n    BlendCelName = InName;\n    FrameBlendPosition = 0;\n\n    GetBoxes();\n}\n\nvoid ABattleObject::GotoLabel(FGameplayTag InName)\n{\n    if (!GameState &amp;&amp; !CharaSelectGameState) return;\n    LabelName = InName;\n    GotoLabelActive = true;\n\n    if (!Player) ObjectState-&gt;CallExec();\n    else Player-&gt;PrimaryStateMachine.Update();\n}\n\nvoid ABattleObject::SetTimeUntilNextCel(int32 InTime)\n{\n    TimeUntilNextCel = InTime;\n}\n\nvoid ABattleObject::SetCelDuration(int32 InTime)\n{\n    TimeUntilNextCel = MaxCelTime = InTime;\n}\n\nvoid ABattleObject::AddPosXWithDir(int InPosX)\n{\n    if (Direction == DIR_Right)\n    {\n        PosX += InPosX;\n    }\n    else\n    {\n        PosX -= InPosX;\n    }\n}\n\nvoid ABattleObject::SetSpeedXRaw(int InSpeedX)\n{\n    if (Direction == DIR_Right)\n    {\n        SpeedX = InSpeedX;\n    }\n    else\n    {\n        SpeedX = -InSpeedX;\n    }\n}\n\nvoid ABattleObject::AddSpeedXRaw(int InSpeedX)\n{\n    if (Direction == DIR_Right)\n    {\n        SpeedX += InSpeedX;\n    }\n    else\n    {\n        SpeedX -= InSpeedX;\n    }\n}\n\nint32 ABattleObject::GetPosYCenter() const\n{\n    int32 CenterPosY = PosY;\n    if (IsPlayer)\n    {\n        switch (Player-&gt;Stance)\n        {\n        case ACT_Standing:\n        case ACT_Jumping:\n        default:\n            CenterPosY += 200000;\n            break;\n        case ACT_Crouching:\n            CenterPosY += 90000;\n            break;\n        }\n    }\n    return CenterPosY;\n}\n\nvoid ABattleObject::SetPitch(int32 Pitch_x1000)\n{\n    AnglePitch_x1000 = NormalizeAngle(Pitch_x1000);\n}\n\nvoid ABattleObject::SetYaw(int32 Yaw_x1000)\n{\n    AngleYaw_x1000 = NormalizeAngle(Yaw_x1000);\n}\n\nvoid ABattleObject::SetRoll(int32 Roll_x1000)\n{\n    AngleRoll_x1000 = NormalizeAngle(Roll_x1000);\n}\n\nint32 ABattleObject::NormalizeAngle(int32 Angle_x1000)\n{\n    Angle_x1000 %= 360000;\n    if (Angle_x1000 &lt; 0) Angle_x1000 += 360000;\n    return Angle_x1000;\n}\n\nint32 ABattleObject::CalculateSpeedAngle() const\n{\n    return UNightSkyBlueprintFunctionLibrary::Vec2Angle_x1000(SpeedX, SpeedY);\n}\n\nint32 ABattleObject::CalculateDistanceBetweenPoints(EDistanceType Type, EObjType Obj1, EPosType Pos1, EObjType Obj2,\n                                                    EPosType Pos2)\n{\n    const ABattleObject* Actor1 = GetBattleObject(Obj1);\n    const ABattleObject* Actor2 = GetBattleObject(Obj2);\n    if (IsValid(Actor1) &amp;&amp; IsValid(Actor2))\n    {\n        int32 PosX1 = 0;\n        int32 PosX2 = 0;\n        int32 PosY1 = 0;\n        int32 PosY2 = 0;\n\n        Actor1-&gt;PosTypeToPosition(Pos1, PosX1, PosY1);\n        Actor2-&gt;PosTypeToPosition(Pos2, PosX2, PosY2);\n\n        int32 ObjDist;\n\n        switch (Type)\n        {\n        case DIST_Distance:\n            ObjDist = isqrt(\n                static_cast&lt;int64&gt;(PosX2 - PosX1) * static_cast&lt;int64&gt;(PosX2 - PosX1) + static_cast&lt;int64&gt;(PosY2 -\n                    PosY1) * static_cast&lt;int64&gt;(PosY2 - PosY1));\n            break;\n        case DIST_DistanceX:\n            ObjDist = abs(PosX2 - PosX1);\n            break;\n        case DIST_DistanceY:\n            ObjDist = abs(PosY2 - PosY1);\n            break;\n        case DIST_FrontDistanceX:\n            {\n                int DirFlag = 1;\n                if (Actor1-&gt;Direction == DIR_Left)\n                {\n                    DirFlag = -1;\n                }\n                ObjDist = (PosX2 - PosX1) * DirFlag;\n            }\n            break;\n        default:\n            return 0;\n        }\n        return ObjDist;\n    }\n    return 0;\n}\n\nint32 ABattleObject::CalculateAngleBetweenPoints(EObjType Obj1, EPosType Pos1, EObjType Obj2, EPosType Pos2)\n{\n    const ABattleObject* Actor1 = GetBattleObject(Obj1);\n    const ABattleObject* Actor2 = GetBattleObject(Obj2);\n    if (IsValid(Actor1) &amp;&amp; IsValid(Actor2))\n    {\n        int32 PosX1 = 0;\n        int32 PosX2 = 0;\n        int32 PosY1 = 0;\n        int32 PosY2 = 0;\n\n        Actor1-&gt;PosTypeToPosition(Pos1, PosX1, PosY1);\n        Actor2-&gt;PosTypeToPosition(Pos2, PosX2, PosY2);\n\n        const auto X = abs(PosX2 - PosX1);\n        const auto Y = PosY2 - PosY1;\n\n        return UNightSkyBlueprintFunctionLibrary::Vec2Angle_x1000(X, Y);\n    }\n    return 0;\n}\n\nvoid ABattleObject::SetFacing(EObjDir NewDir)\n{\n    Direction = NewDir;\n}\n\nvoid ABattleObject::FlipObject()\n{\n    if (Direction == DIR_Right)\n        Direction = DIR_Left;\n    else\n        Direction = DIR_Right;\n}\n\nvoid ABattleObject::FaceOpponent()\n{\n    const EObjDir CurrentDir = Direction;\n    if (!Player-&gt;Enemy) return;\n\n    if (GameState) GameState-&gt;SetScreenBounds();\n\n    if (PosX + 30000 &lt; Player-&gt;Enemy-&gt;PosX - 30000)\n    {\n        SetFacing(DIR_Right);\n    }\n    else if (PosX - 30000 &gt; Player-&gt;Enemy-&gt;PosX + 30000)\n    {\n        SetFacing(DIR_Left);\n    }\n    if (CurrentDir != Direction)\n    {\n        SpeedX = -SpeedX;\n        Inertia = -Inertia;\n        if (IsPlayer)\n        {\n            Player-&gt;StoredInputBuffer.FlipInputsInBuffer();\n            if (Player-&gt;Stance == ACT_Standing &amp;&amp; Player-&gt;GetEnableFlags(StateMachine_Primary) &amp; ENB_Standing)\n                Player-&gt;JumpToStatePrimary(State_Universal_StandFlip);\n            else if (Player-&gt;Stance == ACT_Crouching &amp;&amp; Player-&gt;GetEnableFlags(StateMachine_Primary) &amp; ENB_Crouching)\n                Player-&gt;JumpToStatePrimary(State_Universal_CrouchFlip);\n            else if (Player-&gt;Stance == ACT_Jumping &amp;&amp; Player-&gt;GetEnableFlags(StateMachine_Primary) &amp; ENB_Jumping)\n                Player-&gt;JumpToStatePrimary(State_Universal_JumpFlip);\n        }\n    }\n}\n\nbool ABattleObject::CheckIsGrounded() const\n{\n    return PosY &lt;= GroundHeight;\n}\n\nvoid ABattleObject::EnableHit(bool Enabled)\n{\n    if (Enabled)\n    {\n        AttackFlags |= ATK_HitActive;\n\n        if (GameState)\n        {\n            for (const auto Object : GameState-&gt;SortedObjects)\n            {\n                Object-&gt;ObjectsToIgnoreHitsFrom.Remove(this);\n            }\n        }\n    }\n    else\n    {\n        AttackFlags &amp;= ~ATK_HitActive;\n    }\n\n    if (!IsPlayer)\n    {\n        SetProjectileAttribute(true);\n    }\n}\n\nvoid ABattleObject::SetAttacking(bool Attacking)\n{\n    if (Attacking)\n    {\n        AttackFlags |= ATK_IsAttacking;\n    }\n    else\n    {\n        AttackFlags &amp;= ~ATK_IsAttacking;\n    }\n    AttackFlags &amp;= ~ATK_HasHit;\n    AttackFlags &amp;= ~ATK_HitActive;\n}\n\nvoid ABattleObject::SetPlayerHit(bool Enable)\n{\n    if (!IsPlayer)\n    {\n        if (Enable)\n        {\n            AttackFlags |= ATK_SetPlayerHit;\n        }\n        else\n        {\n            AttackFlags &amp;= ~ATK_SetPlayerHit;\n        }\n    }\n}\n\nvoid ABattleObject::SetProjectileAttribute(bool Attribute)\n{\n    if (Attribute)\n        AttackFlags |= ATK_AttackProjectileAttribute;\n    else\n        AttackFlags &amp;= ~ATK_AttackProjectileAttribute;\n}\n\nvoid ABattleObject::SetProrateOnce(bool Once)\n{\n    if (Once)\n        AttackFlags |= ATK_ProrateOnce;\n    else\n        AttackFlags &amp;= ~ATK_ProrateOnce;\n}\n\nvoid ABattleObject::SetIgnoreOTG(bool Ignore)\n{\n    if (Ignore)\n        AttackFlags |= ATK_IgnoreOTG;\n    else\n        AttackFlags &amp;= ~ATK_IgnoreOTG;\n}\n\nvoid ABattleObject::SetHitOTG(bool Enable)\n{\n    if (Enable)\n        AttackFlags |= ATK_HitOTG;\n    else\n        AttackFlags &amp;= ~ATK_HitOTG;\n\n}\n\nvoid ABattleObject::SetIgnorePushbackScaling(bool Ignore)\n{\n    if (Ignore)\n        AttackFlags |= ATK_IgnorePushbackScaling;\n    else\n        AttackFlags &amp;= ~ATK_IgnorePushbackScaling;\n}\n\nvoid ABattleObject::SetIgnoreHitstunScaling(bool Ignore)\n{\n    if (Ignore)\n        AttackFlags |= ATK_IgnoreHitstunScaling;\n    else\n        AttackFlags &amp;= ~ATK_IgnoreHitstunScaling;\n}\n\nvoid ABattleObject::DeactivateObject()\n{\n    if (IsPlayer) // Don't use on players\n        return;\n    // Remove from player cache\n    for (int i = 0; i &lt; 16; i++)\n    {\n        if (this == Player-&gt;StoredBattleObjects[i])\n        {\n            Player-&gt;StoredBattleObjects[i] = nullptr;\n            break;\n        }\n    }\n\n    // Wait until the next frame to complete\n    MiscFlags |= MISC_DeactivateOnNextUpdate;\n}\n\nbool ABattleObject::CheckBoxOverlap(ABattleObject* OtherObj, const EBoxType SelfType, const FGameplayTag SelfCustomType,\n                                    const EBoxType OtherType, const FGameplayTag OtherCustomType)\n{\n    auto RotatePoint = [](int32 (&amp;Point)[2], int32 Angle)\n    {\n        const int OrigPoint[] = {Point[0], Point[1]};\n        Point[0] = (int64)OrigPoint[0] * UNightSkyBlueprintFunctionLibrary::Cos_x1000(Angle / 100) / 1000 - (int64)\n            OrigPoint[1] *\n            UNightSkyBlueprintFunctionLibrary::Sin_x1000(Angle / 100) / 1000;\n        Point[1] = (int64)OrigPoint[0] * UNightSkyBlueprintFunctionLibrary::Sin_x1000(Angle / 100) / 1000 + (int64)\n            OrigPoint[1] *\n            UNightSkyBlueprintFunctionLibrary::Cos_x1000(Angle / 100) / 1000;\n    };\n\n    // Lambda to automate getting the normal vectors for a box\n    auto GetNormalAxes = [](const int32 (&amp;Vertices)[4][2], int32 (&amp;Normals)[4][2], bool bFacingRight)\n    {\n        // Loop over verts\n        for (int i = 0; i &lt; std::size(Vertices); i++)\n        {\n            // Get vertices\n            const auto P1 = Vertices[i];\n            const auto P2 = Vertices[i + 1 == std::size(Vertices) ? 0 : i + 1];\n            // Get edge vector\n            const int32 Edge[2] = {P1[0] - P2[0], P1[1] - P2[1]};\n            // Get normal vector\n            int32 Normal[2] = {Edge[1], -Edge[0]};\n            if (bFacingRight)\n            {\n                Normal[0] = -Normal[0];\n                Normal[1] = -Normal[1];\n            }\n            // Normalize vector\n            auto Length = isqrt((int64)Normal[0] * Normal[0] + (int64)Normal[1] * Normal[1]);\n            if (Length == 0)\n                Length = 1;\n            Normal[0] = (int64)Normal[0] * COORD_SCALE / Length;\n            Normal[1] = (int64)Normal[1] * COORD_SCALE / Length;\n            // Assign to passed in array\n            Normals[i][0] = Normal[0];\n            Normals[i][1] = Normal[1];\n        }\n    };\n\n    // Lambda to project a box onto an axis.\n    auto ProjectBoxOntoAxis = [](const int32 (&amp;Vertices)[4][2], const int32 (&amp;Normal)[2],\n                                 int32 (&amp;Proj)[2])\n    {\n        // Calculate minimum from dot product\n        int32 Min = (int64)Vertices[0][0] * Normal[0] / COORD_SCALE + (int64)Vertices[0][1] * Normal[1] / COORD_SCALE;\n        int32 Max = Min;\n\n        for (int i = 0; i &lt; std::size(Vertices); i++)\n        {\n            const int32 P = (int64)Vertices[i][0] * Normal[0] / COORD_SCALE + (int64)Vertices[i][1] * Normal[1] /\n                COORD_SCALE;\n            if (P &lt; Min)\n                Min = P;\n            else if (P &gt; Max)\n                Max = P;\n        }\n\n        Proj[0] = Min;\n        Proj[1] = Max;\n    };\n\n    // Lambda to check if projections overlap.\n    auto IsOverlapping = [](const int32 (&amp;Proj1)[2], const int32 (&amp;Proj2)[2]) -&gt; bool\n    {\n        return !(Proj1[1] &lt; Proj2[0] || Proj2[1] &lt; Proj1[0]);\n    };\n\n    // Calculate boxes for self\n    for (auto&amp; Box : Boxes)\n    {\n        if (Box.Type != SelfType)\n            continue;\n        if (Box.Type == BOX_Custom &amp;&amp; Box.CustomType != SelfCustomType)\n            continue;\n\n        // Calculate vertices\n        int32 P1[2] = {-Box.SizeX / 2, -Box.SizeY / 2};\n        int32 P2[2] = {-Box.SizeX / 2, Box.SizeY / 2};\n        int32 P3[2] = {Box.SizeX / 2, -Box.SizeY / 2};\n        int32 P4[2] = {Box.SizeX / 2, Box.SizeY / 2};\n\n        // Calculate rotated points\n        auto Angle = Direction == DIR_Right ? AnglePitch_x1000 : 180000 - AnglePitch_x1000 + 180000;\n\n        // Calculate box transform\n        if (Direction == DIR_Right)\n        {\n            P1[0] += Box.PosX;\n            P2[0] += Box.PosX;\n            P3[0] += Box.PosX;\n            P4[0] += Box.PosX;\n        }\n        else\n        {\n            P1[0] += -Box.PosX;\n            P2[0] += -Box.PosX;\n            P3[0] += -Box.PosX;\n            P4[0] += -Box.PosX;\n        }\n\n        P1[1] += Box.PosY;\n        P2[1] += Box.PosY;\n        P3[1] += Box.PosY;\n        P4[1] += Box.PosY;\n\n        RotatePoint(P1, Angle);\n        RotatePoint(P2, Angle);\n        RotatePoint(P3, Angle);\n        RotatePoint(P4, Angle);\n\n        // Calculate scene transform\n        P1[0] += PosX;\n        P2[0] += PosX;\n        P3[0] += PosX;\n        P4[0] += PosX;\n\n        P1[1] += PosY;\n        P2[1] += PosY;\n        P3[1] += PosY;\n        P4[1] += PosY;\n\n        int32 Vertices[4][2] = {\n            {P1[0], P1[1]},\n            {P2[0], P2[1]},\n            {P3[0], P3[1]},\n            {P4[0], P4[1]},\n        };\n        int32 Normals[4][2];\n        GetNormalAxes(Vertices, Normals, Direction == DIR_Right);\n\n        // Repeat for other object\n        for (auto&amp; OtherBox : OtherObj-&gt;Boxes)\n        {\n            if (OtherBox.Type != OtherType)\n                continue;\n            if (OtherBox.Type == BOX_Custom &amp;&amp; OtherBox.CustomType != OtherCustomType)\n                continue;\n\n            int32 OtherP1[2] = {-OtherBox.SizeX / 2, -OtherBox.SizeY / 2};\n            int32 OtherP2[2] = {-OtherBox.SizeX / 2, OtherBox.SizeY / 2};\n            int32 OtherP3[2] = {OtherBox.SizeX / 2, -OtherBox.SizeY / 2};\n            int32 OtherP4[2] = {OtherBox.SizeX / 2, OtherBox.SizeY / 2};\n\n            auto OtherAngle = OtherObj-&gt;Direction == DIR_Right\n                                  ? OtherObj-&gt;AnglePitch_x1000\n                                  : 180000 - OtherObj-&gt;AnglePitch_x1000 + 180000;\n\n            if (OtherObj-&gt;Direction == DIR_Right)\n            {\n                OtherP1[0] += OtherBox.PosX;\n                OtherP2[0] += OtherBox.PosX;\n                OtherP3[0] += OtherBox.PosX;\n                OtherP4[0] += OtherBox.PosX;\n            }\n            else\n            {\n                OtherP1[0] += -OtherBox.PosX;\n                OtherP2[0] += -OtherBox.PosX;\n                OtherP3[0] += -OtherBox.PosX;\n                OtherP4[0] += -OtherBox.PosX;\n            }\n\n            OtherP1[1] += OtherBox.PosY;\n            OtherP2[1] += OtherBox.PosY;\n            OtherP3[1] += OtherBox.PosY;\n            OtherP4[1] += OtherBox.PosY;\n\n            RotatePoint(OtherP1, OtherAngle);\n            RotatePoint(OtherP2, OtherAngle);\n            RotatePoint(OtherP3, OtherAngle);\n            RotatePoint(OtherP4, OtherAngle);\n\n            OtherP1[0] += OtherObj-&gt;PosX;\n            OtherP2[0] += OtherObj-&gt;PosX;\n            OtherP3[0] += OtherObj-&gt;PosX;\n            OtherP4[0] += OtherObj-&gt;PosX;\n\n            OtherP1[1] += OtherObj-&gt;PosY;\n            OtherP2[1] += OtherObj-&gt;PosY;\n            OtherP3[1] += OtherObj-&gt;PosY;\n            OtherP4[1] += OtherObj-&gt;PosY;\n\n            int32 OtherVertices[4][2] = {\n                {OtherP1[0], OtherP1[1]},\n                {OtherP2[0], OtherP2[1]},\n                {OtherP3[0], OtherP3[1]},\n                {OtherP4[0], OtherP4[1]},\n            };\n            int32 OtherNormals[4][2];\n            GetNormalAxes(OtherVertices, OtherNormals, Direction == DIR_Right);\n\n            int32 Overlap = INT_MAX;\n            int32 Smallest[2];\n\n            // Loop over the first set of normals\n            for (int i = 0; i &lt; std::size(Normals); i++)\n            {\n                int32 Axis[2] = {Normals[i][0], Normals[i][1]};\n                // Project both shapes onto the axis\n                int32 Proj1[2];\n                ProjectBoxOntoAxis(Vertices, Axis, Proj1);\n                int32 Proj2[2];\n                ProjectBoxOntoAxis(OtherVertices, Axis, Proj2);\n                // If the projections overlap...\n                if (IsOverlapping(Proj1, Proj2))\n                {\n                    int32 O = FMath::Abs(FMath::Min(Proj1[1], Proj2[1]) - FMath::Min(Proj1[0], Proj2[0]));\n                    if (O &lt; Overlap)\n                    {\n                        Overlap = O;\n                        Smallest[0] = Axis[0];\n                        Smallest[1] = Axis[1];\n                    }\n                }\n                else\n                {\n                    // Otherwise, the shapes don't overlap.\n                    goto END;\n                }\n            }\n\n            // Loop over the second set of normals\n            for (int i = 0; i &lt; std::size(OtherNormals); i++)\n            {\n                int32 Axis[2] = {OtherNormals[i][0], OtherNormals[i][1]};\n                // Project both shapes onto the axis\n                int32 Proj1[2];\n                ProjectBoxOntoAxis(Vertices, Axis, Proj1);\n                int32 Proj2[2];\n                ProjectBoxOntoAxis(OtherVertices, Axis, Proj2);\n                // If the projections overlap...\n                if (IsOverlapping(Proj1, Proj2))\n                {\n                    int32 O = FMath::Abs(FMath::Min(Proj1[1], Proj2[1]) - FMath::Min(Proj1[0], Proj2[0]));\n                    if (O &lt; Overlap)\n                    {\n                        Overlap = O;\n                        Smallest[0] = Axis[0];\n                        Smallest[1] = Axis[1];\n                    }\n                }\n                else\n                {\n                    // Otherwise, the shapes don't overlap.\n                    goto END;\n                }\n            }\n\n            ColPosX = (FMath::Max(P1[0], OtherP1[0]) + FMath::Min(P3[0], OtherP3[0])) / 2;\n            ColPosY = (FMath::Max(P1[1], OtherP1[1]) + FMath::Min(P2[1], OtherP2[1])) / 2;\n\n            return true;\n\n        END:\n            // Collision not detected, continue to next box.\n            continue;\n        }\n    }\n\n    return false;\n}\n\nvoid ABattleObject::GetBoxPosition(const EBoxType BoxType, const FGameplayTag CustomType, int&amp; OutPosX,\n                                   int&amp; OutPosY) const\n{\n    for (auto&amp; Box : Boxes)\n    {\n        if (Box.Type == BoxType)\n        {\n            if (Box.Type == BOX_Custom &amp;&amp; Box.CustomType != CustomType) continue;\n\n            OutPosX = Box.PosX;\n            OutPosY = Box.PosY;\n\n            return;\n        }\n    }\n}\n\nint32 ABattleObject::GetGauge(int32 GaugeIndex) const\n{\n    if (!GameState) return 0;\n    return GameState-&gt;GetGauge(Player-&gt;PlayerIndex == 0, GaugeIndex);\n}\n\nvoid ABattleObject::SetGauge(int32 GaugeIndex, int32 Value)\n{\n    if (!GameState) return;\n    GameState-&gt;SetGauge(Player-&gt;PlayerIndex == 0, GaugeIndex, Value);\n}\n\nvoid ABattleObject::UseGauge(int32 GaugeIndex, int32 Value)\n{\n    if (!GameState) return;\n    GameState-&gt;UseGauge(Player-&gt;PlayerIndex == 0, GaugeIndex, Value);\n}\n\nvoid ABattleObject::EnableFlip(bool Enabled)\n{\n    if (Enabled)\n    {\n        MiscFlags |= MISC_FlipEnable;\n    }\n    else\n    {\n        MiscFlags = MiscFlags &amp; ~MISC_FlipEnable;\n    }\n}\n\nvoid ABattleObject::EnableInertia()\n{\n    MiscFlags |= MISC_InertiaEnable;\n}\n\nvoid ABattleObject::DisableInertia()\n{\n    MiscFlags = MiscFlags &amp; ~MISC_InertiaEnable;\n}\n\nvoid ABattleObject::HaltMomentum()\n{\n    SpeedX = 0;\n    SpeedY = 0;\n    SpeedZ = 0;\n    Gravity = 0;\n    Inertia = 0;\n}\n\nvoid ABattleObject::SetWallCollisionActive(bool Active)\n{\n    if (Active)\n        MiscFlags |= MISC_WallCollisionActive;\n    else\n        MiscFlags &amp;= ~MISC_WallCollisionActive;\n}\n\nvoid ABattleObject::SetFloorCollisionActive(bool Active)\n{\n    if (Active)\n        MiscFlags |= MISC_FloorCollisionActive;\n    else\n        MiscFlags &amp;= ~MISC_FloorCollisionActive;\n}\n\nvoid ABattleObject::SetPushCollisionActive(bool Active)\n{\n    if (Active)\n        MiscFlags |= MISC_PushCollisionActive;\n    else\n        MiscFlags &amp;= ~MISC_PushCollisionActive;\n}\n\nvoid ABattleObject::SetPushWidthExtend(int32 Extend)\n{\n    PushWidthExtend = Extend;\n}\n\nvoid ABattleObject::CreateCommonParticle(FGameplayTag Name, EPosType PosType, FVector Offset, FRotator Rotation)\n{\n    if (!GameState) return;\n    if (Player-&gt;CommonParticleData != nullptr)\n    {\n        for (FParticleStruct ParticleStruct : Player-&gt;CommonParticleData-&gt;ParticleStructs)\n        {\n            if (ParticleStruct.Name == Name &amp;&amp; ParticleStruct.ParticleSystem)\n            {\n                if (Direction == DIR_Left)\n                {\n                    Rotation.Pitch = -Rotation.Pitch;\n                    Offset = FVector(-Offset.X, Offset.Y, Offset.Z);\n                }\n                Rotation += GameState-&gt;BattleSceneTransform.GetRotation().Rotator();\n                int32 TmpPosX;\n                int32 TmpPosY;\n                PosTypeToPosition(PosType, TmpPosX, TmpPosY);\n                FVector FinalLocation = Offset + FVector(TmpPosX / COORD_SCALE, 0, TmpPosY / COORD_SCALE);\n                FinalLocation = GameState-&gt;BattleSceneTransform.GetRotation().RotateVector(FinalLocation) + GameState-&gt;\n                    BattleSceneTransform.GetLocation();\n                UNiagaraComponent* NiagaraComponent = UNiagaraFunctionLibrary::SpawnSystemAtLocation(\n                    this, ParticleStruct.ParticleSystem, FinalLocation, Rotation, GetActorScale());\n                GameState-&gt;ParticleManager-&gt;BattleParticles.Add(FBattleParticle(NiagaraComponent, nullptr));\n                NiagaraComponent-&gt;SetAgeUpdateMode(ENiagaraAgeUpdateMode::DesiredAge);\n                NiagaraComponent-&gt;SetDesiredAge(0);\n                NiagaraComponent-&gt;SetVariableFloat(FName(\"SpriteRotate\"), -Rotation.Pitch);\n                if (Direction == DIR_Left)\n                {\n                    NiagaraComponent-&gt;SetVariableVec2(FName(\"UVScale\"), FVector2D(-1, 1));\n                    NiagaraComponent-&gt;SetVariableVec2(FName(\"PivotOffset\"), FVector2D(0, 0.5));\n                }\n                NiagaraComponent-&gt;SetVariableFloat(FName(\"ScreenSpaceDepthOffset\"), ScreenSpaceDepthOffset);\n                NiagaraComponent-&gt;SetVariableFloat(FName(\"OrthoBlendActive\"), OrthoBlendActive);\n                NiagaraComponent-&gt;SetCustomDepthStencilValue(2);\n                NiagaraComponent-&gt;SetBoundsScale(40000);\n                break;\n            }\n        }\n    }\n}\n\nvoid ABattleObject::CreateCharaParticle(FGameplayTag Name, EPosType PosType, FVector Offset, FRotator Rotation)\n{\n    if (!GameState) return;\n    if (Player-&gt;CharaParticleData != nullptr)\n    {\n        for (FParticleStruct ParticleStruct : Player-&gt;CharaParticleData-&gt;ParticleStructs)\n        {\n            if (ParticleStruct.Name == Name &amp;&amp; ParticleStruct.ParticleSystem)\n            {\n                if (Direction == DIR_Left)\n                {\n                    Rotation.Pitch = -Rotation.Pitch;\n                    Offset = FVector(-Offset.X, Offset.Y, Offset.Z);\n                }\n                Rotation += GameState-&gt;BattleSceneTransform.GetRotation().Rotator();\n                int32 TmpPosX;\n                int32 TmpPosY;\n                PosTypeToPosition(PosType, TmpPosX, TmpPosY);\n                FVector FinalLocation = Offset + FVector(TmpPosX / COORD_SCALE, 0, TmpPosY / COORD_SCALE);\n                FinalLocation = GameState-&gt;BattleSceneTransform.GetRotation().RotateVector(FinalLocation) + GameState-&gt;\n                    BattleSceneTransform.GetLocation();\n                UNiagaraComponent* NiagaraComponent = UNiagaraFunctionLibrary::SpawnSystemAtLocation(\n                    this, ParticleStruct.ParticleSystem, FinalLocation, Rotation, GetActorScale());\n                GameState-&gt;ParticleManager-&gt;BattleParticles.Add(FBattleParticle(NiagaraComponent, nullptr));\n                NiagaraComponent-&gt;SetAgeUpdateMode(ENiagaraAgeUpdateMode::DesiredAge);\n                NiagaraComponent-&gt;SetDesiredAge(0);\n                NiagaraComponent-&gt;SetVariableFloat(FName(\"SpriteRotate\"), -Rotation.Pitch);\n                if (Direction == DIR_Left)\n                {\n                    NiagaraComponent-&gt;SetVariableVec2(FName(\"UVScale\"), FVector2D(-1, 1));\n                    NiagaraComponent-&gt;SetVariableVec2(FName(\"PivotOffset\"), FVector2D(0, 0.5));\n                }\n                NiagaraComponent-&gt;SetVariableFloat(FName(\"ScreenSpaceDepthOffset\"), ScreenSpaceDepthOffset);\n                NiagaraComponent-&gt;SetVariableFloat(FName(\"OrthoBlendActive\"), OrthoBlendActive);\n                NiagaraComponent-&gt;SetCustomDepthStencilValue(2);\n                NiagaraComponent-&gt;SetBoundsScale(40000);\n                break;\n            }\n        }\n    }\n}\n\nvoid ABattleObject::LinkCommonParticle(FGameplayTag Name)\n{\n    if (!GameState) return;\n    if (IsPlayer)\n        return;\n    if (Player-&gt;CommonParticleData != nullptr)\n    {\n        for (FParticleStruct ParticleStruct : Player-&gt;CommonParticleData-&gt;ParticleStructs)\n        {\n            if (ParticleStruct.Name == Name &amp;&amp; ParticleStruct.ParticleSystem)\n            {\n                if (IsValid(LinkedParticle))\n                    LinkedParticle-&gt;Deactivate();\n                LinkedParticle = UNiagaraFunctionLibrary::SpawnSystemAttached(\n                    ParticleStruct.ParticleSystem, RootComponent, FName(), FVector(), FRotator(),\n                    EAttachLocation::SnapToTargetIncludingScale, true);\n                LinkedParticle-&gt;SetAgeUpdateMode(ENiagaraAgeUpdateMode::DesiredAge);\n                LinkedParticle-&gt;SetDesiredAge(0);\n                GameState-&gt;ParticleManager-&gt;BattleParticles.Add(FBattleParticle(LinkedParticle, this));\n                if (Direction == DIR_Left)\n                    LinkedParticle-&gt;SetVariableVec2(FName(\"UVScale\"), FVector2D(-1, 1));\n                LinkedParticle-&gt;SetBoundsScale(40000);\n                LinkedParticle-&gt;SetCustomDepthStencilValue(2);\n                break;\n            }\n        }\n    }\n}\n\nvoid ABattleObject::LinkCharaParticle(FGameplayTag Name)\n{\n    if (!GameState) return;\n    if (IsPlayer)\n        return;\n    if (Player-&gt;CharaParticleData != nullptr)\n    {\n        for (FParticleStruct ParticleStruct : Player-&gt;CharaParticleData-&gt;ParticleStructs)\n        {\n            if (ParticleStruct.Name == Name &amp;&amp; ParticleStruct.ParticleSystem)\n            {\n                if (IsValid(LinkedParticle))\n                    LinkedParticle-&gt;Deactivate();\n                LinkedParticle = UNiagaraFunctionLibrary::SpawnSystemAttached(\n                    ParticleStruct.ParticleSystem, RootComponent, FName(), FVector(), FRotator(),\n                    EAttachLocation::SnapToTargetIncludingScale, true);\n                LinkedParticle-&gt;SetAgeUpdateMode(ENiagaraAgeUpdateMode::DesiredAge);\n                LinkedParticle-&gt;SetDesiredAge(0);\n                GameState-&gt;ParticleManager-&gt;BattleParticles.Add(FBattleParticle(LinkedParticle, this));\n                if (Direction == DIR_Left)\n                    LinkedParticle-&gt;SetVariableVec2(FName(\"UVScale\"), FVector2D(-1, 1));\n                LinkedParticle-&gt;SetBoundsScale(40000);\n                LinkedParticle-&gt;SetCustomDepthStencilValue(2);\n                break;\n            }\n        }\n    }\n}\n\nALinkActor* ABattleObject::LinkActor(FGameplayTag Name)\n{\n    if (!GameState) return nullptr;\n    if (IsPlayer)\n        return nullptr;\n\n    RemoveLinkActor();\n    for (auto&amp; Container : Player-&gt;StoredLinkActors)\n    {\n        if (Container.Name == Name &amp;&amp; !Container.bIsActive)\n        {\n            Container.bIsActive = true;\n            LinkedActor = Container.StoredActor;\n            LinkedActor-&gt;SetActorHiddenInGame(false);\n            LinkedActor-&gt;Init();\n\n            return LinkedActor;\n        }\n    }\n    return nullptr;\n}\n\nvoid ABattleObject::RemoveLinkActor()\n{\n    if (!LinkedActor) return;\n\n    for (auto&amp; Container : Player-&gt;StoredLinkActors)\n    {\n        if (Container.StoredActor == LinkedActor)\n        {\n            Container.bIsActive = false;\n            LinkedActor-&gt;Exit();\n            LinkedActor-&gt;SetActorHiddenInGame(true);\n            LinkedActor = nullptr;\n        }\n    }\n}\n\nvoid ABattleObject::PlayCommonSound(FGameplayTag Name)\n{\n    if (!IsValid(GameState))\n        return;\n    if (Player-&gt;CommonSoundData != nullptr)\n    {\n        for (FSoundStruct SoundStruct : Player-&gt;CommonSoundData-&gt;SoundDatas)\n        {\n            if (SoundStruct.Name == Name)\n            {\n                GameState-&gt;PlayCommonAudio(SoundStruct.SoundWave, SoundStruct.MaxDuration);\n                break;\n            }\n        }\n    }\n}\n\nvoid ABattleObject::PlayCharaSound(FGameplayTag Name)\n{\n    if (!IsValid(GameState))\n        return;\n    if (Player-&gt;SoundData != nullptr)\n    {\n        for (FSoundStruct SoundStruct : Player-&gt;SoundData-&gt;SoundDatas)\n        {\n            if (SoundStruct.Name == Name)\n            {\n                GameState-&gt;PlayCharaAudio(SoundStruct.SoundWave, SoundStruct.MaxDuration);\n                break;\n            }\n        }\n    }\n}\n\nvoid ABattleObject::AttachToSocketOfObject(FName InSocketName, FVector Offset, EObjType ObjType)\n{\n    SocketName = InSocketName;\n    SocketObj = ObjType;\n    SocketOffset = Offset;\n}\n\nvoid ABattleObject::DetachFromSocket()\n{\n    SocketName = FName();\n    SocketObj = OBJ_Self;\n    SocketOffset = FVector::ZeroVector;\n}\n\nvoid ABattleObject::CameraShake(FGameplayTag PatternName, int32 Scale)\n{\n    if (!GameState) return;\n    if (IsValid(Player-&gt;CameraShakeData))\n    {\n        for (auto [Name, CameraShake] : Player-&gt;CameraShakeData-&gt;CameraShakeStructs)\n        {\n            if (Name == PatternName)\n                GameState-&gt;CameraShake(CameraShake, static_cast&lt;float&gt;(Scale) / 1000);\n        }\n    }\n}\n\nint32 ABattleObject::GenerateRandomNumber(int32 Min, int32 Max) const\n{\n    return GameState-&gt;BattleState.RandomManager.RandRange(Min, Max);\n}\n\nvoid ABattleObject::StartSuperFreeze(int Duration, int SelfDuration)\n{\n    if (!GameState) return;\n    GameState-&gt;StartSuperFreeze(Duration, SelfDuration, this);\n    if (Duration &gt; 0) TriggerEvent(EVT_SuperFreeze, StateMachine_Primary);\n}\n\nvoid ABattleObject::IgnoreSuperFreeze(bool Ignore)\n{\n    if (Ignore)\n        MiscFlags |= MISC_IgnoreSuperFreeze;\n    else\n        MiscFlags &amp;= ~MISC_IgnoreSuperFreeze;\n}\n\nvoid ABattleObject::SetObjectID(int InObjectID)\n{\n    ObjectID = InObjectID;\n}\n\nABattleObject* ABattleObject::GetBattleObject(EObjType Type)\n{\n    switch (Type)\n    {\n    case OBJ_Self:\n        return this;\n    case OBJ_MainPlayer:\n        return GameState-&gt;GetMainPlayer(Player-&gt;PlayerIndex == 0);\n    case OBJ_Enemy:\n        return Player-&gt;Enemy;\n    case OBJ_Parent:\n        return Player;\n    case OBJ_Child0:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[0])\n            if (Player-&gt;StoredBattleObjects[0]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[0];\n        return nullptr;\n    case OBJ_Child1:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[1])\n            if (Player-&gt;StoredBattleObjects[1]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[1];\n        return nullptr;\n    case OBJ_Child2:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[2])\n            if (Player-&gt;StoredBattleObjects[2]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[2];\n        return nullptr;\n    case OBJ_Child3:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[3])\n            if (Player-&gt;StoredBattleObjects[3]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[3];\n        return nullptr;\n    case OBJ_Child4:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[4])\n            if (Player-&gt;StoredBattleObjects[4]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[4];\n        return nullptr;\n    case OBJ_Child5:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[5])\n            if (Player-&gt;StoredBattleObjects[5]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[5];\n        return nullptr;\n    case OBJ_Child6:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[6])\n            if (Player-&gt;StoredBattleObjects[6]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[6];\n        return nullptr;\n    case OBJ_Child7:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[7])\n            if (Player-&gt;StoredBattleObjects[7]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[7];\n        return nullptr;\n    case OBJ_Child8:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[8])\n            if (Player-&gt;StoredBattleObjects[8]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[8];\n        return nullptr;\n    case OBJ_Child9:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[9])\n            if (Player-&gt;StoredBattleObjects[9]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[9];\n        return nullptr;\n    case OBJ_Child10:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[10])\n            if (Player-&gt;StoredBattleObjects[10]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[10];\n        return nullptr;\n    case OBJ_Child11:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[11])\n            if (Player-&gt;StoredBattleObjects[11]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[11];\n        return nullptr;\n    case OBJ_Child12:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[12])\n            if (Player-&gt;StoredBattleObjects[12]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[12];\n        return nullptr;\n    case OBJ_Child13:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[13])\n            if (Player-&gt;StoredBattleObjects[13]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[13];\n        return nullptr;\n    case OBJ_Child14:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[14])\n            if (Player-&gt;StoredBattleObjects[14]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[14];\n        return nullptr;\n    case OBJ_Child15:\n        if (IsPlayer &amp;&amp; Player-&gt;StoredBattleObjects[15])\n            if (Player-&gt;StoredBattleObjects[15]-&gt;IsActive)\n                return Player-&gt;StoredBattleObjects[15];\n        return nullptr;\n    default:\n        return nullptr;\n    }\n}\n\nABattleObject* ABattleObject::AddCommonBattleObject(FGameplayTag InStateName, int32 PosXOffset, int32 PosYOffset,\n                                                    EPosType PosType)\n{\n    if (!GameState) return nullptr;\n    const int StateIndex = Player-&gt;CommonObjectStateNames.Find(InStateName);\n    if (StateIndex != INDEX_NONE)\n    {\n        int32 FinalPosX, FinalPosY;\n\n        PosTypeToPosition(PosType, FinalPosX, FinalPosY);\n        if (Direction == DIR_Left) PosXOffset *= -1;\n        FinalPosX += PosXOffset;\n        FinalPosY += PosYOffset;\n        return GameState-&gt;AddBattleObject(Player-&gt;CommonObjectStates[StateIndex],\n                                          FinalPosX, FinalPosY, Direction, StateIndex, true, Player);\n    }\n    return nullptr;\n}\n\nABattleObject* ABattleObject::AddBattleObject(FGameplayTag InStateName, int32 PosXOffset, int32 PosYOffset,\n                                              EPosType PosType)\n{\n    if (!GameState) return nullptr;\n    const int StateIndex = Player-&gt;ObjectStateNames.Find(InStateName);\n    if (StateIndex != INDEX_NONE)\n    {\n        int32 FinalPosX, FinalPosY;\n\n        PosTypeToPosition(PosType, FinalPosX, FinalPosY);\n        if (Direction == DIR_Left) PosXOffset *= -1;\n        FinalPosX += PosXOffset;\n        FinalPosY += PosYOffset;\n        return GameState-&gt;AddBattleObject(Player-&gt;ObjectStates[StateIndex],\n                                          FinalPosX, FinalPosY, Direction, StateIndex, false, Player);\n    }\n    return nullptr;\n}\n\nvoid ABattleObject::EnableDeactivateIfBeyondBounds(bool Enable)\n{\n    if (Enable)\n    {\n        MiscFlags |= MISC_DeactivateIfBeyondBounds;\n    }\n    else\n    {\n        MiscFlags &amp;= ~MISC_DeactivateIfBeyondBounds;\n    }\n}\n\nvoid ABattleObject::EnableDeactivateOnStateChange(bool Enable)\n{\n    if (Enable)\n    {\n        MiscFlags |= MISC_DeactivateOnStateChange;\n    }\n    else\n    {\n        MiscFlags &amp;= ~MISC_DeactivateOnStateChange;\n    }\n}\n\nvoid ABattleObject::EnableDeactivateOnReceiveHit(bool Enable)\n{\n    if (Enable)\n    {\n        MiscFlags |= MISC_DeactivateOnReceiveHit;\n    }\n    else\n    {\n        MiscFlags &amp;= ~MISC_DeactivateOnReceiveHit;\n    }\n}\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/","title":"File BattleObject.h","text":"<p>FileList &gt; Battle &gt; Objects &gt; BattleObject.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameplayTagContainer.h\"</code></li> <li><code>#include \"GameFramework/Pawn.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Misc/CollisionBox.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/CollisionData.h\"</code></li> <li><code>#include \"BattleObject.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_battle_object_8h/#classes","title":"Classes","text":"Type Name class ABattleObject struct FBattleObjectLog struct FEventHandler struct FGroundBounceData struct FHitData struct FHitDataCommon struct FHitPosition struct FHitValueOverTime struct FHomingParams struct FLinkedActorContainer struct FSuperArmorData struct FWallBounceData"},{"location":"NightSkyEngine/_battle_object_8h/#public-types","title":"Public Types","text":"Type Name enum EBlockType enum EDistanceType enum EEventType enum EFloatingCrumpleType enum EHitAction enum EHitPositionType enum uint8 EHitSFXType enum uint8 EHitVFXType enum EHomingType enum EObjDir enum EObjType enum EPosType enum ESuperArmorType"},{"location":"NightSkyEngine/_battle_object_8h/#public-attributes","title":"Public Attributes","text":"Type Name int32 MaxDrawPriority   = <code>4</code> size_t SizeOfBattleObject   = <code>offsetof([**ABattleObject**](class_a_battle_object.md), ObjSyncEnd) - offsetof([**ABattleObject**](class_a_battle_object.md), ObjSync)</code>"},{"location":"NightSkyEngine/_battle_object_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"NightSkyEngine/_battle_object_8h/#enum-eblocktype","title":"enum EBlockType","text":"<pre><code>enum EBlockType {\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\")\n};\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/#enum-edistancetype","title":"enum EDistanceType","text":"<pre><code>enum EDistanceType {\n    DIST_Distance,\n    DIST_DistanceX,\n    DIST_DistanceY,\n    DIST_FrontDistanceX\n};\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/#enum-eeventtype","title":"enum EEventType","text":"<pre><code>enum EEventType {\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\")\n};\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/#enum-efloatingcrumpletype","title":"enum EFloatingCrumpleType","text":"<pre><code>enum EFloatingCrumpleType {\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\")\n};\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/#enum-ehitaction","title":"enum EHitAction","text":"<pre><code>enum EHitAction {\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\"),\n    UMETA =(DisplayName=\"Update\")\n};\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/#enum-ehitpositiontype","title":"enum EHitPositionType","text":"<pre><code>enum EHitPositionType {\n    UMETA =(DisplayName=\"Update\"),\n    HPT_Rel,\n    HPT_Abs,\n    UMETA =(DisplayName=\"Update\"),\n    HPT_RelNextFrame,\n    HPT_AbsNextFrame,\n    UMETA =(DisplayName=\"Update\")\n};\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/#enum-ehitsfxtype","title":"enum EHitSFXType","text":"<pre><code>enum EHitSFXType {\n    UMETA =(DisplayName=\"Punch\"),\n    UMETA =(DisplayName=\"Kick\"),\n    UMETA =(DisplayName=\"Slash\")\n};\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/#enum-ehitvfxtype","title":"enum EHitVFXType","text":"<pre><code>enum EHitVFXType {\n    UMETA =(DisplayName=\"Strike\"),\n    UMETA =(DisplayName=\"Slash\"),\n    UMETA =(DisplayName=\"Special\")\n};\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/#enum-ehomingtype","title":"enum EHomingType","text":"<pre><code>enum EHomingType {\n    HOMING_DistanceAccel,\n    HOMING_FixAccel,\n    HOMING_ToSpeed\n};\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/#enum-eobjdir","title":"enum EObjDir","text":"<pre><code>enum EObjDir {\n    DIR_Right,\n    DIR_Left\n};\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/#enum-eobjtype","title":"enum EObjType","text":"<pre><code>enum EObjType {\n    OBJ_Self,\n    OBJ_MainPlayer,\n    OBJ_Enemy,\n    OBJ_Parent,\n    OBJ_Child0,\n    OBJ_Child1,\n    OBJ_Child2,\n    OBJ_Child3,\n    OBJ_Child4,\n    OBJ_Child5,\n    OBJ_Child6,\n    OBJ_Child7,\n    OBJ_Child8,\n    OBJ_Child9,\n    OBJ_Child10,\n    OBJ_Child11,\n    OBJ_Child12,\n    OBJ_Child13,\n    OBJ_Child14,\n    OBJ_Child15,\n    OBJ_Null\n};\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/#enum-epostype","title":"enum EPosType","text":"<pre><code>enum EPosType {\n    POS_Player,\n    POS_Self,\n    POS_Center,\n    POS_Ground,\n    POS_Enemy,\n    POS_Col\n};\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/#enum-esuperarmortype","title":"enum ESuperArmorType","text":"<pre><code>enum ESuperArmorType {\n    ARM_None,\n    ARM_Guard,\n    ARM_Dodge\n};\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/_battle_object_8h/#variable-maxdrawpriority","title":"variable MaxDrawPriority","text":"<pre><code>int32 MaxDrawPriority;\n</code></pre>"},{"location":"NightSkyEngine/_battle_object_8h/#variable-sizeofbattleobject","title":"variable SizeOfBattleObject","text":"<pre><code>size_t SizeOfBattleObject;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/BattleObject.h</code></p>"},{"location":"NightSkyEngine/_battle_object_8h_source/","title":"File BattleObject.h","text":"<p>File List &gt; Battle &gt; Objects &gt; BattleObject.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include &lt;fstream&gt;\n\n#include \"CoreMinimal.h\"\n#include \"GameplayTagContainer.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"NightSkyEngine/Battle/Misc/CollisionBox.h\"\n#include \"NightSkyEngine/Data/CollisionData.h\"\n#include \"BattleObject.generated.h\"\n\nclass ALinkActor;\nclass UNightSkyAnimSequenceUserData;\nclass ANightSkyCharaSelectGameState;\nclass UPaperFlipbookComponent;\nclass UNiagaraComponent;\nclass ANightSkyGameState;\nclass UState;\nclass APlayerObject;\n\nconstexpr int32 MaxDrawPriority = 4;\n\n// Event handler data.\n\n/*\n * Event type. When a function is registered with an event handler, \n * it will trigger at the event type specified.\n */\n\nUENUM(BlueprintType)\nenum EEventType\n{\n    EVT_Update UMETA(DisplayName=\"Update\"),\n    EVT_Exit UMETA(DisplayName=\"Exit\"),\n    EVT_Landing UMETA(DisplayName=\"Landing\"),\n    EVT_Hit UMETA(DisplayName=\"Hit\"),\n    EVT_Block UMETA(DisplayName=\"Block\"),\n    EVT_HitOrBlock UMETA(DisplayName=\"Hit or Block\"),\n    EVT_CounterHit UMETA(DisplayName=\"Counter Hit\"),\n    EVT_Kill UMETA(DisplayName=\"Kill\"),\n    EVT_ReceiveHit UMETA(DisplayName=\"Receive Hit\"),\n    EVT_SuperFreeze UMETA(DisplayName=\"Super Freeze\"),\n    EVT_SuperFreezeEnd UMETA(DisplayName=\"Super Freeze End\"),\n    EVT_Timer0 UMETA(DisplayName=\"Timer #0\"),\n    EVT_Timer1 UMETA(DisplayName=\"Timer #1\"),\n    EVT_HitMainPlayer UMETA(DisplayName=\"Hit (Main Player)\"),\n    EVT_BlockMainPlayer UMETA(DisplayName=\"Block (Main Player)\"),\n    EVT_HitOrBlockMainPlayer UMETA(DisplayName=\"Hit or Block (Main Player)\"),\n    EVT_CounterHitMainPlayer UMETA(DisplayName=\"Counter Hit (Main Player)\"),\n    EVT_KillMainPlayer UMETA(DisplayName=\"Kill (Main Player)\"),\n    EVT_ReceiveHitMainPlayer UMETA(DisplayName=\"Receive Hit (Main Player)\"),\n    EVT_NUM UMETA(Hidden)\n};\n\nUSTRUCT()\nstruct FEventHandler\n{\n    GENERATED_BODY()\n\n    FName FunctionName;\n    FGameplayTag SubroutineName;\n};\n\n// Hit related data.\n\n// How the opponent must block the attack.\nUENUM()\nenum EBlockType\n{\n    BLK_Mid UMETA(DisplayName=\"Mid\"),\n    BLK_High UMETA(DisplayName=\"High\"),\n    BLK_Low UMETA(DisplayName=\"Low\"),\n    BLK_None UMETA(DisplayName=\"Unblockable\"),\n};\n\n// Hit sound effect type.\nUENUM()\nenum class EHitSFXType : uint8\n{\n    SFX_Punch UMETA(DisplayName=\"Punch\"),\n    SFX_Kick UMETA(DisplayName=\"Kick\"),\n    SFX_Slash UMETA(DisplayName=\"Slash\"),\n};\n\n// Hit visual effect type.\nUENUM()\nenum class EHitVFXType : uint8\n{\n    VFX_Strike UMETA(DisplayName=\"Strike\"),\n    VFX_Slash UMETA(DisplayName=\"Slash\"),\n    VFX_Special UMETA(DisplayName=\"Special\"),\n};\n\n/*\n * Common data for attacks.\n * These values will be used for blocking, normal hit, and counter hit.\n * Values that are set to INT_MAX will be replaced by a default value depending on attack level.\n */\n\nUSTRUCT(BlueprintType)\nstruct FHitDataCommon\n{\n    GENERATED_BODY()\n\n    /*\n     * This controls default values for hit data.\n     * The minimum attack level is 0, and the maximum is 5.\n     */\n    UPROPERTY(BlueprintReadWrite, meta=(ClampMin=0, ClampMax=5))\n    int32 AttackLevel = 0;\n    // How the opponent must block the attack.\n    UPROPERTY(BlueprintReadWrite)\n    TEnumAsByte&lt;EBlockType&gt; BlockType = BLK_Mid;\n    // Hitstop modifier for self on block, relative to normal hit's hitstop.\n    UPROPERTY(BlueprintReadWrite)\n    int32 BlockstopModifier = INT_MAX;\n    // Hitstop modifier for opponent on block, relative to normal hit's hitstop.\n    UPROPERTY(BlueprintReadWrite)\n    int32 EnemyBlockstopModifier = 0;\n    // How long the opponent will be stunned while blocking.\n    UPROPERTY(BlueprintReadWrite)\n    int32 Blockstun = INT_MAX;\n    // The percent of normal hit damage the opponent will take when blocking this attack.\n    UPROPERTY(BlueprintReadWrite)\n    int32 ChipDamagePercent = 0;\n    /*\n     * Ground pushback for blocking.\n     * If the opponent is in the corner, this will instead apply to self,\n     * even if you are airborne.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 GroundGuardPushbackX = INT_MAX;\n    // Air x pushback for blocking.\n    UPROPERTY(BlueprintReadWrite)\n    int32 AirGuardPushbackX = INT_MAX;\n    // Air y pushback for blocking.\n    UPROPERTY(BlueprintReadWrite)\n    int32 AirGuardPushbackY = INT_MAX;\n    // Gravity for blocking.\n    UPROPERTY(BlueprintReadWrite)\n    int32 GuardGravity = INT_MAX;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ProximityBlockDistanceX = 240000;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ProximityBlockDistanceY = 160000;\n    // The angle at which hit effects will spawn.\n    UPROPERTY(BlueprintReadWrite)\n    int32 HitAngle = 0;\n    // Sound effect type.\n    UPROPERTY(BlueprintReadWrite)\n    EHitSFXType SFXType = EHitSFXType::SFX_Punch;\n    // Visual effect type.\n    UPROPERTY(BlueprintReadWrite)\n    EHitVFXType VFXType = EHitVFXType::VFX_Strike;\n    UPROPERTY(BlueprintReadWrite)\n    FGameplayTag GuardSFXOverride;\n    UPROPERTY(BlueprintReadWrite)\n    FGameplayTag GuardVFXOverride;\n    UPROPERTY(BlueprintReadWrite)\n    FGameplayTag HitSFXOverride;\n    UPROPERTY(BlueprintReadWrite)\n    FGameplayTag HitVFXOverride;\n    UPROPERTY(BlueprintReadWrite)\n    bool DeathCamOverride = false;\n\n    // Guard sound effect name.\n    FGameplayTag GuardSFX;\n    // Guard visual effect name.\n    FGameplayTag GuardVFX;\n    // Hit sound effect name.\n    FGameplayTag HitSFX;\n    // Hit visual effect name.\n    FGameplayTag HitVFX;\n\n    // Hit color data.\n    UPROPERTY(BlueprintReadWrite)\n    FLinearColor DamageColor = FLinearColor(1.0, 1.0, 1.0);\n    UPROPERTY(BlueprintReadWrite)\n    FLinearColor DamageColor2 = FLinearColor(1.0, 1.0, 1.0);\n};\n\n/*\n * List of hit actions.\n * Depending on the hit action, animations and behavior will change.\n */\n\nUENUM()\nenum EHitAction\n{\n    HACT_None UMETA(DisplayName=\"None\"),\n    HACT_GroundNormal UMETA(DisplayName=\"Ground Normal\"),\n    HACT_AirNormal UMETA(DisplayName=\"Air Normal\"),\n    HACT_Stagger UMETA(DisplayName=\"Stagger\"),\n    HACT_Crumple UMETA(DisplayName=\"Crumple\"),\n    HACT_ForceCrouch UMETA(DisplayName=\"Force Crouch\"),\n    HACT_ForceStand UMETA(DisplayName=\"Force Stand\"),\n    HACT_AirFaceUp UMETA(DisplayName=\"Air Face Up\"),\n    HACT_AirVertical UMETA(DisplayName=\"Air Vertical\"),\n    HACT_AirFaceDown UMETA(DisplayName=\"Air Face Down\"),\n    HACT_Blowback UMETA(DisplayName=\"Blowback\"),\n    HACT_Tailspin UMETA(DisplayName=\"Tailspin\"),\n    HACT_GuardBreak UMETA(DisplayName=\"Guard Break\"),\n    HACT_GuardBreakStand UMETA(DisplayName=\"Guard Break Stand\"),\n    HACT_GuardBreakCrouch UMETA(DisplayName=\"Guard Break Crouch\"),\n    HACT_GuardBreakAir UMETA(DisplayName=\"Guard Break Air\"),\n    HACT_FloatingCrumple UMETA(DisplayName=\"Floating Crumple\"),\n    HACT_Custom UMETA(DisplayName=\"Custom\"),\n};\n\n// Used with the Floating Crumple hit action.\nUENUM(BlueprintType)\nenum EFloatingCrumpleType\n{\n    FLT_None UMETA(DisplayName=\"None\"),\n    FLT_Body UMETA(DisplayName=\"Body\"),\n    FLT_Head UMETA(DisplayName=\"Head\"),\n};\n\n// Determines how the opponent's position immediately after hit will be calculated.\nUENUM(BlueprintType)\nenum EHitPositionType\n{\n    HPT_Non UMETA(DisplayName=\"None\"),\n    HPT_Rel,\n    HPT_Abs,\n    HPT_Add UMETA(DisplayName=\"Add\"),\n    HPT_RelNextFrame,\n    HPT_AbsNextFrame,\n    HPT_AddNextFrame UMETA(DisplayName=\"Add Next Frame\"),\n};\n\n/*\n * Data for wall bounce.\n * Values that are set to INT_MAX will be replaced by a default value.\n */\nUSTRUCT(BlueprintType)\nstruct FWallBounceData\n{\n    GENERATED_BODY()\n\n    // How many times the opponent will wall bounce.\n    UPROPERTY(BlueprintReadWrite)\n    int32 WallBounceCount = -1;\n    // If this value is not INT_MAX, it will override the current untech duration.\n    UPROPERTY(BlueprintReadWrite)\n    int32 WallBounceUntech = INT_MAX;\n    // The hitstop upon wall bounce.\n    UPROPERTY(BlueprintReadWrite)\n    int32 WallBounceStop = INT_MAX;\n    /*\n     * Wall bounce x speed.\n     * If this value is INT_MAX, it will be set to the current x speed.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 WallBounceXSpeed = INT_MAX;\n    /*\n     * The percent of wall bounce x speed.\n     * If this value is INT_MAX, it will be set to 33%.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 WallBounceXRate = INT_MAX;\n    /*\n     * Wall bounce y speed.\n     * If this value is INT_MAX, it will be set to the received y pushback.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 WallBounceYSpeed = INT_MAX;\n    /*\n     * The percent of wall bounce y speed.\n     * If this value is INT_MAX, it will be set to 100%.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 WallBounceYRate = INT_MAX;\n    /*\n     * Wall bounce gravity.\n     * If this value is INT_MAX, it will be set to the received hit gravity.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 WallBounceGravity = INT_MAX;\n    // Determines if wall bounce can happen anywhere, or only in stage corner.\n    UPROPERTY(BlueprintReadWrite)\n    bool WallBounceInCornerOnly = false;\n};\n\n/*\n * Data for ground bounce.\n * Values that are set to INT_MAX will be replaced by a default value.\n */\nUSTRUCT(BlueprintType)\nstruct FGroundBounceData\n{\n    GENERATED_BODY()\n\n    // How many times the opponent will ground bounce.\n    UPROPERTY(BlueprintReadWrite)\n    int32 GroundBounceCount = -1;\n    // If this value is not INT_MAX, it will override the current untech duration.\n    UPROPERTY(BlueprintReadWrite)\n    int32 GroundBounceUntech = INT_MAX;\n    // The hitstop upon ground bounce.\n    UPROPERTY(BlueprintReadWrite)\n    int32 GroundBounceStop = INT_MAX;\n    /*\n     * Ground bounce x speed.\n     * If this value is INT_MAX, it will be set to the received x pushback.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 GroundBounceXSpeed = INT_MAX;\n    /*\n     * The percent of ground bounce x speed.\n     * If this value is INT_MAX, it will be set to 100%.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 GroundBounceXRate = INT_MAX;\n    /*\n     * Ground bounce y speed.\n     * If this value is INT_MAX, it will be set to the current y speed.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 GroundBounceYSpeed = INT_MAX;\n    /*\n     * The percent of ground bounce y speed.\n     * If this value is INT_MAX, it will be set to 100%.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 GroundBounceYRate = INT_MAX;\n    /*\n     * Ground bounce gravity.\n     * If this value is INT_MAX, it will be set to the received hit gravity.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 GroundBounceGravity = INT_MAX;\n};\n\n/*\n * Value is added to the specified hit value every frame,\n * from BeginFrame to EndFrame.\n */\nUSTRUCT(BlueprintType)\nstruct FHitValueOverTime\n{\n    GENERATED_BODY()\n\n    UPROPERTY(BlueprintReadWrite)\n    int32 Value = INT_MAX;\n    UPROPERTY(BlueprintReadWrite)\n    int32 BeginFrame = INT_MAX;\n    UPROPERTY(BlueprintReadWrite)\n    int32 EndFrame = INT_MAX;\n};\n\n// Determines the opponent's position after being hit.\nUSTRUCT(BlueprintType)\nstruct FHitPosition\n{\n    GENERATED_BODY()\n\n    UPROPERTY(BlueprintReadWrite)\n    TEnumAsByte&lt;EHitPositionType&gt; Type;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PosX = INT_MAX;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PosY = INT_MAX;\n};\n\n/*\n * Hit data.\n * There is one for normal hit, and one for counter hit.\n * For normal hit, values that are set to INT_MAX will be replaced by a default value depending on attack level.\n * For counter hit, values that are set to INT_MAX will be replaced by the normal hit's value.\n */\nUSTRUCT(BlueprintType)\nstruct FHitData\n{\n    GENERATED_BODY()\n\n    // Hitstop duration for attacker and defender.\n    UPROPERTY(BlueprintReadWrite)\n    int32 Hitstop = INT_MAX;\n    // How long the opponent will be stunned if hit grounded.\n    UPROPERTY(BlueprintReadWrite)\n    int32 Hitstun = INT_MAX;\n    // How long the opponent will be stunned if hit airborne.\n    UPROPERTY(BlueprintReadWrite)\n    int32 Untech = INT_MAX;\n    // Hitstop modifier for the opponent on hit.\n    UPROPERTY(BlueprintReadWrite)\n    int32 EnemyHitstopModifier = INT_MAX;\n    // How much damage the opponent will take.\n    UPROPERTY(BlueprintReadWrite)\n    int32 Damage = INT_MAX;\n    // The percent of damage that can be recovered.\n    UPROPERTY(BlueprintReadWrite)\n    int32 RecoverableDamagePercent = INT_MAX;\n    /*\n     * The minimum damage percent.\n     * Damage scaling cannot bring damage lower than this.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 MinimumDamagePercent = INT_MAX;\n    /*\n     * Initial proration for hit.\n     * This is scaling that is applied only as the first hit of a combo.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 InitialProration = INT_MAX;\n    /*\n     * Initial proration for hit.\n     * This is scaling that is applied every hit.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 ForcedProration = INT_MAX;\n    /*\n     * Ground pushback for hit.\n     * If the opponent is in the corner, this will instead apply to self,\n     * even if you are airborne.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 GroundPushbackX = INT_MAX;\n    // Air x pushback for hit.\n    UPROPERTY(BlueprintReadWrite)\n    int32 AirPushbackX = INT_MAX;\n    // Air y pushback for hit.\n    UPROPERTY(BlueprintReadWrite)\n    int32 AirPushbackY = INT_MAX;\n    // Gravity for hit.\n    UPROPERTY(BlueprintReadWrite)\n    int32 Gravity = INT_MAX;\n    /*\n     * The hit value over time for air pushback x.\n     * The value is a percentage.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    FHitValueOverTime AirPushbackXOverTime;\n    /*\n     * The hit value over time for air pushback y.\n     * The value is a percentage.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    FHitValueOverTime AirPushbackYOverTime;\n    /*\n     * The hit value over time for gravity.\n     * The value is added to current gravity.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    FHitValueOverTime GravityOverTime;\n    // Opponent position after hit.\n    UPROPERTY(BlueprintReadWrite)\n    FHitPosition Position;\n    // Ground hit action.\n    UPROPERTY(BlueprintReadWrite)\n    TEnumAsByte&lt;EHitAction&gt; GroundHitAction = HACT_GroundNormal;\n    // Air hit action.\n    UPROPERTY(BlueprintReadWrite)\n    TEnumAsByte&lt;EHitAction&gt; AirHitAction = HACT_AirNormal;\n    // Custom hit action.\n    UPROPERTY(BlueprintReadWrite)\n    FGameplayTag CustomHitAction;\n    // Blowback animation level. Used with the Blowback hit action.\n    UPROPERTY(BlueprintReadWrite)\n    int32 BlowbackLevel = INT_MAX;\n    // Floating crumple type. Used with the Floating Crumple hit action.\n    UPROPERTY(BlueprintReadWrite)\n    TEnumAsByte&lt;EFloatingCrumpleType&gt; FloatingCrumpleType;\n    // How long the opponent will be knocked down for before recovery. Defaults to 12 frames.\n    UPROPERTY(BlueprintReadWrite)\n    int32 KnockdownTime = INT_MAX;\n    // Determines if the opponent can tech after being knocked down. Default is soft knockdown.\n    UPROPERTY(BlueprintReadWrite)\n    int32 HardKnockdown = INT_MAX;\n    // Ground bounce data.\n    UPROPERTY(BlueprintReadWrite)\n    FGroundBounceData GroundBounce;\n    // Wall bounce data.\n    UPROPERTY(BlueprintReadWrite)\n    FWallBounceData WallBounce;\n};\n\n/*\n * Miscellaneous data.\n */\n\n// The character's facing direction.\nUENUM()\nenum EObjDir\n{\n    DIR_Right,\n    DIR_Left,\n};\n\n// Used for distance calculations.\nUENUM()\nenum EDistanceType\n{\n    DIST_Distance,\n    DIST_DistanceX,\n    DIST_DistanceY,\n    DIST_FrontDistanceX,\n};\n\n// Used for homing calculations.\nUENUM(BlueprintType)\nenum EHomingType\n{\n    HOMING_DistanceAccel,\n    HOMING_FixAccel,\n    HOMING_ToSpeed,\n};\n\n// Determines the position type to check.\nUENUM(BlueprintType)\nenum EPosType\n{\n    POS_Player,\n    POS_Self,\n    POS_Center,\n    POS_Ground,\n    POS_Enemy,\n    POS_Col,\n};\n\n// Determines object type.\nUENUM(BlueprintType)\nenum EObjType\n{\n    OBJ_Self,\n    OBJ_MainPlayer,\n    OBJ_Enemy,\n    OBJ_Parent,\n    OBJ_Child0,\n    OBJ_Child1,\n    OBJ_Child2,\n    OBJ_Child3,\n    OBJ_Child4,\n    OBJ_Child5,\n    OBJ_Child6,\n    OBJ_Child7,\n    OBJ_Child8,\n    OBJ_Child9,\n    OBJ_Child10,\n    OBJ_Child11,\n    OBJ_Child12,\n    OBJ_Child13,\n    OBJ_Child14,\n    OBJ_Child15,\n    OBJ_Null,\n};\n\nUSTRUCT(BlueprintType)\nstruct FHomingParams\n{\n    GENERATED_BODY()\n\n    UPROPERTY(BlueprintReadWrite)\n    TEnumAsByte&lt;EHomingType&gt; Type;\n    UPROPERTY(BlueprintReadWrite)\n    TEnumAsByte&lt;EObjType&gt; Target = OBJ_Null;\n    UPROPERTY(BlueprintReadWrite)\n    TEnumAsByte&lt;EPosType&gt; Pos;\n    UPROPERTY(BlueprintReadWrite)\n    int32 OffsetX;\n    UPROPERTY(BlueprintReadWrite)\n    int32 OffsetY;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ParamA;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ParamB;\n};\n\nUSTRUCT()\nstruct FLinkedActorContainer\n{\n    GENERATED_BODY()\n\n    UPROPERTY()\n    TObjectPtr&lt;ALinkActor&gt; StoredActor;\n    FGameplayTag Name;\n    int32 Index;\n    UPROPERTY(SaveGame)\n    bool bIsActive;\n};\n\nUENUM(BlueprintType)\nenum ESuperArmorType\n{\n    ARM_None,\n    ARM_Guard,\n    ARM_Dodge,\n};\n\nUSTRUCT(BlueprintType)\nstruct FSuperArmorData\n{\n    GENERATED_BODY()\n\n    UPROPERTY(BlueprintReadWrite)\n    TEnumAsByte&lt;ESuperArmorType&gt; Type;\n    UPROPERTY(BlueprintReadWrite)\n    uint8 bArmorMid : 1;\n    UPROPERTY(BlueprintReadWrite)\n    uint8 bArmorOverhead : 1;\n    UPROPERTY(BlueprintReadWrite)\n    uint8 bArmorLow : 1;\n    UPROPERTY(BlueprintReadWrite)\n    uint8 bArmorStrike : 1;\n    UPROPERTY(BlueprintReadWrite)\n    uint8 bArmorThrow : 1;\n    UPROPERTY(BlueprintReadWrite)\n    uint8 bArmorHead : 1;\n    UPROPERTY(BlueprintReadWrite)\n    uint8 bArmorProjectile : 1;\n    UPROPERTY(BlueprintReadWrite)\n    uint8 bArmorTakeChipDamage : 1;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ArmorDamagePercent;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ArmorHits;\n};\n\nUSTRUCT(BlueprintType)\nstruct FBattleObjectLog\n{\n    GENERATED_BODY()\n\npublic:\n    virtual ~FBattleObjectLog() = default;\n\n    //Starting from this until ObjSyncEnd, everything is saved/loaded for rollback.\n    unsigned char ObjSync = 0;\n\n    /*\n     * Movement and position values\n     */\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)\n    int32 PosX = 0;\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)\n    int32 PosY = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PosZ = 0;\n    int32 PrevPosX = 0;\n    int32 PrevPosY = 0;\n    int32 PrevPosZ = 0;\n    int32 PrevRootMotionX = 0;\n    int32 PrevRootMotionY = 0;\n    int32 PrevRootMotionZ = 0;\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 AnglePitch_x10 = 0;\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 AngleYaw_x10 = 0;\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 AngleRoll_x10 = 0;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    bool BlendOffset = false;\n    int32 PrevOffsetX = 0;\n    int32 PrevOffsetY = 0;\n    int32 NextOffsetX = 0;\n    int32 NextOffsetY = 0;\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)\n    int32 SpeedX = 0;\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)\n    int32 SpeedY = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SpeedZ = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SpeedXRate = 100;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SpeedXRatePerFrame = 100;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SpeedYRate = 100;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SpeedYRatePerFrame = 100;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SpeedZRate = 100;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SpeedZRatePerFrame = 100;\n    UPROPERTY(BlueprintReadWrite)\n    int32 Gravity = 1900;\n    // Inertia adds to the position every frame, but also decays every frame until it reaches zero.\n    UPROPERTY(BlueprintReadWrite)\n    int32 Inertia = 0;\n    // The minimum Y position before considered grounded.\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)\n    int32 GroundHeight = 0;\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    TEnumAsByte&lt;EObjDir&gt; Direction = DIR_Right;\n    // Ground hit pushback.\n    int32 Pushback = 0;\n\n    /*\n     * Attack data\n     */\n\n    UPROPERTY(BlueprintReadWrite)\n    FHitDataCommon HitCommon = {};\n    UPROPERTY(BlueprintReadWrite)\n    FHitData NormalHit = {};\n    UPROPERTY(BlueprintReadWrite)\n    FHitData CounterHit = {};\n    uint32 AttackFlags = 0;\n\n    /*\n     * Received attack data\n     */\n\n    UPROPERTY(BlueprintReadOnly)\n    FHitDataCommon ReceivedHitCommon = {};\n    UPROPERTY(BlueprintReadOnly)\n    FHitData ReceivedHit = {};\n    uint32 StunTime = 0;\n    uint32 StunTimeMax = 0;\n    uint32 Hitstop = 0;\n\n    /*\n     * Registers\n    */\n\n    //This value stores the return value for functions.\n    bool ReturnReg = false;\n\n    //The following values are per-action registers. Shared between the player and its child objects.\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg1 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg2 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg3 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg4 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg5 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg6 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg7 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg8 = 0;\n\n    //The following values are per-object registers.\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg1 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg2 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg3 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg4 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg5 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg6 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg7 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg8 = 0;\n\n    /*\n     * Subroutine registers. These are set when calling a subroutine, and reset upon round end.\n     */\n    UPROPERTY(BlueprintReadOnly)\n    int32 SubroutineReg1 = 0;\n    UPROPERTY(BlueprintReadOnly)\n    int32 SubroutineReg2 = 0;\n    UPROPERTY(BlueprintReadOnly)\n    int32 SubroutineReg3 = 0;\n    UPROPERTY(BlueprintReadOnly)\n    int32 SubroutineReg4 = 0;\n\n    /*\n     * Subroutine return values. Subroutines can optionally return values.\n     * These are reset upon the next called subroutine.\n    */\n    UPROPERTY(BlueprintReadWrite)\n    int32 SubroutineReturnVal1 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SubroutineReturnVal2 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SubroutineReturnVal3 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SubroutineReturnVal4 = 0;\n\n    /*\n     * Action data\n     */\n\n    UPROPERTY(BlueprintReadOnly)\n    int32 ActionTime = 0;\n    /*\n     * The current cel name.\n     * Cels map to collision data.\n     * The collision frame also stores animation data.\n     */\n    FGameplayTag CelName = {};\n    /*\n     * The blend cel name.\n     * This is used to make traditional 3D animations.\n     */\n    FGameplayTag BlendCelName = {};\n    /*\n     * The name of the label that is currently being jumped to.\n     */\n    FGameplayTag LabelName = {};\n\n    UPROPERTY(BlueprintReadOnly)\n    float AnimBlendIn{};\n    UPROPERTY(BlueprintReadOnly)\n    float AnimBlendOut{};\n    // Are we jumping to a label right now?\n    UPROPERTY(BlueprintReadWrite)\n    bool GotoLabelActive = false;\n    UPROPERTY(BlueprintReadWrite)\n    int32 AnimFrame = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 BlendAnimFrame = 0;\n    UPROPERTY(BlueprintReadWrite)\n    float FrameBlendPosition = 0;\n    // The index of the current cel in blueprint.\n    UPROPERTY(BlueprintReadWrite)\n    int32 CelIndex = 0;\n    // How long until the next cel activates.\n    UPROPERTY(BlueprintReadOnly)\n    int32 TimeUntilNextCel = 0;\n    // Max time of the cel.\n    int32 MaxCelTime = 0;\n    // Event handlers for every function.\n    FEventHandler EventHandlers[EVT_NUM] = {};\n\n    /*\n     * Action data for objects only.\n     */\n    FGameplayTag ObjectStateName = {};\n    uint32 ObjectID = 0;\n\nprotected:\n    /*\n     * Collision data\n     */\n    int32 PushHeight = 0;\n    int32 PushHeightLow = 0;\n    int32 PushWidth = 0;\n    int32 PushWidthExtend = 0;\n\npublic:\n    /*\n     * Push collision\n     */\n\n    int32 L = 0;\n    int32 R = 0;\n    int32 T = 0;\n    int32 B = 0;\n\n    /*\n     * Socket data\n     */\n    FName SocketName = {};\n    EObjType SocketObj = OBJ_Self;\n    FVector SocketOffset = FVector::ZeroVector;\n\n    //material parameters\n    UPROPERTY(BlueprintReadWrite)\n    FLinearColor MulColor = FLinearColor(1, 1, 1, 1);\n    UPROPERTY(BlueprintReadWrite)\n    FLinearColor AddColor = FLinearColor(0, 0, 0, 1);\n    UPROPERTY(BlueprintReadWrite)\n    FLinearColor MulFadeColor = {};\n    UPROPERTY(BlueprintReadWrite)\n    FLinearColor AddFadeColor = {};\n    UPROPERTY(BlueprintReadWrite)\n    float MulFadeSpeed = 0;\n    UPROPERTY(BlueprintReadWrite)\n    float AddFadeSpeed = 0;\n    UPROPERTY(BlueprintReadWrite)\n    float Transparency = 1;\n    UPROPERTY(BlueprintReadWrite)\n    float FadeTransparency = 1;\n    UPROPERTY(BlueprintReadWrite)\n    float TransparencySpeed = 0;\n    UPROPERTY(BlueprintReadWrite)\n    FLinearColor DamageColor = FLinearColor(1, 1, 1, 1);\n    UPROPERTY(BlueprintReadWrite)\n    FLinearColor DamageColor2 = FLinearColor(1, 1, 1, 1);\n\n    /*\n     * Miscellaneous data\n     */\n    int32 ColPosX = 0;\n    int32 ColPosY = 0;\n    int32 MiscFlags = 0;\n    int32 Timer0 = 0;\n    int32 Timer1 = 0;\n    bool IsPlayer = false;\n    bool IsActive = false;\n    UPROPERTY(BlueprintReadWrite)\n    int32 DrawPriority = 0; // the higher the number, the farther in front the object will be drawn\n\n    UPROPERTY(BlueprintReadWrite)\n    bool bRender = true;\n\n    UPROPERTY(BlueprintReadWrite)\n    FHomingParams HomingParams = FHomingParams();\n    UPROPERTY(BlueprintReadWrite)\n    FSuperArmorData SuperArmorData = FSuperArmorData();\n\n    UPROPERTY(BlueprintReadOnly)\n    int32 UpdateTime = 0;\n\n    /*\n     * Visual object transform\n     */\n    UPROPERTY(BlueprintReadWrite)\n    FVector ObjectOffset = FVector::ZeroVector;\n    UPROPERTY(BlueprintReadWrite)\n    FRotator ObjectRotation = FRotator::ZeroRotator;\n    UPROPERTY(BlueprintReadWrite)\n    FVector ObjectScale = FVector::One();\n\n    /*\n     * Object pointers.\n     */\n\n    // Pointer to player object. If this is not a player, it will point to the owning player.\n    UPROPERTY(BlueprintReadOnly)\n    APlayerObject* Player = nullptr;\n    UPROPERTY(BlueprintReadOnly)\n    ABattleObject* AttackOwner;\n    UPROPERTY(BlueprintReadOnly)\n    ABattleObject* AttackTarget = nullptr;\n    UPROPERTY(BlueprintReadWrite)\n    ABattleObject* PositionLinkObj = nullptr;\n    UPROPERTY(BlueprintReadWrite)\n    ABattleObject* DrawPriorityLinkObj = nullptr;\n    UPROPERTY(BlueprintReadWrite)\n    ABattleObject* StopLinkObj = nullptr;\n    UPROPERTY(BlueprintReadWrite)\n    ABattleObject* MaterialLinkObj = nullptr;\n\n    int32 ObjectStateIndex = 0;\n    bool bIsCommonState = false;\n\n    // Anything past here isn't saved or loaded for rollback, unless it has the SaveGame tag.\n    unsigned char ObjSyncEnd = 0;\n\n    virtual void LogForSyncTestFile(std::ofstream&amp; file);\n};\n\n/*\n * A battle object.\n * These are any objects that affect gameplay, or need values to change after being spawned.\n */\nUCLASS()\nclass NIGHTSKYENGINE_API ABattleObject : public APawn\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this pawn's properties\n    ABattleObject();\n\n    //Starting from this until ObjSyncEnd, everything is saved/loaded for rollback.\n    unsigned char ObjSync = 0;\n\n    /*\n     * Movement and position values\n     */\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)\n    int32 PosX = 0;\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)\n    int32 PosY = 0;\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)\n    int32 PosZ = 0;\n    int32 PrevPosX = 0;\n    int32 PrevPosY = 0;\n    int32 PrevPosZ = 0;\n    int32 PrevRootMotionX = 0;\n    int32 PrevRootMotionY = 0;\n    int32 PrevRootMotionZ = 0;\n    UPROPERTY(VisibleAnywhere)\n    int32 AnglePitch_x1000 = 0;\n    UPROPERTY(VisibleAnywhere)\n    int32 AngleYaw_x1000 = 0;\n    UPROPERTY(VisibleAnywhere)\n    int32 AngleRoll_x1000 = 0;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    bool BlendOffset = false;\n    int32 PrevOffsetX = 0;\n    int32 PrevOffsetY = 0;\n    int32 NextOffsetX = 0;\n    int32 NextOffsetY = 0;\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)\n    int32 SpeedX = 0;\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)\n    int32 SpeedY = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SpeedZ = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SpeedXRate = 100;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SpeedXRatePerFrame = 100;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SpeedYRate = 100;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SpeedYRatePerFrame = 100;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SpeedZRate = 100;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SpeedZRatePerFrame = 100;\n    UPROPERTY(BlueprintReadWrite)\n    int32 Gravity = 1900;\n    // Inertia adds to the position every frame, but also decays every frame until it reaches zero.\n    UPROPERTY(BlueprintReadWrite)\n    int32 Inertia = 0;\n    // The minimum Y position before considered grounded.\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)\n    int32 GroundHeight = 0;\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)\n    TEnumAsByte&lt;EObjDir&gt; Direction = DIR_Right;\n    // Ground hit pushback.\n    UPROPERTY(VisibleAnywhere, BlueprintReadWrite)\n    int32 Pushback = 0;\n\n    /*\n     * Attack data\n     */\n\n    UPROPERTY(BlueprintReadWrite)\n    FHitDataCommon HitCommon = {};\n    UPROPERTY(BlueprintReadWrite)\n    FHitData NormalHit = {};\n    UPROPERTY(BlueprintReadWrite)\n    FHitData CounterHit = {};\n    uint32 AttackFlags = 0;\n\n    /*\n     * Received attack data\n     */\n\n    UPROPERTY(BlueprintReadOnly)\n    FHitDataCommon ReceivedHitCommon = {};\n    UPROPERTY(BlueprintReadOnly)\n    FHitData ReceivedHit = {};\n    int32 StunTime = 0;\n    int32 StunTimeMax = 0;\n    int32 Hitstop = 0;\n\n    /*\n     * Registers\n    */\n\n    //The following values are per-action registers. Shared between the player and its child objects.\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg1 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg2 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg3 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg4 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg5 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg6 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg7 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ActionReg8 = 0;\n\n    //The following values are per-object registers.\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg1 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg2 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg3 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg4 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg5 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg6 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg7 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 ObjectReg8 = 0;\n\n    /*\n     * Subroutine registers. These are set when calling a subroutine, and reset upon round end.\n     */\n    UPROPERTY(BlueprintReadOnly)\n    int32 SubroutineReg1 = 0;\n    UPROPERTY(BlueprintReadOnly)\n    int32 SubroutineReg2 = 0;\n    UPROPERTY(BlueprintReadOnly)\n    int32 SubroutineReg3 = 0;\n    UPROPERTY(BlueprintReadOnly)\n    int32 SubroutineReg4 = 0;\n\n    /*\n     * Subroutine return values. Subroutines can optionally return values.\n     * These are reset upon the next called subroutine.\n    */\n    UPROPERTY(BlueprintReadWrite)\n    int32 SubroutineReturnVal1 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SubroutineReturnVal2 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SubroutineReturnVal3 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 SubroutineReturnVal4 = 0;\n\n    /*\n     * Action data\n     */\n\n    UPROPERTY(BlueprintReadOnly)\n    int32 ActionTime = 0;\n    /*\n     * The current cel name.\n     * Cels map to collision data.\n     * The collision frame also stores animation data.\n     */\n    FGameplayTag CelName = {};\n    /*\n     * The blend cel name.\n     * This is used to make traditional 3D animations.\n     */\n    FGameplayTag BlendCelName = {};\n    /*\n     * The name of the label that is currently being jumped to.\n     */\n    FGameplayTag LabelName = {};\n\n    UPROPERTY(BlueprintReadOnly)\n    float AnimBlendIn{};\n    UPROPERTY(BlueprintReadOnly)\n    float AnimBlendOut{};\n    // Are we jumping to a label right now?\n    UPROPERTY(BlueprintReadWrite)\n    bool GotoLabelActive = false;\n    UPROPERTY(BlueprintReadWrite)\n    int32 AnimFrame = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 BlendAnimFrame = 0;\n    UPROPERTY(BlueprintReadWrite)\n    float FrameBlendPosition = 0;\n    // The index of the current cel in blueprint.\n    UPROPERTY(BlueprintReadWrite)\n    int32 CelIndex = 0;\n    // How long until the next cel activates.\n    UPROPERTY(BlueprintReadOnly)\n    int32 TimeUntilNextCel = 0;\n    // Max time of the cel.\n    int32 MaxCelTime = 0;\n    // Event handlers for every function.\n    FEventHandler EventHandlers[EVT_NUM] = {};\n\n    /*\n     * Action data for objects only.\n     */\n    FGameplayTag ObjectStateName = {};\n    uint32 ObjectID = 0;\n\nprotected:\n    /*\n     * Collision data\n     */\n    int32 PushHeight = 0;\n    int32 PushHeightLow = 0;\n    int32 PushWidth = 0;\n    int32 PushWidthExtend = 0;\n\npublic:\n    /*\n     * Push collision\n     */\n\n    int32 L = 0;\n    int32 R = 0;\n    int32 T = 0;\n    int32 B = 0;\n\n    /*\n     * Socket data\n     */\n    FName SocketName = {};\n    EObjType SocketObj = OBJ_Self;\n    FVector SocketOffset = FVector::ZeroVector;\n\n    //material parameters\n    UPROPERTY(BlueprintReadWrite)\n    FLinearColor MulColor = FLinearColor(1, 1, 1, 1);\n    UPROPERTY(BlueprintReadWrite)\n    FLinearColor AddColor = FLinearColor(0, 0, 0, 1);\n    UPROPERTY(BlueprintReadWrite)\n    FLinearColor MulFadeColor = {};\n    UPROPERTY(BlueprintReadWrite)\n    FLinearColor AddFadeColor = {};\n    UPROPERTY(BlueprintReadWrite)\n    float MulFadeSpeed = 0;\n    UPROPERTY(BlueprintReadWrite)\n    float AddFadeSpeed = 0;\n    UPROPERTY(BlueprintReadWrite)\n    float Transparency = 1;\n    UPROPERTY(BlueprintReadWrite)\n    float FadeTransparency = 1;\n    UPROPERTY(BlueprintReadWrite)\n    float TransparencySpeed = 0;\n    UPROPERTY(BlueprintReadWrite)\n    FLinearColor DamageColor = FLinearColor(1, 1, 1, 1);\n    UPROPERTY(BlueprintReadWrite)\n    FLinearColor DamageColor2 = FLinearColor(1, 1, 1, 1);\n\n    /*\n     * Miscellaneous data\n     */\n    int32 ColPosX = 0;\n    int32 ColPosY = 0;\n    int32 MiscFlags = 0;\n    int32 Timer0 = 0;\n    int32 Timer1 = 0;\n    bool IsPlayer = false;\n    bool IsActive = false;\n    UPROPERTY(BlueprintReadWrite)\n    int32 DrawPriority = 0; // the higher the number, the farther in front the object will be drawn\n\n    UPROPERTY(BlueprintReadWrite)\n    bool bRender = true;\n\n    UPROPERTY(BlueprintReadWrite)\n    FHomingParams HomingParams = FHomingParams();\n    UPROPERTY(BlueprintReadWrite)\n    FSuperArmorData SuperArmorData = FSuperArmorData();\n\n    UPROPERTY(BlueprintReadOnly)\n    int32 UpdateTime = 0;\n\n    /*\n     * Visual object transform\n     */\n    UPROPERTY(BlueprintReadWrite)\n    FVector ObjectOffset = FVector::ZeroVector;\n    UPROPERTY(BlueprintReadWrite)\n    FRotator ObjectRotation = FRotator::ZeroRotator;\n    UPROPERTY(BlueprintReadWrite)\n    FVector ObjectScale = FVector::One();\n\n    /*\n     * Object pointers.\n     */\n\n    // Pointer to player object. If this is not a player, it will point to the owning player.\n    UPROPERTY(BlueprintReadOnly)\n    APlayerObject* Player = nullptr;\n    UPROPERTY(BlueprintReadOnly)\n    ABattleObject* AttackOwner;\n    UPROPERTY(BlueprintReadOnly)\n    ABattleObject* AttackTarget = nullptr;\n    UPROPERTY(BlueprintReadWrite)\n    ABattleObject* PositionLinkObj = nullptr;\n    UPROPERTY(BlueprintReadWrite)\n    ABattleObject* DrawPriorityLinkObj = nullptr;\n    UPROPERTY(BlueprintReadWrite)\n    ABattleObject* StopLinkObj = nullptr;\n    UPROPERTY(BlueprintReadWrite)\n    ABattleObject* MaterialLinkObj = nullptr;\n\n    int32 ObjectStateIndex = 0;\n    bool bIsCommonState = false;\n\n    // Anything past here isn't saved or loaded for rollback, unless it has the SaveGame tag.\n    unsigned char ObjSyncEnd = 0;\n\n    UPROPERTY(SaveGame)\n    TArray&lt;ABattleObject*&gt; ObjectsToIgnoreHitsFrom;\n\n    UPROPERTY(BlueprintReadOnly, SaveGame)\n    TArray&lt;FCollisionBox&gt; Boxes;\n\n    /*\n     * Link data (for object), not serialized\n     */\n\n    UPROPERTY(SaveGame)\n    TObjectPtr&lt;ALinkActor&gt; LinkedActor;\n    UPROPERTY()\n    TObjectPtr&lt;UNiagaraComponent&gt; LinkedParticle = nullptr;\n\n    uint32 ObjNumber = 0;\n\n    UPROPERTY(BlueprintReadWrite, SaveGame)\n    float ScreenSpaceDepthOffset = 0;\n    UPROPERTY(BlueprintReadWrite, SaveGame)\n    float OrthoBlendActive = 0;\n\n    UPROPERTY(SaveGame)\n    TArray&lt;FAnimStruct&gt; AnimStructs;\n\n    UPROPERTY(BlueprintReadOnly)\n    TObjectPtr&lt;ANightSkyGameState&gt; GameState = nullptr;\n    UPROPERTY()\n    TObjectPtr&lt;ANightSkyCharaSelectGameState&gt; CharaSelectGameState = nullptr;\n\n    UPROPERTY()\n    TObjectPtr&lt;UState&gt; ObjectState = nullptr;\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n    // Moves object\n    void Move();\n    void CalculateHoming();\n    bool SuperArmorSuccess(const ABattleObject* Attacker) const;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n    void PositionLinkUpdate();\n    //calculate pushbox\n    void CalculatePushbox();\n    //handles pushing objects\n    void HandlePushCollision(ABattleObject* OtherObj);\n    //handles hitting objects\n    void HandleHitCollision(ABattleObject* AttackedObj);\n    //initializes hit data by attack level\n    FHitData InitHitDataByAttackLevel(bool IsCounter);\n    //handles object clashes\n    void HandleClashCollision(ABattleObject* OtherObj);\n    //handles flip\n    void HandleFlip();\n    void TriggerEvent(EEventType EventType, FGameplayTag StateMachineName);\n\n    UFUNCTION(BlueprintCallable)\n    void CollisionView();\n\n    void SaveForRollback(unsigned char* Buffer) const;\n    void LoadForRollback(const unsigned char* Buffer);\n\nprotected:\n    void FuncCall(const FName&amp; FuncName) const;\n    UNightSkyAnimSequenceUserData* GetAnimSequenceUserData(const FName PartName) const;\n    TArray&lt;UNightSkyAnimSequenceUserData*&gt; GetAnimSequenceUserDatas() const;\n\npublic:\n    // Cannot be called on player objects. Initializes the object for use.\n    void InitObject();\n    // update object\n    virtual void Update();\n    // update visuals\n    virtual void UpdateVisuals();\n    virtual void UpdateVisualsNoRollback();\n    UFUNCTION(BlueprintImplementableEvent)\n    void UpdateVisuals_BP();\n\n    void GetBoxes();\n\n    // resets object for next use\n    void ResetObject();\n\n    /*\n     * Blueprint callable functions.\n     */\n\n    UFUNCTION(BlueprintPure)\n    UAnimSequenceBase* GetAnimSequenceForPart(const FName Part) const;\n    UFUNCTION(BlueprintPure)\n    UPaperFlipbook* GetFlipbookForPart(const FName Part) const;\n    UFUNCTION(BlueprintPure)\n    bool IsStopped() const;\n    UFUNCTION(BlueprintPure)\n    bool IsTimerPaused() const;\n    //calls subroutine\n    UFUNCTION(BlueprintCallable)\n    void CallSubroutine(FGameplayTag Name);\n    //calls subroutine\n    UFUNCTION(BlueprintCallable)\n    void CallSubroutineWithArgs(FGameplayTag Name, int32 Arg1, int32 Arg2, int32 Arg3, int32 Arg4);\n    //initializes event handler\n    UFUNCTION(BlueprintCallable)\n    void InitEventHandler(EEventType EventType, FName FuncName, int32 Value, FGameplayTag SubroutineName);\n    //initializes event handler\n    UFUNCTION(BlueprintCallable)\n    void RemoveEventHandler(EEventType EventType);\n    //gets cel name\n    UFUNCTION(BlueprintPure)\n    FGameplayTag GetCelName() const;\n    //gets label name\n    UFUNCTION(BlueprintPure)\n    FGameplayTag GetLabelName() const;\n    //sets cel name\n    UFUNCTION(BlueprintCallable)\n    void SetCelName(FGameplayTag InName);\n    //sets cel name\n    UFUNCTION(BlueprintCallable)\n    void SetBlendCelName(FGameplayTag InName);\n    //jumps to label\n    UFUNCTION(BlueprintCallable)\n    void GotoLabel(FGameplayTag InName);\n    //sets time until next cel\n    UFUNCTION(BlueprintCallable)\n    void SetTimeUntilNextCel(int32 InTime);\n    // sets cel duration\n    UFUNCTION(BlueprintCallable)\n    void SetCelDuration(int32 InTime);\n    //adds x position\n    UFUNCTION(BlueprintCallable)\n    void AddPosXWithDir(int InPosX);\n    //sets x speed\n    UFUNCTION(BlueprintCallable)\n    void SetSpeedXRaw(int InSpeedX);\n    //adds x speed\n    UFUNCTION(BlueprintCallable)\n    void AddSpeedXRaw(int InSpeedX);\n    //gets y center\n    UFUNCTION(BlueprintPure)\n    int32 GetPosYCenter() const;\n    // Sets pitch.\n    UFUNCTION(BlueprintCallable)\n    void SetPitch(int32 Pitch_x1000);\n    // Sets pitch.\n    UFUNCTION(BlueprintCallable)\n    void SetYaw(int32 Yaw_x1000);\n    // Sets pitch.\n    UFUNCTION(BlueprintCallable)\n    void SetRoll(int32 Roll_x1000);\n    // Normalizes angle to between 0 and 360 degrees.\n    UFUNCTION(BlueprintPure)\n    static int32 NormalizeAngle(int32 Angle_x1000);\n    //calculates angle between points\n    UFUNCTION(BlueprintPure)\n    int32 CalculateSpeedAngle() const;\n    //calculates distance between points\n    UFUNCTION(BlueprintPure)\n    int32 CalculateDistanceBetweenPoints(EDistanceType Type, EObjType Obj1, EPosType Pos1, EObjType Obj2,\n                                         EPosType Pos2);\n    //calculates angle between points\n    UFUNCTION(BlueprintPure)\n    int32 CalculateAngleBetweenPoints(EObjType Obj1, EPosType Pos1, EObjType Obj2, EPosType Pos2);\n    //gets position from pos type\n    UFUNCTION(BlueprintPure)\n    void PosTypeToPosition(EPosType Type, int32&amp; OutPosX, int32&amp; OutPosY) const;\n    UFUNCTION(BlueprintPure)\n    void ScreenPosToWorldPos(const int32 X, const int32 Y, int32&amp; OutX, int32&amp; OutY) const;\n    //sets direction\n    UFUNCTION(BlueprintCallable)\n    void SetFacing(EObjDir NewDir);\n    //flips character\n    UFUNCTION(BlueprintCallable)\n    void FlipObject();\n    //forcibly face opponent\n    UFUNCTION(BlueprintCallable)\n    void FaceOpponent();\n    //check if grounded\n    UFUNCTION(BlueprintPure)\n    bool CheckIsGrounded() const;\n    //enables hit\n    UFUNCTION(BlueprintCallable)\n    void EnableHit(bool Enabled);\n    //sets attacking. while this is true, you can be counter hit, but you can hit the opponent and chain cancel.\n    UFUNCTION(BlueprintCallable)\n    void SetAttacking(bool Attacking);\n    UFUNCTION(BlueprintCallable)\n    void SetPlayerHit(bool Enable);\n    UFUNCTION(BlueprintCallable)\n    void SetProjectileAttribute(bool Attribute);\n    UFUNCTION(BlueprintCallable)\n    void SetProrateOnce(bool Once);\n    UFUNCTION(BlueprintCallable)\n    void SetIgnoreOTG(bool Ignore);\n    UFUNCTION(BlueprintCallable)\n    void SetHitOTG(bool Enable);\n    UFUNCTION(BlueprintCallable)\n    void SetIgnorePushbackScaling(bool Ignore);\n    UFUNCTION(BlueprintCallable)\n    void SetIgnoreHitstunScaling(bool Ignore);\n    //enables flip\n    UFUNCTION(BlueprintCallable)\n    void EnableFlip(bool Enabled);\n    //enables inertia\n    UFUNCTION(BlueprintCallable)\n    void EnableInertia();\n    //disables inertia\n    UFUNCTION(BlueprintCallable)\n    void DisableInertia();\n    //halts momentum\n    UFUNCTION(BlueprintCallable)\n    void HaltMomentum();\n    //should wall collision be used?\n    UFUNCTION(BlueprintCallable)\n    void SetWallCollisionActive(bool Active);\n    //should floor collision be used?\n    UFUNCTION(BlueprintCallable)\n    void SetFloorCollisionActive(bool Active);\n    //should push collision be used?\n    UFUNCTION(BlueprintCallable)\n    void SetPushCollisionActive(bool Active);\n    //set push width extend\n    UFUNCTION(BlueprintCallable)\n    void SetPushWidthExtend(int32 Extend);\n    //creates common particle\n    UFUNCTION(BlueprintCallable)\n    void CreateCommonParticle(FGameplayTag Name, EPosType PosType, FVector Offset = FVector::ZeroVector,\n                              FRotator Rotation = FRotator::ZeroRotator);\n    //creates character particle\n    UFUNCTION(BlueprintCallable)\n    void CreateCharaParticle(FGameplayTag Name, EPosType PosType, FVector Offset = FVector::ZeroVector,\n                             FRotator Rotation = FRotator::ZeroRotator);\n    //creates common particle and attaches it to the object. can only be used with non-player objects.\n    UFUNCTION(BlueprintCallable)\n    void LinkCommonParticle(FGameplayTag Name);\n    //creates character particle and attaches it to the object. can only be used with non-player objects.\n    UFUNCTION(BlueprintCallable)\n    void LinkCharaParticle(FGameplayTag Name);\n    //gets link actor and attaches it to the object. can only be used with non-player objects.\n    UFUNCTION(BlueprintCallable)\n    ALinkActor* LinkActor(FGameplayTag Name);\n    UFUNCTION(BlueprintCallable)\n    void RemoveLinkActor();\n    //plays common sound\n    UFUNCTION(BlueprintCallable)\n    void PlayCommonSound(FGameplayTag Name);\n    //plays chara sound\n    UFUNCTION(BlueprintCallable)\n    void PlayCharaSound(FGameplayTag Name);\n    //attaches object to skeletal socket\n    UFUNCTION(BlueprintCallable)\n    void AttachToSocketOfObject(FName InSocketName, FVector Offset, EObjType ObjType);\n    //detaches object from skeletal socket\n    UFUNCTION(BlueprintCallable)\n    void DetachFromSocket();\n    UFUNCTION(BlueprintCallable)\n    void CameraShake(FGameplayTag PatternName, int32 Scale);\n    //generate random number\n    UFUNCTION(BlueprintPure)\n    int32 GenerateRandomNumber(int32 Min, int32 Max) const;\n    // starts super freeze\n    UFUNCTION(BlueprintCallable)\n    void StartSuperFreeze(int Duration, int SelfDuration = 0);\n    // ignore super freeze\n    UFUNCTION(BlueprintCallable)\n    void IgnoreSuperFreeze(bool Ignore);\n    //sets object id\n    UFUNCTION(BlueprintCallable)\n    void SetObjectID(int InObjectID);\n    //gets object by type\n    UFUNCTION(BlueprintPure)\n    ABattleObject* GetBattleObject(EObjType Type);\n    //creates common object\n    UFUNCTION(BlueprintCallable)\n    ABattleObject* AddCommonBattleObject(FGameplayTag InStateName, int32 PosXOffset = 0, int32 PosYOffset = 0,\n                                         EPosType PosType = POS_Player);\n    //creates object\n    UFUNCTION(BlueprintCallable)\n    ABattleObject* AddBattleObject(FGameplayTag InStateName, int32 PosXOffset = 0, int32 PosYOffset = 0,\n                                   EPosType PosType = POS_Player);\n    //if object goes beyond screen bounds, deactivate\n    UFUNCTION(BlueprintCallable)\n    void EnableDeactivateIfBeyondBounds(bool Enable);\n    //if player changes state, deactivate\n    UFUNCTION(BlueprintCallable)\n    void EnableDeactivateOnStateChange(bool Enable);\n    //if player receives hit, deactivate\n    UFUNCTION(BlueprintCallable)\n    void EnableDeactivateOnReceiveHit(bool Enable);\n    // Cannot be called on player objects. Deactivates the object and returns it to the pool.\n    UFUNCTION(BlueprintCallable)\n    void DeactivateObject();\n    UFUNCTION(BlueprintPure)\n    bool CheckBoxOverlap(ABattleObject* OtherObj, const EBoxType SelfType, const FGameplayTag SelfCustomType,\n                         const EBoxType OtherType, const FGameplayTag OtherCustomType);\n    UFUNCTION(BlueprintPure)\n    void GetBoxPosition(const EBoxType BoxType, const FGameplayTag CustomType, int&amp; OutPosX, int&amp; OutPosY) const;\n    UFUNCTION(BlueprintPure)\n    int32 GetGauge(int32 GaugeIndex) const;\n    UFUNCTION(BlueprintCallable)\n    void SetGauge(int32 GaugeIndex, int32 Value);\n    UFUNCTION(BlueprintCallable)\n    void UseGauge(int32 GaugeIndex, int32 Value);\n\n    // Handles custom collision. Activates before clash or hit collision.\n    UFUNCTION(BlueprintImplementableEvent)\n    void HandleCustomCollision_PreHit(ABattleObject* OtherObj);\n    // Handles custom collision. Activates after clash and hit collision.\n    UFUNCTION(BlueprintImplementableEvent)\n    void HandleCustomCollision_PostHit(ABattleObject* OtherObj);\n};\n\nconstexpr size_t SizeOfBattleObject = offsetof(ABattleObject, ObjSyncEnd) - offsetof(ABattleObject, ObjSync);\n\n#if WITH_EDITOR\nstatic_assert(offsetof(FBattleObjectLog, ObjSyncEnd) - offsetof(FBattleObjectLog, ObjSync) == SizeOfBattleObject,\n              \"FBattleObjectLog must contain all members from ABattleObject between ObjSync and ObjSyncEnd\");\n#endif\n</code></pre>"},{"location":"NightSkyEngine/_player_object_8cpp/","title":"File PlayerObject.cpp","text":"<p>FileList &gt; Battle &gt; Objects &gt; PlayerObject.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"PlayerObject.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/NightSkyGameState.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Actors/LinkActor.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Script/Subroutine.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/LinkActorData.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/ParticleData.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/SubroutineData.h\"</code></li> <li><code>#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"</code></li> <li><code>#include \"Serialization/ObjectReader.h\"</code></li> <li><code>#include \"Serialization/ObjectWriter.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_player_object_8cpp/#public-functions","title":"Public Functions","text":"Type Name UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Label_Blowback_1, \"State.Label.Blowback.1\", \"Blowback Label 1\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Label_Blowback_2, \"State.Label.Blowback.2\", \"Blowback Label 2\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Label_Blowback_3, \"State.Label.Blowback.3\", \"Blowback Label 3\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Label_Blowback_4, \"State.Label.Blowback.4\", \"Blowback Label 4\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Label_Block_PreGuard, \"State.Label.Block.PreGuard\", \"Block Label Pre Guard\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Label_Block_Level1, \"State.Label.Block.Level1\", \"Block Label Level 1\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Label_Block_Level2, \"State.Label.Block.Level2\", \"Block Label Level 2\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Label_Block_Level3, \"State.Label.Block.Level3\", \"Block Label Level 3\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_Cmn_IsCorrectBlock, \"Subroutine.Cmn.IsCorrectBlock\", \"Common Is Correct Block\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_Cmn_HitCollision, \"Subroutine.Cmn.HitCollision\", \"Common Hit Collision\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_Cmn_OnBlock, \"Subroutine.Cmn.OnBlock\", \"Common On Block\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_Cmn_OnHit, \"Subroutine.Cmn.OnHit\", \"Common On Hit\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_Cmn_OnCounterHit, \"Subroutine.Cmn.OnCounterHit\", \"Common On Counter Hit\")"},{"location":"NightSkyEngine/_player_object_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_player_object_8cpp/#function-ue_define_gameplay_tag_comment","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Label_Blowback_1,\n    \"State.Label.Blowback.1\",\n    \"Blowback Label 1\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8cpp/#function-ue_define_gameplay_tag_comment_1","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Label_Blowback_2,\n    \"State.Label.Blowback.2\",\n    \"Blowback Label 2\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8cpp/#function-ue_define_gameplay_tag_comment_2","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Label_Blowback_3,\n    \"State.Label.Blowback.3\",\n    \"Blowback Label 3\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8cpp/#function-ue_define_gameplay_tag_comment_3","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Label_Blowback_4,\n    \"State.Label.Blowback.4\",\n    \"Blowback Label 4\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8cpp/#function-ue_define_gameplay_tag_comment_4","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Label_Block_PreGuard,\n    \"State.Label.Block.PreGuard\",\n    \"Block Label Pre Guard\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8cpp/#function-ue_define_gameplay_tag_comment_5","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Label_Block_Level1,\n    \"State.Label.Block.Level1\",\n    \"Block Label Level 1\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8cpp/#function-ue_define_gameplay_tag_comment_6","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Label_Block_Level2,\n    \"State.Label.Block.Level2\",\n    \"Block Label Level 2\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8cpp/#function-ue_define_gameplay_tag_comment_7","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Label_Block_Level3,\n    \"State.Label.Block.Level3\",\n    \"Block Label Level 3\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8cpp/#function-ue_define_gameplay_tag_comment_8","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_Cmn_IsCorrectBlock,\n    \"Subroutine.Cmn.IsCorrectBlock\",\n    \"Common Is Correct Block\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8cpp/#function-ue_define_gameplay_tag_comment_9","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_Cmn_HitCollision,\n    \"Subroutine.Cmn.HitCollision\",\n    \"Common Hit Collision\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8cpp/#function-ue_define_gameplay_tag_comment_10","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_Cmn_OnBlock,\n    \"Subroutine.Cmn.OnBlock\",\n    \"Common On Block\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8cpp/#function-ue_define_gameplay_tag_comment_11","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_Cmn_OnHit,\n    \"Subroutine.Cmn.OnHit\",\n    \"Common On Hit\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8cpp/#function-ue_define_gameplay_tag_comment_12","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_Cmn_OnCounterHit,\n    \"Subroutine.Cmn.OnCounterHit\",\n    \"Common On Counter Hit\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/PlayerObject.cpp</code></p>"},{"location":"NightSkyEngine/_player_object_8cpp_source/","title":"File PlayerObject.cpp","text":"<p>File List &gt; Battle &gt; Objects &gt; PlayerObject.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"PlayerObject.h\"\n\n#include \"NightSkyEngine/Battle/NightSkyGameState.h\"\n#include \"NightSkyEngine/Battle/Actors/LinkActor.h\"\n#include \"NightSkyEngine/Battle/Script/Subroutine.h\"\n#include \"NightSkyEngine/Data/LinkActorData.h\"\n#include \"NightSkyEngine/Data/ParticleData.h\"\n#include \"NightSkyEngine/Data/SubroutineData.h\"\n#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"\n#include \"Serialization/ObjectReader.h\"\n#include \"Serialization/ObjectWriter.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(PlayerObject)\n\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Blowback_1, \"State.Label.Blowback.1\", \"Blowback Label 1\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Blowback_2, \"State.Label.Blowback.2\", \"Blowback Label 2\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Blowback_3, \"State.Label.Blowback.3\", \"Blowback Label 3\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Blowback_4, \"State.Label.Blowback.4\", \"Blowback Label 4\");\n\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Block_PreGuard, \"State.Label.Block.PreGuard\", \"Block Label Pre Guard\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Block_Level1, \"State.Label.Block.Level1\", \"Block Label Level 1\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Block_Level2, \"State.Label.Block.Level2\", \"Block Label Level 2\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Label_Block_Level3, \"State.Label.Block.Level3\", \"Block Label Level 3\");\n\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_IsCorrectBlock, \"Subroutine.Cmn.IsCorrectBlock\", \"Common Is Correct Block\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_HitCollision, \"Subroutine.Cmn.HitCollision\", \"Common Hit Collision\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_OnBlock, \"Subroutine.Cmn.OnBlock\", \"Common On Block\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_OnHit, \"Subroutine.Cmn.OnHit\", \"Common On Hit\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_OnCounterHit, \"Subroutine.Cmn.OnCounterHit\", \"Common On Counter Hit\");\n\nvoid FPlayerObjectLog::LogForSyncTestFile(std::ofstream&amp; file)\n{\n    FBattleObjectLog::LogForSyncTestFile(file);\n    if (file)\n    {\n        file &lt;&lt; \"PlayerObject:\\n\";\n        file &lt;&lt; \"\\tCurrentAirJumpCount: \" &lt;&lt; CurrentAirJumpCount &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tCurrentAirDashCount: \" &lt;&lt; CurrentAirDashCount &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tAirDashTimer: \" &lt;&lt; AirDashTimer &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tAirDashTimerMax: \" &lt;&lt; AirDashTimerMax &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tCurrentHealth: \" &lt;&lt; CurrentHealth &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tCancelFlags: \" &lt;&lt; CancelFlags &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tPlayerFlags: \" &lt;&lt; PlayerFlags &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tInputs: \" &lt;&lt; StoredInputBuffer.InputBufferInternal[InputBufferSize - 1] &lt;&lt; std::endl;\n        file &lt;&lt; \"\\tStance: \" &lt;&lt; Stance.GetValue() &lt;&lt; std::endl;\n    }\n}\n\nAPlayerObject::APlayerObject()\n{\n    PrimaryStateMachine.Parent = this;\n    MiscFlags = MISC_PushCollisionActive | MISC_WallCollisionActive | MISC_FloorCollisionActive;\n    CancelFlags = CNC_EnableKaraCancel | CNC_ChainCancelEnabled | CNC_EnableReverseBeat;\n    PlayerFlags = PLF_DefaultLandingAction;\n    FWalkSpeed = 7800;\n    BWalkSpeed = 4800;\n    FDashInitSpeed = 13000;\n    FDashAccel = 600;\n    FDashFriction = 95;\n    FDashMaxSpeed = 38500;\n    BDashSpeed = 14000;\n    BDashHeight = 5200;\n    BDashGravity = 700;\n    JumpHeight = 35000;\n    FJumpSpeed = 7900;\n    BJumpSpeed = 5200;\n    JumpGravity = 1900;\n    SuperJumpHeight = 43700;\n    FSuperJumpSpeed = 7900;\n    BSuperJumpSpeed = 5200;\n    SuperJumpGravity = 1900;\n    AirDashMinimumHeight = 105000;\n    FAirDashSpeed = 30000;\n    BAirDashSpeed = 24500;\n    FAirDashTime = 20;\n    BAirDashTime = 12;\n    FAirDashNoAttackTime = 5;\n    BAirDashNoAttackTime = 5;\n    AirJumpCount = 1;\n    AirDashCount = 1;\n    Stance = ACT_Standing;\n    StandPushWidth = 110000;\n    StandPushHeight = 240000;\n    CrouchPushWidth = 120000;\n    CrouchPushHeight = 180000;\n    AirPushWidth = 100000;\n    AirPushHeight = 275000;\n    AirPushHeightLow = -135000;\n    IsPlayer = true;\n    IsActive = true;\n    MaxHealth = 10000;\n    ForwardWalkMeterGain = 12;\n    ForwardJumpMeterGain = 10;\n    ForwardDashMeterGain = 25;\n    ForwardAirDashMeterGain = 25;\n    PushWidth = StandPushWidth;\n    PushHeight = StandPushHeight;\n    PushHeightLow = 0;\n    AttackFlags = 0;\n    for (bool&amp; Visible : ComponentVisible)\n        Visible = true;\n\n    PrimaryStateMachine.bPrimary = true;\n    PrimaryStateMachine.StateMachineName = StateMachine_Primary;\n    std::fill_n(StoredInputBuffer.InputBufferInternal, InputBufferSize, INP_Neutral);\n}\n\nvoid APlayerObject::BeginPlay()\n{\n    Super::BeginPlay();\n\n    if (CommonLinkActorData != nullptr)\n    {\n        for (FLinkActorStruct LinkedActorStruct : CommonLinkActorData-&gt;LinkedActorStructs)\n        {\n            for (int i = 0; i &lt; LinkedActorStruct.MaxInstances; i++)\n            {\n                auto Actor = GetWorld()-&gt;SpawnActor&lt;ALinkActor&gt;(LinkedActorStruct.ActorClass);\n                Actor-&gt;SetActorHiddenInGame(true);\n                FLinkedActorContainer Container{Actor, LinkedActorStruct.Name, StoredLinkActors.Num(), false};\n                StoredLinkActors.Add(Container);\n            }\n        }\n    }\n\n    if (LinkActorData != nullptr)\n    {\n        for (FLinkActorStruct LinkedActorStruct : LinkActorData-&gt;LinkedActorStructs)\n        {\n            for (int i = 0; i &lt; LinkedActorStruct.MaxInstances; i++)\n            {\n                auto Actor = GetWorld()-&gt;SpawnActor&lt;ALinkActor&gt;(LinkedActorStruct.ActorClass);\n                Actor-&gt;SetActorHiddenInGame(true);\n                FLinkedActorContainer Container{Actor, LinkedActorStruct.Name, StoredLinkActors.Num(), false};\n                StoredLinkActors.Add(Container);\n            }\n        }\n    }\n\n    InitPlayer();\n}\n\nvoid APlayerObject::HandleLanding()\n{\n    if (PosY &lt;= GroundHeight &amp;&amp; PrevPosY &gt; GroundHeight) // trigger landing\n    {\n        PrevPosY = PosY;\n        CurrentAirJumpCount = AirJumpCount;\n        CurrentAirDashCount = AirDashCount;\n        SpeedX = 0;\n        if (PlayerFlags &amp; PLF_DefaultLandingAction &amp;&amp; PrimaryStateMachine.CurrentState-&gt;StateType !=\n            EStateType::Hitstun)\n        {\n            JumpToStatePrimary(State_Universal_JumpLanding);\n        }\n        SetStance(ACT_Standing);\n        TriggerEvent(EVT_Landing, StateMachine_Primary);\n        CallSubroutine(Subroutine_Cmn_OnLanding);\n        CallSubroutine(Subroutine_OnLanding);\n        CreateCommonParticle(Particle_JumpSmoke_Land, POS_Player);\n        if (PrimaryStateMachine.CurrentState-&gt;StateType != EStateType::Hitstun) PlayCommonSound(Sound_Land);\n        BufferedStateName = FGameplayTag::EmptyTag;\n    }\n}\n\nuint32 APlayerObject::FlipInput(uint32 Input)\n{\n    const unsigned int Bit1 = Input &gt;&gt; 2 &amp; 1;\n    const unsigned int Bit2 = Input &gt;&gt; 3 &amp; 1;\n    unsigned int x = Bit1 ^ Bit2;\n\n    x = x &lt;&lt; 2 | x &lt;&lt; 3;\n\n    return Input ^ x;\n}\n\nvoid APlayerObject::InitPlayer()\n{\n    Player = this;\n    CurrentHealth = MaxHealth;\n    EnableFlip(true);\n\n    EmptyStateMachine();\n\n    if (!CharaStateData) return;\n\n    for (auto StateClass : CharaStateData-&gt;StateArray)\n    {\n        if (!IsValid(StateClass)) continue;\n        auto State = NewObject&lt;UState&gt;(this, StateClass);\n        AddState(State-&gt;Name, State, StateMachine_Primary);\n    }\n    for (auto SubStatePair : SubStateData)\n    {\n        for (auto StateClass : SubStatePair.Value-&gt;StateArray)\n        {\n            if (!IsValid(StateClass)) continue;\n            auto State = NewObject&lt;UState&gt;(this, StateClass);\n            AddState(State-&gt;Name, State, SubStatePair.Key);\n        }\n    }\n    if (IsValid(CommonSubroutineData))\n    {\n        for (auto SubroutineClass : CommonSubroutineData-&gt;SubroutineArray)\n        {\n            if (!IsValid(SubroutineClass)) continue;\n            auto Subroutine = NewObject&lt;USubroutine&gt;(this, SubroutineClass);\n            AddSubroutine(Subroutine-&gt;Name, Subroutine, true);\n        }\n    }\n    if (IsValid(CharaSubroutineData))\n    {\n        for (auto SubroutineClass : CharaSubroutineData-&gt;SubroutineArray)\n        {\n            if (!IsValid(SubroutineClass)) continue;\n            auto Subroutine = NewObject&lt;USubroutine&gt;(this, SubroutineClass);\n            AddSubroutine(Subroutine-&gt;Name, Subroutine, false);\n        }\n    }\n    if (IsValid(CommonObjectStateData))\n    {\n        for (auto StateClass : CommonObjectStateData-&gt;StateArray)\n        {\n            if (!IsValid(StateClass)) continue;\n\n            for (int i = 0; i &lt; StateClass.GetDefaultObject()-&gt;MaxInstances; i++)\n            {\n                auto State = NewObject&lt;UState&gt;(this, StateClass);\n                AddObjectState(State-&gt;Name, State, true);\n            }\n        }\n    }\n    if (IsValid(ObjectStateData))\n    {\n        for (auto StateClass : ObjectStateData-&gt;StateArray)\n        {\n            if (!IsValid(StateClass)) continue;\n\n            for (int i = 0; i &lt; StateClass.GetDefaultObject()-&gt;MaxInstances; i++)\n            {\n                auto State = NewObject&lt;UState&gt;(this, StateClass);\n                AddObjectState(State-&gt;Name, State, false);\n            }\n        }\n    }\n}\n\nvoid APlayerObject::HandleStateMachine(bool Buffer, FStateMachine&amp; StateMachine)\n{\n    BufferedStateName = FGameplayTag::EmptyTag;\n    for (int i = StateMachine.States.Num() - 1; i &gt;= 0; i--)\n    {\n        if (CanEnterState(StateMachine.States[i], StateMachine.StateMachineName))\n        {\n            if (HandleAutoCombo(i, StateMachine)) return;\n            if (HandleStateInputs(i, Buffer, StateMachine))\n            {\n                bIsAutoCombo = false;\n                return;\n            }\n        }\n        else\n        {\n            PlayerFlags &amp;= ~PLF_DidKaraCancel;\n        }\n    }\n}\n\nbool APlayerObject::HandleAutoCombo(int32 StateIndex, FStateMachine&amp; StateMachine)\n{\n    if (!FindAutoComboCancelOption(StateMachine.States[StateIndex]-&gt;Name, StateMachine)) return false;\n\n    bool AutoComboSuccess = false;\n    for (int i = 0; i &lt; 8; i++)\n    {\n        const auto AutoComboCancel = AutoComboCancels[i];\n        if (AutoComboCancel != StateIndex) continue;\n\n        EInputFlags Button;\n        switch (i)\n        {\n        case 0:\n            Button = INP_A;\n            break;\n        case 1:\n            Button = INP_A;\n            break;\n        case 2:\n            Button = INP_A;\n            break;\n        case 3:\n            Button = INP_A;\n            break;\n        case 4:\n            Button = INP_A;\n            break;\n        case 5:\n            Button = INP_A;\n            break;\n        case 6:\n            Button = INP_A;\n            break;\n        case 7:\n            Button = INP_A;\n            break;\n        default:\n            Button = INP_A;\n            break;\n        }\n\n        FInputCondition AutoComboCondition;\n        AutoComboCondition.Sequence.Add(FInputBitmask(Button));\n        AutoComboCondition.Sequence.Last().Lenience = 0;\n        AutoComboCondition.Method = EInputMethod::Once;\n\n        if (CheckInput(AutoComboCondition))\n        {\n            AutoComboSuccess = true;\n            break;\n        }\n    }\n\n    if (!AutoComboSuccess) return false;\n\n    bIsAutoCombo = HandleStateTransition(StateIndex, true, StateMachine);\n    return bIsAutoCombo;\n}\n\nbool APlayerObject::HandleStateInputs(int32 StateIndex, bool Buffer, FStateMachine&amp; StateMachine)\n{\n    for (FInputConditionList&amp; List : StateMachine.States[StateIndex]-&gt;InputConditionLists)\n    {\n        for (int v = 0; v &lt; List.InputConditions.Num(); v++) //iterate over input conditions\n        {\n            //check input condition against input buffer, if not met break.\n            if (!StoredInputBuffer.CheckInputCondition(List.InputConditions[v]))\n            {\n                break;\n            }\n            if (v == List.InputConditions.Num() - 1) //have all conditions been met?\n            {\n                return HandleStateTransition(StateIndex, Buffer, StateMachine);\n            }\n        }\n        if (List.InputConditions.Num() == 0) //if no input conditions, set state\n        {\n            return HandleStateTransition(StateIndex, Buffer, StateMachine);\n        }\n    }\n    return false;\n}\n\nbool APlayerObject::HandleStateTransition(int32 StateIndex, bool Buffer, FStateMachine&amp; StateMachine)\n{\n    if (FindChainCancelOption(StateMachine.States[StateIndex]-&gt;Name, StateMachine)\n        || FindAutoComboCancelOption(StateMachine.States[StateIndex]-&gt;Name, StateMachine)\n        || FindWhiffCancelOption(StateMachine.States[StateIndex]-&gt;Name, StateMachine)\n        || CancelFlags &amp; CNC_CancelIntoSelf) //if cancel option, allow resetting state\n    {\n        if (Buffer)\n        {\n            BufferedStateName = StateMachine.States[StateIndex]-&gt;Name;\n            return true; //don't try to enter another state\n        }\n        if (StateMachine.ForceSetState(StateMachine.States[StateIndex]-&gt;Name)) //if state set successful...\n        {\n            GotoLabelActive = false;\n            switch (StateMachine.States[StateIndex]-&gt;EntryStance)\n            {\n            case EEntryStance::Standing:\n                Stance = ACT_Standing;\n                break;\n            case EEntryStance::Crouching:\n                Stance = ACT_Crouching;\n                break;\n            case EEntryStance::Jumping:\n                Stance = ACT_Jumping;\n                break;\n            default:\n                break;\n            }\n            return true; //don't try to enter another state\n        }\n    }\n    else\n    {\n        if (Buffer)\n        {\n            BufferedStateName = StateMachine.States[StateIndex]-&gt;Name;\n            return true; //don't try to enter another state\n        }\n        if (StateMachine.SetState(StateMachine.States[StateIndex]-&gt;Name)) //if state set successful...\n        {\n            GotoLabelActive = false;\n            switch (StateMachine.States[StateIndex]-&gt;EntryStance)\n            {\n            case EEntryStance::Standing:\n                Stance = ACT_Standing;\n                break;\n            case EEntryStance::Crouching:\n                Stance = ACT_Crouching;\n                break;\n            case EEntryStance::Jumping:\n                Stance = ACT_Jumping;\n                break;\n            default:\n                break;\n            }\n            return true; //don't try to enter another state\n        }\n    }\n    return false; //state couldn't be entered\n}\n\nvoid APlayerObject::Update()\n{\n    if ((PlayerFlags &amp; PLF_IsOnScreen) == 0)\n    {\n        return;\n    }\n\n    if (Inputs &lt;&lt; 27 == 0) //if no direction, set neutral input\n        Inputs |= INP_Neutral;\n    else\n        Inputs = Inputs &amp; ~INP_Neutral; //remove neutral input if directional input\n\n    if (Inputs &gt;&gt; 5 != StoredInputBuffer.InputBufferInternal[InputBufferSize - 1] &gt;&gt; 5)\n    {\n        IntroEndFlag = true;\n        if (RoundWinTimer &lt;= 0 || (bIsCpu &amp;&amp; Enemy-&gt;IntroEndFlag))\n        {\n            RoundEndFlag = true;\n        }\n    }\n\n    Super::Update();\n    CallSubroutine(Subroutine_Cmn_OnUpdate);\n    CallSubroutine(Subroutine_OnUpdate);\n\n    if (GameState-&gt;GameInstance-&gt;IsTraining)\n    {\n        if ((PlayerFlags &amp; PLF_IsStunned) == 0)\n        {\n            CurrentHealth = MaxHealth;\n            RecoverableHealth = 0;\n        }\n        if ((AttackFlags &amp; ATK_IsAttacking) == 0 &amp;&amp; ComboTimer &lt;= 0)\n        {\n            GameState-&gt;BattleState.Meter[PlayerIndex] = GameState-&gt;BattleState.MaxMeter[PlayerIndex];\n            for (int i = 0; i &lt; GameState-&gt;BattleState.MaxGauge.Num(); i++)\n            {\n                if (PlayerIndex == 0) GameState-&gt;BattleState.GaugeP1[i] = GameState-&gt;BattleState.MaxGauge[i];\n                else GameState-&gt;BattleState.GaugeP2[i] = GameState-&gt;BattleState.MaxGauge[i];\n            }\n        }\n        if (PlayerIndex == 1)\n        {\n            if (CheckIsStunned())\n                Inputs = INP_A;\n            else\n                Inputs = INP_Neutral;\n        }\n    }\n\n    if (GameState-&gt;BattleState.TimeUntilRoundStart &gt; 0)\n        Inputs = INP_Neutral;\n\n    HandleFlipInput();\n\n    if (ComboCounter &gt; 0)\n        ComboTimer++;\n\n    if (PlayerFlags &amp; PLF_IsThrowLock)\n    {\n        if (!bIsCpu) StoredInputBuffer.Update(Inputs, IsStopped());\n\n        HandleStateMachine(true, PrimaryStateMachine); //handle state transitions\n        PrimaryStateMachine.Update();\n\n        for (auto&amp; StateMachine : SubStateMachines)\n        {\n            HandleStateMachine(false, StateMachine);\n            StateMachine.Update();\n        }\n\n        if (TimeUntilNextCel &gt; 0)\n            TimeUntilNextCel--;\n        if (TimeUntilNextCel == 0)\n            CelIndex++;\n\n        if (ActionTime &lt; ThrowTechTimer)\n        {\n            if (PrimaryStateMachine.GetStateIndex(State_Universal_Throw) != INDEX_NONE)\n            {\n                bool IsTech = true;\n                if (!CanProximityThrow)\n                {\n                    const auto ThrowState = PrimaryStateMachine.States[PrimaryStateMachine.GetStateIndex(\n                        State_Universal_Throw)];\n                    for (auto InputConditionList : ThrowState-&gt;InputConditionLists)\n                    {\n                        IsTech = true;\n                        for (auto InputCondition : InputConditionList.InputConditions)\n                        {\n                            if (!CheckInput(InputCondition))\n                            {\n                                IsTech = false;\n                                break;\n                            }\n                        }\n                        if (IsTech == true) break;\n                    }\n                }\n                else\n                {\n                    FInputCondition Left;\n                    FInputBitmask BitmaskLeft;\n                    BitmaskLeft.InputFlag = INP_Left;\n                    BitmaskLeft.Lenience = 1;\n                    Left.Sequence.Add(BitmaskLeft);\n                    Left.Method = EInputMethod::Strict;\n                    FInputCondition Right;\n                    FInputBitmask BitmaskRight;\n                    BitmaskRight.InputFlag = INP_Right;\n                    BitmaskRight.Lenience = 1;\n                    Right.Sequence.Add(BitmaskRight);\n                    Right.Method = EInputMethod::Strict;\n                    if (!CheckInput(ProximityThrowInput) || (!CheckInput(Left) &amp;&amp; !CheckInput(Right)))\n                    {\n                        IsTech = false;\n                    }\n                }\n                if (IsTech)\n                {\n                    PlayerFlags &amp;= ~PLF_IsThrowLock;\n                    FaceOpponent();\n                    if (Enemy-&gt;Stance != ACT_Jumping)\n                    {\n                        JumpToStatePrimary(State_Universal_GuardBreakStand);\n                        Enemy-&gt;JumpToStatePrimary(State_Universal_GuardBreakStand);\n                        InitEventHandler(EVT_Update, \"ThrowTech\", 0, FGameplayTag::EmptyTag);\n                        Enemy-&gt;InitEventHandler(EVT_Update, \"ThrowTech\", 0, FGameplayTag::EmptyTag);\n                    }\n                    else\n                    {\n                        JumpToStatePrimary(State_Universal_GuardBreakAir);\n                        Enemy-&gt;JumpToStatePrimary(State_Universal_GuardBreakAir);\n                        InitEventHandler(EVT_Update, \"ThrowTechAir\", 0, FGameplayTag::EmptyTag);\n                        Enemy-&gt;InitEventHandler(EVT_Update, \"ThrowTechAir\", 0, FGameplayTag::EmptyTag);\n                    }\n                    ColPosX = (PosX + Enemy-&gt;PosX) / 2;\n                    ColPosY = (PosY + Enemy-&gt;PosY) / 2 + 250000;\n                    CreateCommonParticle(Particle_ThrowTech, POS_Col);\n                    return;\n                }\n            }\n        }\n        ActionTime++;\n        return;\n    }\n\n    if (CurrentHealth &lt;= 0 &amp;&amp; (PlayerFlags &amp; PLF_IsDead) == 0)\n    {\n        HandleBufferedState(PrimaryStateMachine);\n        for (auto&amp; StateMachine : SubStateMachines)\n        {\n            HandleBufferedState(StateMachine);\n        }\n\n        PlayerFlags |= PLF_IsDead;\n        RecoverableHealth = 0;\n        if (Enemy-&gt;CurrentHealth &gt; 0)\n        {\n            if (IsMainPlayer())\n            {\n                if (!(PlayerFlags &amp; PLF_DeathCamOverride))\n                {\n                    if (ReceivedHitCommon.AttackLevel &lt; 2)\n                    {\n                        AddCommonBattleObject(State_BattleObject_KO_S);\n                    }\n                    else if (ReceivedHitCommon.AttackLevel &lt; 4)\n                    {\n                        AddCommonBattleObject(State_BattleObject_KO_M);\n                    }\n                    else\n                    {\n                        AddCommonBattleObject(State_BattleObject_KO_L);\n                    }\n                    Hitstop = 1;\n                    AttackOwner-&gt;Hitstop = 1;\n                }\n            }\n        }\n        if (Enemy-&gt;CurrentHealth == 0 &amp;&amp; (Enemy-&gt;PlayerFlags &amp; PLF_IsDead) == 0)\n        {\n            AddCommonBattleObject(State_BattleObject_KO_Draw);\n            Hitstop = 1;\n            AttackOwner-&gt;Hitstop = 1;\n        }\n        else if (!IsMainPlayer())\n        {\n            PlayerFlags &amp;= ~PLF_IsOnScreen;\n        }\n    }\n\n    if (Hitstop &gt; 0)\n    {\n        if (PlayerFlags &amp; PLF_IsStunned)\n        {\n            HandleBufferedState(PrimaryStateMachine);\n\n            for (auto&amp; StateMachine : SubStateMachines)\n            {\n                HandleBufferedState(StateMachine);\n            }\n        }\n        GetBoxes();\n        if (!bIsCpu) StoredInputBuffer.Update(Inputs, IsStopped());\n        HandleStateMachine(true, PrimaryStateMachine); //handle state transitions\n        for (auto&amp; StateMachine : SubStateMachines)\n        {\n            HandleStateMachine(false, StateMachine);\n        }\n        return;\n    }\n\n    //reset moves used in combo if not currently doing combo \n    if (PrimaryStateMachine.CurrentState-&gt;StateType != EStateType::NormalAttack\n        &amp;&amp; PrimaryStateMachine.CurrentState-&gt;StateType != EStateType::SpecialAttack\n        &amp;&amp; PrimaryStateMachine.CurrentState-&gt;StateType != EStateType::SuperAttack)\n    {\n        MovesUsedInCombo.Empty();\n    }\n\n    if (!(AttackFlags &amp; ATK_IsAttacking)) //enable kara cancel when not attacking\n        CancelFlags |= CNC_EnableKaraCancel;\n\n    if (StrikeInvulnerableTimer &gt; 0)\n        StrikeInvulnerableTimer--;\n    if (ThrowInvulnerableTimer &gt; 0)\n        ThrowInvulnerableTimer--;\n    if (ThrowResistTimer &gt; 0)\n        ThrowResistTimer--;\n\n    if (MeterCooldownTimer &gt; 0)\n        MeterCooldownTimer--;\n\n    if (!bIsCpu)\n    {\n        if (IsMainPlayer() &amp;&amp; ((PlayerFlags &amp; PLF_RoundWinInputLock) == 0\n            || GameState-&gt;BattleState.BattleFormat == EBattleFormat::Tag))\n        {\n            StoredInputBuffer.Update(Inputs, IsStopped());\n        }\n        else StoredInputBuffer.Update(INP_Neutral, IsStopped());\n    }\n\n    if (AirDashTimer &gt; 0)\n    {\n        AirDashTimer--;\n    }\n    if (AirDashTimer == 1)\n    {\n        CallSubroutine(Subroutine_Cmn_AnyCancel_Air);\n        SpeedX /= 2;\n    }\n\n    if (AirDashNoAttackTime &gt; 0)\n        AirDashNoAttackTime--;\n    if (AirDashNoAttackTime == 1)\n        EnableAttacks();\n\n    if (StunTime &gt; 0)\n        StunTime--;\n    if (StunTime &lt;= 0 &amp;&amp; !(PlayerFlags &amp; PLF_IsDead) &amp;&amp; CheckIsStunned())\n    {\n        if (PrimaryStateMachine.CurrentState-&gt;StateType == EStateType::Blockstun)\n        {\n            if (Stance == ACT_Standing)\n            {\n                JumpToStatePrimary(State_Universal_StandBlockEnd);\n            }\n            else if (Stance == ACT_Crouching)\n            {\n                JumpToStatePrimary(State_Universal_CrouchBlockEnd);\n            }\n            else\n            {\n                JumpToStatePrimary(State_Universal_AirBlockEnd);\n            }\n        }\n        else if (PosY == GroundHeight &amp;&amp; PrevPosY == GroundHeight \n            &amp;&amp; GetCurrentStateName(StateMachine_Primary) != State_Universal_Crumple \n            &amp;&amp; GetCurrentStateName(StateMachine_Primary) != State_Universal_FaceDownLoop \n            &amp;&amp; GetCurrentStateName(StateMachine_Primary) != State_Universal_FaceUpLoop\n            &amp;&amp; GetCurrentStateName(StateMachine_Primary) != State_Universal_FaceDownWakeUp \n            &amp;&amp; GetCurrentStateName(StateMachine_Primary) != State_Universal_FaceUpWakeUp\n        &amp;&amp; !(PlayerFlags &amp; PLF_IsKnockedDown))\n        {\n            if (Stance == ACT_Crouching)\n            {\n                JumpToStatePrimary(State_Universal_Crouch);\n            }\n            else\n            {\n                JumpToStatePrimary(State_Universal_Stand);\n            }\n        }\n        else\n        {\n            if (((PlayerFlags &amp; PLF_IsKnockedDown) == 0 || (PlayerFlags &amp; PLF_IsHardKnockedDown) == 0) &amp;&amp; (PlayerFlags &amp;\n                PLF_IsDead) == 0)\n                EnableState(ENB_Tech, StateMachine_Primary);\n        }\n    }\n\n    if (PlayerFlags &amp; PLF_TouchingWall &amp;&amp; Enemy-&gt;PrimaryStateMachine.CurrentState-&gt;StateType != EStateType::Hitstun &amp;&amp;\n        Pushback != 0)\n    {\n        if (IsValid(AttackOwner))\n            AttackOwner-&gt;Pushback = Pushback;\n        Pushback = 0;\n    }\n\n    if (PrimaryStateMachine.CurrentState-&gt;StateType != EStateType::Hitstun)\n    {\n        PlayerFlags &amp;= ~PLF_IsKnockedDown;\n    }\n\n    if (PrimaryStateMachine.CurrentState-&gt;StateType != EStateType::Hitstun\n        &amp;&amp; PrimaryStateMachine.CurrentState-&gt;StateType != EStateType::Blockstun)\n    {\n        if (Enemy-&gt;PrimaryStateMachine.CurrentState-&gt;StateType != EStateType::Hitstun\n            &amp;&amp; Enemy-&gt;PrimaryStateMachine.CurrentState-&gt;StateType != EStateType::Blockstun)\n            Pushback = 0;\n    }\n\n    if ((GetCurrentStateName(StateMachine_Primary) == State_Universal_FaceDownLoop ||\n            GetCurrentStateName(StateMachine_Primary) == State_Universal_FaceUpLoop)\n        &amp;&amp; ActionTime &gt;= ReceivedHit.KnockdownTime &amp;&amp; (PlayerFlags &amp; PLF_IsDead) == 0)\n    {\n        HandleEndCombo();\n        if (PrimaryStateMachine.CurrentState-&gt;Name == State_Universal_FaceDownLoop)\n            JumpToStatePrimary(State_Universal_FaceDownWakeUp);\n        else if (PrimaryStateMachine.CurrentState-&gt;Name == State_Universal_FaceUpLoop)\n            JumpToStatePrimary(State_Universal_FaceUpWakeUp);\n        PlayerFlags &amp;= ~PLF_IsKnockedDown;\n        DisableState(ENB_Tech, StateMachine_Primary);\n    }\n\n    if (PlayerFlags &amp; PLF_IsDead)\n        DisableState(ENB_Tech, StateMachine_Primary);\n\n    InstantBlockLockoutTimer--;\n\n    HandleProximityBlock();\n\n    if (Stance == ACT_Standing) //set pushbox values based on stance\n    {\n        PushWidth = StandPushWidth;\n        PushHeight = StandPushHeight;\n        PushHeightLow = 0;\n    }\n    else if (Stance == ACT_Crouching)\n    {\n        PushWidth = CrouchPushWidth;\n        PushHeight = CrouchPushHeight;\n        PushHeightLow = 0;\n    }\n    else if (Stance == ACT_Jumping)\n    {\n        PushWidth = AirPushWidth;\n        PushHeight = AirPushHeight;\n        PushHeightLow = AirPushHeightLow;\n    }\n\n    HandleLanding();\n    Move();\n    HandleLanding();\n\n    Player-&gt;PrimaryStateMachine.Update();\n    for (auto&amp; StateMachine : SubStateMachines)\n    {\n        StateMachine.Update();\n    }\n\n    TriggerEvent(EVT_Update, StateMachine_Primary);\n\n    if (PrimaryStateMachine.CurrentState-&gt;StateType == EStateType::Hitstun)\n    {\n        if (GetCurrentStateName(StateMachine_Primary) == State_Universal_FaceDownBounce\n            || GetCurrentStateName(StateMachine_Primary) == State_Universal_FaceUpBounce)\n        {\n            if (ReceivedHit.GroundBounce.GroundBounceCount &gt; 0) HandleGroundBounce();\n        }\n    }\n\n    for (auto&amp; Gauge : ExtraGauges)\n    {\n        Gauge.Value = FMath::Clamp(Gauge.Value, 0, Gauge.MaxValue);\n    }\n\n    if (TimeUntilNextCel &gt; 0)\n        TimeUntilNextCel--;\n    if (TimeUntilNextCel == 0)\n        CelIndex++;\n\n    if (PrimaryStateMachine.CurrentState-&gt;StateType == EStateType::Hitstun &amp;&amp; ReceivedHit.WallBounce.WallBounceCount &gt; 0\n        &amp;&amp; PosY &gt; GroundHeight)\n        HandleWallBounce();\n\n    if (PosY &gt; GroundHeight) //set jumping if above ground\n        Stance = ACT_Jumping;\n\n    HandleStateMachine(true, PrimaryStateMachine);\n    HandleBufferedState(PrimaryStateMachine);\n    for (auto&amp; StateMachine : SubStateMachines)\n    {\n        HandleStateMachine(false, StateMachine);\n        HandleBufferedState(StateMachine);\n    }\n\n    GetBoxes();\n\n    HandleThrowCollision();\n\n    if (CurrentHealth &gt; MaxHealth) CurrentHealth = MaxHealth;\n\n    ActionTime++;\n}\n\nvoid APlayerObject::UpdateNotBattle()\n{\n    Player-&gt;PrimaryStateMachine.Update();\n\n    if (TimeUntilNextCel &gt; 0)\n        TimeUntilNextCel--;\n    if (TimeUntilNextCel == 0)\n        CelIndex++;\n    GetBoxes();\n\n    UpdateVisuals();\n    UpdateVisualsNoRollback();\n}\n\nvoid APlayerObject::EditorUpdate_Implementation()\n{\n    Player = this;\n\n    GetBoxes();\n    UpdateVisuals();\n    UpdateVisualsNoRollback();\n}\n\nvoid APlayerObject::HandleHitAction(EHitAction HACT)\n{\n    int32 FinalHitstop = ReceivedHit.Hitstop + ReceivedHit.EnemyHitstopModifier;\n\n    Hitstop = FinalHitstop;\n\n    int32 Proration = ReceivedHit.ForcedProration;\n    if (Enemy-&gt;ComboCounter == 0)\n        Proration *= ReceivedHit.InitialProration;\n    else\n        Proration *= 100;\n    if (Enemy-&gt;ComboCounter == 0)\n        TotalProration = 10000;\n    Proration = Proration * TotalProration / 10000;\n\n    if ((AttackFlags &amp; ATK_ProrateOnce) == 0 || (AttackFlags &amp; ATK_ProrateOnce &amp;&amp; Enemy-&gt;ComboCounter == 0))\n        TotalProration = Proration;\n    else\n        Proration = TotalProration;\n\n    Enemy-&gt;ComboCounter++;\n\n    if (ReceivedHitCommon.DeathCamOverride)\n        PlayerFlags |= PLF_DeathCamOverride;\n\n    else\n        PlayerFlags &amp;= ~PLF_DeathCamOverride;\n\n    if (PlayerFlags &amp; PLF_IsKnockedDown)\n    {\n        if (PosY &lt;= GroundHeight)\n            PosY = GroundHeight + 1;\n\n        if (!(AttackOwner-&gt;AttackFlags &amp; ATK_IgnoreOTG))\n            OTGCount++;\n        PlayerFlags &amp;= ~PLF_IsKnockedDown;\n    }\n    else if (PlayerFlags &amp; PLF_IsDead &amp;&amp; PosY &lt;= GroundHeight)\n    {\n        PosY = GroundHeight + 1;\n    }\n\n    int FinalDamage;\n    if (Enemy-&gt;ComboCounter == 1)\n        FinalDamage = ReceivedHit.Damage;\n    else\n        FinalDamage = ReceivedHit.Damage * Proration * Enemy-&gt;ComboRate / 10000 / 100;\n\n    if (FinalDamage &lt; ReceivedHit.MinimumDamagePercent * ReceivedHit.Damage / 100)\n        FinalDamage = ReceivedHit.Damage * ReceivedHit.MinimumDamagePercent / 100;\n\n    if (MaxOTGCount &gt;= 0 &amp;&amp; OTGCount &gt; MaxOTGCount &amp;&amp; !(AttackOwner-&gt;AttackFlags &amp; ATK_IgnoreOTG))\n        FinalDamage = FinalDamage * OtgProration / 100;\n\n    CurrentHealth -= FinalDamage;\n    if (CurrentHealth &gt; 0)\n    {\n        if (IsMainPlayer())\n        {\n            RecoverableHealth += FinalDamage * ReceivedHit.RecoverableDamagePercent / 100;\n        }\n        else\n        {\n            RecoverableHealth += FinalDamage;\n        }\n    }\n    else\n    {\n        if (!(PlayerFlags &amp; PLF_IsDead))\n        {\n            Enemy-&gt;TriggerEvent(EVT_Kill, StateMachine_Primary);\n            if (IsMainPlayer())\n            {\n                Enemy-&gt;TriggerEvent(EVT_KillMainPlayer, StateMachine_Primary);\n            }\n            else\n            {\n                if (PlayerIndex == 0)\n                {\n                    GameState-&gt;BattleState.P2RoundsWon++;\n                }\n                else\n                {\n                    GameState-&gt;BattleState.P1RoundsWon++;\n                }\n            }\n        }\n    }\n\n    if (GameState-&gt;GameInstance-&gt;IsTraining &amp;&amp; CurrentHealth &lt; 1)\n        CurrentHealth = 1;\n\n    AddMeter(FinalDamage * MeterPercentOnReceiveHit / 100);\n    Enemy-&gt;AddMeter(FinalDamage * Enemy-&gt;MeterPercentOnHit / 100);\n\n    EnableCancelIntoSelf(true);\n\n    switch (ReceivedHit.Position.Type)\n    {\n    case HPT_Rel:\n        {\n            PosX = Enemy-&gt;PosX;\n            PosY = Enemy-&gt;PosY;\n            Direction = Enemy-&gt;Direction == DIR_Right ? DIR_Left : DIR_Right;\n            if (PlayerFlags &amp; PLF_TouchingWall)\n            {\n                Enemy-&gt;AddPosXWithDir(-ReceivedHit.Position.PosX);\n            }\n            else\n            {\n                AddPosXWithDir(-ReceivedHit.Position.PosX);\n            }\n            PosY += ReceivedHit.Position.PosY;\n            if (PosY &lt; GroundHeight)\n                PosY = GroundHeight;\n        }\n        break;\n    case HPT_Abs:\n        {\n            PosX = ReceivedHit.Position.PosX;\n            PosY = ReceivedHit.Position.PosY;\n        }\n        break;\n    case HPT_Add:\n        {\n            if (PlayerFlags &amp; PLF_TouchingWall)\n            {\n                Enemy-&gt;AddPosXWithDir(-ReceivedHit.Position.PosX);\n            }\n            else\n            {\n                AddPosXWithDir(-ReceivedHit.Position.PosX);\n            }\n            PosY += ReceivedHit.Position.PosY;\n            if (PosY &lt; GroundHeight)\n                PosY = GroundHeight;\n        }\n        break;\n    default:\n        break;\n    }\n\n    for (int i = GameState-&gt;Players.Num(); i &lt; GameState-&gt;BattleState.ActiveObjectCount; i++)\n    {\n        if (GameState-&gt;SortedObjects[i]-&gt;Player == this &amp;&amp; GameState-&gt;SortedObjects[i]-&gt;MiscFlags &amp;\n            MISC_DeactivateOnReceiveHit)\n            GameState-&gt;SortedObjects[i]-&gt;DeactivateObject();\n    }\n    if (CurrentHealth &lt;= 0)\n    {\n        CurrentHealth = 0;\n\n        if (ReceivedHit.CustomHitAction != FGameplayTag::EmptyTag)\n        {\n            BufferedStateName = ReceivedHit.CustomHitAction;\n        }\n        else if (PosY &lt;= GroundHeight &amp;&amp; !(PlayerFlags &amp; PLF_IsKnockedDown))\n        {\n            if (HACT == HACT_AirVertical)\n                BufferedStateName = State_Universal_Launch_V;\n            else if (HACT == HACT_AirFaceDown)\n                BufferedStateName = State_Universal_Launch_F;\n            else if (HACT == HACT_Blowback)\n                BufferedStateName = State_Universal_Blowback;\n            else if (HACT == HACT_Tailspin)\n                BufferedStateName = State_Universal_Tailspin;\n            else if (HACT == HACT_Custom)\n            {\n                BufferedStateName = ReceivedHit.CustomHitAction;\n            }\n            else if (!(PlayerFlags &amp; PLF_IsDead))\n            {\n                BufferedStateName = State_Universal_Crumple;\n            }\n            else\n            {\n                BufferedStateName = State_Universal_Launch_B;\n            }\n        }\n        else\n        {\n            if (PosY &lt;= GroundHeight)\n                PosY = GroundHeight + 1;\n            if (HACT == HACT_AirFaceUp || HACT == HACT_AirNormal)\n                BufferedStateName = State_Universal_Launch_B;\n            else if (HACT == HACT_AirVertical)\n                BufferedStateName = State_Universal_Launch_V;\n            else if (HACT == HACT_AirFaceDown)\n                BufferedStateName = State_Universal_Launch_F;\n            else if (HACT == HACT_Blowback)\n                BufferedStateName = State_Universal_Blowback;\n            else if (HACT == HACT_Tailspin)\n                BufferedStateName = State_Universal_Tailspin;\n            else if (HACT == HACT_Custom)\n                BufferedStateName = ReceivedHit.CustomHitAction;\n            else\n                BufferedStateName = State_Universal_Launch_B;\n        }\n        return;\n    }\n    if (bLimitCrumple &amp;&amp; bCrumpled &amp;&amp; HACT == HACT_Crumple)\n    {\n        HACT = HACT_AirNormal;\n    }\n    switch (HACT)\n    {\n    case HACT_GroundNormal:\n        switch (Stance)\n        {\n        case ACT_Standing:\n        default:\n            if (ReceivedHitCommon.AttackLevel == 0)\n                BufferedStateName = FGameplayTag(State_Universal_Hitstun_0);\n            else if (ReceivedHitCommon.AttackLevel == 1)\n                BufferedStateName = FGameplayTag(State_Universal_Hitstun_1);\n            else if (ReceivedHitCommon.AttackLevel == 2)\n                BufferedStateName = FGameplayTag(State_Universal_Hitstun_2);\n            else if (ReceivedHitCommon.AttackLevel == 3)\n                BufferedStateName = FGameplayTag(State_Universal_Hitstun_3);\n            else if (ReceivedHitCommon.AttackLevel == 4)\n                BufferedStateName = FGameplayTag(State_Universal_Hitstun_4);\n            else if (ReceivedHitCommon.AttackLevel == 5)\n                BufferedStateName = FGameplayTag(State_Universal_Hitstun_5);\n            break;\n        case ACT_Crouching:\n            if (ReceivedHitCommon.AttackLevel == 0)\n                BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_0);\n            else if (ReceivedHitCommon.AttackLevel == 1)\n                BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_1);\n            else if (ReceivedHitCommon.AttackLevel == 2)\n                BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_2);\n            else if (ReceivedHitCommon.AttackLevel == 3)\n                BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_3);\n            else if (ReceivedHitCommon.AttackLevel == 4)\n                BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_4);\n            else if (ReceivedHitCommon.AttackLevel == 5)\n                BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_5);\n            StunTime += 1;\n            StunTimeMax += 1;\n        }\n        break;\n    case HACT_Crumple:\n        BufferedStateName = FGameplayTag(State_Universal_Crumple);\n        break;\n    case HACT_ForceCrouch:\n        Stance = ACT_Crouching;\n        if (ReceivedHitCommon.AttackLevel == 0)\n            BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_0);\n        else if (ReceivedHitCommon.AttackLevel == 1)\n            BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_1);\n        else if (ReceivedHitCommon.AttackLevel == 2)\n            BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_2);\n        else if (ReceivedHitCommon.AttackLevel == 3)\n            BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_3);\n        else if (ReceivedHitCommon.AttackLevel == 4)\n            BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_4);\n        else if (ReceivedHitCommon.AttackLevel == 5)\n            BufferedStateName = FGameplayTag(State_Universal_CrouchHitstun_5);\n        StunTime += 1;\n        StunTimeMax += 1;\n        break;\n    case HACT_ForceStand:\n        Stance = ACT_Standing;\n        if (ReceivedHitCommon.AttackLevel == 0)\n            BufferedStateName = FGameplayTag(State_Universal_Hitstun_0);\n        else if (ReceivedHitCommon.AttackLevel == 1)\n            BufferedStateName = FGameplayTag(State_Universal_Hitstun_1);\n        else if (ReceivedHitCommon.AttackLevel == 2)\n            BufferedStateName = FGameplayTag(State_Universal_Hitstun_2);\n        else if (ReceivedHitCommon.AttackLevel == 3)\n            BufferedStateName = FGameplayTag(State_Universal_Hitstun_3);\n        else if (ReceivedHitCommon.AttackLevel == 4)\n            BufferedStateName = FGameplayTag(State_Universal_Hitstun_4);\n        else if (ReceivedHitCommon.AttackLevel == 5)\n            BufferedStateName = FGameplayTag(State_Universal_Hitstun_5);\n        break;\n    case HACT_GuardBreakCrouch:\n        BufferedStateName = State_Universal_GuardBreakCrouch;\n        break;\n    case HACT_GuardBreakStand:\n        BufferedStateName = State_Universal_GuardBreakStand;\n        break;\n    case HACT_AirNormal:\n    case HACT_AirFaceUp:\n        BufferedStateName = State_Universal_Launch_B;\n        break;\n    case HACT_AirVertical:\n        BufferedStateName = State_Universal_Launch_V;\n        break;\n    case HACT_AirFaceDown:\n        BufferedStateName = State_Universal_Launch_F;\n        break;\n    case HACT_Blowback:\n        BufferedStateName = State_Universal_Blowback;\n        break;\n    case HACT_Tailspin:\n        BufferedStateName = State_Universal_Tailspin;\n        break;\n    case HACT_FloatingCrumple:\n        if (ReceivedHit.FloatingCrumpleType == FLT_Body)\n            BufferedStateName = State_Universal_FloatingCrumpleBody;\n        else\n            BufferedStateName = State_Universal_FloatingCrumpleHead;\n        break;\n    case HACT_Custom:\n        BufferedStateName = ReceivedHit.CustomHitAction;\n    case HACT_None: break;\n    default: ;\n    }\n    DisableAll(StateMachine_Primary);\n}\n\nvoid APlayerObject::SetHitValuesOverTime()\n{\n    if (PrimaryStateMachine.CurrentState-&gt;StateType == EStateType::Hitstun &amp;&amp; PosY &gt; GroundHeight\n        &amp;&amp; GetCurrentStateName(StateMachine_Primary) != State_Universal_FloatingCrumpleBody &amp;&amp; GetCurrentStateName(\n            StateMachine_Primary) !=\n        State_Universal_FloatingCrumpleHead)\n    {\n        const int32 CurrentStunTime = StunTimeMax - StunTime;\n        if (ReceivedHit.AirPushbackXOverTime.BeginFrame &lt;= CurrentStunTime\n            &amp;&amp; ReceivedHit.AirPushbackXOverTime.EndFrame &gt; CurrentStunTime)\n        {\n            SpeedX = SpeedX * ReceivedHit.AirPushbackXOverTime.Value / 100;\n        }\n        if (ReceivedHit.AirPushbackYOverTime.BeginFrame &lt;= CurrentStunTime\n            &amp;&amp; ReceivedHit.AirPushbackYOverTime.EndFrame &gt; CurrentStunTime\n            &amp;&amp; SpeedY &gt; 0)\n        {\n            SpeedY = SpeedY * ReceivedHit.AirPushbackYOverTime.Value / 100;\n        }\n        if (ReceivedHit.GravityOverTime.BeginFrame &lt;= CurrentStunTime\n            &amp;&amp; ReceivedHit.GravityOverTime.EndFrame &gt; CurrentStunTime)\n        {\n            Gravity += ReceivedHit.GravityOverTime.Value;\n        }\n    }\n}\n\nvoid APlayerObject::SetHitValues(bool bCustomAir)\n{\n    if (!GameState) return;\n    if (!Enemy-&gt;CheckIsStunned() &amp;&amp; Enemy == AttackOwner)\n        GameState-&gt;SetDrawPriorityFront(Enemy);\n\n    DamageColor = ReceivedHitCommon.DamageColor;\n    DamageColor2 = ReceivedHitCommon.DamageColor2;\n\n    int32 FinalHitPushbackX;\n    int32 FinalAirHitPushbackX;\n    int32 FinalAirHitPushbackY;\n    int32 FinalGravity;\n\n    if (!(AttackOwner-&gt;AttackFlags &amp; ATK_IgnorePushbackScaling))\n    {\n        FinalHitPushbackX = ReceivedHit.GroundPushbackX + MovesUsedInCombo.Num() * 500;\n        FinalAirHitPushbackX = ReceivedHit.AirPushbackX + MovesUsedInCombo.Num() * 150;\n        FinalAirHitPushbackY = ReceivedHit.AirPushbackY - MovesUsedInCombo.Num() * 150;\n        FinalGravity = ReceivedHit.Gravity + MovesUsedInCombo.Num() * 10;\n    }\n    else\n    {\n        FinalHitPushbackX = ReceivedHit.GroundPushbackX;\n        FinalAirHitPushbackX = ReceivedHit.AirPushbackX;\n        FinalAirHitPushbackY = ReceivedHit.AirPushbackY;\n        FinalGravity = ReceivedHit.Gravity;\n    }\n\n    EHitAction HACT;\n\n    if (PosY == GroundHeight &amp;&amp; !(PlayerFlags &amp; PLF_IsKnockedDown))\n        HACT = ReceivedHit.GroundHitAction;\n    else\n        HACT = ReceivedHit.AirHitAction;\n\n    Pushback = -FinalHitPushbackX;\n\n    switch (ReceivedHit.Position.Type)\n    {\n    case HPT_RelNextFrame:\n        {\n            PosX = Enemy-&gt;PosX;\n            PosY = Enemy-&gt;PosY;\n            Direction = Enemy-&gt;Direction == DIR_Right ? DIR_Left : DIR_Right;\n            if (PlayerFlags &amp; PLF_TouchingWall)\n            {\n                Enemy-&gt;AddPosXWithDir(-ReceivedHit.Position.PosX);\n            }\n            else\n            {\n                AddPosXWithDir(-ReceivedHit.Position.PosX);\n            }\n            PosY += ReceivedHit.Position.PosY;\n            if (PosY &lt; GroundHeight)\n                PosY = GroundHeight;\n        }\n        break;\n    case HPT_AbsNextFrame:\n        {\n            PosX = ReceivedHit.Position.PosX;\n            PosY = ReceivedHit.Position.PosY;\n        }\n        break;\n    case HPT_AddNextFrame:\n        {\n            if (PlayerFlags &amp; PLF_TouchingWall)\n            {\n                Enemy-&gt;AddPosXWithDir(-ReceivedHit.Position.PosX);\n            }\n            else\n            {\n                AddPosXWithDir(-ReceivedHit.Position.PosX);\n            }\n            PosY += ReceivedHit.Position.PosY;\n            if (PosY &lt; GroundHeight)\n                PosY = GroundHeight;\n        }\n        break;\n    default:\n        break;\n    }\n\n    int32 FinalHitstun = ReceivedHit.Hitstun;\n    int32 FinalUntech = ReceivedHit.Untech;\n    if (!(AttackOwner-&gt;AttackFlags &amp; ATK_IgnoreHitstunScaling))\n    {\n        if (Enemy-&gt;ComboTimer &gt;= 14 * 60)\n        {\n            FinalHitstun = FinalHitstun * 50 / 100;\n            FinalUntech = FinalUntech * 50 / 100;\n        }\n        else if (Enemy-&gt;ComboTimer &gt;= 12 * 60)\n        {\n            FinalHitstun = FinalHitstun * 80 / 100;\n            FinalUntech = FinalUntech * 70 / 100;\n        }\n        else if (Enemy-&gt;ComboTimer &gt;= 10 * 60)\n        {\n            FinalHitstun = FinalHitstun * 90 / 100;\n            FinalUntech = FinalUntech * 80 / 100;\n        }\n        else if (Enemy-&gt;ComboTimer &gt;= 7 * 60)\n        {\n            FinalUntech = FinalUntech * 85 / 100;\n        }\n        else if (Enemy-&gt;ComboTimer &gt;= 5 * 60)\n        {\n            FinalUntech = FinalUntech * 90 / 100;\n        }\n    }\n    if (FinalHitstun &lt; 1) FinalHitstun = 1;\n    if (FinalUntech &lt; 1) FinalUntech = 1;\n\n    if (bLimitCrumple &amp;&amp; bCrumpled &amp;&amp; HACT == HACT_Crumple)\n    {\n        HACT = HACT_AirNormal;\n    }\n    switch (HACT)\n    {\n    case HACT_GroundNormal:\n    case HACT_ForceCrouch:\n    case HACT_ForceStand:\n    default:\n        StunTime = FinalHitstun;\n        StunTimeMax = FinalHitstun;\n        if (PlayerFlags &amp; PLF_TouchingWall &amp;&amp; FinalHitPushbackX != INT_MAX)\n        {\n            AttackOwner-&gt;Pushback = -FinalHitPushbackX;\n            Pushback = 0;\n        }\n        break;\n    case HACT_FloatingCrumple:\n        if (CurrentHealth &lt;= 0)\n        {\n            if (PosY &lt;= GroundHeight)\n                PosY = GroundHeight + 1;\n            StunTime = FinalUntech;\n            StunTimeMax = FinalUntech;\n            SpeedX = -FinalAirHitPushbackX;\n            SpeedY = FinalAirHitPushbackY;\n            Gravity = FinalGravity;\n            if (PlayerFlags &amp; PLF_TouchingWall &amp;&amp; FinalHitPushbackX != INT_MAX)\n            {\n                AttackOwner-&gt;Pushback = -FinalHitPushbackX;\n                Pushback = 0;\n            }\n            break;\n        }\n        StunTime = FinalUntech;\n        StunTimeMax = FinalUntech;\n        if (PlayerFlags &amp; PLF_TouchingWall &amp;&amp; FinalHitPushbackX != INT_MAX)\n        {\n            AttackOwner-&gt;Pushback = -FinalHitPushbackX;\n            Pushback = 0;\n        }\n        break;\n    case HACT_AirNormal:\n    case HACT_AirFaceUp:\n    case HACT_AirVertical:\n    case HACT_AirFaceDown:\n    case HACT_Tailspin:\n        if (PosY &lt;= GroundHeight)\n            PosY = GroundHeight + 1;\n        StunTime = FinalUntech;\n        StunTimeMax = FinalUntech;\n        SpeedX = -FinalAirHitPushbackX;\n        SpeedY = FinalAirHitPushbackY;\n        Gravity = FinalGravity;\n        if (PlayerFlags &amp; PLF_TouchingWall &amp;&amp; FinalHitPushbackX != INT_MAX)\n        {\n            AttackOwner-&gt;Pushback = -FinalHitPushbackX;\n            Pushback = 0;\n        }\n        break;\n    case HACT_Crumple:\n        StunTime = FinalUntech;\n        StunTimeMax = FinalUntech;\n        if (PlayerFlags &amp; PLF_TouchingWall &amp;&amp; FinalHitPushbackX != INT_MAX)\n        {\n            AttackOwner-&gt;Pushback = -FinalHitPushbackX;\n            Pushback = 0;\n        }\n        bCrumpled = true;\n        break;\n    case HACT_Blowback:\n        switch (ReceivedHit.BlowbackLevel)\n        {\n        case 0:\n        default:\n            break;\n        case 1:\n            GotoLabel(State_Label_Blowback_1);\n            break;\n        case 2:\n            GotoLabel(State_Label_Blowback_2);\n            break;\n        case 3:\n            GotoLabel(State_Label_Blowback_3);\n            break;\n        case 4:\n            GotoLabel(State_Label_Blowback_4);\n            break;\n        }\n        if (PosY &lt;= GroundHeight)\n            PosY = GroundHeight + 1;\n        StunTime = FinalUntech;\n        StunTimeMax = FinalUntech;\n        SpeedX = -FinalAirHitPushbackX;\n        SpeedY = FinalAirHitPushbackY;\n        Gravity = FinalGravity;\n        if (PlayerFlags &amp; PLF_TouchingWall &amp;&amp; FinalHitPushbackX != INT_MAX)\n        {\n            AttackOwner-&gt;Pushback = -FinalHitPushbackX;\n            Pushback = 0;\n        }\n    case HACT_Custom:\n        if (bCustomAir)\n        {\n            if (PosY &lt;= GroundHeight)\n                PosY = GroundHeight + 1;\n            StunTime = FinalUntech;\n            StunTimeMax = FinalUntech;\n            SpeedX = -FinalAirHitPushbackX;\n            SpeedY = FinalAirHitPushbackY;\n            Gravity = FinalGravity;\n        }           \n        else\n        {\n            StunTime = FinalHitstun;\n            StunTimeMax = FinalHitstun;\n        }\n        if (PlayerFlags &amp; PLF_TouchingWall &amp;&amp; FinalHitPushbackX != INT_MAX)\n        {\n            AttackOwner-&gt;Pushback = -FinalHitPushbackX;\n            Pushback = 0;\n        }\n        break;\n    }\n    AirDashTimer = 0;\n    AirDashNoAttackTime = 0;\n\n    if (ReceivedHit.HardKnockdown)\n        PlayerFlags |= PLF_IsHardKnockedDown;\n    else\n        PlayerFlags &amp;= ~PLF_IsHardKnockedDown;\n\n    if (MaxOTGCount &gt;= 0 &amp;&amp; OTGCount &gt; MaxOTGCount &amp;&amp; !(AttackOwner-&gt;AttackFlags &amp; ATK_IgnoreOTG))\n    {\n        SpeedX = -30000;\n        SpeedY = 8000;\n        Gravity = 3500;\n        StunTime = 5;\n        ReceivedHit.AirPushbackXOverTime = FHitValueOverTime();\n        ReceivedHit.AirPushbackYOverTime = FHitValueOverTime();\n        ReceivedHit.GravityOverTime = FHitValueOverTime();\n        ReceivedHit.KnockdownTime = 0;\n        PlayerFlags &amp;= ~PLF_IsHardKnockedDown;\n    }\n}\n\nvoid APlayerObject::SetGuardValues()\n{\n    if (StunTime &lt;= 0) return;\n    Pushback = -ReceivedHitCommon.GroundGuardPushbackX;\n    SpeedX = 0;\n    if (PlayerFlags &amp; PLF_TouchingWall)\n    {\n        AttackOwner-&gt;Pushback = -ReceivedHitCommon.GroundGuardPushbackX;\n        Pushback = 0;\n    }\n    if (Stance == ACT_Jumping)\n    {\n        SpeedX = -ReceivedHitCommon.AirGuardPushbackX;\n        SpeedY = ReceivedHitCommon.AirGuardPushbackY;\n        Gravity = ReceivedHitCommon.GuardGravity;\n    }\n}\n\nvoid APlayerObject::ForceEnableFarNormal(bool Enable)\n{\n    if (Enable)\n    {\n        PlayerFlags |= PLF_ForceEnableFarNormal;\n    }\n    else\n    {\n        PlayerFlags &amp;= ~PLF_ForceEnableFarNormal;\n    }\n}\n\nvoid APlayerObject::SetHeadAttribute(bool Attribute)\n{\n    if (Attribute)\n        AttackFlags |= ATK_AttackHeadAttribute;\n    else\n        AttackFlags &amp;= ~ATK_AttackHeadAttribute;\n}\n\nvoid APlayerObject::SetThrowActive(bool Active)\n{\n    if (Active)\n    {\n        PlayerFlags |= PLF_ThrowActive;\n    }\n    else\n    {\n        PlayerFlags &amp;= ~PLF_ThrowActive;\n    }\n}\n\nvoid APlayerObject::ThrowEnd()\n{\n    if (!Enemy) return;\n    Enemy-&gt;PlayerFlags &amp;= ~PLF_IsThrowLock;\n}\n\nvoid APlayerObject::SetThrowRange(int32 InThrowRange)\n{\n    ThrowRange = InThrowRange;\n}\n\nvoid APlayerObject::SetThrowExeState(FGameplayTag ExeState)\n{\n    ExeStateName = ExeState;\n}\n\nvoid APlayerObject::SetThrowPosition(int32 ThrowPosX, int32 ThrowPosY)\n{\n    if (!Enemy) return;\n    if (!(Enemy-&gt;PlayerFlags &amp; PLF_IsThrowLock)) return;\n\n    if (Direction == DIR_Right)\n        Enemy-&gt;PosX = R + ThrowPosX;\n    else\n        Enemy-&gt;PosX = L - ThrowPosX;\n    Enemy-&gt;PosY = PosY + ThrowPosY;\n}\n\nvoid APlayerObject::SetDamageReactionCel(FGameplayTag Type)\n{\n    if (!Enemy) return;\n    if (!(Enemy-&gt;PlayerFlags &amp; PLF_IsThrowLock)) return;\n\n    if (Enemy-&gt;DamageReactionCels.Contains(Type))\n    {\n        Enemy-&gt;SetCelName(Enemy-&gt;DamageReactionCels[Type]);\n        Enemy-&gt;GetBoxes();\n    }\n}\n\nvoid APlayerObject::SetHitgrabActive(bool Active)\n{\n    if (Active)\n    {\n        PlayerFlags |= PLF_HitgrabActive;\n    }\n    else\n    {\n        PlayerFlags &amp;= ~PLF_HitgrabActive;\n    }\n}\n\nvoid APlayerObject::PlayVoiceLine(FGameplayTag Name)\n{\n    if (!IsValid(GameState))\n        return;\n    if (VoiceData != nullptr)\n    {\n        for (FSoundStruct SoundStruct : VoiceData-&gt;SoundDatas)\n        {\n            if (SoundStruct.Name == Name)\n            {\n                GameState-&gt;PlayVoiceLine(SoundStruct.SoundWave, SoundStruct.MaxDuration, ObjNumber - 400);\n                break;\n            }\n        }\n    }\n}\n\nvoid APlayerObject::PlayCommonLevelSequence(FGameplayTag Name)\n{\n    if (!GameState) return;\n    if (CommonSequenceData != nullptr)\n    {\n        for (FSequenceStruct SequenceStruct : CommonSequenceData-&gt;SequenceStructs)\n        {\n            if (SequenceStruct.Name == Name)\n            {\n                GameState-&gt;PlayLevelSequence(this, Enemy, SequenceStruct.Sequence);\n            }\n        }\n    }\n}\n\nvoid APlayerObject::PlayLevelSequence(FGameplayTag Name)\n{\n    if (!GameState) return;\n    if (SequenceData != nullptr)\n    {\n        for (FSequenceStruct SequenceStruct : SequenceData-&gt;SequenceStructs)\n        {\n            if (SequenceStruct.Name == Name)\n            {\n                GameState-&gt;PlayLevelSequence(this, Enemy, SequenceStruct.Sequence);\n            }\n        }\n    }\n}\n\nvoid APlayerObject::StopLevelSequence()\n{\n    if (!GameState) return;\n    GameState-&gt;StopLevelSequence();\n}\n\nvoid APlayerObject::BattleHudVisibility(bool Visible)\n{\n    if (!GameState) return;\n    GameState-&gt;BattleHudVisibility(Visible);\n}\n\nvoid APlayerObject::EndRound() const\n{\n    if (!GameState) return;\n    GameState-&gt;RoundInit();\n}\n\nvoid APlayerObject::EndMatch() const\n{\n    if (!GameState) return;\n    GameState-&gt;EndMatch_BP();\n}\n\nvoid APlayerObject::PauseRoundTimer(bool Pause)\n{\n    if (!GameState) return;\n    GameState-&gt;BattleState.PauseTimer = Pause;\n}\n\nvoid APlayerObject::AddBattleObjectToStorage(ABattleObject* InActor, int Index)\n{\n    if (Index &lt; 16)\n    {\n        StoredBattleObjects[Index] = InActor;\n    }\n}\n\nAPlayerObject* APlayerObject::CallAssist(const int AssistIndex, const FGameplayTag AssistName)\n{\n    if (!GameState) return nullptr;\n    return GameState-&gt;CallAssist(PlayerIndex == 0, AssistIndex, AssistName);\n}\n\nAPlayerObject* APlayerObject::SwitchMainPlayer(int NewTeamIndex, bool bForce, bool bEvenOnScreen)\n{\n    if (!GameState) return nullptr;\n    return GameState-&gt;SwitchMainPlayer(this, NewTeamIndex, bForce, bEvenOnScreen);\n}\n\nvoid APlayerObject::SetTeamCooldown(int NewTeamIndex, int Cooldown)\n{\n    if (!GameState) return;\n    return GameState-&gt;SetTeamCooldown(PlayerIndex == 0, NewTeamIndex, Cooldown);\n}\n\nbool APlayerObject::IsMainPlayer() const\n{\n    if (!GameState) return true;\n    return this == GameState-&gt;GetMainPlayer(PlayerIndex == 0);\n}\n\nbool APlayerObject::IsOnScreen() const\n{\n    return (PlayerFlags &amp; PLF_IsOnScreen) == PLF_IsOnScreen;\n}\n\nvoid APlayerObject::SetOnScreen(bool OnScreen)\n{\n    if (OnScreen)\n        PlayerFlags |= PLF_IsOnScreen;\n    else\n        PlayerFlags &amp;= ~PLF_IsOnScreen;\n}\n\nvoid APlayerObject::ToggleComponentVisibility(FName ComponentName, bool Visible)\n{\n    TInlineComponentArray&lt;UPrimitiveComponent*&gt; Components;\n    GetComponents(Components);\n    for (int i = 0; i &lt; Components.Num(); i++)\n    {\n        if (const auto Component = Components[i]; Component-&gt;GetName() == ComponentName)\n        {\n            ComponentVisible[i] = Visible;\n        }\n    }\n}\n\nbool APlayerObject::CanEnterState(UState* State, FGameplayTag StateMachineName)\n{\n    FStateMachine&amp; StateMachine = GetStateMachine(StateMachineName);\n    const FGameplayTag MoveChainName = State-&gt;ShareChainName != FGameplayTag::EmptyTag\n                                           ? State-&gt;ShareChainName\n                                           : State-&gt;Name;\n    if (!CheckMovesUsedInChain(MoveChainName, StateMachine) ||\n        !((CheckStateEnabled(State-&gt;StateType, State-&gt;CustomStateType, StateMachineName) &amp;&amp; !State-&gt;IsFollowupState)\n            || FindChainCancelOption(State-&gt;Name, StateMachine)\n            || FindAutoComboCancelOption(State-&gt;Name, StateMachine)\n            || FindWhiffCancelOption(State-&gt;Name, StateMachine)\n            || (CheckKaraCancel(State-&gt;StateType, StateMachine)\n                &amp;&amp; !State-&gt;IsFollowupState\n                &amp;&amp; StateMachine.GetStateIndex(State-&gt;Name) &gt; StateMachine.GetStateIndex(GetStateEntryName()))\n        )) //check if the state is enabled\n    {\n        return false;\n    }\n    if (CheckObjectPreventingState(State-&gt;ObjectID)) //check if an object is preventing state entry\n    {\n        return false;\n    }\n    //check current character state against entry stance condition\n    if (!StateMachine.CheckStateStanceCondition(State-&gt;EntryStance, Stance))\n    {\n        return false;\n    }\n    if (State-&gt;StateConditions.Num() != 0) //only check state conditions if there are any\n    {\n        for (int j = 0; j &lt; State-&gt;StateConditions.Num(); j++) //iterate over state conditions\n        {\n            if (!HandleStateCondition(State-&gt;StateConditions[j])) //check state condition\n            {\n                return false;\n            }\n        }\n    }\n    if (!State-&gt;CanEnterState()) //check bp state condition\n    {\n        return false;\n    }\n\n    return true;\n}\n\nvoid APlayerObject::SetStateForCPU(FGameplayTag StateName, FGameplayTag StateMachineName)\n{\n    HandleStateTransition(GetStateMachine(StateMachineName).GetStateIndex(StateName), false,\n                          GetStateMachine(StateMachineName));\n}\n\nbool APlayerObject::CheckEnemyInRange(int32 XBegin, int32 XEnd, int32 YBegin, int32 YEnd) const\n{\n    // force x range to current direction\n    XBegin *= Direction == DIR_Right ? 1 : -1;\n    XEnd *= Direction == DIR_Right ? 1 : -1;\n\n    if (Direction == DIR_Right)\n    {\n        return XBegin + PosX &lt;= Enemy-&gt;PosX &amp;&amp; XEnd + PosX &gt;= Enemy-&gt;PosX &amp;&amp; YBegin + PosY &lt;= Enemy-&gt;PosY\n            &amp;&amp; YEnd + PosY &gt;= Enemy-&gt;PosY;\n    }\n    return XEnd + PosX &lt;= Enemy-&gt;PosX &amp;&amp; XBegin + PosX &gt;= Enemy-&gt;PosX &amp;&amp; YBegin + PosY &lt;= Enemy-&gt;PosY\n        &amp;&amp; YEnd + PosY &gt;= Enemy-&gt;PosY;\n}\n\nbool APlayerObject::IsEnemyAttackState() const\n{\n    return Enemy-&gt;PrimaryStateMachine.CurrentState-&gt;StateType &gt;= EStateType::NormalAttack\n        &amp;&amp; Enemy-&gt;PrimaryStateMachine.CurrentState-&gt;StateType &lt;= EStateType::SuperAttack;\n}\n\nbool APlayerObject::IsEnemyThrow() const\n{\n    return Enemy-&gt;PlayerFlags &amp; PLF_ThrowActive;\n}\n\nbool APlayerObject::IsEnemyBlocking() const\n{\n    return Enemy-&gt;GetCurrentStateName(StateMachine_Primary) == State_Universal_StandBlock || Enemy-&gt;GetCurrentStateName(\n            StateMachine_Primary) ==\n        State_Universal_CrouchBlock || Enemy-&gt;GetCurrentStateName(StateMachine_Primary) == State_Universal_AirBlock;\n}\n\nEBlockType APlayerObject::GetAttackBlockType() const\n{\n    return HitCommon.BlockType;\n}\n\nbool APlayerObject::IsCorrectBlock(EBlockType BlockType)\n{\n    CallSubroutine(Subroutine_Cmn_IsCorrectBlock);\n    if (SubroutineReturnVal2) return SubroutineReturnVal1;\n\n    if (BlockType != BLK_None &amp;&amp; GetEnableFlags(StateMachine_Primary) &amp; ENB_Block)\n    {\n        FInputCondition Left;\n        FInputBitmask BitmaskLeft;\n        BitmaskLeft.InputFlag = INP_Left;\n        BitmaskLeft.Lenience = 10;\n        Left.Sequence.Add(BitmaskLeft);\n        FInputCondition Right;\n        FInputBitmask BitmaskRight;\n        BitmaskRight.InputFlag = INP_Right;\n        Right.Sequence.Add(BitmaskRight);\n        if ((CheckInput(Left) &amp;&amp; !CheckInput(Right) &amp;&amp; PosY &gt; GroundHeight) || GetCurrentStateName(StateMachine_Primary)\n            ==\n            State_Universal_AirBlock)\n        {\n            if (PrimaryStateMachine.StateNames.Contains(State_Universal_AirBlock))\n            {\n                Left.Method = EInputMethod::Once;\n                if (CheckInput(Left) &amp;&amp; InstantBlockLockoutTimer == 0)\n                {\n                    AddMeter(800);\n                }\n                return true;\n            }\n        }\n        FInputCondition Input1;\n        FInputBitmask BitmaskDownLeft;\n        BitmaskDownLeft.InputFlag = INP_DownLeft;\n        BitmaskDownLeft.Lenience = 12;\n        Input1.Sequence.Add(BitmaskDownLeft);\n        Input1.Method = EInputMethod::Strict;\n        if ((CheckInput(Input1) || GetCurrentStateName(StateMachine_Primary) == State_Universal_CrouchBlock) &amp;&amp;\n            BlockType != BLK_High &amp;&amp; !\n            CheckInput(Right))\n        {\n            if (PrimaryStateMachine.StateNames.Contains(State_Universal_CrouchBlock))\n            {\n                Input1.Method = EInputMethod::OnceStrict;\n                if (CheckInput(Input1) &amp;&amp; InstantBlockLockoutTimer == 0)\n                {\n                    AddMeter(800);\n                }\n                return true;\n            }\n        }\n        FInputCondition Input4;\n        Input4.Sequence.Add(BitmaskLeft);\n        Input4.Method = EInputMethod::Strict;\n        if ((CheckInput(Input4) || GetCurrentStateName(StateMachine_Primary) == State_Universal_StandBlock) &amp;&amp; BlockType\n            != BLK_Low &amp;&amp; !\n            CheckInput(Right))\n        {\n            if (PrimaryStateMachine.StateNames.Contains(State_Universal_StandBlock))\n            {\n                Input4.Method = EInputMethod::OnceStrict;\n                if (CheckInput(Input4) &amp;&amp; InstantBlockLockoutTimer == 0)\n                {\n                    AddMeter(800);\n                }\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid APlayerObject::HandleBlockAction()\n{\n    AttackOwner-&gt;Hitstop = ReceivedHit.Hitstop;\n    Hitstop = ReceivedHit.Hitstop + ReceivedHitCommon.EnemyBlockstopModifier;\n    StunTime = ReceivedHitCommon.Blockstun;\n    StunTimeMax = ReceivedHitCommon.Blockstun;\n\n    FInputCondition Input1;\n    FInputBitmask BitmaskDownLeft;\n    BitmaskDownLeft.InputFlag = INP_DownLeft;\n    Input1.Sequence.Add(BitmaskDownLeft);\n    Input1.Method = EInputMethod::Strict;\n    switch (ReceivedHitCommon.AttackLevel)\n    {\n    case 0:\n    default:\n        GotoLabel(State_Label_Block_Level1);\n        break;\n    case 1:\n        GotoLabel(State_Label_Block_Level1);\n        break;\n    case 2:\n        GotoLabel(State_Label_Block_Level2);\n        break;\n    case 3:\n        GotoLabel(State_Label_Block_Level2);\n        break;\n    case 4:\n        GotoLabel(State_Label_Block_Level3);\n        break;\n    case 5:\n        GotoLabel(State_Label_Block_Level3);\n        break;\n    }\n    if (Stance == ACT_Jumping || GetCurrentStateName(StateMachine_Primary) == State_Universal_AirBlock)\n    {\n        BufferedStateName = State_Universal_AirBlock;\n    }\n    else if (CheckInput(Input1) || GetCurrentStateName(StateMachine_Primary) == State_Universal_CrouchBlock)\n    {\n        PosY = 0;\n        BufferedStateName = State_Universal_CrouchBlock;\n    }\n    else\n    {\n        PosY = 0;\n        BufferedStateName = State_Universal_StandBlock;\n    }\n}\n\nvoid APlayerObject::HandleProximityBlock()\n{\n    if (!(Enemy-&gt;AttackFlags &amp; ATK_HitActive) || !IsCorrectBlock(Enemy-&gt;HitCommon.BlockType)\n        || (CalculateDistanceBetweenPoints(DIST_DistanceX, OBJ_Self, POS_Self, OBJ_Enemy, POS_Self) &gt; Enemy-&gt;HitCommon.\n            ProximityBlockDistanceX\n            || CalculateDistanceBetweenPoints(DIST_DistanceY, OBJ_Self, POS_Self, OBJ_Enemy, POS_Self) &gt; Enemy-&gt;\n            HitCommon.ProximityBlockDistanceY))\n    {\n        if (PrimaryStateMachine.CurrentState-&gt;StateType == EStateType::Blockstun &amp;&amp; StunTime &lt;= 0)\n        {\n            if (Stance == ACT_Standing)\n            {\n                JumpToStatePrimary(State_Universal_StandBlockEnd);\n            }\n            else if (Stance == ACT_Crouching)\n            {\n                JumpToStatePrimary(State_Universal_CrouchBlockEnd);\n            }\n            else\n            {\n                JumpToStatePrimary(State_Universal_AirBlockEnd);\n            }\n        }\n        return;\n    }\n    if (!(GetEnableFlags(StateMachine_Primary) &amp; ENB_ProximityBlock))\n        return;\n\n    FInputCondition Input1;\n    FInputBitmask BitmaskDownLeft;\n    BitmaskDownLeft.InputFlag = INP_DownLeft;\n    Input1.Sequence.Add(BitmaskDownLeft);\n    Input1.Method = EInputMethod::Strict;\n    GotoLabel(State_Label_Block_PreGuard);\n    if (PosY &gt; GroundHeight)\n    {\n        JumpToStatePrimary(State_Universal_AirBlock, true);\n        Stance = ACT_Jumping;\n    }\n    else if (CheckInput(Input1))\n    {\n        JumpToStatePrimary(State_Universal_CrouchBlock, true);\n        Stance = ACT_Crouching;\n    }\n    else\n    {\n        JumpToStatePrimary(State_Universal_StandBlock, true);\n        Stance = ACT_Standing;\n    }\n}\n\nvoid APlayerObject::EmptyStateMachine()\n{\n    PrimaryStateMachine.States.Empty();\n    PrimaryStateMachine.StateNames.Empty();\n    PrimaryStateMachine.CurrentState = nullptr;\n    for (auto&amp; StateMachine : SubStateMachines)\n    {\n        StateMachine.States.Empty();\n        StateMachine.StateNames.Empty();\n        StateMachine.CurrentState = nullptr;\n    }\n\n    CommonSubroutineNames.Empty();\n    CommonSubroutines.Empty();\n\n    SubroutineNames.Empty();\n    Subroutines.Empty();\n\n    CommonObjectStates.Empty();\n    CommonObjectStateNames.Empty();\n\n    ObjectStates.Empty();\n    ObjectStateNames.Empty();\n}\n\nvoid APlayerObject::HandleBufferedState()\n{\n    HandleBufferedState(PrimaryStateMachine);\n}\n\nvoid APlayerObject::HandleBufferedState(FStateMachine&amp; StateMachine)\n{\n    if (BufferedStateName != FGameplayTag::EmptyTag)\n    {\n        if (StateMachine.ForceSetState(BufferedStateName))\n        {\n            GotoLabelActive = false;\n            switch (StateMachine.CurrentState-&gt;EntryStance)\n            {\n            case EEntryStance::Standing:\n                Stance = ACT_Standing;\n                break;\n            case EEntryStance::Crouching:\n                Stance = ACT_Crouching;\n                break;\n            case EEntryStance::Jumping:\n                Stance = ACT_Jumping;\n                break;\n            default:\n                break;\n            }\n        }\n        BufferedStateName = FGameplayTag::EmptyTag;\n    }\n}\n\nbool APlayerObject::HandleStateCondition(EStateCondition StateCondition) const\n{\n    switch (StateCondition)\n    {\n    case EStateCondition::None:\n        return true;\n    case EStateCondition::AirJumpOk:\n        if (CurrentAirJumpCount &gt; 0)\n            return true;\n        break;\n    case EStateCondition::AirJumpMinimumHeight:\n        if (SpeedY &lt;= 0 || PosY &gt;= 122500)\n            return true;\n        break;\n    case EStateCondition::AirDashOk:\n        if (CurrentAirDashCount &gt; 0)\n            return true;\n        break;\n    case EStateCondition::AirDashMinimumHeight:\n        if (PosY &gt; AirDashMinimumHeight &amp;&amp; SpeedY &gt; 0)\n            return true;\n        if (PosY &gt; 70000 &amp;&amp; SpeedY &lt;= 0)\n            return true;\n        break;\n    case EStateCondition::IsAttacking:\n        return AttackFlags &amp; ATK_IsAttacking;\n    case EStateCondition::HitstopCancel:\n        return Hitstop &gt; 0 &amp;&amp; AttackFlags &amp; ATK_IsAttacking;\n    case EStateCondition::IsStunned:\n        return CheckIsStunned();\n    case EStateCondition::CloseNormal:\n        if (abs(PosX - Enemy-&gt;PosX) &lt; CloseNormalRange &amp;&amp; (PlayerFlags &amp; PLF_ForceEnableFarNormal) == 0)\n            return true;\n        break;\n    case EStateCondition::FarNormal:\n        if (abs(PosX - Enemy-&gt;PosX) &gt; CloseNormalRange || PlayerFlags &amp; PLF_ForceEnableFarNormal)\n            return true;\n        break;\n    case EStateCondition::CanTag2nd:\n        if (GameState-&gt;CanTag(this, 1))\n            return true;\n        break;\n    case EStateCondition::CanTag3rd:\n        if (GameState-&gt;CanTag(this, 2))\n            return true;\n        break;\n    case EStateCondition::MeterNotZero:\n        if (GameState-&gt;BattleState.Meter[PlayerIndex] &gt; 0)\n            return true;\n        break;\n    case EStateCondition::MeterQuarterBar:\n        if (GameState-&gt;BattleState.Meter[PlayerIndex] &gt;= 2500)\n            return true;\n        break;\n    case EStateCondition::MeterHalfBar:\n        if (GameState-&gt;BattleState.Meter[PlayerIndex] &gt;= 5000)\n            return true;\n        break;\n    case EStateCondition::MeterOneBar:\n        if (GameState-&gt;BattleState.Meter[PlayerIndex] &gt;= 10000)\n            return true;\n        break;\n    case EStateCondition::MeterTwoBars:\n        if (GameState-&gt;BattleState.Meter[PlayerIndex] &gt;= 20000)\n            return true;\n        break;\n    case EStateCondition::MeterThreeBars:\n        if (GameState-&gt;BattleState.Meter[PlayerIndex] &gt;= 30000)\n            return true;\n        break;\n    case EStateCondition::MeterFourBars:\n        if (GameState-&gt;BattleState.Meter[PlayerIndex] &gt;= 40000)\n            return true;\n        break;\n    case EStateCondition::MeterFiveBars:\n        if (GameState-&gt;BattleState.Meter[PlayerIndex] &gt;= 50000)\n            return true;\n        break;\n    case EStateCondition::PlayerReg1True:\n        return PlayerReg1 != 0;\n    case EStateCondition::PlayerReg2True:\n        return PlayerReg2 != 0;\n    case EStateCondition::PlayerReg3True:\n        return PlayerReg3 != 0;\n    case EStateCondition::PlayerReg4True:\n        return PlayerReg4 != 0;\n    case EStateCondition::PlayerReg5True:\n        return PlayerReg5 != 0;\n    case EStateCondition::PlayerReg6True:\n        return PlayerReg6 != 0;\n    case EStateCondition::PlayerReg7True:\n        return PlayerReg7 != 0;\n    case EStateCondition::PlayerReg8True:\n        return PlayerReg8 != 0;\n    case EStateCondition::PlayerReg1False:\n        return PlayerReg1 == 0;\n    case EStateCondition::PlayerReg2False:\n        return PlayerReg2 == 0;\n    case EStateCondition::PlayerReg3False:\n        return PlayerReg3 == 0;\n    case EStateCondition::PlayerReg4False:\n        return PlayerReg4 == 0;\n    case EStateCondition::PlayerReg5False:\n        return PlayerReg5 == 0;\n    case EStateCondition::PlayerReg6False:\n        return PlayerReg6 == 0;\n    case EStateCondition::PlayerReg7False:\n        return PlayerReg7 == 0;\n    case EStateCondition::PlayerReg8False:\n        return PlayerReg8 == 0;\n    default:\n        break;\n    }\n    return false;\n}\n\nbool APlayerObject::FindChainCancelOption(const FGameplayTag Name, FStateMachine&amp; StateMachine)\n{\n    if (AttackFlags &amp; ATK_HasHit &amp;&amp; AttackFlags &amp; ATK_IsAttacking &amp;&amp; CancelFlags &amp; CNC_ChainCancelEnabled)\n    {\n        if (CheckReverseBeat(Name, StateMachine))\n            return true;\n        for (int i = 0; i &lt; ChainCancelOptions.Num(); i++)\n        {\n            if (ChainCancelOptions[i] == StateMachine.GetStateIndex(Name) &amp;&amp; ChainCancelOptions[i] != INDEX_NONE)\n            {\n                return CheckMovesUsedInChain(Name, StateMachine);\n            }\n        }\n    }\n    return false;\n}\n\nbool APlayerObject::FindAutoComboCancelOption(const FGameplayTag Name, FStateMachine&amp; StateMachine)\n{\n    if (AttackFlags &amp; ATK_HasHit &amp;&amp; CancelFlags &amp; CNC_ChainCancelEnabled)\n    {\n        for (int i = 0; i &lt; 8; i++)\n        {\n            if (AutoComboCancels[i] == StateMachine.GetStateIndex(Name) &amp;&amp; AutoComboCancels[i] != INDEX_NONE)\n            {\n                return CheckMovesUsedInChain(Name, StateMachine);\n            }\n        }\n    }\n    return false;\n}\n\nbool APlayerObject::FindWhiffCancelOption(const FGameplayTag Name, FStateMachine&amp; StateMachine)\n{\n    if (CancelFlags &amp; CNC_WhiffCancelEnabled)\n    {\n        if (CheckReverseBeat(Name, StateMachine))\n            return true;\n        for (int i = 0; i &lt; WhiffCancelOptions.Num(); i++)\n        {\n            if (WhiffCancelOptions[i] == StateMachine.GetStateIndex(Name) &amp;&amp; WhiffCancelOptions[i] != INDEX_NONE)\n            {\n                return CheckMovesUsedInChain(Name, StateMachine);\n            }\n        }\n    }\n    return false;\n}\n\nbool APlayerObject::CheckReverseBeat(const FGameplayTag Name, FStateMachine&amp; StateMachine)\n{\n    if (!CanReverseBeat || (CancelFlags &amp; CNC_EnableReverseBeat) == 0)\n        return false;\n\n    const int32 Index = StateMachine.GetStateIndex(Name);\n    if (!StateMachine.States[Index]-&gt;bEnableReverseBeat) return false;\n\n    if (StateMachine.CurrentState-&gt;StateType == EStateType::NormalAttack\n        &amp;&amp; Index != INDEX_NONE &amp;&amp; StateMachine.States[Index]-&gt;StateType == EStateType::NormalAttack)\n    {\n        return CheckMovesUsedInChain(Name, StateMachine);\n    }\n    return false;\n}\n\nbool APlayerObject::CheckMovesUsedInChain(const FGameplayTag Name, FStateMachine&amp; StateMachine)\n{\n    int32 Usages = 0;\n    for (const int32 Index : MovesUsedInChain)\n    {\n        if (Index == StateMachine.GetStateIndex(Name) &amp;&amp; Index != INDEX_NONE)\n            Usages++;\n    }\n    if (CanReverseBeat &amp;&amp; Usages)\n    {\n        auto LastMove = MovesUsedInChain.Last();\n        if (LastMove != StateMachine.GetStateIndex(Name))\n        {\n            return false;\n        }\n    }\n\n    auto State = StateMachine.States[StateMachine.GetStateIndex(Name)];\n\n    if (Usages &lt; State-&gt;MaxChain || State-&gt;MaxChain == -1)\n    {\n        return true;\n    }\n    return false;\n}\n\nvoid APlayerObject::ThrowExe()\n{\n    JumpToStatePrimary(ExeStateName);\n    PlayerFlags &amp;= ~PLF_ThrowActive;\n}\n\nvoid APlayerObject::HandleThrowCollision()\n{\n    if ((Enemy-&gt;InvulnFlags &amp; INV_ThrowInvulnerable) == 0 &amp;&amp; !Enemy-&gt;ThrowInvulnerableTimer\n        &amp;&amp; !Enemy-&gt;ThrowResistTimer &amp;&amp; !Enemy-&gt;CheckIsStunned()\n        &amp;&amp; ((Enemy-&gt;PosY &lt;= GroundHeight &amp;&amp; PosY &lt;= GroundHeight)\n            || (Enemy-&gt;PosY &gt; GroundHeight &amp;&amp; PosY &gt; GroundHeight)))\n    {\n        FInputCondition Left;\n        FInputBitmask BitmaskLeft;\n        BitmaskLeft.InputFlag = INP_Left;\n        BitmaskLeft.Lenience = 1;\n        Left.Sequence.Add(BitmaskLeft);\n        Left.Method = EInputMethod::Strict;\n\n        if (CanProximityThrow)\n        {\n            if (ActionTime == 0 &amp;&amp; PrimaryStateMachine.CurrentState-&gt;StateType == EStateType::NormalAttack)\n            {\n                FInputCondition Right;\n                FInputBitmask BitmaskRight;\n                BitmaskRight.InputFlag = INP_Right;\n                BitmaskRight.Lenience = 1;\n                Right.Sequence.Add(BitmaskRight);\n                Right.Method = EInputMethod::Strict;\n\n                if (CheckInput(ProximityThrowInput) &amp;&amp; (CheckInput(Left) || CheckInput(Right)))\n                {\n                    if (PosY &lt;= GroundHeight)\n                        CallSubroutine(Subroutine_ThrowParam_Ground);\n                    else\n                        CallSubroutine(Subroutine_ThrowParam_Air);\n                }\n            }\n            else\n            {\n                SetThrowActive(false);\n            }\n        }\n\n        int ThrowPosX;\n        if (Direction == DIR_Right)\n            ThrowPosX = R + ThrowRange;\n        else\n            ThrowPosX = L - ThrowRange;\n        if (AttackFlags &amp; ATK_IsAttacking &amp;&amp; PlayerFlags &amp; PLF_ThrowActive\n            &amp;&amp; ((PosX &lt;= Enemy-&gt;PosX &amp;&amp; ThrowPosX &gt;= Enemy-&gt;L)\n                || (PosX &gt; Enemy-&gt;PosX &amp;&amp; ThrowPosX &lt;= Enemy-&gt;R))\n            &amp;&amp; T &gt;= Enemy-&gt;B &amp;&amp; B &lt;= Enemy-&gt;T)\n        {\n            Enemy-&gt;JumpToStatePrimary(State_Universal_ThrowLock);\n            Enemy-&gt;PlayerFlags |= PLF_IsThrowLock;\n            Enemy-&gt;StunTime = 0x7FFFFFFF;\n            Enemy-&gt;ThrowTechTimer = ThrowTechWindow;\n            Enemy-&gt;AttackOwner = this;\n            ThrowExe();\n        }\n    }\n}\n\nbool APlayerObject::CheckKaraCancel(EStateType InStateType, const FStateMachine&amp; StateMachine)\n{\n    if ((CancelFlags &amp; CNC_EnableKaraCancel) == 0 || PlayerFlags &amp; PLF_DidKaraCancel)\n    {\n        return false;\n    }\n\n    if (ActionTime &gt;= 3)\n        return false;\n\n    if (InStateType == StateMachine.CurrentState-&gt;StateType)\n    {\n        PlayerFlags |= PLF_DidKaraCancel;\n        return true;\n    }\n    if (InStateType == EStateType::SpecialAttack &amp;&amp; StateMachine.CurrentState-&gt;StateType &gt;=\n        EStateType::NormalAttack &amp;&amp; StateMachine.CurrentState-&gt;StateType &lt; EStateType::SpecialAttack)\n    {\n        PlayerFlags |= PLF_DidKaraCancel;\n        return true;\n    }\n    if (InStateType == EStateType::SuperAttack &amp;&amp; StateMachine.CurrentState-&gt;StateType &gt;=\n        EStateType::NormalAttack &amp;&amp; StateMachine.CurrentState-&gt;StateType &lt; EStateType::SuperAttack)\n    {\n        PlayerFlags |= PLF_DidKaraCancel;\n        return true;\n    }\n\n    return false;\n}\n\nbool APlayerObject::CheckObjectPreventingState(int InObjectID) const\n{\n    if (InObjectID != 0)\n    {\n        for (int i = GameState-&gt;Players.Num(); i &lt; GameState-&gt;BattleState.ActiveObjectCount; i++)\n        {\n            if (GameState-&gt;SortedObjects[i]-&gt;Player == this &amp;&amp; GameState-&gt;SortedObjects[i]-&gt;ObjectID == InObjectID)\n                return true;\n        }\n    }\n    return false;\n}\n\nvoid APlayerObject::HandleWallBounce()\n{\n    if (ReceivedHit.WallBounce.WallBounceInCornerOnly)\n    {\n        if (PlayerFlags &amp; PLF_TouchingWall &amp;&amp; \n            GameState-&gt;BattleState.ScreenData.ScreenWorldCenterX + GameState-&gt;BattleState.ScreenData.ScreenWorldWidth / 2\n            &gt;= GameState-&gt;BattleState.ScreenData.StageBoundsRight ||\n            GameState-&gt;BattleState.ScreenData.ScreenWorldCenterX - GameState-&gt;BattleState.ScreenData.ScreenWorldWidth / 2\n            &lt;= GameState-&gt;BattleState.ScreenData.StageBoundsLeft)\n        {\n            if (ReceivedHit.WallBounce.WallBounceCount &gt; 0)\n            {\n                PlayCommonSound(Sound_Landing_Crash);\n                CreateCommonParticle(Particle_WallBounce, POS_Self);\n                ReceivedHit.GroundBounce.GroundBounceCount = 0;\n                PlayerFlags &amp;= ~PLF_TouchingWall;\n                ReceivedHit.WallBounce.WallBounceCount--;\n                ReceivedHit.GroundPushbackX = 0;\n                ReceivedHit.AirPushbackX = -ReceivedHit.WallBounce.WallBounceXSpeed * ReceivedHit.WallBounce.WallBounceXRate / 100;\n                ReceivedHit.AirPushbackY = ReceivedHit.WallBounce.WallBounceYSpeed * ReceivedHit.WallBounce.\n                    WallBounceYRate / 100;\n                ReceivedHit.Gravity = ReceivedHit.WallBounce.WallBounceGravity;\n                if (ReceivedHit.WallBounce.WallBounceUntech &gt; 0)\n                    ReceivedHit.Untech = ReceivedHit.WallBounce.WallBounceUntech;\n                else\n                    ReceivedHit.Untech = StunTime;\n                StunTime = INT_MAX;\n                ReceivedHit.Hitstop = ReceivedHit.WallBounce.WallBounceStop;\n                ReceivedHit.GroundHitAction = HACT_AirFaceDown;\n                ReceivedHit.AirHitAction = HACT_AirFaceDown;\n                ReceivedHit.Position = FHitPosition();\n                ReceivedHit.AirPushbackXOverTime = FHitValueOverTime();\n                ReceivedHit.AirPushbackYOverTime = FHitValueOverTime();\n                ReceivedHit.GravityOverTime = FHitValueOverTime();\n                HaltMomentum();\n                BufferedStateName = State_Universal_WallBounce;\n\n                int32 FinalHitstop = ReceivedHit.Hitstop;\n\n                Hitstop = FinalHitstop;\n                HandleBufferedState(PrimaryStateMachine);\n            }\n        }\n        return;\n    }\n    if (PlayerFlags &amp; PLF_TouchingWall)\n    {\n        if (ReceivedHit.WallBounce.WallBounceCount &gt; 0)\n        {\n            PlayCommonSound(Sound_Landing_Crash);\n            CreateCommonParticle(Particle_WallBounce, POS_Self);\n            ReceivedHit.GroundBounce.GroundBounceCount = 0;\n            PlayerFlags &amp;= ~PLF_TouchingWall;\n            ReceivedHit.WallBounce.WallBounceCount--;\n            ReceivedHit.GroundPushbackX = 0;\n            ReceivedHit.AirPushbackX = -ReceivedHit.WallBounce.WallBounceXSpeed * ReceivedHit.WallBounce.WallBounceXRate / 100;\n            ReceivedHit.AirPushbackY = ReceivedHit.WallBounce.WallBounceYSpeed * ReceivedHit.WallBounce.WallBounceYRate\n                / 100;\n            ReceivedHit.Gravity = ReceivedHit.WallBounce.WallBounceGravity;\n            if (ReceivedHit.WallBounce.WallBounceUntech &gt; 0)\n                ReceivedHit.Untech = ReceivedHit.WallBounce.WallBounceUntech;\n            else\n                ReceivedHit.Untech = StunTime;\n            StunTime = INT_MAX;\n            ReceivedHit.Hitstop = ReceivedHit.WallBounce.WallBounceStop;\n            ReceivedHit.GroundHitAction = HACT_AirFaceDown;\n            ReceivedHit.AirHitAction = HACT_AirFaceDown;\n            ReceivedHit.Position = FHitPosition();\n            ReceivedHit.AirPushbackXOverTime = FHitValueOverTime();\n            ReceivedHit.AirPushbackYOverTime = FHitValueOverTime();\n            ReceivedHit.GravityOverTime = FHitValueOverTime();\n            HaltMomentum();\n            BufferedStateName = State_Universal_WallBounce;\n\n            int32 FinalHitstop = ReceivedHit.Hitstop;\n\n            Hitstop = FinalHitstop;\n            HandleBufferedState(PrimaryStateMachine);\n        }\n    }\n}\n\nvoid APlayerObject::HandleGroundBounce()\n{\n    CreateCommonParticle(Particle_JumpSmoke_Land, POS_Player);\n    ReceivedHit.GroundBounce.GroundBounceCount--;\n    ReceivedHit.GroundPushbackX = 0;\n    if (SpeedX &gt; 0)\n        ReceivedHit.AirPushbackX = -ReceivedHit.GroundBounce.GroundBounceXSpeed * ReceivedHit.GroundBounce.\n            GroundBounceXRate / 100;\n    else\n        ReceivedHit.AirPushbackX = ReceivedHit.GroundBounce.GroundBounceXSpeed * ReceivedHit.GroundBounce.\n            GroundBounceXRate / 100;\n    ReceivedHit.AirPushbackY = ReceivedHit.GroundBounce.GroundBounceYSpeed * ReceivedHit.GroundBounce.GroundBounceYRate / 100;\n    ReceivedHit.Gravity = ReceivedHit.GroundBounce.GroundBounceGravity;\n    if (ReceivedHit.GroundBounce.GroundBounceUntech &gt; 0)\n        ReceivedHit.Untech = ReceivedHit.GroundBounce.GroundBounceUntech;\n    else\n        ReceivedHit.Untech = StunTime;\n    ReceivedHit.Hitstop = ReceivedHit.GroundBounce.GroundBounceStop;\n    ReceivedHit.GroundHitAction = HACT_AirFaceUp;\n    ReceivedHit.AirHitAction = HACT_AirFaceUp;\n    ReceivedHit.Position = FHitPosition();\n    ReceivedHit.AirPushbackXOverTime = FHitValueOverTime();\n    ReceivedHit.AirPushbackYOverTime = FHitValueOverTime();\n    ReceivedHit.GravityOverTime = FHitValueOverTime();\n    EnableCancelIntoSelf(true);\n    PosY = GroundHeight + 1;\n    switch (ReceivedHit.AirHitAction)\n    {\n    case HACT_AirFaceUp:\n    default:\n        BufferedStateName = State_Universal_Launch_B;\n        break;\n    case HACT_AirVertical:\n        BufferedStateName = State_Universal_Launch_V;\n        break;\n    case HACT_AirFaceDown:\n        BufferedStateName = State_Universal_Launch_F;\n        break;\n    }\n\n    Hitstop = ReceivedHit.GroundBounce.GroundBounceStop;\n    PlayerFlags &amp;= ~PLF_IsKnockedDown;\n    HandleBufferedState(PrimaryStateMachine);\n}\n\nvoid APlayerObject::SetComponentVisibility() const\n{\n    TInlineComponentArray&lt;UPrimitiveComponent*&gt; Components;\n    GetComponents(Components);\n    for (int i = 0; i &lt; Components.Num(); i++)\n    {\n        UPrimitiveComponent* Component = Components[i];\n        Component-&gt;SetVisibility(ComponentVisible[i]);\n    }\n}\n\nvoid APlayerObject::UpdateVisualsNoRollback()\n{\n    Super::UpdateVisualsNoRollback();\n\n    for (const auto&amp; LinkActor : StoredLinkActors)\n    {\n        LinkActor.StoredActor-&gt;SetActorHiddenInGame(!LinkActor.bIsActive);\n    }\n    SetComponentVisibility();\n\n    TArray&lt;USkeletalMeshComponent*&gt; SkeletalMeshComponents;\n    GetComponents(USkeletalMeshComponent::StaticClass(), SkeletalMeshComponents);\n\n    for (auto SkeletalMeshComponent : SkeletalMeshComponents)\n    {\n        if (!SkeletalMeshComponent-&gt;IsVisible() || !IsValid(SkeletalMeshComponent-&gt;GetAnimInstance())) continue;\n        SkeletalMeshComponent-&gt;GetAnimInstance()-&gt;UpdateAnimation(OneFrame, false); \n        SkeletalMeshComponent-&gt;TickAnimation(OneFrame, false); \n        SkeletalMeshComponent-&gt;TickPose(OneFrame, true);  \n    }\n}\n\nvoid APlayerObject::AddState(FGameplayTag Name, UState* State, FGameplayTag StateMachineName)\n{\n    auto&amp; StateMachine = GetStateMachine(StateMachineName);\n\n    StateMachine.Parent = this;\n    StateMachine.AddState(Name, State);\n}\n\nvoid APlayerObject::AddObjectState(FGameplayTag Name, UState* State, bool IsCommon)\n{\n    State-&gt;Parent = this;\n    if (IsCommon)\n    {\n        CommonObjectStates.Add(State);\n        CommonObjectStateNames.Add(Name);\n    }\n    else\n    {\n        ObjectStates.Add(State);\n        ObjectStateNames.Add(Name);\n    }\n}\n\nvoid APlayerObject::AddSubroutine(FGameplayTag Name, USubroutine* Subroutine, bool IsCommon)\n{\n    Subroutine-&gt;Parent = this;\n    if (IsCommon)\n    {\n        CommonSubroutines.Add(Subroutine);\n        CommonSubroutineNames.Add(Name);\n    }\n    else\n    {\n        Subroutines.Add(Subroutine);\n        SubroutineNames.Add(Name);\n    }\n}\n\nvoid APlayerObject::SetHealth(int Value)\n{\n    CurrentHealth = Value;\n}\n\nvoid APlayerObject::AddHealth(int Value)\n{\n    CurrentHealth += Value;\n}\n\nvoid APlayerObject::SetRecoverableHealth(int Value)\n{\n    RecoverableHealth = Value;\n}\n\nvoid APlayerObject::AddRecoverableHealth(int Value)\n{\n    RecoverableHealth += Value;\n}\n\nvoid APlayerObject::RecoverHealth(int Value)\n{\n    if (Value &lt;= RecoverableHealth)\n    {\n        CurrentHealth += Value;\n        RecoverableHealth -= Value;\n    }\n    else\n    {\n        CurrentHealth += RecoverableHealth;\n        RecoverableHealth = 0;\n    }\n}\n\nvoid APlayerObject::UseMeter(int Use)\n{\n    if (!GameState) return;\n    GameState-&gt;BattleState.Meter[PlayerIndex] -= Use;\n}\n\nvoid APlayerObject::AddMeter(int Meter)\n{\n    if (!GameState) return;\n    if (MeterCooldownTimer &gt; 0)\n        Meter /= 10;\n    GameState-&gt;BattleState.Meter[PlayerIndex] += Meter;\n}\n\nvoid APlayerObject::SetMeterCooldownTimer(int Timer)\n{\n    MeterCooldownTimer = Timer;\n}\n\nvoid APlayerObject::SetStance(EActionStance InStance)\n{\n    Stance = InStance;\n}\n\nbool APlayerObject::JumpToStatePrimary(FGameplayTag NewName, bool IsLabel)\n{\n    return JumpToState(NewName, StateMachine_Primary, IsLabel);\n}\n\nbool APlayerObject::JumpToState(FGameplayTag NewName, FGameplayTag StateMachineName, bool IsLabel)\n{\n    if (!GameState &amp;&amp; !CharaSelectGameState) return false;\n    GotoLabelActive = IsLabel;\n    FStateMachine&amp; StateMachine = GetStateMachine(StateMachineName);\n    if (StateMachine.ForceSetState(NewName) &amp;&amp; StateMachine.CurrentState != nullptr)\n    {\n        switch (StateMachine.CurrentState-&gt;EntryStance)\n        {\n        case EEntryStance::Standing:\n            Stance = ACT_Standing;\n            break;\n        case EEntryStance::Crouching:\n            Stance = ACT_Crouching;\n            break;\n        case EEntryStance::Jumping:\n            Stance = ACT_Jumping;\n            break;\n        default:\n            break;\n        }\n        return true;\n    }\n    return false;\n}\n\n\nbool APlayerObject::JumpToStateByClassPrimary(TSubclassOf&lt;UState&gt; Class, bool IsLabel)\n{\n    return JumpToStateByClass(Class, StateMachine_Primary, IsLabel);\n}\n\nbool APlayerObject::JumpToStateByClass(TSubclassOf&lt;UState&gt; Class, FGameplayTag StateMachineName, bool IsLabel)\n{\n    if (!GameState &amp;&amp; !CharaSelectGameState) return false;\n    GotoLabelActive = IsLabel;\n    FStateMachine&amp; StateMachine = GetStateMachine(StateMachineName);\n    if (StateMachine.ForceSetState(Class) &amp;&amp; StateMachine.CurrentState != nullptr)\n    {\n        switch (StateMachine.CurrentState-&gt;EntryStance)\n        {\n        case EEntryStance::Standing:\n            Stance = ACT_Standing;\n            break;\n        case EEntryStance::Crouching:\n            Stance = ACT_Crouching;\n            break;\n        case EEntryStance::Jumping:\n            Stance = ACT_Jumping;\n            break;\n        default:\n            break;\n        }\n        return true;\n    }\n    return false;\n}\n\nFGameplayTag APlayerObject::GetCurrentStateName(FGameplayTag StateMachineName)\n{\n    if (!GetStateMachine(StateMachineName).CurrentState) return FGameplayTag::EmptyTag;\n    return GetStateMachine(StateMachineName).CurrentState-&gt;Name;\n}\n\nFGameplayTag APlayerObject::GetLastStateName() const\n{\n    return LastStateName;\n}\n\nFGameplayTag APlayerObject::GetStateEntryName() const\n{\n    return StateEntryName;\n}\n\nFStateMachine&amp; APlayerObject::GetStateMachine(FGameplayTag StateMachineName)\n{\n    for (auto&amp; StateMachine : SubStateMachines)\n    {\n        if (StateMachineName == StateMachine.StateMachineName)\n        {\n            return StateMachine;\n        }\n    }\n    if (StateMachineName != StateMachine_Primary &amp;&amp; StateMachineName != FGameplayTag::EmptyTag)\n    {\n        UE_LOGFMT(LogCore, Error, \"State machine `{Name}` was not found, returning primary.\",\n                  (\"Name\", StateMachineName.ToString()));\n    }\n    return PrimaryStateMachine;\n}\n\nbool APlayerObject::CheckStateEnabled(EStateType StateType, FGameplayTag CustomStateType, FGameplayTag StateMachineName)\n{\n    switch (StateType)\n    {\n    case EStateType::Standing:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_Standing)\n            return true;\n        break;\n    case EStateType::Crouching:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_Crouching)\n            return true;\n        break;\n    case EStateType::NeutralJump:\n    case EStateType::ForwardJump:\n    case EStateType::BackwardJump:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_Jumping || (CancelFlags &amp; CNC_JumpCancel &amp;&amp; AttackFlags &amp; ATK_HasHit\n            &amp;&amp; AttackFlags &amp;\n            ATK_IsAttacking))\n            return true;\n        break;\n    case EStateType::ForwardWalk:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_ForwardWalk)\n            return true;\n        break;\n    case EStateType::BackwardWalk:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_BackWalk)\n            return true;\n        break;\n    case EStateType::ForwardDash:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_ForwardDash)\n            return true;\n        break;\n    case EStateType::BackwardDash:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_BackDash)\n            return true;\n        break;\n    case EStateType::ForwardAirDash:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_ForwardAirDash || (CancelFlags &amp; CNC_FAirDashCancel &amp;&amp; AttackFlags &amp;\n            ATK_HasHit &amp;&amp;\n            AttackFlags &amp; ATK_IsAttacking))\n            return true;\n        break;\n    case EStateType::BackwardAirDash:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_BackAirDash || (CancelFlags &amp; CNC_BAirDashCancel &amp;&amp; AttackFlags &amp;\n            ATK_HasHit &amp;&amp;\n            AttackFlags &amp; ATK_IsAttacking))\n            return true;\n        break;\n    case EStateType::NormalAttack:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_NormalAttack)\n            return true;\n        break;\n    case EStateType::SpecialAttack:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_SpecialAttack || (CancelFlags &amp; CNC_SpecialCancel &amp;&amp; AttackFlags &amp;\n            ATK_HasHit &amp;&amp;\n            AttackFlags &amp; ATK_IsAttacking))\n            return true;\n        break;\n    case EStateType::SuperAttack:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_SuperAttack || (CancelFlags &amp; CNC_SuperCancel &amp;&amp; AttackFlags &amp;\n            ATK_HasHit &amp;&amp; AttackFlags &amp;\n            ATK_IsAttacking))\n            return true;\n        break;\n    case EStateType::Tech:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_Tech &amp;&amp; CheckIsStunned())\n            return true;\n        break;\n    case EStateType::Burst:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_Burst &amp;&amp; (Enemy-&gt;Player-&gt;PlayerFlags &amp; PLF_LockOpponentBurst) == 0\n            &amp;&amp; (PlayerFlags &amp; PLF_IsDead) == 0)\n            return true;\n        break;\n    case EStateType::Tag:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_Tag)\n            return true;\n        break;\n    case EStateType::Assist:\n        if (GetEnableFlags(StateMachineName) &amp; ENB_Assist)\n            return true;\n        break;\n    case EStateType::Custom:\n        if (GetStateMachine(StateMachineName).EnabledCustomStateTypes.Contains(CustomStateType))\n            return true;\n        break;\n    default:\n        break;\n    }\n    return false;\n}\n\nvoid APlayerObject::OnStateChange()\n{\n    if (!GameState) return;\n\n    CallSubroutine(Subroutine_Cmn_OnStateChange);\n    CallSubroutine(Subroutine_OnStateChange);\n\n    // Deactivate all objects that need to be destroyed on state change.\n    for (int i = GameState-&gt;Players.Num(); i &lt; GameState-&gt;BattleState.ActiveObjectCount; i++)\n    {\n        if (GameState-&gt;SortedObjects[i]-&gt;Player == this &amp;&amp; GameState-&gt;SortedObjects[i]-&gt;MiscFlags &amp;\n            MISC_DeactivateOnStateChange)\n            GameState-&gt;SortedObjects[i]-&gt;DeactivateObject();\n    }\n\n    DisableAll(StateMachine_Primary);\n\n    // Reset flags\n    CancelFlags = CNC_ChainCancelEnabled | CNC_EnableReverseBeat;\n    if (!(PlayerFlags &amp; PLF_DidKaraCancel))\n    {\n        CancelFlags |= CNC_EnableKaraCancel;\n    }\n    else\n    {\n        PlayerFlags &amp;= ~PLF_DidKaraCancel;\n    }\n    PlayerFlags &amp;= ~PLF_ThrowActive;\n    PlayerFlags &amp;= ~PLF_HitgrabActive;\n    PlayerFlags &amp;= ~PLF_LockOpponentBurst;\n    PlayerFlags &amp;= ~PLF_ForceEnableFarNormal;\n    PlayerFlags |= PLF_DefaultLandingAction;\n    AttackFlags = 0;\n    MiscFlags = 0;\n    MiscFlags |= MISC_PushCollisionActive;\n    MiscFlags |= MISC_WallCollisionActive;\n    MiscFlags |= MISC_FloorCollisionActive;\n    MiscFlags |= MISC_InertiaEnable;\n    InvulnFlags = 0;\n    GetStateMachine(StateMachine_Primary).EnableFlags = 0;\n\n    // Reset offset, as the offset should be applied\n    PrevOffsetX = 0;\n    PrevOffsetY = 0;\n    NextOffsetX = 0;\n    NextOffsetY = 0;\n\n    // Reset root motion params\n    PrevRootMotionX = 0;\n    PrevRootMotionY = 0;\n    PrevRootMotionZ = 0;\n\n    // Reset angle\n    AnglePitch_x1000 = 0;\n    AngleYaw_x1000 = 0;\n    AngleRoll_x1000 = 0;\n\n    PosZ = 0;\n\n    // Reset speed modifiers\n    Gravity = JumpGravity;\n    SpeedXRate = 100;\n    SpeedXRatePerFrame = 100;\n    SpeedYRate = 100;\n    SpeedYRatePerFrame = 100;\n\n    // Reset action data\n    ActionTime = 0;\n    AnimFrame = 0;\n    BlendAnimFrame = 0;\n    CelIndex = 0;\n    TimeUntilNextCel = 0;\n    for (auto&amp; Handler : EventHandlers)\n        Handler = FEventHandler();\n\n    // Reset action registers\n    ActionReg1 = 0;\n    ActionReg2 = 0;\n    ActionReg3 = 0;\n    ActionReg4 = 0;\n    ActionReg5 = 0;\n    ActionReg6 = 0;\n    ActionReg7 = 0;\n    ActionReg8 = 0;\n\n    // Miscellaneous resets\n    PushWidthExtend = 0;\n    FlipInputs = false;\n    for (int32&amp; CancelOption : AutoComboCancels)\n    {\n        CancelOption = -1;\n    }\n    GetStateMachine(StateMachine_Primary).EnabledCustomStateTypes.Empty();\n    for (auto&amp; StateMachine : SubStateMachines)\n    {\n        StateMachine.EnabledCustomStateTypes.Empty();\n    }\n    ChainCancelOptions.Empty();\n    WhiffCancelOptions.Empty();\n    HitCommon = FHitDataCommon();\n    NormalHit = FHitData();\n    CounterHit = FHitData();\n    CelName = FGameplayTag();\n    BlendCelName = FGameplayTag();\n    LastStateName = GetCurrentStateName(StateMachine_Primary);\n    HomingParams = FHomingParams();\n    SuperArmorData = FSuperArmorData();\n    UpdateTime = 0;\n    ObjectOffset = FVector::ZeroVector;\n    ObjectRotation = FRotator::ZeroRotator;\n    ObjectScale = FVector::OneVector;\n    bRender = true;\n    Transparency = 1;\n    FadeTransparency = 1;\n    TransparencySpeed = 0;\n    DamageColor = FLinearColor(1, 1, 1, 1);\n    DamageColor2 = FLinearColor(1, 1, 1, 1);\n}\n\nvoid APlayerObject::PostStateChange()\n{\n    CallSubroutine(Subroutine_Cmn_PostStateChange);\n    CallSubroutine(Subroutine_PostStateChange);\n\n    if (StunTime == 0 &amp;&amp; PrimaryStateMachine.CurrentState-&gt;StateType != EStateType::Hitstun)\n    {\n        PlayerFlags &amp;= ~PLF_IsStunned;\n        DisableState(ENB_Tech, StateMachine_Primary);\n    }\n\n    if (!CheckIsStunned())\n    {\n        PlayerFlags &amp;= ~PLF_ReceivedCounterHit;\n    }\n    AttackFlags &amp;= ~ATK_HasHit;\n\n    MovesUsedInCombo.Add(PrimaryStateMachine.GetStateIndex(GetCurrentStateName(StateMachine_Primary)));\n    if (PrimaryStateMachine.CurrentState-&gt;StateType &gt;= EStateType::NormalAttack\n        &amp;&amp; PrimaryStateMachine.CurrentState-&gt;StateType &lt;= EStateType::SuperAttack)\n    {\n        const FGameplayTag MoveChainName = PrimaryStateMachine.CurrentState-&gt;ShareChainName != FGameplayTag::EmptyTag\n                                               ? PrimaryStateMachine.CurrentState-&gt;ShareChainName\n                                               : PrimaryStateMachine.CurrentState-&gt;Name;\n        MovesUsedInChain.Add(PrimaryStateMachine.GetStateIndex(MoveChainName));\n    }\n    else\n    {\n        MovesUsedInChain.Empty();\n    }\n    PrimaryStateMachine.CurrentState-&gt;ResetToCDO();\n}\n\nvoid APlayerObject::RoundInit(bool ResetHealth)\n{\n    OrthoBlendActive = 1;\n    StoredInputBuffer = FInputBuffer();\n    if (PlayerIndex == 0)\n    {\n        PosX = -GameState-&gt;BattleState.RoundStartPos;\n    }\n    else\n    {\n        PosX = GameState-&gt;BattleState.RoundStartPos;\n    }\n    PosY = 0;\n    PosZ = 0;\n    PrevPosX = 0;\n    PrevPosY = 0;\n    PrevPosZ = 0;\n    SpeedX = 0;\n    SpeedY = 0;\n    SpeedZ = 0;\n    Gravity = JumpGravity;\n    Inertia = 0;\n    Pushback = 0;\n    ActionTime = 0;\n    PushHeight = 0;\n    PushHeightLow = 0;\n    PushWidth = 0;\n    PushWidthExtend = 0;\n    Hitstop = 0;\n    L = 0;\n    R = 0;\n    T = 0;\n    B = 0;\n    HitCommon = FHitDataCommon();\n    NormalHit = FHitData();\n    CounterHit = FHitData();\n    ReceivedHitCommon = FHitDataCommon();\n    ReceivedHit = FHitData();\n    AttackFlags = 0;\n    StunTime = 0;\n    StunTimeMax = 0;\n    Hitstop = 0;\n    MiscFlags = 0;\n    MiscFlags |= MISC_PushCollisionActive;\n    MiscFlags |= MISC_WallCollisionActive;\n    MiscFlags |= MISC_FloorCollisionActive;\n    MiscFlags |= MISC_InertiaEnable;\n    Direction = DIR_Right;\n    SpeedXRate = 100;\n    SpeedXRatePerFrame = 100;\n    SpeedYRate = 100;\n    SpeedYRatePerFrame = 100;\n    SpeedZRate = 100;\n    SpeedZRatePerFrame = 100;\n    GroundHeight = 0;\n    ActionReg1 = 0;\n    ActionReg2 = 0;\n    ActionReg3 = 0;\n    ActionReg4 = 0;\n    ActionReg5 = 0;\n    ActionReg6 = 0;\n    ActionReg7 = 0;\n    ActionReg8 = 0;\n    ObjectReg1 = 0;\n    ObjectReg2 = 0;\n    ObjectReg3 = 0;\n    ObjectReg4 = 0;\n    ObjectReg5 = 0;\n    ObjectReg6 = 0;\n    ObjectReg7 = 0;\n    ObjectReg8 = 0;\n    SubroutineReg1 = 0;\n    SubroutineReg2 = 0;\n    SubroutineReg3 = 0;\n    SubroutineReg4 = 0;\n    SubroutineReturnVal1 = 0;\n    SubroutineReturnVal2 = 0;\n    SubroutineReturnVal3 = 0;\n    SubroutineReturnVal4 = 0;\n    IsPlayer = true;\n    AttackTarget = nullptr;\n    AttackOwner = nullptr;\n    StopLinkObj = nullptr;\n    PositionLinkObj = nullptr;\n    MaterialLinkObj = nullptr;\n    Timer0 = 0;\n    Timer1 = 0;\n    HomingParams = FHomingParams();\n    SuperArmorData = FSuperArmorData();\n    UpdateTime = 0;\n    ObjectOffset = FVector::ZeroVector;\n    ObjectRotation = FRotator::ZeroRotator;\n    ObjectScale = FVector::OneVector;\n    CelName = FGameplayTag();\n    BlendCelName = FGameplayTag();\n    AnimFrame = 0;\n    BlendAnimFrame = 0;\n    FrameBlendPosition = 0;\n    CelIndex = 0;\n    TimeUntilNextCel = 0;\n    for (auto&amp; Handler : EventHandlers)\n        Handler = FEventHandler();\n    SocketName = FName();\n    SocketObj = OBJ_Self;\n    SocketOffset = FVector::ZeroVector;\n    ObjectScale = FVector::OneVector;\n    AddColor = FLinearColor(0, 0, 0, 1);\n    MulColor = FLinearColor(1, 1, 1, 1);\n    AddFadeColor = FLinearColor(0, 0, 0, 1);\n    MulFadeColor = FLinearColor(1, 1, 1, 1);\n    AddFadeSpeed = 0;\n    MulFadeSpeed = 0;\n    Transparency = 1;\n    FadeTransparency = 1;\n    TransparencySpeed = 0;\n    DamageColor = FLinearColor(1, 1, 1, 1);\n    DamageColor2 = FLinearColor(1, 1, 1, 1);\n    bRender = true;\n    ObjectsToIgnoreHitsFrom.Empty();\n    for (auto&amp; Box : Boxes)\n    {\n        Box = FCollisionBox();\n    }\n    PlayerReg1 = 0;\n    PlayerReg2 = 0;\n    PlayerReg3 = 0;\n    PlayerReg4 = 0;\n    PlayerReg5 = 0;\n    PlayerReg6 = 0;\n    PlayerReg7 = 0;\n    PlayerReg8 = 0;\n    CmnPlayerReg1 = 0;\n    CmnPlayerReg2 = 0;\n    CmnPlayerReg3 = 0;\n    CmnPlayerReg4 = 0;\n    CmnPlayerReg5 = 0;\n    CmnPlayerReg6 = 0;\n    CmnPlayerReg7 = 0;\n    CmnPlayerReg8 = 0;\n    IntroEndFlag = false;\n    RoundEndFlag = false;\n    SubroutineReg1 = 0;\n    SubroutineReg2 = 0;\n    SubroutineReg3 = 0;\n    SubroutineReg4 = 0;\n    Inputs = 0;\n    FlipInputs = false;\n    Stance = ACT_Standing;\n    if (ResetHealth)\n    {\n        CurrentHealth = MaxHealth;\n        RecoverableHealth = 0;\n    }\n    TotalProration = 10000;\n    ComboCounter = 0;\n    ComboTimer = 0;\n    ThrowTechWindow = 6;\n    InvulnFlags = 0;\n    PlayerFlags &amp;= ~PLF_IsDead;\n    PlayerFlags &amp;= ~PLF_ThrowActive;\n    PlayerFlags &amp;= ~PLF_HitgrabActive;\n    PlayerFlags &amp;= ~PLF_IsStunned;\n    PlayerFlags &amp;= ~PLF_IsThrowLock;\n    PlayerFlags &amp;= ~PLF_DeathCamOverride;\n    PlayerFlags &amp;= ~PLF_IsKnockedDown;\n    PlayerFlags &amp;= ~PLF_RoundWinInputLock;\n    PlayerFlags &amp;= ~PLF_LockOpponentBurst;\n    PlayerFlags &amp;= ~PLF_ForceEnableFarNormal;\n    PlayerFlags |= PLF_DefaultLandingAction;\n    StrikeInvulnerableTimer = 0;\n    ThrowInvulnerableTimer = 0;\n    ThrowResistTimer = 0;\n    for (auto&amp; Gauge : ExtraGauges)\n        Gauge.Value = Gauge.InitialValue;\n    AirDashTimer = 0;\n    OTGCount = 0;\n    RoundWinTimer = 120;\n    for (auto&amp; StoredObj : StoredBattleObjects)\n        StoredObj = nullptr;\n    CurrentAirJumpCount = AirJumpCount;\n    CurrentAirDashCount = AirDashCount;\n    AirDashTimerMax = 0;\n    CancelFlags = 0;\n    GetStateMachine(StateMachine_Primary).EnableFlags = 0;\n    for (auto&amp; StateMachine : SubStateMachines)\n    {\n        if (!StateMachine.States.IsEmpty())\n            StateMachine.CurrentState = StateMachine.States[0];\n        StateMachine.EnableFlags = 0;\n    }\n    AirDashNoAttackTime = 0;\n    InstantBlockLockoutTimer = 0;\n    MeterCooldownTimer = 0;\n    for (auto&amp; LinkActor : StoredLinkActors)\n    {\n        LinkActor.bIsActive = false;\n        LinkActor.StoredActor-&gt;SetActorHiddenInGame(true);\n    }\n    for (int32&amp; CancelOption : AutoComboCancels)\n    {\n        CancelOption = -1;\n    }\n    GetStateMachine(StateMachine_Primary).EnabledCustomStateTypes.Empty();\n    for (auto&amp; StateMachine : SubStateMachines)\n    {\n        StateMachine.EnabledCustomStateTypes.Empty();\n    }\n    ChainCancelOptions.Empty();\n    WhiffCancelOptions.Empty();\n    MovesUsedInCombo.Empty();\n    LastStateName = FGameplayTag();\n    ExeStateName = FGameplayTag();\n    BufferedStateName = FGameplayTag();\n    WallTouchTimer = 0;\n    GameState-&gt;BattleState.MaxMeter[PlayerIndex] = MaxMeter;\n    SetDefaultComponentVisibility();\n    if (PlayerIndex == 1)\n    {\n        SetFacing(DIR_Left);\n    }\n    RoundInit_BP();\n\n    CallSubroutine(Subroutine_Cmn_RoundInit);\n    CallSubroutine(Subroutine_RoundInit);\n}\n\nvoid APlayerObject::HandleFlipInput()\n{\n    if ((Direction == DIR_Left &amp;&amp; !FlipInputs) || (FlipInputs &amp;&amp; Direction == DIR_Right))\n        //flip inputs with direction\n    {\n        Inputs = FlipInput(Inputs);\n    }\n}\n\nvoid APlayerObject::HandleEndCombo()\n{\n    if (!CheckIsStunned() &amp;&amp; IsMainPlayer() &amp;&amp; Enemy-&gt;ComboCounter)\n    {\n        Enemy-&gt;ComboCounter = 0;\n        Enemy-&gt;ComboTimer = 0;\n        Enemy-&gt;CallSubroutine(Subroutine_Cmn_OnComboEnd);\n        Enemy-&gt;CallSubroutine(Subroutine_OnComboEnd);\n        ReceivedHitCommon = FHitDataCommon();\n        ReceivedHit = FHitData();\n        TotalProration = 10000;\n        OTGCount = 0;\n        bCrumpled = false;\n    }\n}\n\nvoid APlayerObject::SaveForRollbackPlayer(unsigned char* Buffer) const\n{\n    FMemory::Memcpy(Buffer, &amp;PlayerSync, SizeOfPlayerObject);\n}\n\nTArray&lt;uint8&gt; APlayerObject::SaveForRollbackBP()\n{\n    TArray&lt;uint8&gt; SaveData;\n    FObjectWriter Writer(SaveData);\n    Writer.ArIsSaveGame = true;\n    GetClass()-&gt;SerializeBin(Writer, this);\n    return SaveData;\n}\n\nvoid APlayerObject::LoadForRollbackPlayer(const unsigned char* Buffer)\n{\n    FMemory::Memcpy(&amp;PlayerSync, Buffer, SizeOfPlayerObject);\n}\n\nvoid APlayerObject::LoadForRollbackBP(TArray&lt;uint8&gt; InBytes)\n{\n    if (InBytes.Num() &lt;= 1) return;\n    FObjectReader Reader(InBytes);\n    Reader.ArIsSaveGame = true;\n    GetClass()-&gt;SerializeBin(Reader, this);\n}\n\nvoid APlayerObject::EnableState(int32 EnableType, FGameplayTag StateMachineName)\n{\n    GetStateMachine(StateMachineName).EnableFlags |= EnableType;\n}\n\nvoid APlayerObject::DisableState(int32 EnableType, FGameplayTag StateMachineName)\n{\n    GetStateMachine(StateMachineName).EnableFlags = GetStateMachine(StateMachineName).EnableFlags &amp; ~EnableType;\n}\n\nint32 APlayerObject::GetEnableFlags(FGameplayTag StateMachineName)\n{\n    return GetStateMachine(StateMachineName).EnableFlags;\n}\n\nvoid APlayerObject::EnableCustomState(FGameplayTag CustomStateType, FGameplayTag StateMachineName)\n{\n    GetStateMachine(StateMachineName).EnabledCustomStateTypes.AddUnique(CustomStateType);\n}\n\nvoid APlayerObject::DisableCustomState(FGameplayTag CustomStateType, FGameplayTag StateMachineName)\n{\n    GetStateMachine(StateMachineName).EnabledCustomStateTypes.Remove(CustomStateType);\n}\n\nvoid APlayerObject::EnableAttacks()\n{\n    EnableState(ENB_NormalAttack, StateMachine_Primary);\n    EnableState(ENB_SpecialAttack, StateMachine_Primary);\n    EnableState(ENB_SuperAttack, StateMachine_Primary);\n}\n\nvoid APlayerObject::EnableCancelIntoSelf(bool Enable)\n{\n    if (Enable)\n    {\n        CancelFlags |= CNC_CancelIntoSelf;\n    }\n    else\n    {\n        CancelFlags &amp;= ~CNC_CancelIntoSelf;\n    }\n}\n\nvoid APlayerObject::EnableAll(FGameplayTag StateMachineName)\n{\n    EnableState(ENB_Standing, StateMachineName);\n    EnableState(ENB_Crouching, StateMachineName);\n    EnableState(ENB_Jumping, StateMachineName);\n    EnableState(ENB_ForwardWalk, StateMachineName);\n    EnableState(ENB_BackWalk, StateMachineName);\n    EnableState(ENB_ForwardDash, StateMachineName);\n    EnableState(ENB_BackDash, StateMachineName);\n    EnableState(ENB_ForwardAirDash, StateMachineName);\n    EnableState(ENB_BackAirDash, StateMachineName);\n    EnableState(ENB_NormalAttack, StateMachineName);\n    EnableState(ENB_SpecialAttack, StateMachineName);\n    EnableState(ENB_SuperAttack, StateMachineName);\n    EnableState(ENB_Block, StateMachineName);\n    EnableState(ENB_ProximityBlock, StateMachineName);\n    EnableState(ENB_Tech, StateMachineName);\n    EnableState(ENB_Burst, StateMachineName);\n    EnableState(ENB_Tag, StateMachineName);\n    EnableState(ENB_Assist, StateMachineName);\n}\n\nvoid APlayerObject::DisableAll(FGameplayTag StateMachineName)\n{\n    DisableState(ENB_Standing, StateMachineName);\n    DisableState(ENB_Crouching, StateMachineName);\n    DisableState(ENB_Jumping, StateMachineName);\n    DisableState(ENB_ForwardWalk, StateMachineName);\n    DisableState(ENB_BackWalk, StateMachineName);\n    DisableState(ENB_ForwardDash, StateMachineName);\n    DisableState(ENB_BackDash, StateMachineName);\n    DisableState(ENB_ForwardAirDash, StateMachineName);\n    DisableState(ENB_BackAirDash, StateMachineName);\n    DisableState(ENB_NormalAttack, StateMachineName);\n    DisableState(ENB_SpecialAttack, StateMachineName);\n    DisableState(ENB_SuperAttack, StateMachineName);\n    DisableState(ENB_Block, StateMachineName);\n    DisableState(ENB_ProximityBlock, StateMachineName);\n    DisableState(ENB_Tech, StateMachineName);\n    DisableState(ENB_Burst, StateMachineName);\n    DisableState(ENB_Tag, StateMachineName);\n    DisableState(ENB_Assist, StateMachineName);\n}\n\nbool APlayerObject::CheckInput(const FInputCondition&amp; Input)\n{\n    return StoredInputBuffer.CheckInputCondition(Input);\n}\n\nbool APlayerObject::CheckIsAttacking() const\n{\n    return AttackFlags &amp; ATK_IsAttacking;\n}\n\nbool APlayerObject::CheckHasHit() const\n{\n    return AttackFlags &amp; ATK_HasHit;\n}\n\nbool APlayerObject::CheckIsStunned() const\n{\n    return PlayerFlags &amp; PLF_IsStunned || PlayerFlags &amp; PLF_IsThrowLock || PlayerFlags &amp; PLF_IsDead\n        || PrimaryStateMachine.CurrentState-&gt;StateType == EStateType::Hitstun\n        || PrimaryStateMachine.CurrentState-&gt;StateType == EStateType::Blockstun;\n}\n\nvoid APlayerObject::AddAirJump(int32 NewAirJump)\n{\n    CurrentAirJumpCount += NewAirJump;\n}\n\nvoid APlayerObject::ResetAirJump()\n{\n    CurrentAirJumpCount = AirJumpCount;\n}\n\nvoid APlayerObject::AddAirDash(int32 NewAirDash)\n{\n    CurrentAirDashCount += NewAirDash;\n}\n\nvoid APlayerObject::ResetAirDash()\n{\n    CurrentAirDashCount = AirDashCount;\n}\n\nvoid APlayerObject::SetAirDashTimer(bool IsForward)\n{\n    if (IsForward)\n        AirDashTimer = FAirDashTime + 1;\n    else\n        AirDashTimer = BAirDashTime + 1;\n}\n\nvoid APlayerObject::SetAirDashNoAttackTimer(bool IsForward)\n{\n    if (IsForward)\n        AirDashNoAttackTime = FAirDashNoAttackTime + 1;\n    else\n        AirDashNoAttackTime = BAirDashNoAttackTime + 1;\n}\n\nvoid APlayerObject::AddChainCancelOption(FGameplayTag Option)\n{\n    ChainCancelOptions.AddUnique(PrimaryStateMachine.GetStateIndex(Option));\n}\n\nvoid APlayerObject::AddAutoComboCancel(FGameplayTag Option, EInputFlags Button)\n{\n    int32 Index;\n    switch (Button)\n    {\n    case INP_A:\n    default:\n        Index = 0;\n        break;\n    case INP_B:\n        Index = 1;\n        break;\n    case INP_C:\n        Index = 2;\n        break;\n    case INP_D:\n        Index = 3;\n        break;\n    case INP_E:\n        Index = 4;\n        break;\n    case INP_F:\n        Index = 5;\n        break;\n    case INP_G:\n        Index = 6;\n        break;\n    case INP_H:\n        Index = 7;\n        break;\n    }\n\n    AutoComboCancels[Index] = PrimaryStateMachine.GetStateIndex(Option);\n}\n\nvoid APlayerObject::AddWhiffCancelOption(FGameplayTag Option)\n{\n    WhiffCancelOptions.AddUnique(PrimaryStateMachine.GetStateIndex(Option));\n}\n\nvoid APlayerObject::RemoveChainCancelOption(FGameplayTag Option)\n{\n    ChainCancelOptions.Remove(PrimaryStateMachine.GetStateIndex(Option));\n}\n\nvoid APlayerObject::RemoveAutoComboCancel(EInputFlags Button)\n{\n    int32 Index;\n    switch (Button)\n    {\n    case INP_A:\n        Index = 0;\n        break;\n    case INP_B:\n        Index = 1;\n        break;\n    case INP_C:\n        Index = 2;\n        break;\n    case INP_D:\n        Index = 3;\n        break;\n    case INP_E:\n        Index = 4;\n        break;\n    case INP_F:\n        Index = 5;\n        break;\n    case INP_G:\n        Index = 6;\n        break;\n    case INP_H:\n        Index = 7;\n        break;\n    default: return;\n    }\n\n    AutoComboCancels[Index] = -1;\n}\n\nvoid APlayerObject::RemoveWhiffCancelOption(FGameplayTag Option)\n{\n    WhiffCancelOptions.Remove(PrimaryStateMachine.GetStateIndex(Option));\n}\n\nvoid APlayerObject::EnableChainCancel(bool Enable)\n{\n    if (Enable)\n    {\n        CancelFlags |= CNC_ChainCancelEnabled;\n    }\n    else\n    {\n        CancelFlags &amp;= ~CNC_ChainCancelEnabled;\n    }\n}\n\nvoid APlayerObject::EnableWhiffCancel(bool Enable)\n{\n    if (Enable)\n    {\n        CancelFlags |= CNC_WhiffCancelEnabled;\n    }\n    else\n    {\n        CancelFlags &amp;= ~CNC_WhiffCancelEnabled;\n    }\n}\n\nvoid APlayerObject::EnableReverseBeat(bool Enable)\n{\n    if (Enable)\n    {\n        CancelFlags |= CNC_EnableReverseBeat;\n    }\n    else\n    {\n        CancelFlags &amp;= ~CNC_EnableReverseBeat;\n    }\n}\n\nvoid APlayerObject::EnableJumpCancel(bool Enable)\n{\n    if (Enable)\n    {\n        CancelFlags |= CNC_JumpCancel;\n    }\n    else\n    {\n        CancelFlags &amp;= ~CNC_JumpCancel;\n    }\n}\n\nvoid APlayerObject::EnableSpecialCancel(bool Enable)\n{\n    if (Enable)\n    {\n        CancelFlags |= CNC_SpecialCancel;\n        CancelFlags |= CNC_SuperCancel;\n    }\n    else\n    {\n        CancelFlags &amp;= ~CNC_SpecialCancel;\n        CancelFlags &amp;= ~CNC_SuperCancel;\n    }\n}\n\nvoid APlayerObject::EnableSuperCancel(bool Enable)\n{\n    if (Enable)\n    {\n        CancelFlags |= CNC_SuperCancel;\n    }\n    else\n    {\n        CancelFlags &amp;= ~CNC_SuperCancel;\n    }\n}\n\nvoid APlayerObject::EnableForwardAirdashCancel(bool Enable)\n{\n    if (Enable)\n    {\n        CancelFlags |= CNC_FAirDashCancel;\n    }\n    else\n    {\n        CancelFlags &amp;= ~CNC_FAirDashCancel;\n    }\n}\n\nvoid APlayerObject::SetDefaultLandingAction(bool Enable)\n{\n    if (Enable)\n    {\n        PlayerFlags |= PLF_DefaultLandingAction;\n    }\n    else\n    {\n        PlayerFlags &amp;= ~PLF_DefaultLandingAction;\n    }\n}\n\nvoid APlayerObject::SetKnockdownState()\n{\n    StunTime = 0;\n    StunTimeMax = 0;\n    PlayerFlags |= PLF_IsKnockedDown;\n    if ((PlayerFlags &amp; PLF_IsHardKnockedDown) == 0 &amp;&amp; !(PlayerFlags &amp; PLF_IsDead))\n        EnableState(ENB_Tech, StateMachine_Primary);\n}\n\nbool APlayerObject::IsTouchingWall() const\n{\n    return PlayerFlags &amp; PLF_TouchingWall;\n}\n\nbool APlayerObject::IsInvulnerable(const ABattleObject* Attacker) const\n{\n    if (IsInvulnerable_BP()) return true;\n\n    if (PlayerFlags &amp; PLF_IsThrowLock &amp;&amp; Attacker != Enemy) return true;\n    if (Enemy-&gt;PlayerFlags &amp; PLF_IsThrowLock) return true;\n    if (InvulnFlags &amp; INV_StrikeInvulnerable || StrikeInvulnerableTimer) return true;\n    if (Attacker-&gt;AttackFlags &amp; ATK_AttackHeadAttribute &amp;&amp; InvulnFlags &amp; INV_HeadInvulnerable) return true;\n    if (Attacker-&gt;AttackFlags &amp; ATK_AttackProjectileAttribute &amp;&amp; InvulnFlags &amp; INV_ProjectileInvulnerable) return true;\n    if ((Attacker-&gt;AttackFlags &amp; ATK_HitOTG) == 0 &amp;&amp; PlayerFlags &amp; PLF_IsKnockedDown) return true;\n\n    return false;\n}\n\nvoid APlayerObject::SetStrikeInvulnerable(bool Invulnerable)\n{\n    if (Invulnerable)\n    {\n        InvulnFlags |= INV_StrikeInvulnerable;\n    }\n    else\n    {\n        InvulnFlags &amp;= ~INV_StrikeInvulnerable;\n    }\n}\n\nvoid APlayerObject::SetThrowInvulnerable(bool Invulnerable)\n{\n    if (Invulnerable)\n    {\n        InvulnFlags |= INV_ThrowInvulnerable;\n    }\n    else\n    {\n        InvulnFlags &amp;= ~INV_ThrowInvulnerable;\n    }\n}\n\nvoid APlayerObject::SetHeadInvulnerable(bool Invulnerable)\n{\n    if (Invulnerable)\n    {\n        InvulnFlags |= INV_HeadInvulnerable;\n    }\n    else\n    {\n        InvulnFlags &amp;= ~INV_HeadInvulnerable;\n    }\n}\n\nvoid APlayerObject::SetProjectileInvulnerable(bool Invulnerable)\n{\n    if (Invulnerable)\n    {\n        InvulnFlags |= INV_ProjectileInvulnerable;\n    }\n    else\n    {\n        InvulnFlags &amp;= ~INV_ProjectileInvulnerable;\n    }\n}\n\nvoid APlayerObject::SetStrikeInvulnerableForTime(int32 Timer)\n{\n    StrikeInvulnerableTimer = Timer;\n}\n\nvoid APlayerObject::SetThrowInvulnerableForTime(int32 Timer)\n{\n    ThrowInvulnerableTimer = Timer;\n}\n\nvoid APlayerObject::SetThrowResistForTime(int32 Timer)\n{\n    ThrowResistTimer = Timer;\n}\n\nvoid APlayerObject::SetStunTime(int32 NewTime)\n{\n    StunTime = NewTime;\n}\n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/","title":"File PlayerObject.h","text":"<p>FileList &gt; Battle &gt; Objects &gt; PlayerObject.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"BattleObject.h\"</code></li> <li><code>#include \"NativeGameplayTags.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Misc/InputBuffer.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Script/State.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Script/StateMachine.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/CollisionData.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/SequenceData.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/SoundData.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/StateData.h\"</code></li> <li><code>#include \"PlayerObject.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_player_object_8h/#classes","title":"Classes","text":"Type Name class APlayerObject struct FExtraGauge struct FPlayerObjectLog"},{"location":"NightSkyEngine/_player_object_8h/#public-types","title":"Public Types","text":"Type Name enum EActionStance"},{"location":"NightSkyEngine/_player_object_8h/#public-attributes","title":"Public Attributes","text":"Type Name int32 MaxComponentCount   = <code>64</code> size_t SizeOfPlayerObject   = <code>offsetof([**APlayerObject**](class_a_player_object.md), PlayerSyncEnd) - offsetof([**APlayerObject**](class_a_player_object.md), PlayerSync)</code>"},{"location":"NightSkyEngine/_player_object_8h/#public-functions","title":"Public Functions","text":"Type Name UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Label_Blowback_1)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Label_Blowback_2)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Label_Blowback_3)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Label_Blowback_4)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Label_Block_PreGuard)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Label_Block_Level1)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Label_Block_Level2)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Label_Block_Level3)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_Cmn_IsCorrectBlock)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_Cmn_HitCollision)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_Cmn_OnBlock)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_Cmn_OnHit)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_Cmn_OnCounterHit)"},{"location":"NightSkyEngine/_player_object_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"NightSkyEngine/_player_object_8h/#enum-eactionstance","title":"enum EActionStance","text":"<pre><code>enum EActionStance {\n    ACT_Standing,\n    ACT_Crouching,\n    ACT_Jumping\n};\n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/_player_object_8h/#variable-maxcomponentcount","title":"variable MaxComponentCount","text":"<pre><code>int32 MaxComponentCount;\n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#variable-sizeofplayerobject","title":"variable SizeOfPlayerObject","text":"<pre><code>size_t SizeOfPlayerObject;\n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_player_object_8h/#function-ue_declare_gameplay_tag_extern","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Label_Blowback_1\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#function-ue_declare_gameplay_tag_extern_1","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Label_Blowback_2\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#function-ue_declare_gameplay_tag_extern_2","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Label_Blowback_3\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#function-ue_declare_gameplay_tag_extern_3","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Label_Blowback_4\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#function-ue_declare_gameplay_tag_extern_4","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Label_Block_PreGuard\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#function-ue_declare_gameplay_tag_extern_5","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Label_Block_Level1\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#function-ue_declare_gameplay_tag_extern_6","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Label_Block_Level2\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#function-ue_declare_gameplay_tag_extern_7","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Label_Block_Level3\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#function-ue_declare_gameplay_tag_extern_8","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_Cmn_IsCorrectBlock\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#function-ue_declare_gameplay_tag_extern_9","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_Cmn_HitCollision\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#function-ue_declare_gameplay_tag_extern_10","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_Cmn_OnBlock\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#function-ue_declare_gameplay_tag_extern_11","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_Cmn_OnHit\n) \n</code></pre>"},{"location":"NightSkyEngine/_player_object_8h/#function-ue_declare_gameplay_tag_extern_12","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_Cmn_OnCounterHit\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Objects/PlayerObject.h</code></p>"},{"location":"NightSkyEngine/_player_object_8h_source/","title":"File PlayerObject.h","text":"<p>File List &gt; Battle &gt; Objects &gt; PlayerObject.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"BattleObject.h\"\n#include \"NativeGameplayTags.h\"\n#include \"NightSkyEngine/Battle/Misc/InputBuffer.h\"\n#include \"NightSkyEngine/Battle/Script/State.h\"\n#include \"NightSkyEngine/Battle/Script/StateMachine.h\"\n#include \"NightSkyEngine/Data/CollisionData.h\"\n#include \"NightSkyEngine/Data/SequenceData.h\"\n#include \"NightSkyEngine/Data/SoundData.h\"\n#include \"NightSkyEngine/Data/StateData.h\"\n#include \"PlayerObject.generated.h\"\n\nclass ULinkActorData;\nclass USubroutine;\nclass UCameraShakeData;\nconstexpr int32 MaxComponentCount = 64;\n\nclass USubroutineData;\nclass UStateData;\nclass UParticleData;\nclass UMaterialData;\n\nUENUM(BlueprintType)\nenum EActionStance\n{\n    ACT_Standing,\n    ACT_Crouching,\n    ACT_Jumping,\n};\n\nUSTRUCT(BlueprintType)\nstruct FExtraGauge\n{\n    GENERATED_BODY()\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, SaveGame)\n    int32 Value;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, SaveGame)\n    int32 InitialValue;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, SaveGame)\n    int32 MaxValue;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, SaveGame)\n    int32 Sections;\n};\n\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Blowback_1);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Blowback_2);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Blowback_3);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Blowback_4);\n\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Block_PreGuard);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Block_Level1);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Block_Level2);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Label_Block_Level3);\n\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_IsCorrectBlock);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_HitCollision);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_OnBlock);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_OnHit);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_OnCounterHit);\n\nUSTRUCT(BlueprintType)\nstruct FPlayerObjectLog : public FBattleObjectLog\n{\n    GENERATED_BODY()\n\n    //Starting from this until PlayerSyncEnd, everything is saved/loaded for rollback.\n    unsigned char PlayerSync;\n\n    /*\n     * Default values\n     */\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FWalkSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BWalkSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FDashInitSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FDashAccel;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FDashMaxSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FDashFriction;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BDashSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BDashHeight;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BDashGravity;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 JumpHeight;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FJumpSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BJumpSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 JumpGravity;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 SuperJumpHeight;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FSuperJumpSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BSuperJumpSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 SuperJumpGravity;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 AirDashMinimumHeight;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FAirDashSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BAirDashSpeed;\n    // Time until forward air dash properties stop applying.\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FAirDashTime;\n    // Time until backward air dash properties stop applying.\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BAirDashTime;\n    // Time until forward air dash can be cancelled.\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FAirDashNoAttackTime;\n    // Time until backward air dash can be cancelled.\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BAirDashNoAttackTime;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 AirJumpCount;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 AirDashCount;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 StandPushWidth;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 StandPushHeight;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 CrouchPushWidth;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 CrouchPushHeight;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 AirPushWidth;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 AirPushHeight;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 AirPushHeightLow;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 CloseNormalRange;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 MaxHealth;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 MaxMeter = 10000;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 ComboRate = 60;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 OtgProration = 80;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 ForwardWalkMeterGain;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 ForwardJumpMeterGain;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 ForwardDashMeterGain;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 ForwardAirDashMeterGain;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 MeterPercentOnHit = 72;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 MeterPercentOnHitGuard = 18;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 MeterPercentOnReceiveHitGuard = 10;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 MeterPercentOnReceiveHit = 40;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    bool CanReverseBeat;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    bool CanProximityThrow;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    FInputCondition ProximityThrowInput;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 ThrowTechWindow = 6;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 ThrowResistAfterWakeUp = 5;\n\n    /*\n     * Player registers. These are only touched by the engine to reset per round.\n     * Use these to keep track of values (timers, toggles, counters, etc) that are character-specific.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg1 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg2 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg3 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg4 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg5 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg6 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg7 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg8 = 0;\n\n    /*\n     * Common player registers. These are only touched by the engine to reset per round.\n     * These are meant to be used by any character.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg1 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg2 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg3 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg4 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg5 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg6 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg7 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg8 = 0;\n\n    UPROPERTY(BlueprintReadWrite)\n    bool IntroEndFlag = false;\n    UPROPERTY(BlueprintReadWrite)\n    bool RoundEndFlag = false;\n\n    /*\n     * Input data.\n     */\n    uint32 Inputs;\n\n    FInputBuffer StoredInputBuffer;\n\n    /*\n     * Miscellaneous values.\n     */\n\n    // If true, inputs will operate as if the character is facing the opposite direction.\n    UPROPERTY(BlueprintReadWrite)\n    bool FlipInputs;\n    UPROPERTY(EditAnywhere, Category=Defaults)\n    int32 MaxOTGCount;\n    UPROPERTY(EditAnywhere, Category=Defaults)\n    bool bLimitCrumple = true;\n\n    UPROPERTY(BlueprintReadOnly)\n    int32 PlayerIndex;\n    UPROPERTY(BlueprintReadOnly)\n    int32 TeamIndex;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    TEnumAsByte&lt;EActionStance&gt; Stance;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 CurrentHealth;\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 RecoverableHealth;\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 ComboCounter;\n\n    int32 TotalProration = 10000;\n    int32 ComboTimer;\n    uint32 InvulnFlags = 0;\n    uint32 PlayerFlags = 0;\n    uint32 StrikeInvulnerableTimer = 0;\n    uint32 ThrowInvulnerableTimer = 0;\n    uint32 ThrowResistTimer = 0;\n    uint32 AirDashTimer = 0;\n    int32 OTGCount;\n    bool bCrumpled;\n    int32 RoundWinTimer = 120;\n    int32 WallTouchTimer;\n\n    /*\n     * Object pointers.\n     */\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    APlayerObject* Enemy;\n    UPROPERTY()\n    ABattleObject* StoredBattleObjects[16];\n\n    bool ComponentVisible[MaxComponentCount];\n\n    FGameplayTag StateEntryName;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category=Intro)\n    FGameplayTag IntroName;\n\nprotected:\n    /*\n     * Internal values.\n     */\n    uint32 CurrentAirJumpCount = 0;\n    uint32 CurrentAirDashCount = 0;\n    uint32 AirDashTimerMax = 0;\n    uint32 CancelFlags = 0;\n    uint32 AirDashNoAttackTime = 0;\n    uint32 InstantBlockLockoutTimer = 0;\n    uint32 MeterCooldownTimer = 0;\n    int32 ThrowRange = 0;\n    int32 ThrowTechTimer = 0;\n\n    //Auto combo cancels\n    int32 AutoComboCancels[8] = {};\n\n    UPROPERTY(BlueprintReadOnly)\n    bool bIsAutoCombo = false;\n    FGameplayTag LastStateName;\n    FGameplayTag ExeStateName;\n    FGameplayTag BufferedStateName;\n\npublic:\n    // Anything past here isn't saved or loaded for rollback, unless it has the SaveGame tag.\n    unsigned char PlayerSyncEnd;\n\n    virtual void LogForSyncTestFile(std::ofstream&amp; file) override;\n};\n\nUCLASS()\nclass NIGHTSKYENGINE_API APlayerObject : public ABattleObject\n{\n    GENERATED_BODY()\n\npublic:\n    APlayerObject();\n\n    //Starting from this until PlayerSyncEnd, everything is saved/loaded for rollback.\n    unsigned char PlayerSync;\n\n    /*\n     * Default values\n     */\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FWalkSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BWalkSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FDashInitSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FDashAccel;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FDashMaxSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FDashFriction;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BDashSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BDashHeight;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BDashGravity;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 JumpHeight;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FJumpSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BJumpSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 JumpGravity;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 SuperJumpHeight;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FSuperJumpSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BSuperJumpSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 SuperJumpGravity;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 AirDashMinimumHeight;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FAirDashSpeed;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BAirDashSpeed;\n    // Time until forward air dash properties stop applying.\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FAirDashTime;\n    // Time until backward air dash properties stop applying.\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BAirDashTime;\n    // Time until forward air dash can be cancelled.\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 FAirDashNoAttackTime;\n    // Time until backward air dash can be cancelled.\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 BAirDashNoAttackTime;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 AirJumpCount;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 AirDashCount;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 StandPushWidth;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 StandPushHeight;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 CrouchPushWidth;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 CrouchPushHeight;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 AirPushWidth;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 AirPushHeight;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 AirPushHeightLow;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 CloseNormalRange;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 MaxHealth;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 MaxMeter = 10000;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 ComboRate = 60;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 OtgProration = 80;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 ForwardWalkMeterGain;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 ForwardJumpMeterGain;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 ForwardDashMeterGain;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 ForwardAirDashMeterGain;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 MeterPercentOnHit = 72;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 MeterPercentOnHitGuard = 18;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 MeterPercentOnReceiveHitGuard = 10;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 MeterPercentOnReceiveHit = 40;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    bool CanReverseBeat;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    bool CanProximityThrow;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    FInputCondition ProximityThrowInput;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 ThrowTechWindow = 6;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Defaults)\n    int32 ThrowResistAfterWakeUp = 5;\n\n    /*\n     * Player registers. These are only touched by the engine to reset per round.\n     * Use these to keep track of values (timers, toggles, counters, etc) that are character-specific.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg1 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg2 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg3 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg4 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg5 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg6 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg7 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 PlayerReg8 = 0;\n\n    /*\n     * Common player registers. These are only touched by the engine to reset per round.\n     * These are meant to be used by any character.\n     */\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg1 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg2 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg3 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg4 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg5 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg6 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg7 = 0;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CmnPlayerReg8 = 0;\n\n    UPROPERTY(BlueprintReadWrite)\n    bool IntroEndFlag = false;\n    UPROPERTY(BlueprintReadWrite)\n    bool RoundEndFlag = false;\n\n    /*\n     * Input data.\n     */\n    uint32 Inputs;\n\n    FInputBuffer StoredInputBuffer;\n\n    /*\n     * Miscellaneous values.\n     */\n\n    // If true, inputs will operate as if the character is facing the opposite direction.\n    UPROPERTY(BlueprintReadWrite)\n    bool FlipInputs;\n    UPROPERTY(EditAnywhere, Category=Defaults)\n    int32 MaxOTGCount;\n    UPROPERTY(EditAnywhere, Category=Defaults)\n    bool bLimitCrumple = true;\n\n    UPROPERTY(BlueprintReadOnly)\n    int32 PlayerIndex;\n    UPROPERTY(BlueprintReadOnly)\n    int32 TeamIndex;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    TEnumAsByte&lt;EActionStance&gt; Stance;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 CurrentHealth;\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 RecoverableHealth;\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 ComboCounter;\n\n    int32 TotalProration = 10000;\n    int32 ComboTimer;\n    uint32 InvulnFlags = 0;\n    uint32 PlayerFlags = 0;\n    uint32 StrikeInvulnerableTimer = 0;\n    uint32 ThrowInvulnerableTimer = 0;\n    uint32 ThrowResistTimer = 0;\n    uint32 AirDashTimer = 0;\n    int32 OTGCount;\n    bool bCrumpled;\n    int32 RoundWinTimer = 120;\n    int32 WallTouchTimer;\n\n    /*\n     * Object pointers.\n     */\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    APlayerObject* Enemy;\n    UPROPERTY()\n    ABattleObject* StoredBattleObjects[16];\n\n    bool ComponentVisible[MaxComponentCount];\n\n    FGameplayTag StateEntryName;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category=Intro)\n    FGameplayTag IntroName;\n\nprotected:\n    /*\n     * Internal values.\n     */\n    uint32 CurrentAirJumpCount = 0;\n    uint32 CurrentAirDashCount = 0;\n    uint32 AirDashTimerMax = 0;\n    uint32 CancelFlags = 0;\n    uint32 AirDashNoAttackTime = 0;\n    uint32 InstantBlockLockoutTimer = 0;\n    uint32 MeterCooldownTimer = 0;\n    int32 ThrowRange = 0;\n    int32 ThrowTechTimer = 0;\n\n    //Auto combo cancels\n    int32 AutoComboCancels[8] = {};\n\n    UPROPERTY(BlueprintReadOnly)\n    bool bIsAutoCombo = false;\n    FGameplayTag LastStateName;\n    FGameplayTag ExeStateName;\n    FGameplayTag BufferedStateName;\n\npublic:\n    // Anything past here isn't saved or loaded for rollback, unless it has the SaveGame tag.\n    unsigned char PlayerSyncEnd;\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    bool bIsCpu = false;\n\n    /*\n     * These properties are saved and loaded for rollback, as they have the SaveGame tag.\n     */\n\n    UPROPERTY(SaveGame)\n    FStateMachine PrimaryStateMachine;\n\n    UPROPERTY(EditDefaultsOnly, SaveGame)\n    TArray&lt;FStateMachine&gt; SubStateMachines;\n\n    // All instances of actors needed for link actors.\n    UPROPERTY(SaveGame)\n    TArray&lt;FLinkedActorContainer&gt; StoredLinkActors;\n\n    // Extra gauges.\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, SaveGame, Category=Defaults)\n    TArray&lt;FExtraGauge&gt; ExtraGauges;\n\n    //options to whiff cancel into\n    UPROPERTY(SaveGame)\n    TArray&lt;int32&gt; ChainCancelOptions;\n    //options to chain cancel into\n    UPROPERTY(SaveGame)\n    TArray&lt;int32&gt; WhiffCancelOptions;\n    //checks state indices for moves used in current combo\n    UPROPERTY(SaveGame)\n    TArray&lt;int32&gt; MovesUsedInCombo = {};\n    //checks state indices for moves used in current combo\n    UPROPERTY(SaveGame)\n    TArray&lt;int32&gt; MovesUsedInChain = {};\n\n    /*\n     * Defaults\n     */\n\n    UPROPERTY(EditAnywhere, Category=Defaults)\n    TMap&lt;FGameplayTag, FGameplayTag&gt; DamageReactionCels;\n    UPROPERTY(EditAnywhere, Category=Defaults)\n    bool bMirrorWhenFlip;\n\n    /*\n     * States and subroutines\n    */\n\n    UPROPERTY()\n    TArray&lt;USubroutine*&gt; CommonSubroutines;\n    TArray&lt;FGameplayTag&gt; CommonSubroutineNames;\n    UPROPERTY()\n    TArray&lt;USubroutine*&gt; Subroutines;\n    TArray&lt;FGameplayTag&gt; SubroutineNames;\n\n    UPROPERTY()\n    TArray&lt;UState*&gt; CommonObjectStates;\n    TArray&lt;FGameplayTag&gt; CommonObjectStateNames;\n    UPROPERTY()\n    TArray&lt;UState*&gt; ObjectStates;\n    TArray&lt;FGameplayTag&gt; ObjectStateNames;\n\n    /*\n     * Data assets\n     */\n\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)\n    UCollisionData* CommonCollisionData;\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)\n    UCollisionData* CollisionData;\n\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)\n    USubroutineData* CommonSubroutineData;\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)\n    USubroutineData* CharaSubroutineData;\n\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)\n    UStateData* CommonObjectStateData;\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)\n    UStateData* ObjectStateData;\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)\n    UStateData* CharaStateData;\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)\n    TMap&lt;FGameplayTag, UStateData*&gt; SubStateData;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Assets)\n    UMaterialData* MaterialData;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Assets)\n    int32 ColorIndex = 1;\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)\n    int32 MaxColorIndex = 2;\n\n    UPROPERTY(EditAnywhere, Category=Assets)\n    ULinkActorData* CommonLinkActorData;\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)\n    ULinkActorData* LinkActorData;\n\n    UPROPERTY(EditAnywhere, Category=Assets)\n    UParticleData* CommonParticleData;\n    UPROPERTY(EditAnywhere, Category=Assets)\n    UParticleData* CharaParticleData;\n\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)\n    USequenceData* CommonSequenceData;\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)\n    USequenceData* SequenceData;\n    UPROPERTY(EditAnywhere, Category=Assets)\n    UCameraShakeData* CameraShakeData;\n\n    UPROPERTY(EditAnywhere, Category=Assets)\n    USoundData* CommonSoundData;\n    UPROPERTY(EditAnywhere, Category=Assets)\n    USoundData* SoundData;\n    UPROPERTY(EditAnywhere, Category=Assets)\n    USoundData* VoiceData;\n\nprivate:\n    virtual void BeginPlay() override;\n\n    void HandleLanding();\n    //check state conditions\n    bool HandleStateCondition(EStateCondition StateCondition) const;\n    //check if chain cancel option exists\n    bool FindChainCancelOption(const FGameplayTag Name, FStateMachine&amp; StateMachine);\n    //check if chain cancel option exists\n    bool FindAutoComboCancelOption(const FGameplayTag Name, FStateMachine&amp; StateMachine);\n    //check if whiff cancel option exists\n    bool FindWhiffCancelOption(const FGameplayTag Name, FStateMachine&amp; StateMachine);\n    //check reverse beat\n    bool CheckReverseBeat(const FGameplayTag Name, FStateMachine&amp; StateMachine);\n    //checks moves used in combo\n    bool CheckMovesUsedInChain(const FGameplayTag Name, FStateMachine&amp; StateMachine);\n    //handles throwing objects\n    void HandleThrowCollision();\n    //checks kara cancel\n    bool CheckKaraCancel(EStateType InStateType, const FStateMachine&amp; StateMachine);\n    //checks if a child object with a corresponding object id exists. if so, do not enter state \n    bool CheckObjectPreventingState(int InObjectID) const;\n    //handles wall bounce\n    void HandleWallBounce();\n    //handles ground bounce\n    void HandleGroundBounce();\n    void SetComponentVisibility() const;\n    virtual void UpdateVisualsNoRollback() override;\n\npublic:\n    //initialize player for match/round start\n    void InitPlayer();\n    //update object\n    virtual void Update() override;\n    // handle state machine\n    void HandleStateMachine(bool Buffer, FStateMachine&amp; StateMachine);\n    // handle auto combos for state transition\n    bool HandleAutoCombo(int32 StateIndex, FStateMachine&amp; StateMachine);\n    // handle input conditions for state transition\n    bool HandleStateInputs(int32 StateIndex, bool Buffer, FStateMachine&amp; StateMachine);\n    // handle state transition\n    bool HandleStateTransition(int32 StateIndex, bool Buffer, FStateMachine&amp; StateMachine);\n    //buffer state\n    void HandleBufferedState();\n    void HandleBufferedState(FStateMachine&amp; StateMachine);\n    //update object for non-battle modes (like character select)\n    void UpdateNotBattle();\n    //update object (editor only, compiled out otherwise)\n    UFUNCTION(BlueprintNativeEvent)\n    void EditorUpdate();\n    //based on received hit action, choose state\n    void HandleHitAction(EHitAction HACT);\n    //upon successful throw, jump to state\n    void ThrowExe();\n    //set hit values over time\n    void SetHitValuesOverTime();\n    //check attack against block stance\n    bool IsCorrectBlock(EBlockType BlockType);\n    //jump to correct block state\n    void HandleBlockAction();\n    //handles proximity blocking\n    void HandleProximityBlock();\n    //called right before state changes\n    void OnStateChange();\n    //called right after state changes\n    void PostStateChange();\n    //resets object for next round\n    void RoundInit(bool ResetHealth);\n    void HandleFlipInput();\n    void HandleEndCombo();\n\n    static uint32 FlipInput(uint32 Input);\n\n\n    void SaveForRollbackPlayer(unsigned char* Buffer) const;\n    TArray&lt;uint8&gt; SaveForRollbackBP();\n    void LoadForRollbackPlayer(const unsigned char* Buffer);\n    void LoadForRollbackBP(TArray&lt;uint8&gt; InBytes);\n    void EmptyStateMachine();\n\n    // Only call when initializing the match.\n    UFUNCTION(BlueprintImplementableEvent)\n    void InitBP();\n    // Only call when resetting player object for round.\n    UFUNCTION(BlueprintImplementableEvent)\n    void RoundInit_BP();\n\n    /*\n     * Blueprint callable functions.\n     */\n    //add state to state machine\n    UFUNCTION(BlueprintCallable)\n    void AddState(FGameplayTag Name, UState* State, FGameplayTag StateMachineName);\n    //add object state\n    UFUNCTION(BlueprintCallable)\n    void AddObjectState(FGameplayTag Name, UState* State, bool IsCommon);\n    //add subroutine to state machine\n    UFUNCTION(BlueprintCallable)\n    void AddSubroutine(FGameplayTag Name, USubroutine* Subroutine, bool IsCommon);\n    UFUNCTION(BlueprintCallable)\n    void SetHealth(int Value);\n    UFUNCTION(BlueprintCallable)\n    void AddHealth(int Value);\n    UFUNCTION(BlueprintCallable)\n    void SetRecoverableHealth(int Value);\n    UFUNCTION(BlueprintCallable)\n    void AddRecoverableHealth(int Value);\n    UFUNCTION(BlueprintCallable)\n    void RecoverHealth(int Value);\n    //check if state can be entered\n    UFUNCTION(BlueprintCallable)\n    bool CanEnterState(UState* State, FGameplayTag StateMachineName);\n    //use meter\n    UFUNCTION(BlueprintCallable)\n    void UseMeter(int Use);\n    //add meter\n    UFUNCTION(BlueprintCallable)\n    void AddMeter(int Meter);\n    //sets meter gain cooldown timer\n    UFUNCTION(BlueprintCallable)\n    void SetMeterCooldownTimer(int Timer);\n    //set stance\n    UFUNCTION(BlueprintCallable)\n    void SetStance(EActionStance InStance);\n    //force set state\n    bool JumpToStatePrimary (FGameplayTag NewName, bool IsLabel = false);\n    //force set state\n    UFUNCTION(BlueprintCallable, CallInEditor)\n    bool JumpToState(FGameplayTag NewName, FGameplayTag StateMachineName, bool IsLabel = false);\n    //force set state\n    bool JumpToStateByClassPrimary(TSubclassOf&lt;UState&gt; Class, bool IsLabel = false);\n    //force set state\n    UFUNCTION(BlueprintCallable, CallInEditor)\n    bool JumpToStateByClass(TSubclassOf&lt;UState&gt; Class, FGameplayTag StateMachineName, bool IsLabel = false);\n    //gets current state name\n    UFUNCTION(BlueprintPure)\n    FGameplayTag GetCurrentStateName(FGameplayTag StateMachineName);\n    //gets last state name\n    UFUNCTION(BlueprintPure)\n    FGameplayTag GetLastStateName() const;\n    //gets state entry name\n    UFUNCTION(BlueprintPure)\n    FGameplayTag GetStateEntryName() const;\n    // Get state machine by name.\n    UFUNCTION(BlueprintPure)\n    FStateMachine&amp; GetStateMachine(FGameplayTag StateMachineName);\n    // Get enable flags.\n    UFUNCTION(BlueprintPure)\n    int32 GetEnableFlags(FGameplayTag StateMachineName);\n    // check if state can be entered\n    UFUNCTION(BlueprintPure)\n    bool CheckStateEnabled(EStateType StateType, FGameplayTag CustomStateType, FGameplayTag StateMachineName);\n    //enable state type\n    UFUNCTION(BlueprintCallable)\n    void EnableState(UPARAM(meta = (Bitmask, BitmaskEnum = \"/Script/NightSkyEngine.EEnableFlags\"))\n        int32 Bitmask, FGameplayTag StateMachineName);\n    //disables state type\n    UFUNCTION(BlueprintCallable)\n    void DisableState(UPARAM(meta = (Bitmask, BitmaskEnum = \"/Script/NightSkyEngine.EEnableFlags\"))\n        int32 Bitmask, FGameplayTag StateMachineName);\n    //enable custom state type\n    UFUNCTION(BlueprintCallable)\n    void EnableCustomState(FGameplayTag CustomStateType, FGameplayTag StateMachineName);\n    //disable custom state type\n    UFUNCTION(BlueprintCallable)\n    void DisableCustomState(FGameplayTag CustomStateType, FGameplayTag StateMachineName);\n    //enable all attacks only\n    UFUNCTION(BlueprintCallable)\n    void EnableAttacks();\n    //enable cancelling into same state\n    UFUNCTION(BlueprintCallable)\n    void EnableCancelIntoSelf(bool Enable);\n    //enables all state types\n    UFUNCTION(BlueprintCallable)\n    void EnableAll(FGameplayTag StateMachineName);\n    //disable all state types\n    UFUNCTION(BlueprintCallable)\n    void DisableAll(FGameplayTag StateMachineName);\n    //checks input condition\n    UFUNCTION(BlueprintPure)\n    bool CheckInput(const FInputCondition&amp; Input);\n    //is attacking\n    UFUNCTION(BlueprintPure)\n    bool CheckIsAttacking() const;\n    //has hit\n    UFUNCTION(BlueprintPure)\n    bool CheckHasHit() const;\n    UFUNCTION(BlueprintPure)\n    bool CheckIsStunned() const;\n    //temporarily adds air jump\n    UFUNCTION(BlueprintCallable)\n    void AddAirJump(int32 NewAirJump);\n    //reset air jump\n    UFUNCTION(BlueprintCallable)\n    void ResetAirJump();\n    //temporarily adds air dash\n    UFUNCTION(BlueprintCallable)\n    void AddAirDash(int32 NewAirDash);\n    //reset air jump\n    UFUNCTION(BlueprintCallable)\n    void ResetAirDash();\n    //set air dash timer (set is forward for forward airdashes)\n    UFUNCTION(BlueprintCallable)\n    void SetAirDashTimer(bool IsForward);\n    //set air dash timer (set is forward for forward airdashes)\n    UFUNCTION(BlueprintCallable)\n    void SetAirDashNoAttackTimer(bool IsForward);\n    //add chain cancel option, use this in Init\n    UFUNCTION(BlueprintCallable)\n    void AddChainCancelOption(FGameplayTag Option);\n    //add auto combo option, use this in Init\n    UFUNCTION(BlueprintCallable)\n    void AddAutoComboCancel(FGameplayTag Option, EInputFlags Button);\n    //add whiff cancel option, use this in Init\n    UFUNCTION(BlueprintCallable)\n    void AddWhiffCancelOption(FGameplayTag Option);\n    //remove chain cancel option\n    UFUNCTION(BlueprintCallable)\n    void RemoveChainCancelOption(FGameplayTag Option);\n    //remove auto combo cancel\n    UFUNCTION(BlueprintCallable)\n    void RemoveAutoComboCancel(EInputFlags Button);\n    //remove whiff cancel option\n    UFUNCTION(BlueprintCallable)\n    void RemoveWhiffCancelOption(FGameplayTag Option);\n    UFUNCTION(BlueprintCallable)\n    void EnableChainCancel(bool Enable);\n    //sets whiff cancel options enabled. off by default\n    UFUNCTION(BlueprintCallable)\n    void EnableWhiffCancel(bool Enable);\n    //enables reverse beat\n    UFUNCTION(BlueprintCallable)\n    void EnableReverseBeat(bool Enable);\n    //enables jump cnacel\n    UFUNCTION(BlueprintCallable)\n    void EnableJumpCancel(bool Enable);\n    //sets special cancel enabled. off by default\n    UFUNCTION(BlueprintCallable)\n    void EnableSpecialCancel(bool Enable);\n    //sets super cancel enabled. off by default\n    UFUNCTION(BlueprintCallable)\n    void EnableSuperCancel(bool Enable);\n    //enables forward airdash cnacel\n    UFUNCTION(BlueprintCallable)\n    void EnableForwardAirdashCancel(bool Enable);\n    //toggles default landing action. if true, landing will go to JumpLanding state. if false, define your own landing.\n    UFUNCTION(BlueprintCallable)\n    void SetDefaultLandingAction(bool Enable);\n    UFUNCTION(BlueprintCallable)\n    void SetKnockdownState();\n    // check if touching wall\n    UFUNCTION(BlueprintCallable)\n    bool IsTouchingWall() const;\n    //checks if invulnerable\n    UFUNCTION(BlueprintPure)\n    bool IsInvulnerable(const ABattleObject* Attacker) const;\n    //sets strike invulnerable enabled\n    UFUNCTION(BlueprintCallable)\n    void SetStrikeInvulnerable(bool Invulnerable);\n    //sets throw invulnerable enabled\n    UFUNCTION(BlueprintCallable)\n    void SetThrowInvulnerable(bool Invulnerable);\n    UFUNCTION(BlueprintCallable)\n    void SetHeadInvulnerable(bool Invulnerable);\n    UFUNCTION(BlueprintCallable)\n    void SetProjectileInvulnerable(bool Invulnerable);\n    //sets strike invulnerable enabled for time\n    UFUNCTION(BlueprintCallable)\n    void SetStrikeInvulnerableForTime(int32 Timer);\n    //sets throw invulnerable enabled for time\n    UFUNCTION(BlueprintCallable)\n    void SetThrowInvulnerableForTime(int32 Timer);\n    //sets throw resist enabled for time\n    UFUNCTION(BlueprintCallable)\n    void SetThrowResistForTime(int32 Timer);\n    //sets projectile invulnerable enabled\n    //set stun time\n    UFUNCTION(BlueprintCallable)\n    void SetStunTime(int32 NewTime);\n    //based on received hit data, set values\n    UFUNCTION(BlueprintCallable)\n    void SetHitValues(bool bCustomAir = false);\n    //based on received guard data, set values\n    UFUNCTION(BlueprintCallable)\n    void SetGuardValues();\n    //force enables far proximity normals\n    UFUNCTION(BlueprintCallable)\n    void ForceEnableFarNormal(bool Enable);\n    UFUNCTION(BlueprintCallable)\n    void SetHeadAttribute(bool Attribute);\n    //initiate throw\n    UFUNCTION(BlueprintCallable)\n    void SetThrowActive(bool Active);\n    //end throw\n    UFUNCTION(BlueprintCallable)\n    void ThrowEnd();\n    //initiate throw range\n    UFUNCTION(BlueprintCallable)\n    void SetThrowRange(int32 InThrowRange);\n    //sets throw execution state\n    UFUNCTION(BlueprintCallable)\n    void SetThrowExeState(FGameplayTag ExeState);\n    //sets grip position for throw\n    UFUNCTION(BlueprintCallable)\n    void SetThrowPosition(int32 ThrowPosX, int32 ThrowPosY);\n    //sets grip position for throw\n    UFUNCTION(BlueprintCallable)\n    void SetDamageReactionCel(FGameplayTag Type);\n    // initiate hitgrab\n    UFUNCTION(BlueprintCallable)\n    void SetHitgrabActive(bool Active);\n    //plays voice line\n    UFUNCTION(BlueprintCallable)\n    void PlayVoiceLine(FGameplayTag Name);\n    //plays common level sequence\n    UFUNCTION(BlueprintCallable)\n    void PlayCommonLevelSequence(FGameplayTag Name);\n    //plays character level sequence\n    UFUNCTION(BlueprintCallable)\n    void PlayLevelSequence(FGameplayTag Name);\n    //stop level sequence\n    UFUNCTION(BlueprintCallable)\n    void StopLevelSequence();\n    //toggles hud visibility\n    UFUNCTION(BlueprintCallable)\n    void BattleHudVisibility(bool Visible);\n    //ends round\n    UFUNCTION(BlueprintCallable)\n    void EndRound() const;\n    //match round\n    UFUNCTION(BlueprintCallable)\n    void EndMatch() const;\n    //pauses round timer\n    UFUNCTION(BlueprintCallable)\n    void PauseRoundTimer(bool Pause);\n    //stores battle actor in slot\n    UFUNCTION(BlueprintCallable)\n    void AddBattleObjectToStorage(ABattleObject* InActor, int Index);\n    UFUNCTION(BlueprintCallable)\n    APlayerObject* CallAssist(int AssistIndex, FGameplayTag AssistName);\n    UFUNCTION(BlueprintCallable)\n    APlayerObject* SwitchMainPlayer(int NewTeamIndex, bool bForce = false, bool bEvenOnScreen = false);\n    UFUNCTION(BlueprintCallable)\n    void SetTeamCooldown(int NewTeamIndex, int Cooldown);\n    UFUNCTION(BlueprintPure)\n    bool IsMainPlayer() const;\n    UFUNCTION(BlueprintPure)\n    bool IsOnScreen() const;\n    UFUNCTION(BlueprintCallable)\n    void SetOnScreen(bool OnScreen);\n    UFUNCTION(BlueprintCallable)\n    void ToggleComponentVisibility(FName ComponentName, bool Visible);\n    UFUNCTION(BlueprintImplementableEvent, BlueprintCallable)\n    void SetDefaultComponentVisibility();\n    UFUNCTION(BlueprintImplementableEvent)\n    bool IsInvulnerable_BP() const;\n\n    // Intended for CPU opponents\n    void SetStateForCPU(FGameplayTag StateName, FGameplayTag StateMachineName);\n    bool CheckEnemyInRange(int32 XBegin, int32 XEnd, int32 YBegin, int32 YEnd) const;\n    bool IsEnemyAttackState() const;\n    bool IsEnemyThrow() const;\n    bool IsEnemyBlocking() const;\n    EBlockType GetAttackBlockType() const;\n};\n\nconstexpr size_t SizeOfPlayerObject = offsetof(APlayerObject, PlayerSyncEnd) - offsetof(APlayerObject, PlayerSync);\n\n#if WITH_EDITOR\nstatic_assert(offsetof(FPlayerObjectLog, PlayerSyncEnd) - offsetof(FPlayerObjectLog, PlayerSync) == SizeOfPlayerObject, \"FPlayerObjectLog must contain all members from ABattleObject between PlayerSync and PlayerSyncEnd\");\n#endif\n</code></pre>"},{"location":"NightSkyEngine/dir_0ca77fec7001245ae32841da8dbaa106/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script","text":"<p>FileList &gt; Battle &gt; Script</p>"},{"location":"NightSkyEngine/dir_0ca77fec7001245ae32841da8dbaa106/#files","title":"Files","text":"Type Name file BattleExtension.cpp file BattleExtension.h file State.cpp file State.h file StateAlias.h file StateMachine.cpp file StateMachine.h file Subroutine.cpp file Subroutine.h file SubroutineState.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/</code></p>"},{"location":"NightSkyEngine/_battle_extension_8cpp/","title":"File BattleExtension.cpp","text":"<p>FileList &gt; Battle &gt; Script &gt; BattleExtension.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"BattleExtension.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/BattleExtension.cpp</code></p>"},{"location":"NightSkyEngine/_battle_extension_8cpp_source/","title":"File BattleExtension.cpp","text":"<p>File List &gt; Battle &gt; Script &gt; BattleExtension.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"BattleExtension.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(BattleExtension)\n\nvoid UBattleExtension::Exec_Implementation()\n{\n    //TODO implement Night Sky Script\n}\n</code></pre>"},{"location":"NightSkyEngine/_battle_extension_8h/","title":"File BattleExtension.h","text":"<p>FileList &gt; Battle &gt; Script &gt; BattleExtension.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/NightSkyGameState.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Misc/SerializableObj.h\"</code></li> <li><code>#include \"BattleExtension.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_battle_extension_8h/#classes","title":"Classes","text":"Type Name class UBattleExtension A customizable extension to the battle ruleset. <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/BattleExtension.h</code></p>"},{"location":"NightSkyEngine/_battle_extension_8h_source/","title":"File BattleExtension.h","text":"<p>File List &gt; Battle &gt; Script &gt; BattleExtension.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NightSkyEngine/Battle/NightSkyGameState.h\"\n#include \"NightSkyEngine/Battle/Misc/SerializableObj.h\"\n#include \"BattleExtension.generated.h\"\n\nUCLASS(BlueprintType, Blueprintable)\nclass NIGHTSKYENGINE_API UBattleExtension : public USerializableObj\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(BlueprintReadOnly)\n    ANightSkyGameState* Parent;\n\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    FGameplayTag Name;\n\n    UFUNCTION(BlueprintNativeEvent)\n    void Exec();\n};\n</code></pre>"},{"location":"NightSkyEngine/_state_8cpp/","title":"File State.cpp","text":"<p>FileList &gt; Battle &gt; Script &gt; State.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"State.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/State.cpp</code></p>"},{"location":"NightSkyEngine/_state_8cpp_source/","title":"File State.cpp","text":"<p>File List &gt; Battle &gt; Script &gt; State.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"State.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(State)\n\nvoid UState::Exec_Implementation()\n{\n}\n\nvoid UState::CallExec()\n{\n    CelIndex = 0;\n    Exec();\n}\n\nbool UState::CanEnterState_Implementation()\n{\n    return true;\n}\n</code></pre>"},{"location":"NightSkyEngine/_state_8h/","title":"File State.h","text":"<p>FileList &gt; Battle &gt; Script &gt; State.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Misc/Bitflags.h\"</code></li> <li><code>#include \"GameplayTagContainer.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Misc/SerializableObj.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Objects/BattleObject.h\"</code></li> <li><code>#include \"State.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_state_8h/#classes","title":"Classes","text":"Type Name struct FInputBitmask struct FInputCondition struct FInputConditionList struct FStateCPUData class UState A character state that determines behavior."},{"location":"NightSkyEngine/_state_8h/#public-types","title":"Public Types","text":"Type Name enum EAttackSpeed enum uint8 EEntryStance enum uint8 EInputMethod enum ERangeType enum uint8 EStateCondition enum uint8 EStateType"},{"location":"NightSkyEngine/_state_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"NightSkyEngine/_state_8h/#enum-eattackspeed","title":"enum EAttackSpeed","text":"<pre><code>enum EAttackSpeed {\n    ASPD_Fast,\n    ASPD_Medium,\n    ASPD_Slow\n};\n</code></pre> <p>Attack speed used for CPU behavior. </p>"},{"location":"NightSkyEngine/_state_8h/#enum-eentrystance","title":"enum EEntryStance","text":"<pre><code>enum EEntryStance {\n    None,\n    Standing,\n    Crouching,\n    Jumping\n};\n</code></pre> <p>What stance the character must be in to enter this state. Upon entering the state, the character will take this stance. </p>"},{"location":"NightSkyEngine/_state_8h/#enum-einputmethod","title":"enum EInputMethod","text":"<pre><code>enum EInputMethod {\n    Normal,\n    Strict,\n    Once,\n    OnceStrict,\n    PressAndRelease,\n    PressAndReleaseStrict,\n    Negative,\n    NegativeStrict\n};\n</code></pre> <p>Determines the method of which the input will be read. </p>"},{"location":"NightSkyEngine/_state_8h/#enum-erangetype","title":"enum ERangeType","text":"<pre><code>enum ERangeType {\n    RAN_Near,\n    RAN_Mid,\n    RAN_Far\n};\n</code></pre> <p>A range used for CPU behavior. </p>"},{"location":"NightSkyEngine/_state_8h/#enum-estatecondition","title":"enum EStateCondition","text":"<pre><code>enum EStateCondition {\n    None,\n    AirJumpOk,\n    AirJumpMinimumHeight,\n    AirDashOk,\n    AirDashMinimumHeight,\n    IsAttacking,\n    HitstopCancel,\n    IsStunned,\n    CloseNormal,\n    FarNormal,\n    CanTag2nd,\n    CanTag3rd,\n    MeterNotZero,\n    MeterQuarterBar,\n    MeterHalfBar,\n    MeterOneBar,\n    MeterTwoBars,\n    MeterThreeBars,\n    MeterFourBars,\n    MeterFiveBars,\n    PlayerReg1True,\n    PlayerReg2True,\n    PlayerReg3True,\n    PlayerReg4True,\n    PlayerReg5True,\n    PlayerReg6True,\n    PlayerReg7True,\n    PlayerReg8True,\n    PlayerReg1False,\n    PlayerReg2False,\n    PlayerReg3False,\n    PlayerReg4False,\n    PlayerReg5False,\n    PlayerReg6False,\n    PlayerReg7False,\n    PlayerReg8False\n};\n</code></pre> <p>A condition to enter the state.</p> <p>See also: APlayerObject::HandleStateCondition </p>"},{"location":"NightSkyEngine/_state_8h/#enum-estatetype","title":"enum EStateType","text":"<pre><code>enum EStateType {\n    Standing,\n    Crouching,\n    NeutralJump,\n    ForwardJump,\n    BackwardJump,\n    ForwardWalk,\n    BackwardWalk,\n    ForwardDash,\n    BackwardDash,\n    ForwardAirDash,\n    BackwardAirDash,\n    NormalAttack,\n    SpecialAttack,\n    SuperAttack,\n    Hitstun,\n    Blockstun,\n    Tech,\n    Burst,\n    Tag,\n    Assist,\n    Custom\n};\n</code></pre> <p>The type of state. State types can have the ability to enter them toggled on and off. </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/State.h</code></p>"},{"location":"NightSkyEngine/_state_8h_source/","title":"File State.h","text":"<p>File List &gt; Battle &gt; Script &gt; State.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NightSkyEngine/Battle/Misc/Bitflags.h\"\n#include \"GameplayTagContainer.h\"\n#include \"NightSkyEngine/Battle/Misc/SerializableObj.h\"\n#include \"NightSkyEngine/Battle/Objects/BattleObject.h\"\n#include \"State.generated.h\"\n\nclass APlayerObject;\nclass ABattleObject;\n\nUENUM(BlueprintType)\nenum class EEntryStance : uint8\n{\n    None,\n    Standing,\n    Crouching,\n    Jumping,\n};\n\nUENUM(BlueprintType)\nenum class EStateType : uint8\n{\n    Standing,\n    Crouching,\n    NeutralJump,\n    ForwardJump,\n    BackwardJump,\n    ForwardWalk,\n    BackwardWalk,\n    ForwardDash,\n    BackwardDash,\n    ForwardAirDash,\n    BackwardAirDash,\n    NormalAttack,\n    SpecialAttack,\n    SuperAttack,\n    Hitstun,\n    Blockstun,\n    Tech,\n    Burst,\n    Tag,\n    Assist,\n    Custom,\n};\n\nUENUM(BlueprintType)\nenum class EStateCondition : uint8\n{\n    None,\n    AirJumpOk,\n    AirJumpMinimumHeight,\n    AirDashOk,\n    AirDashMinimumHeight,\n    IsAttacking,\n    HitstopCancel,\n    IsStunned,\n    CloseNormal,\n    FarNormal,\n    CanTag2nd,\n    CanTag3rd,\n    MeterNotZero,\n    MeterQuarterBar,\n    MeterHalfBar,\n    MeterOneBar,\n    MeterTwoBars,\n    MeterThreeBars,\n    MeterFourBars,\n    MeterFiveBars,\n    PlayerReg1True,\n    PlayerReg2True,\n    PlayerReg3True,\n    PlayerReg4True,\n    PlayerReg5True,\n    PlayerReg6True,\n    PlayerReg7True,\n    PlayerReg8True,\n    PlayerReg1False,\n    PlayerReg2False,\n    PlayerReg3False,\n    PlayerReg4False,\n    PlayerReg5False,\n    PlayerReg6False,\n    PlayerReg7False,\n    PlayerReg8False,\n};\n\nUENUM()\nenum class EInputMethod : uint8\n{\n    /*\n     * The button or direction may be held indefinitely.\n     * Diagonal directions are counted as both of the cardinal directions it represents.\n     */\n    Normal,\n    /*\n     * The button or direction may be held indefinitely.\n     * Diagonal directions are not counted as either of the cardinal directions it represents.\n     */\n    Strict,\n    /*\n     * The button or direction will only be counted on first press until release.\n      * Diagonal directions are counted as both of the cardinal directions it represents.\n     */\n    Once,\n    /*\n     * The button or direction will only be counted on first press until release.\n     * Diagonal directions are not counted as either of the cardinal directions it represents.\n     * This is a combination of the Once and Strict methods.\n     */\n    OnceStrict,\n    /*\n     * The button or direction will only be counted when first pressed, then released.\n      * Diagonal directions are counted as both of the cardinal directions it represents.\n     */\n    PressAndRelease,\n    /*\n     * The button or direction will only be counted when first pressed, then released.\n     * Diagonal directions are not counted as either of the cardinal directions it represents.\n     * This is a combination of the Once and Strict methods.\n     */\n    PressAndReleaseStrict,\n    /*\n     * The button or direction will only be counted at the moment of release.\n      * Diagonal directions are counted as both of the cardinal directions it represents.\n     */\n    Negative,\n    /*\n     * The button or direction will only be counted at the moment of release.\n     * Diagonal directions are not counted as either of the cardinal directions it represents.\n     * This is a combination of the Negative and Strict methods.\n     */\n    NegativeStrict,\n};\n\nUSTRUCT(BlueprintType)\nstruct FInputBitmask\n{\n    GENERATED_BODY()\n\n    FInputBitmask()\n    {\n        InputFlag = INP_None;\n    };\n    FInputBitmask(EInputFlags Input)\n    {\n        InputFlag = Input;\n    };\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, meta = (Bitmask, BitmaskEnum = \"/Script/NightSkyEngine.EInputFlags\"))\n    int InputFlag;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    int32 Lenience = 3;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    int32 Hold = 0;\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    TArray&lt;TEnumAsByte&lt;EInputFlags&gt;&gt; DisallowedInputs;\n};\n\nUSTRUCT(BlueprintType)\nstruct FInputCondition\n{\n    GENERATED_BODY()\n\n\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    TArray&lt;FInputBitmask&gt; Sequence;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    TArray&lt;TEnumAsByte&lt;EInputFlags&gt;&gt; DisallowedInputs;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    int ImpreciseInputCount = 0;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    EInputMethod Method = EInputMethod::Normal;\n};\n\nUSTRUCT(BlueprintType)\nstruct FInputConditionList\n{\n    GENERATED_BODY()\n\n    UPROPERTY(EditAnywhere)\n    TArray&lt;FInputCondition&gt; InputConditions;\n};\n\nUENUM()\nenum ERangeType\n{\n    RAN_Near,\n    RAN_Mid,\n    RAN_Far,\n};\n\nUENUM()\nenum EAttackSpeed\n{\n    ASPD_Fast,\n    ASPD_Medium,\n    ASPD_Slow,\n};\n\nUSTRUCT()\nstruct FStateCPUData\n{\n    GENERATED_BODY()\n\n    UPROPERTY(EditAnywhere)\n    int32 AttackXBeginRange = 0;\n    UPROPERTY(EditAnywhere)\n    int32 AttackXEndRange = 300000;\n    UPROPERTY(EditAnywhere)\n    int32 AttackYBeginRange = 120000;\n    UPROPERTY(EditAnywhere)\n    int32 AttackYEndRange = 360000;\n    UPROPERTY(EditAnywhere)\n    bool bAttack;\n    UPROPERTY(EditAnywhere)\n    bool bCombo;\n    UPROPERTY(EditAnywhere)\n    bool bNoCombo;\n    UPROPERTY(EditAnywhere)\n    bool bBlockstring;\n    UPROPERTY(EditAnywhere)\n    bool bPunish;\n    UPROPERTY(EditAnywhere)\n    bool bAntiAir;\n    UPROPERTY(EditAnywhere)\n    bool bThrow;\n    UPROPERTY(EditAnywhere)\n    bool bProjectile;\n    UPROPERTY(EditAnywhere)\n    TEnumAsByte&lt;ERangeType&gt; PunishRange;\n    UPROPERTY(EditAnywhere)\n    TEnumAsByte&lt;EBlockType&gt; BlockType;\n    UPROPERTY(EditAnywhere)\n    TEnumAsByte&lt;EAttackSpeed&gt; AttackSpeed;\n    UPROPERTY(EditAnywhere)\n    bool bBigDamage;\n    UPROPERTY(EditAnywhere)\n    bool bUsesResource;\n    UPROPERTY(EditAnywhere)\n    bool bInvuln;\n};\n\nUCLASS(BlueprintType, Blueprintable)\nclass UState : public USerializableObj\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(BlueprintReadOnly)\n    ABattleObject* Parent;\n    UPROPERTY(BlueprintReadWrite)\n    int32 CelIndex;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    FGameplayTag Name;\n    UPROPERTY(EditAnywhere)\n    FGameplayTag ShareChainName;\n    UPROPERTY(EditAnywhere)\n    EEntryStance EntryStance;\n    UPROPERTY(EditAnywhere)\n    TArray&lt;FInputConditionList&gt; InputConditionLists;\n    UPROPERTY(EditAnywhere)\n    EStateType StateType;\n    UPROPERTY(EditAnywhere)\n    FGameplayTag CustomStateType;\n    UPROPERTY(EditAnywhere)\n    TArray&lt;EStateCondition&gt; StateConditions;\n    UPROPERTY(EditAnywhere)\n    bool IsFollowupState;\n    UPROPERTY(EditAnywhere)\n    int32 ObjectID;\n    UPROPERTY(EditAnywhere)\n    int32 MaxChain = -1;\n    UPROPERTY(EditAnywhere)\n    bool bEnableReverseBeat = true;\n    UPROPERTY(EditAnywhere, BlueprintReadOnly)\n    int32 MaxInstances = 1;\n    UPROPERTY(EditAnywhere)\n    FStateCPUData CPUData;\n    UPROPERTY(EditAnywhere)\n    bool bHumanUsable = true;\n    UPROPERTY(EditAnywhere)\n    bool bCPUUsable = true;\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void Init();\n\n    virtual void CallExec();\n\n    UFUNCTION(BlueprintNativeEvent)\n    void Exec();\n\n    UFUNCTION(BlueprintNativeEvent)\n    bool CanEnterState();\n};\n</code></pre>"},{"location":"NightSkyEngine/_state_alias_8h/","title":"File StateAlias.h","text":"<p>FileList &gt; Battle &gt; Script &gt; StateAlias.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"State.h\"</code></li> <li><code>#include \"StateAlias.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_state_alias_8h/#classes","title":"Classes","text":"Type Name class UStateAlias <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/StateAlias.h</code></p>"},{"location":"NightSkyEngine/_state_alias_8h_source/","title":"File StateAlias.h","text":"<p>File List &gt; Battle &gt; Script &gt; StateAlias.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"State.h\"\n#include \"StateAlias.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API UStateAlias : public UState\n{\n    GENERATED_BODY()\n\npublic:\n    // Which state to enter from the alias\n    UPROPERTY(EditAnywhere)\n    FGameplayTag StateToEnter;\n\n    // Dummy CallExec, we don't want it to execute code\n    virtual void CallExec() override {}\n};\n</code></pre>"},{"location":"NightSkyEngine/_state_machine_8cpp/","title":"File StateMachine.cpp","text":"<p>FileList &gt; Battle &gt; Script &gt; StateMachine.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"StateMachine.h\"</code></li> <li><code>#include \"StateAlias.h\"</code></li> <li><code>#include \"SubroutineState.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Objects/PlayerObject.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_state_machine_8cpp/#public-functions","title":"Public Functions","text":"Type Name UE_DEFINE_GAMEPLAY_TAG_COMMENT (StateMachine_Primary, \"StateMachine.Primary\", \"Primary State Machine\")"},{"location":"NightSkyEngine/_state_machine_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_state_machine_8cpp/#function-ue_define_gameplay_tag_comment","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    StateMachine_Primary,\n    \"StateMachine.Primary\",\n    \"Primary State Machine\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/StateMachine.cpp</code></p>"},{"location":"NightSkyEngine/_state_machine_8cpp_source/","title":"File StateMachine.cpp","text":"<p>File List &gt; Battle &gt; Script &gt; StateMachine.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"StateMachine.h\"\n\n#include \"StateAlias.h\"\n#include \"SubroutineState.h\"\n#include \"NightSkyEngine/Battle/Objects/PlayerObject.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(StateMachine)\n\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(StateMachine_Primary, \"StateMachine.Primary\", \"Primary State Machine\");\n\nvoid FStateMachine::AddState(const FGameplayTag&amp; Name, UState* Config)\n{\n    Config-&gt;Parent = Parent;\n    States.Add(Config);\n    StateNames.Add(Name);\n    if (CurrentState == nullptr)\n    {\n        CurrentState = Config;\n        CurrentState-&gt;Init();\n        Update();\n    }\n}\n\nFGameplayTag FStateMachine::GetStateName(int Index)\n{\n    if (Index &gt; 0 &amp;&amp; Index &lt; States.Num())\n    {\n        return States[Index]-&gt;Name;\n    }\n    return FGameplayTag::EmptyTag;\n}\n\nint FStateMachine::GetStateIndex(FGameplayTag Name) const\n{\n    return StateNames.Find(Name);\n}\n\nbool FStateMachine::SetState(const FGameplayTag Name, bool bIsAlias)\n{\n    if (StateNames.Find(Name) == INDEX_NONE)\n    {\n        return false;\n    }\n\n    if (IsCurrentState(Name))\n    {\n        CurrentState = States[StateNames.Find(Name)];\n        return true;\n    }\n\n    const auto StateToEnter = States[StateNames.Find(Name)];\n    if (const auto SubroutineState = Cast&lt;USubroutineState&gt;(StateToEnter))\n    {\n        Parent-&gt;CallSubroutine(SubroutineState-&gt;SubroutineName);\n        return false;\n    }\n    if (!bIsAlias)\n    {\n        Parent-&gt;StateEntryName = StateToEnter-&gt;Name;\n    }\n    if (const auto Alias = Cast&lt;UStateAlias&gt;(StateToEnter))\n    {\n        return SetState(Alias-&gt;StateToEnter, true);\n    }\n\n    Parent-&gt;TriggerEvent(EVT_Exit, StateMachineName);\n    if (bPrimary) Parent-&gt;OnStateChange();\n\n    CurrentState = StateToEnter;\n    if (bPrimary) Parent-&gt;PostStateChange();\n    CurrentState-&gt;Init();\n    Update();\n\n    return true;\n}\n\nbool FStateMachine::ForceSetState(const FGameplayTag Name, bool bIsAlias)\n{\n    if (StateNames.Find(Name) == INDEX_NONE)\n    {\n        return false;\n    }\n\n    const auto StateToEnter = States[StateNames.Find(Name)];\n    if (const auto SubroutineState = Cast&lt;USubroutineState&gt;(StateToEnter))\n    {\n        Parent-&gt;CallSubroutine(SubroutineState-&gt;SubroutineName);\n        return false;\n    }\n    if (!bIsAlias)\n    {\n        Parent-&gt;StateEntryName = StateToEnter-&gt;Name;\n    }\n    if (const auto Alias = Cast&lt;UStateAlias&gt;(StateToEnter))\n    {\n        return ForceSetState(Alias-&gt;StateToEnter, true);\n    }\n\n    Parent-&gt;TriggerEvent(EVT_Exit, StateMachineName);\n    if (bPrimary) Parent-&gt;OnStateChange();\n\n    CurrentState = StateToEnter;\n    if (bPrimary) Parent-&gt;PostStateChange();\n    CurrentState-&gt;Init();\n    Update();\n\n    return true;\n}\n\nbool FStateMachine::ForceSetState(TSubclassOf&lt;UState&gt; Class, bool bIsAlias)\n{\n    for (auto State : States)\n    {\n        if (State-&gt;GetClass() == Class)\n        {\n            if (const auto SubroutineState = Cast&lt;USubroutineState&gt;(State))\n            {\n                Parent-&gt;CallSubroutine(SubroutineState-&gt;SubroutineName);\n                return false;\n            }\n            if (!bIsAlias)\n            {\n                Parent-&gt;StateEntryName = State-&gt;Name;\n            }\n            if (const auto Alias = Cast&lt;UStateAlias&gt;(State))\n            {\n                return ForceSetState(Alias-&gt;StateToEnter, true);\n            }\n\n            Parent-&gt;TriggerEvent(EVT_Exit, StateMachineName);\n            if (bPrimary) Parent-&gt;OnStateChange();\n\n            CurrentState = State;\n            if (bPrimary) Parent-&gt;PostStateChange();\n            CurrentState-&gt;Init();\n            Update();\n\n            return true;\n        }\n    }\n    return false;\n}\n\nbool FStateMachine::ForceRollbackState(const FGameplayTag Name)\n{\n    if (StateNames.Find(Name) == INDEX_NONE)\n    {\n        return false;\n    }\n\n    CurrentState = States[StateNames.Find(Name)];\n\n    return true;\n}\n\nbool FStateMachine::CheckStateStanceCondition(const EEntryStance StateStance, const int PlayerStance)\n{\n    if ((StateStance == EEntryStance::Standing &amp;&amp; PlayerStance == ACT_Standing)\n    || (StateStance == EEntryStance::Standing &amp;&amp; PlayerStance == ACT_Crouching)\n    || (StateStance == EEntryStance::Crouching &amp;&amp; PlayerStance == ACT_Standing)\n    || (StateStance == EEntryStance::Crouching &amp;&amp; PlayerStance == ACT_Crouching)\n    || (StateStance == EEntryStance::Jumping &amp;&amp; PlayerStance == ACT_Jumping)\n    || StateStance == EEntryStance::None)\n    {\n        return true;\n    }\n    return false;\n}\n\nvoid FStateMachine::Update() const\n{\n    if (CurrentState != nullptr)\n    {\n        CurrentState-&gt;CallExec();\n    }\n}\n</code></pre>"},{"location":"NightSkyEngine/_state_machine_8h/","title":"File StateMachine.h","text":"<p>FileList &gt; Battle &gt; Script &gt; StateMachine.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"NativeGameplayTags.h\"</code></li> <li><code>#include \"State.h\"</code></li> <li><code>#include \"StateMachine.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_state_machine_8h/#classes","title":"Classes","text":"Type Name struct FStateMachine The player object's state machine."},{"location":"NightSkyEngine/_state_machine_8h/#public-functions","title":"Public Functions","text":"Type Name UE_DECLARE_GAMEPLAY_TAG_EXTERN (StateMachine_Primary)"},{"location":"NightSkyEngine/_state_machine_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_state_machine_8h/#function-ue_declare_gameplay_tag_extern","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    StateMachine_Primary\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/StateMachine.h</code></p>"},{"location":"NightSkyEngine/_state_machine_8h_source/","title":"File StateMachine.h","text":"<p>File List &gt; Battle &gt; Script &gt; StateMachine.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NativeGameplayTags.h\"\n#include \"State.h\"\n#include \"StateMachine.generated.h\"\n\nclass APlayerObject;\n\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(StateMachine_Primary);\n\nUSTRUCT(BlueprintType)\nstruct NIGHTSKYENGINE_API FStateMachine\n{\n    GENERATED_BODY()\n\n    UPROPERTY(SaveGame)\n    bool bPrimary;\n    UPROPERTY(EditDefaultsOnly, SaveGame)\n    FGameplayTag StateMachineName;\n    UPROPERTY(SaveGame, meta=(Bitmask, BitmaskEnum = \"/Script/NightSkyEngine.EEnableFlags\"))\n    int32 EnableFlags = 0;\n    UPROPERTY(SaveGame)\n    TArray&lt;FGameplayTag&gt; EnabledCustomStateTypes;\n    UPROPERTY(SaveGame)\n    UState* CurrentState;\n    UPROPERTY()\n    TArray&lt;UState*&gt; States;\n    UPROPERTY()\n    TArray&lt;FGameplayTag&gt; StateNames;\n    UPROPERTY()\n    APlayerObject* Parent;\n\n    void AddState(const FGameplayTag&amp; Name, UState* Config);\n\n    FORCEINLINE bool IsCurrentState(const FGameplayTag&amp; Name) const\n    {\n        return CurrentState-&gt;Name == Name;\n    }\n\n    FGameplayTag GetStateName(int Index);\n    int GetStateIndex(FGameplayTag Name) const;\n\n    bool SetState(const FGameplayTag Name, bool bIsAlias = false);\n    bool ForceSetState(const FGameplayTag Name, bool bIsAlias = false);\n    bool ForceSetState(TSubclassOf&lt;UState&gt; Class, bool bIsAlias = false);\n    bool ForceRollbackState(const FGameplayTag Name);\n\n    static bool CheckStateStanceCondition(const EEntryStance StateStance, const int PlayerStance);\n\n    void Update() const;\n};\n</code></pre>"},{"location":"NightSkyEngine/_subroutine_8cpp/","title":"File Subroutine.cpp","text":"<p>FileList &gt; Battle &gt; Script &gt; Subroutine.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Subroutine.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/Subroutine.cpp</code></p>"},{"location":"NightSkyEngine/_subroutine_8cpp_source/","title":"File Subroutine.cpp","text":"<p>File List &gt; Battle &gt; Script &gt; Subroutine.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Subroutine.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(Subroutine)\n\nvoid USubroutine::Exec_Implementation()\n{\n    ResetToCDO();\n}\n</code></pre>"},{"location":"NightSkyEngine/_subroutine_8h/","title":"File Subroutine.h","text":"<p>FileList &gt; Battle &gt; Script &gt; Subroutine.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameplayTagContainer.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Misc/SerializableObj.h\"</code></li> <li><code>#include \"UObject/Object.h\"</code></li> <li><code>#include \"Subroutine.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_subroutine_8h/#classes","title":"Classes","text":"Type Name class USubroutine A subroutine callable from any player or object state. <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/Subroutine.h</code></p>"},{"location":"NightSkyEngine/_subroutine_8h_source/","title":"File Subroutine.h","text":"<p>File List &gt; Battle &gt; Script &gt; Subroutine.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameplayTagContainer.h\"\n#include \"NightSkyEngine/Battle/Misc/SerializableObj.h\"\n#include \"UObject/Object.h\"\n#include \"Subroutine.generated.h\"\n\nclass ABattleObject;\n\nUCLASS(BlueprintType, Blueprintable)\nclass USubroutine : public USerializableObj\n{\n    GENERATED_BODY()\npublic:\n    UPROPERTY(BlueprintReadOnly)\n    ABattleObject* Parent;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    FGameplayTag Name;\n\n    UFUNCTION(BlueprintNativeEvent)\n    void Exec();\n};\n</code></pre>"},{"location":"NightSkyEngine/_subroutine_state_8h/","title":"File SubroutineState.h","text":"<p>FileList &gt; Battle &gt; Script &gt; SubroutineState.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"State.h\"</code></li> <li><code>#include \"SubroutineState.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_subroutine_state_8h/#classes","title":"Classes","text":"Type Name class USubroutineState <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/Script/SubroutineState.h</code></p>"},{"location":"NightSkyEngine/_subroutine_state_8h_source/","title":"File SubroutineState.h","text":"<p>File List &gt; Battle &gt; Script &gt; SubroutineState.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"State.h\"\n#include \"SubroutineState.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API USubroutineState : public UState\n{\n    GENERATED_BODY()\n\npublic:\n    // Which subroutine to call from the state\n    UPROPERTY(EditAnywhere)\n    FGameplayTag SubroutineName;\n\n    // Dummy CallExec, we don't want it to execute code\n    virtual void CallExec() override {}\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_game_state_8cpp/","title":"File NightSkyGameState.cpp","text":"<p>FileList &gt; Battle &gt; NightSkyGameState.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyGameState.h\"</code></li> <li><code>#include \"LevelSequenceActor.h\"</code></li> <li><code>#include \"LevelSequencePlayer.h\"</code></li> <li><code>#include \"NightSkyPlayerController.h\"</code></li> <li><code>#include \"Actors/ParticleManager.h\"</code></li> <li><code>#include \"Camera/CameraActor.h\"</code></li> <li><code>#include \"CineCameraActor.h\"</code></li> <li><code>#include \"Camera/CameraComponent.h\"</code></li> <li><code>#include \"Components/AudioComponent.h\"</code></li> <li><code>#include \"Components/SlateWrapperTypes.h\"</code></li> <li><code>#include \"FighterRunners/FighterReplayRunner.h\"</code></li> <li><code>#include \"FighterRunners/FighterSynctestRunner.h\"</code></li> <li><code>#include \"Kismet/GameplayStatics.h\"</code></li> <li><code>#include \"Kismet/KismetMathLibrary.h\"</code></li> <li><code>#include \"Misc/Globals.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/CPU/NightSkyAIController.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/BattleExtensionData.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/PrimaryCharaData.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/SubroutineData.h\"</code></li> <li><code>#include \"NightSkyEngine/Network/FighterRunners.h\"</code></li> <li><code>#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"</code></li> <li><code>#include \"NightSkyEngine/UI/NightSkyBattleHudActor.h\"</code></li> <li><code>#include \"NightSkyEngine/UI/NightSkyBattleWidget.h\"</code></li> <li><code>#include \"Serialization/ObjectReader.h\"</code></li> <li><code>#include \"Serialization/ObjectWriter.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyGameState.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_game_state_8cpp_source/","title":"File NightSkyGameState.cpp","text":"<p>File List &gt; Battle &gt; NightSkyGameState.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyGameState.h\"\n#include \"LevelSequenceActor.h\"\n#include \"LevelSequencePlayer.h\"\n#include \"NightSkyPlayerController.h\"\n#include \"Actors/ParticleManager.h\"\n#include \"Camera/CameraActor.h\"\n#include \"CineCameraActor.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"Components/AudioComponent.h\"\n#include \"Components/SlateWrapperTypes.h\"\n#include \"FighterRunners/FighterReplayRunner.h\"\n#include \"FighterRunners/FighterSynctestRunner.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n#include \"Misc/Globals.h\"\n#include \"NightSkyEngine/Battle/CPU/NightSkyAIController.h\"\n#include \"NightSkyEngine/Data/BattleExtensionData.h\"\n#include \"NightSkyEngine/Data/PrimaryCharaData.h\"\n#include \"NightSkyEngine/Data/SubroutineData.h\"\n#include \"NightSkyEngine/Network/FighterRunners.h\"\n#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"\n#include \"NightSkyEngine/UI/NightSkyBattleHudActor.h\"\n#include \"NightSkyEngine/UI/NightSkyBattleWidget.h\"\n#include \"Serialization/ObjectReader.h\"\n#include \"Serialization/ObjectWriter.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyGameState)\n\nvoid FRollbackData::Serialize(FArchive&amp; Ar)\n{\n    Ar &lt;&lt; ObjActive;\n    Ar &lt;&lt; ObjBuffer;\n    Ar &lt;&lt; CharBuffer;\n    Ar &lt;&lt; BattleStateBuffer;\n    Ar &lt;&lt; BattleStateData;\n    Ar &lt;&lt; PlayerData;\n    Ar &lt;&lt; StateData;\n    Ar &lt;&lt; ExtensionData;\n    Ar &lt;&lt; WidgetAnimationData;\n}\n\n// Sets default values\nANightSkyGameState::ANightSkyGameState()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n    SequenceCameraActorClass = ACineCameraActor::StaticClass();\n}\n\n// Called when the game starts or when spawned\nvoid ANightSkyGameState::BeginPlay()\n{\n    Super::BeginPlay();\n\n    FActorSpawnParameters SpawnParameters;\n    ParticleManager = GetWorld()-&gt;SpawnActor&lt;AParticleManager&gt;();\n    AudioManager = GetWorld()-&gt;SpawnActor&lt;AAudioManager&gt;();\n    GameInstance = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance());\n    CameraActor = GetWorld()-&gt;SpawnActor&lt;ACameraActor&gt;(ACameraActor::StaticClass());\n    CameraActor-&gt;GetCameraComponent()-&gt;SetFieldOfView(54);\n    SequenceCameraActor = GetWorld()-&gt;SpawnActor&lt;ACineCameraActor&gt;(SequenceCameraActorClass);\n    SequenceActor = GetWorld()-&gt;SpawnActor&lt;ALevelSequenceActor&gt;(ALevelSequenceActor::StaticClass());\n\n    UpdateCamera();\n\n    Init();\n}\n\nvoid ANightSkyGameState::EndPlay(const EEndPlayReason::Type EndPlayReason)\n{\n    Super::EndPlay(EndPlayReason);\n    GameInstance-&gt;EndRecordReplay();\n}\n\nvoid ANightSkyGameState::Init()\n{\n    if (IsValid(BattleExtensionData))\n    {\n        for (auto Extension : BattleExtensionData-&gt;ExtensionArray)\n        {\n            BattleExtensions.Add(NewObject&lt;UBattleExtension&gt;(this, Extension));\n            BattleExtensions.Last()-&gt;Parent = this;\n            BattleExtensionNames.Add(BattleExtensions.Last()-&gt;Name);\n        }\n    }\n\n    for (int i = 0; i &lt; GameInstance-&gt;BattleData.PlayerListP1.Num(); i++)\n    {\n        APlayerObject* SpawnedPlayer;\n        if (const auto Player = GameInstance-&gt;BattleData.PlayerListP1[i]; Player != nullptr)\n        {\n            Players.Add(GetWorld()-&gt;SpawnActor&lt;APlayerObject&gt;(Player-&gt;PlayerClass,\n                                                              BattleSceneTransform));\n            SpawnedPlayer = Players.Last();\n            SpawnedPlayer-&gt;ColorIndex = 1;\n            if (GameInstance-&gt;BattleData.ColorIndicesP1.Num() &gt; i)\n                SpawnedPlayer-&gt;ColorIndex = GameInstance-&gt;BattleData.ColorIndicesP1[i];\n        }\n        else\n        {\n            Players.Add(GetWorld()-&gt;SpawnActor&lt;APlayerObject&gt;(APlayerObject::StaticClass(), BattleSceneTransform));\n            SpawnedPlayer = Players.Last();\n        }\n        SortedObjects.Add(SpawnedPlayer);\n        SpawnedPlayer-&gt;GameState = this;\n    }\n\n    for (int i = 0; i &lt; GameInstance-&gt;BattleData.PlayerListP2.Num(); i++)\n    {\n        APlayerObject* SpawnedPlayer;\n        if (const auto Player = GameInstance-&gt;BattleData.PlayerListP2[i]; Player != nullptr)\n        {\n            Players.Add(GetWorld()-&gt;SpawnActor&lt;APlayerObject&gt;(Player-&gt;PlayerClass,\n                                                              BattleSceneTransform));\n            SpawnedPlayer = Players.Last();\n            SpawnedPlayer-&gt;ColorIndex = 1;\n            if (GameInstance-&gt;BattleData.ColorIndicesP2.Num() &gt; i)\n                SpawnedPlayer-&gt;ColorIndex = GameInstance-&gt;BattleData.ColorIndicesP2[i];\n            for (int j = 0; j &lt; GameInstance-&gt;BattleData.PlayerListP1.Num(); j++)\n            {\n                if (IsValid(GameInstance-&gt;BattleData.PlayerListP1[j]))\n                {\n                    if (SpawnedPlayer-&gt;IsA(GameInstance-&gt;BattleData.PlayerListP1[j]-&gt;PlayerClass))\n                    {\n                        if (SpawnedPlayer-&gt;ColorIndex == Players[j]-&gt;ColorIndex)\n                        {\n                            if (SpawnedPlayer-&gt;ColorIndex &gt; 1)\n                                SpawnedPlayer-&gt;ColorIndex = 1;\n                            else\n                                SpawnedPlayer-&gt;ColorIndex = 2;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        else\n        {\n            Players.Add(GetWorld()-&gt;SpawnActor&lt;APlayerObject&gt;(APlayerObject::StaticClass(), BattleSceneTransform));\n            SpawnedPlayer = Players.Last();\n        }\n        SortedObjects.Add(SpawnedPlayer);\n        SpawnedPlayer-&gt;GameState = this;\n\n        if (GameInstance-&gt;IsCPUBattle &amp;&amp; !GameInstance-&gt;IsTraining)\n        {\n            SpawnedPlayer-&gt;SpawnDefaultController();\n            SpawnedPlayer-&gt;bIsCpu = true;\n        }\n    }\n\n    for (int i = 0; i &lt; MaxBattleObjects; i++)\n    {\n        Objects.Add(GetWorld()-&gt;SpawnActor&lt;ABattleObject&gt;(BattleObjectClass, BattleSceneTransform));\n        Objects[i]-&gt;GameState = this;\n        SortedObjects.Add(Objects.Last());\n    }\n\n    MatchInit();\n    HUDInit();\n\n    if (!GameInstance-&gt;IsReplay)\n    {\n        GameInstance-&gt;EndRecordReplay();\n        // GameInstance-&gt;RecordReplay();\n    }\n}\n\nvoid ANightSkyGameState::PlayIntros()\n{\n    if (GameInstance-&gt;IsTraining)\n    {\n        BattleState.BattlePhase = EBattlePhase::Battle;\n        GetMainPlayer(true)-&gt;JumpToStatePrimary(State_Universal_Stand);\n        GetMainPlayer(false)-&gt;JumpToStatePrimary(State_Universal_Stand);\n        return;\n    }\n    BattleState.BattlePhase = EBattlePhase::Intro;\n    BattleState.CurrentIntroSide = INT_P1;\n    GetMainPlayer(true)-&gt;JumpToStatePrimary(GetMainPlayer(true)-&gt;IntroName);\n    BattleHudVisibility(false);\n}\n\nvoid ANightSkyGameState::RoundInit()\n{\n    BattleState.PauseTimer = false;\n    BattleState.RandomManager.Reseed(BattleState.RandomManager.Rand() + BattleState.RoundCount);\n    BattleState.RoundCount++;\n\n    BattleState.SuperFreezeSelfDuration = 0;\n    BattleState.SuperFreezeDuration = 0;\n    BattleState.SuperFreezeCaller = nullptr;\n    BattleState.BattlePhase = EBattlePhase::Battle;\n    BattleState.FadeTimer = BattleState.MaxFadeTimer;\n\n    if (BattleState.BattleFormat == EBattleFormat::Rounds || BattleState.RoundCount == 1)\n    {\n        BattleState.ScreenData = Cast&lt;ANightSkyGameState&gt;(GetClass()-&gt;GetDefaultObject())-&gt;BattleState.ScreenData;\n\n        if (!GameInstance-&gt;IsTraining)\n            BattleState.TimeUntilRoundStart = BattleState.MaxTimeUntilRoundStart;\n        for (int i = 0; i &lt; MaxBattleObjects; i++)\n            Objects[i]-&gt;ResetObject();\n\n        for (const auto Player : Players)\n        {\n            Player-&gt;RoundInit(true);\n            if (!Player-&gt;IsMainPlayer()) Player-&gt;SetOnScreen(false);\n        }\n\n        GetMainPlayer(true)-&gt;JumpToStatePrimary(State_Universal_Stand);\n        GetMainPlayer(false)-&gt;JumpToStatePrimary(State_Universal_Stand);\n\n        Players[0]-&gt;PlayerFlags = PLF_IsOnScreen;\n        Players[BattleState.TeamData[0].TeamCount]-&gt;PlayerFlags = PLF_IsOnScreen;\n\n        BattleState.MaxMeter[0] = Players[0]-&gt;MaxMeter;\n        BattleState.MaxMeter[1] = Players[BattleState.TeamData[0].TeamCount]-&gt;MaxMeter;\n\n        BattleState.RoundTimer = GameInstance-&gt;BattleData.StartRoundTimer * 60;\n        BattleState.bHUDVisible = true;\n\n        UpdateCamera();\n        CallBattleExtension(BattleExtension_RoundInit);\n    }\n    else if (BattleState.BattleFormat == EBattleFormat::Tag)\n    {\n        const bool IsP1 = GetMainPlayer(true)-&gt;CurrentHealth == 0;\n        GetMainPlayer(IsP1)-&gt;SetOnScreen(false);\n        const auto NewPosX = GetMainPlayer(IsP1)-&gt;PosX;\n        const auto NewDirection = GetMainPlayer(IsP1)-&gt;Direction;\n        if (!SwitchMainPlayer(GetMainPlayer(IsP1), 1, true)) return;\n        GetMainPlayer(IsP1)-&gt;PosX = NewPosX;\n        GetMainPlayer(IsP1)-&gt;Direction = NewDirection;\n        GetMainPlayer(IsP1)-&gt;PosY = 0;\n        GetMainPlayer(IsP1)-&gt;JumpToStatePrimary(State_Universal_TagIn);\n\n        GetMainPlayer(true)-&gt;PlayerFlags &amp;= ~PLF_RoundWinInputLock;\n        GetMainPlayer(false)-&gt;PlayerFlags &amp;= ~PLF_RoundWinInputLock;\n\n        for (const auto&amp; Player : Players) Player-&gt;RoundWinTimer = 120;\n    }\n    else\n    {\n        BattleState.ScreenData = Cast&lt;ANightSkyGameState&gt;(GetClass()-&gt;GetDefaultObject())-&gt;BattleState.ScreenData;\n\n        const bool IsP1 = GetMainPlayer(true)-&gt;CurrentHealth == 0;\n        GetMainPlayer(IsP1)-&gt;SetOnScreen(false);\n        SwitchMainPlayer(GetMainPlayer(IsP1), 1, true);\n\n        if (!GameInstance-&gt;IsTraining)\n            BattleState.TimeUntilRoundStart = BattleState.MaxTimeUntilRoundStart;\n        for (int i = 0; i &lt; MaxBattleObjects; i++)\n            Objects[i]-&gt;ResetObject();\n\n        for (const auto Player : Players)\n        {\n            Player-&gt;RoundInit(true);\n            if (!Player-&gt;IsMainPlayer()) Player-&gt;SetOnScreen(false);\n        }\n\n        GetMainPlayer(true)-&gt;JumpToStatePrimary(State_Universal_Stand);\n        GetMainPlayer(false)-&gt;JumpToStatePrimary(State_Universal_Stand);\n\n        GetMainPlayer(true)-&gt;PlayerFlags = PLF_IsOnScreen;\n        GetMainPlayer(false)-&gt;PlayerFlags = PLF_IsOnScreen;\n\n        BattleState.MaxMeter[0] = GetMainPlayer(true)-&gt;MaxMeter;\n        BattleState.MaxMeter[1] = GetMainPlayer(false)-&gt;MaxMeter;\n\n        BattleState.RoundTimer = GameInstance-&gt;BattleData.StartRoundTimer * 60;\n        BattleState.bHUDVisible = true;\n\n        UpdateCamera();\n        CallBattleExtension(BattleExtension_RoundInit);\n    }\n\n    BattleState.ScreenData.TargetObjects.AddUnique(GetMainPlayer(true));\n    BattleState.ScreenData.TargetObjects.AddUnique(GetMainPlayer(false));\n    AssignEnemy();\n}\n\nvoid ANightSkyGameState::AssignEnemy()\n{\n    for (int i = 0; i &lt; Players.Num(); i++)\n    {\n        if (i &lt; BattleState.TeamData[0].TeamCount)\n        {\n            Players[i]-&gt;Enemy = GetMainPlayer(false);\n        }\n        else\n        {\n            Players[i]-&gt;Enemy = GetMainPlayer(true);\n        }\n    }\n}\n\nvoid ANightSkyGameState::UpdateLocalInput()\n{\n    LocalInputs[0] = GetLocalInputs(0);\n    LocalInputs[1] = GetLocalInputs(1);\n}\n\n// Called every frame\nvoid ANightSkyGameState::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    FighterRunner-&gt;Update(DeltaTime);\n}\n\nvoid ANightSkyGameState::MatchInit()\n{\n    if (!FighterRunner)\n    {\n        FActorSpawnParameters SpawnParameters;\n        SpawnParameters.Owner = GetOwner();\n\n        switch (GameInstance-&gt;FighterRunner)\n        {\n        case LocalPlay:\n            FighterRunner = GetWorld()-&gt;SpawnActor&lt;AFighterLocalRunner&gt;(SpawnParameters);\n            break;\n        case Multiplayer:\n            if (GameInstance-&gt;IsReplay)\n                FighterRunner = GetWorld()-&gt;SpawnActor&lt;AFighterReplayRunner&gt;(SpawnParameters);\n            else\n                FighterRunner = GetWorld()-&gt;SpawnActor&lt;AFighterMultiplayerRunner&gt;(SpawnParameters);\n            break;\n        case SyncTest:\n            FighterRunner = GetWorld()-&gt;SpawnActor&lt;AFighterSynctestRunner&gt;(SpawnParameters);\n            break;\n        default:\n            FighterRunner = GetWorld()-&gt;SpawnActor&lt;AFighterLocalRunner&gt;(SpawnParameters);\n            break;\n        }\n    }\n\n    BattleState = Cast&lt;ANightSkyGameState&gt;(GetClass()-&gt;GetDefaultObject())-&gt;BattleState;\n\n    BattleState.RandomManager = GameInstance-&gt;BattleData.Random;\n    BattleState.TeamData[0].TeamCount = GameInstance-&gt;BattleData.PlayerListP1.Num();\n    BattleState.TeamData[0].CooldownTimer.AddDefaulted(GameInstance-&gt;BattleData.PlayerListP1.Num());\n    BattleState.TeamData[1].TeamCount = GameInstance-&gt;BattleData.PlayerListP2.Num();\n    BattleState.TeamData[1].CooldownTimer.AddDefaulted(GameInstance-&gt;BattleData.PlayerListP2.Num());\n    BattleState.GaugeP1.Empty();\n    BattleState.GaugeP2.Empty();\n    BattleState.GaugeP1.AddDefaulted(BattleState.MaxGauge.Num());\n    BattleState.GaugeP2.AddDefaulted(BattleState.MaxGauge.Num());\n\n    CallBattleExtension(BattleExtension_MatchInit);\n\n    for (int i = 0; i &lt; Players.Num(); i++)\n    {\n        Players[i]-&gt;PlayerIndex = i &gt;= BattleState.TeamData[0].TeamCount;\n        Players[i]-&gt;TeamIndex = i &gt;= BattleState.TeamData[0].TeamCount ? i - BattleState.TeamData[0].TeamCount : i;\n        Players[i]-&gt;PlayerFlags &amp;= ~PLF_IsOnScreen;\n        Players[i]-&gt;ObjNumber = i + MaxBattleObjects;\n        Players[i]-&gt;CallSubroutine(Subroutine_Cmn_MatchInit);\n        Players[i]-&gt;CallSubroutine(Subroutine_MatchInit);\n    }\n    for (int i = 0; i &lt; MaxBattleObjects; i++)\n    {\n        Objects[i]-&gt;ObjNumber = i;\n    }\n    for (int i = SortedObjects.Num() - 1; i &gt;= 0; i--)\n    {\n        SetDrawPriorityFront(SortedObjects[i]);\n    }\n\n    BattleState.MainPlayer[0] = Players[0];\n    BattleState.MainPlayer[0]-&gt;PlayerFlags |= PLF_IsOnScreen;\n    BattleState.MainPlayer[1] = Players[BattleState.TeamData[0].TeamCount];\n    BattleState.MainPlayer[1]-&gt;PlayerFlags |= PLF_IsOnScreen;\n    BattleState.BattleFormat = GameInstance-&gt;BattleData.BattleFormat;\n    BattleState.MaxTimeUntilRoundStart = GameInstance-&gt;BattleData.TimeUntilRoundStart;\n    BattleState.MaxRoundCount = GameInstance-&gt;BattleData.RoundCount;\n    BattleState.RoundTimer = GameInstance-&gt;BattleData.StartRoundTimer * 60;\n\n    PlayMusic(GameInstance-&gt;BattleData.MusicName);\n    BattleHudActor-&gt;BottomWidget-&gt;PlayFadeOutAnim();\n    RoundInit();\n    PlayIntros();\n}\n\nvoid ANightSkyGameState::UpdateGameState(int32 Input1, int32 Input2, bool bShouldResimulate)\n{\n    if ((Input1 &amp; INP_Rematch) == INP_Rematch &amp;&amp; (Input2 &amp; INP_Rematch) == INP_Rematch)\n    {\n        MatchInit();\n        ANightSkyPlayerController* Controller1 = Cast&lt;ANightSkyPlayerController&gt;(\n            UGameplayStatics::GetPlayerController(GetWorld(), 0));\n        ANightSkyPlayerController* Controller2 = Cast&lt;ANightSkyPlayerController&gt;(\n            UGameplayStatics::GetPlayerController(GetWorld(), 1));\n        Controller1-&gt;PostRematch();\n        Controller2-&gt;PostRematch();\n    }\n    if (Input1 &amp; INP_ResetTraining || Input2 &amp; INP_ResetTraining)\n    {\n        ResetTraining();\n    }\n\n    if (bShouldResimulate == false &amp;&amp; bIsResimulating == true) RollbackStartAudio(BattleState.FrameNumber);\n    bIsResimulating = bShouldResimulate;\n    LocalFrame++;\n\n    ParticleManager-&gt;UpdateParticles();\n    UpdateScreen();\n\n    AssignEnemy();\n\n    if (BattleState.BattlePhase == EBattlePhase::Intro)\n    {\n        if (BattleState.CurrentIntroSide == INT_P1)\n        {\n            if (GetMainPlayer(true)-&gt;IntroEndFlag)\n            {\n                GetMainPlayer(true)-&gt;JumpToStatePrimary(State_Universal_Stand);\n                SequenceActor-&gt;GetSequencePlayer()-&gt;Stop();\n                BattleState.CurrentSequenceTime = -1;\n                BattleState.IsPlayingSequence = false;\n            }\n            if (GetMainPlayer(true)-&gt;GetCurrentStateName(StateMachine_Primary) != GetMainPlayer(true)-&gt;IntroName)\n            {\n                GetMainPlayer(false)-&gt;JumpToStatePrimary(GetMainPlayer(false)-&gt;IntroName);\n                BattleState.CurrentIntroSide = INT_P2;\n            }\n        }\n        else if (BattleState.CurrentIntroSide == INT_P2)\n        {\n            bool bIsP1 = false;\n            if (GetMainPlayer(false)-&gt;bIsCpu)\n            {\n                bIsP1 = true;\n            }\n            if (GetMainPlayer(bIsP1)-&gt;IntroEndFlag)\n            {\n                GetMainPlayer(false)-&gt;JumpToStatePrimary(State_Universal_Stand);\n                SequenceActor-&gt;GetSequencePlayer()-&gt;Stop();\n                BattleState.CurrentSequenceTime = -1;\n                BattleState.IsPlayingSequence = false;\n            }\n            if (GetMainPlayer(false)-&gt;GetCurrentStateName(StateMachine_Primary) != GetMainPlayer(false)-&gt;IntroName)\n            {\n                GetMainPlayer(true)-&gt;OrthoBlendActive = 1;\n                GetMainPlayer(false)-&gt;OrthoBlendActive = 1;\n                GetMainPlayer(true)-&gt;JumpToStatePrimary(State_Universal_Stand);\n                GetMainPlayer(false)-&gt;JumpToStatePrimary(State_Universal_Stand);\n                BattleState.CurrentIntroSide = INT_None;\n                BattleState.BattlePhase = EBattlePhase::Battle;\n                BattleHudVisibility(true);\n                BattleHudActor-&gt;BottomWidget-&gt;PlayRoundInitAnim();\n                BattleState.FadeTimer = BattleState.MaxFadeTimer;\n            }\n        }\n    }\n    else\n    {\n        if (!GameInstance-&gt;IsTraining &amp;&amp; !BattleState.PauseTimer)\n        {\n            if (BattleState.TimeUntilRoundStart &gt; 0)\n                BattleState.TimeUntilRoundStart--;\n            else\n                BattleState.RoundTimer--;\n        }\n    }\n\n    if (BattleState.RoundTimer &lt; 0)\n        BattleState.RoundTimer = 0;\n    BattleState.FrameNumber++;\n\n    if (!BattleState.SuperFreezeDuration)\n    {\n        CallBattleExtension(BattleExtension_Update);\n        for (int i = 0; i &lt; 2; i++)\n        {\n            for (auto&amp; Cooldown : BattleState.TeamData[i].CooldownTimer)\n            {\n                if (Cooldown == 0) continue;\n                if (GameInstance-&gt;IsTraining &amp;&amp; !GetMainPlayer(i == 0)-&gt;ComboCounter) Cooldown = 0;\n                else Cooldown--;\n            }\n        }\n    }\n\n    if (BattleState.CurrentSequenceTime != -1)\n        BattleState.CurrentSequenceTime++;\n\n    SortObjects();\n\n    if (!BattleState.MainPlayer[0]-&gt;bIsCpu) BattleState.MainPlayer[0]-&gt;Inputs = Input1;\n    else if (const auto CPU = Cast&lt;ANightSkyAIController&gt;(BattleState.MainPlayer[0]-&gt;Controller); CPU &amp;&amp; !bShouldResimulate)\n        CPU-&gt;Update();\n    if (!BattleState.MainPlayer[1]-&gt;bIsCpu) BattleState.MainPlayer[1]-&gt;Inputs = Input2;\n    else if (const auto CPU = Cast&lt;ANightSkyAIController&gt;(BattleState.MainPlayer[1]-&gt;Controller); CPU &amp;&amp; !bShouldResimulate)\n        CPU-&gt;Update();\n\n    for (int i = 0; i &lt; SortedObjects.Num(); i++)\n    {\n        if (i == BattleState.ActiveObjectCount)\n            break;\n        if (((BattleState.SuperFreezeSelfDuration &amp;&amp; SortedObjects[i] == BattleState.SuperFreezeCaller)\n                || (BattleState.SuperFreezeDuration &amp;&amp; SortedObjects[i] != BattleState.SuperFreezeCaller))\n            &amp;&amp; (SortedObjects[i]-&gt;MiscFlags &amp; MISC_IgnoreSuperFreeze) == 0)\n        {\n            if (SortedObjects[i]-&gt;IsPlayer)\n            {\n                if (SortedObjects[i]-&gt;Player-&gt;PlayerFlags &amp; PLF_IsStunned)\n                    SortedObjects[i]-&gt;Player-&gt;HandleBufferedState();\n                SortedObjects[i]-&gt;GetBoxes();\n                SortedObjects[i]-&gt;Player-&gt;HandleFlipInput();\n                SortedObjects[i]-&gt;Player-&gt;StoredInputBuffer.Update(SortedObjects[i]-&gt;Player-&gt;Inputs, true);\n\n                // Handle state transitions\n                SortedObjects[i]-&gt;Player-&gt;HandleStateMachine(\n                    true, SortedObjects[i]-&gt;Player-&gt;GetStateMachine(StateMachine_Primary));\n                for (auto&amp; StateMachine : SortedObjects[i]-&gt;Player-&gt;SubStateMachines)\n                {\n                    SortedObjects[i]-&gt;Player-&gt;HandleStateMachine(false, StateMachine);\n                }\n            }\n            SortedObjects[i]-&gt;PositionLinkUpdate();\n            if (!SortedObjects[i]-&gt;IsPlayer &amp;&amp; SortedObjects[i]-&gt;MiscFlags &amp; MISC_DeactivateOnNextUpdate)\n            {\n                SortedObjects[i]-&gt;ResetObject();\n            }\n            continue;\n        }\n        SortedObjects[i]-&gt;Update();\n    }\n\n    SortObjects();\n    HandleHitCollision();\n\n    if (BattleState.SuperFreezeSelfDuration == 1)\n    {\n        BattleState.SuperFreezeCaller-&gt;TriggerEvent(EVT_SuperFreezeEnd, StateMachine_Primary);\n    }\n    if (BattleState.SuperFreezeDuration == 1)\n    {\n        for (int i = 0; i &lt; SortedObjects.Num(); i++)\n        {\n            SortedObjects[i]-&gt;TriggerEvent(EVT_SuperFreezeEnd, StateMachine_Primary);\n        }\n\n        BattleState.PauseTimer = false;\n        BattleState.SuperFreezeCaller = nullptr;\n    }\n\n    if (BattleState.SuperFreezeSelfDuration) BattleState.SuperFreezeSelfDuration--;\n    if (BattleState.SuperFreezeDuration) BattleState.SuperFreezeDuration--;\n\n    GetMainPlayer(true)-&gt;HandleEndCombo();\n    GetMainPlayer(false)-&gt;HandleEndCombo();\n\n    SetScreenBounds();\n    HandlePushCollision();\n    SetScreenBounds();\n    if (!BattleState.SuperFreezeDuration)\n    {\n        HandleRoundWin();\n    }\n\n    // these aren't strictly game state related, but tying them to game state update makes things better    \n\n    if (!GameInstance-&gt;IsReplay)\n    {\n        // GameInstance-&gt;UpdateReplay(Input1, Input2);\n    }\n\n    CollisionView();\n\n    const auto [network, timesync] = GetNetworkStats();\n    NetworkStats.Ping = network.ping;\n    const int32 LocalFramesBehind = timesync.local_frames_behind;\n    const int32 RemoteFramesBehind = timesync.remote_frames_behind;\n\n    if (LocalFramesBehind &lt; 0 &amp;&amp; RemoteFramesBehind &lt; 0)\n    {\n        NetworkStats.RollbackFrames = abs(abs(LocalFramesBehind) - abs(RemoteFramesBehind));\n    }\n    else if (LocalFramesBehind &gt; 0 &amp;&amp; RemoteFramesBehind &gt; 0)\n    {\n        NetworkStats.RollbackFrames = 0;\n    }\n    else\n    {\n        NetworkStats.RollbackFrames = abs(LocalFramesBehind) + abs(RemoteFramesBehind);\n    }\n\n    for (int i = 0; i &lt; 2; i++)\n    {\n        if (BattleState.Meter[i] &gt; BattleState.MaxMeter[i])\n            BattleState.Meter[i] = BattleState.MaxMeter[i];\n        if (BattleState.Meter[i] &lt; 0)\n            BattleState.Meter[i] = 0;\n    }\n\n    for (int i = 0; i &lt; BattleState.MaxGauge.Num(); i++)\n    {\n        if (BattleState.GaugeP1[i] &gt; BattleState.MaxGauge[i])\n            BattleState.GaugeP1[i] = BattleState.MaxGauge[i];\n        if (BattleState.GaugeP1[i] &lt; 0)\n            BattleState.GaugeP1[i] = 0;\n        if (BattleState.GaugeP2[i] &gt; BattleState.MaxGauge[i])\n            BattleState.GaugeP2[i] = BattleState.MaxGauge[i];\n        if (BattleState.GaugeP2[i] &lt; 0)\n            BattleState.GaugeP2[i] = 0;\n    }\n\n    ParticleManager-&gt;PauseParticles();\n    UpdateVisuals(bShouldResimulate);\n    UpdateCamera();\n    UpdateHUD();\n    ManageAudio();\n}\n\nvoid ANightSkyGameState::SetScreenCorners()\n{\n    const auto ScreenData = &amp;BattleState.ScreenData;\n\n    if (ScreenData-&gt;TargetObjects.Num() == 0)\n    {\n        ScreenData-&gt;ObjTop = 0;\n        ScreenData-&gt;ObjBottom = 0;\n        ScreenData-&gt;HigherObjBottom = 0;\n        ScreenData-&gt;ObjLeft = 0;\n        ScreenData-&gt;ObjRight = 0;\n        ScreenData-&gt;ObjLength = 0;\n        ScreenData-&gt;ObjHeight = 0;\n\n        return;\n    }\n\n    bool bIsFirst = true;\n\n    for (const auto Target : ScreenData-&gt;TargetObjects)\n    {\n        if (Target == nullptr) break;\n\n        Target-&gt;CalculatePushbox();\n\n        auto TargetL = Target-&gt;PosX - 85000;\n        auto TargetR = Target-&gt;PosX + 85000;\n\n        if (bIsFirst)\n        {\n            ScreenData-&gt;ObjTop = Target-&gt;T / 1000;\n            ScreenData-&gt;ObjBottom = Target-&gt;B / 1000;\n            ScreenData-&gt;HigherObjBottom = Target-&gt;B / 1000;\n            ScreenData-&gt;ObjLeft = TargetL / 1000;\n            ScreenData-&gt;ObjRight = TargetR / 1000;\n\n            bIsFirst = false;\n        }\n        else\n        {\n            if (Target-&gt;T &gt; ScreenData-&gt;ObjTop * 1000) ScreenData-&gt;ObjTop = Target-&gt;T / 1000;\n            if (Target-&gt;B &lt; ScreenData-&gt;ObjBottom * 1000) ScreenData-&gt;ObjBottom = Target-&gt;B / 1000;\n            if (Target-&gt;B &gt; ScreenData-&gt;HigherObjBottom * 1000) ScreenData-&gt;HigherObjBottom = Target-&gt;B / 1000;\n            if (TargetL &lt; ScreenData-&gt;ObjLeft * 1000) ScreenData-&gt;ObjLeft = TargetL / 1000;\n            if (TargetR &gt; ScreenData-&gt;ObjRight * 1000) ScreenData-&gt;ObjRight = TargetR / 1000;\n        }\n    }\n\n    ScreenData-&gt;ObjLength = ScreenData-&gt;ObjRight - ScreenData-&gt;ObjLeft;\n    ScreenData-&gt;ObjHeight = ScreenData-&gt;ObjTop - ScreenData-&gt;ObjBottom;\n    ScreenData-&gt;ObjDistanceY = ScreenData-&gt;HigherObjBottom - ScreenData-&gt;ObjBottom;\n}\n\nvoid ANightSkyGameState::UpdateScreen()\n{\n    const auto ScreenData = &amp;BattleState.ScreenData;\n\n    ScreenData-&gt;MaxZoomOutWidth = ScreenData-&gt;DefaultMaxWidth;\n    ScreenData-&gt;ZoomOutBeginX = ScreenData-&gt;DefaultWidth;\n\n    SetScreenCorners();\n\n    if ((ScreenData-&gt;Flags &amp; SCR_Lock) == 0)\n    {\n        if ((ScreenData-&gt;Flags &amp; SCR_LockXPos) == 0)\n            ScreenData-&gt;TargetCenterX = ScreenData-&gt;ObjLeft + ScreenData-&gt;\n                ObjLength / 2;\n\n        if ((ScreenData-&gt;Flags &amp; SCR_LockWidth) == 0)\n        {\n            auto XWidth = ScreenData-&gt;ObjLength + ScreenData-&gt;ZoomOutBeginX / 4;\n            auto YWidth = FMath::Max(ScreenData-&gt;ObjDistanceY - ScreenData-&gt;ZoomOutBeginY, 0) + ScreenData-&gt;\n                ZoomOutBeginX;\n            auto HWidth = FMath::Max(ScreenData-&gt;ObjHeight - ScreenData-&gt;ZoomOutBeginH, 0) + ScreenData-&gt;ZoomOutBeginX;\n\n            ScreenData-&gt;TargetWidth = FMath::Max(XWidth, FMath::Max(YWidth, HWidth));\n            if (ScreenData-&gt;TargetWidth &lt; ScreenData-&gt;ZoomOutBeginX)\n                ScreenData-&gt;TargetWidth = ScreenData-&gt;\n                    ZoomOutBeginX;\n            if (ScreenData-&gt;TargetWidth &gt; ScreenData-&gt;MaxZoomOutWidth)\n                ScreenData-&gt;TargetWidth = ScreenData-&gt;\n                    MaxZoomOutWidth;\n        }\n\n        if ((ScreenData-&gt;Flags &amp; SCR_LockYPos) == 0)\n        {\n            int TargetOffsetY;\n\n            auto Ratio = ScreenData-&gt;DefaultWidth * 1000 / ScreenData-&gt;TargetWidth;\n\n            if (Ratio * ScreenData-&gt;ObjBottom / 1000 &lt;= ScreenData-&gt;TargetOffsetAirYPos ||\n                Ratio * (ScreenData-&gt;HigherObjBottom - ScreenData-&gt;ObjBottom) / 1000 &gt;= ScreenData-&gt;\n                TargetOffsetAirYDist)\n            {\n                TargetOffsetY = FMath::Min(ScreenData-&gt;TargetOffsetY + ScreenData-&gt;TargetOffsetLandYAdd,\n                                           ScreenData-&gt;TargetOffsetLandYMax);\n            }\n            else\n            {\n                TargetOffsetY = FMath::Max(ScreenData-&gt;TargetOffsetY - ScreenData-&gt;TargetOffsetAirYAdd,\n                                           ScreenData-&gt;TargetOffsetAirYMax);\n            }\n\n            ScreenData-&gt;TargetOffsetY = TargetOffsetY;\n\n            Ratio = Ratio * ScreenData-&gt;HigherObjBottom / 1000 - Ratio * TargetOffsetY / 1000;\n            ScreenData-&gt;TargetCenterY = FMath::Clamp(Ratio, 0, ScreenData-&gt;StageBoundsTop);\n        }\n    }\n\n    const auto Width = ScreenData-&gt;TargetWidth - ScreenData-&gt;ScreenWorldWidth;\n    ScreenData-&gt;WidthVelocity = Width / 14 - 1;\n    ScreenData-&gt;ScreenWorldWidth += ScreenData-&gt;WidthVelocity;\n\n    auto ScreenXSpeedFrame = 10;\n    auto ScreenXSpeed = 50;\n\n    ScreenData-&gt;CenterXVelocity = (ScreenData-&gt;TargetCenterX - ScreenData-&gt;ScreenWorldCenterX) / ScreenXSpeedFrame;\n\n    if (ScreenData-&gt;CenterXVelocity &gt; ScreenXSpeed) ScreenData-&gt;CenterXVelocity = ScreenXSpeed;\n    else if (ScreenData-&gt;CenterXVelocity &lt; -ScreenXSpeed) ScreenData-&gt;CenterXVelocity = -ScreenXSpeed;\n\n    if (ScreenData-&gt;TargetCenterX - ScreenData-&gt;ScreenWorldCenterX &gt; 0)\n    {\n        ScreenData-&gt;CenterXVelocity++;\n    }\n    else if (ScreenData-&gt;TargetCenterX - ScreenData-&gt;ScreenWorldCenterX &lt; 0)\n    {\n        ScreenData-&gt;CenterXVelocity--;\n    }\n\n    ScreenData-&gt;ScreenWorldCenterX += ScreenData-&gt;CenterXVelocity;\n\n    auto CenterYVelocity = ScreenData-&gt;TargetCenterY - ScreenData-&gt;ScreenWorldCenterY &gt; 0 ? 3000 : 1000;\n    auto ScreenYSpeed = 250;\n\n    if (ScreenData-&gt;TargetCenterY - ScreenData-&gt;ScreenWorldCenterY &lt;= 0) CenterYVelocity = 3000;\n\n    ScreenData-&gt;CenterYVelocity = (ScreenData-&gt;TargetCenterY - ScreenData-&gt;ScreenWorldCenterY) * 1000 / CenterYVelocity;\n\n    if (ScreenData-&gt;CenterYVelocity &gt; ScreenYSpeed) ScreenData-&gt;CenterYVelocity = ScreenYSpeed;\n    else if (ScreenData-&gt;CenterYVelocity &lt; -ScreenYSpeed) ScreenData-&gt;CenterYVelocity = -ScreenYSpeed;\n\n    if (ScreenData-&gt;TargetCenterY - ScreenData-&gt;ScreenWorldCenterY &gt; 0)\n    {\n        ScreenData-&gt;CenterYVelocity++;\n    }\n    else if (ScreenData-&gt;TargetCenterY - ScreenData-&gt;ScreenWorldCenterY &lt; 0)\n    {\n        ScreenData-&gt;CenterYVelocity--;\n    }\n\n    ScreenData-&gt;ScreenWorldCenterY += ScreenData-&gt;CenterYVelocity;\n\n    ScreenData-&gt;bTouchingWorldSide = false;\n\n    if (ScreenData-&gt;ScreenWorldCenterX + ScreenData-&gt;ScreenWorldWidth / 2 &gt;= ScreenData-&gt;StageBoundsRight)\n    {\n        ScreenData-&gt;ScreenWorldCenterX = ScreenData-&gt;StageBoundsRight - ScreenData-&gt;ScreenWorldWidth / 2;\n        ScreenData-&gt;bTouchingWorldSide = true;\n    }\n\n    if (ScreenData-&gt;ScreenWorldCenterX - ScreenData-&gt;ScreenWorldWidth / 2 &lt;= ScreenData-&gt;StageBoundsLeft)\n    {\n        ScreenData-&gt;ScreenWorldCenterX = ScreenData-&gt;StageBoundsLeft + ScreenData-&gt;ScreenWorldWidth / 2;\n        ScreenData-&gt;bTouchingWorldSide = true;\n    }\n\n    ScreenData-&gt;ScreenBoundsLeft = ScreenData-&gt;ScreenWorldCenterX - ScreenData-&gt;ScreenWorldWidth / 2;\n    ScreenData-&gt;ScreenBoundsRight = ScreenData-&gt;ScreenWorldCenterX + ScreenData-&gt;ScreenWorldWidth / 2;\n\n    if (ScreenData-&gt;Flags &amp; SCR_DisableScreenSides)\n    {\n        ScreenData-&gt;ScreenBoundsLeft = ScreenData-&gt;StageBoundsLeft;\n        ScreenData-&gt;ScreenBoundsRight = ScreenData-&gt;StageBoundsRight;\n    }\n\n    ScreenData-&gt;ScreenBoundsTop = 106432 / (ScreenData-&gt;ZoomOutBeginX * 1000 / ScreenData-&gt;ScreenWorldWidth) +\n        368000 / (ScreenData-&gt;ZoomOutBeginX * 1000 / ScreenData-&gt;ScreenWorldWidth) + ScreenData-&gt;ScreenWorldCenterY;\n\n    ScreenData-&gt;FinalScreenX = ScreenData-&gt;ScreenWorldCenterX;\n    ScreenData-&gt;FinalScreenY = ScreenData-&gt;ScreenWorldCenterY;\n    ScreenData-&gt;FinalScreenWidth = ScreenData-&gt;ScreenWorldWidth;\n\n    if (ScreenData-&gt;FinalScreenY &gt;= ScreenData-&gt;StageBoundsTop - 106)\n        ScreenData-&gt;FinalScreenY = ScreenData-&gt;\n            StageBoundsTop - 106;\n\n    ScreenData-&gt;ScreenYZoom = 150 * (1\n        - static_cast&lt;float&gt;(ScreenData-&gt;FinalScreenWidth) / static_cast&lt;float&gt;(ScreenData-&gt;DefaultWidth));\n}\n\nvoid ANightSkyGameState::UpdateGameState()\n{\n    RemoteFrame++;\n    UpdateLocalInput();\n    UpdateGameState(LocalInputs[0], LocalInputs[1], false);\n}\n\nvoid ANightSkyGameState::SortObjects()\n{\n    BattleState.ActiveObjectCount = Players.Num();\n    for (int i = Players.Num(); i &lt; SortedObjects.Num(); i++)\n    {\n        for (int j = i + 1; j &lt; SortedObjects.Num(); j++)\n        {\n            if (SortedObjects[j]-&gt;IsActive &amp;&amp; !SortedObjects[i]-&gt;IsActive)\n            {\n                ABattleObject* Temp = SortedObjects[i];\n                SortedObjects[i] = SortedObjects[j];\n                SortedObjects[j] = Temp;\n            }\n        }\n        if (SortedObjects[i]-&gt;IsActive)\n        {\n            BattleState.ActiveObjectCount++;\n        }\n    }\n}\n\nvoid ANightSkyGameState::HandlePushCollision() const\n{\n    for (int i = 0; i &lt; Players.Num(); i++)\n    {\n        for (int j = 0; j &lt; Players.Num(); j++)\n        {\n            if (Players[i]-&gt;PlayerIndex != Players[j]-&gt;PlayerIndex &amp;&amp; Players[i]-&gt;PlayerFlags &amp; PLF_IsOnScreen &amp;&amp;\n                Players[j]-&gt;PlayerFlags &amp; PLF_IsOnScreen)\n            {\n                Players[i]-&gt;HandlePushCollision(Players[j]);\n            }\n        }\n    }\n}\n\nvoid ANightSkyGameState::HandleHitCollision() const\n{\n    for (int i = 0; i &lt; SortedObjects.Num(); i++)\n    {\n        if (i == BattleState.ActiveObjectCount)\n            break;\n        for (int j = 0; j &lt; SortedObjects.Num(); j++)\n        {\n            if (j == BattleState.ActiveObjectCount)\n                break;\n            if (SortedObjects[i]-&gt;Player-&gt;PlayerIndex != SortedObjects[j]-&gt;Player-&gt;PlayerIndex\n                &amp;&amp; SortedObjects[i]-&gt;Player-&gt;PlayerFlags &amp; PLF_IsOnScreen\n                &amp;&amp; SortedObjects[j]-&gt;Player-&gt;PlayerFlags &amp; PLF_IsOnScreen)\n            {\n                SortedObjects[i]-&gt;HandleCustomCollision_PreHit(SortedObjects[j]);\n                SortedObjects[i]-&gt;HandleClashCollision(SortedObjects[j]);\n                SortedObjects[i]-&gt;HandleHitCollision(SortedObjects[j]);\n                SortedObjects[i]-&gt;HandleCustomCollision_PostHit(SortedObjects[j]);\n            }\n        }\n    }\n}\n\nvoid ANightSkyGameState::UpdateVisuals(bool bShouldResimulate) const\n{\n    for (int i = 0; i &lt; SortedObjects.Num(); i++)\n    {\n        SortedObjects[i]-&gt;UpdateVisuals();\n        if (!bShouldResimulate)\n            SortedObjects[i]-&gt;UpdateVisualsNoRollback();\n    }\n}\n\nvoid ANightSkyGameState::HandleRoundWin()\n{\n    if (BattleState.BattlePhase == EBattlePhase::EndScreen) return;\n\n    if (GetMainPlayer(true)-&gt;CurrentHealth &gt; 0 &amp;&amp; GetMainPlayer(false)-&gt;CurrentHealth &lt;= 0)\n    {\n        if ((GetMainPlayer(true)-&gt;PlayerFlags &amp; PLF_RoundWinInputLock) == 0)\n            BattleState.P1RoundsWon++;\n        GetMainPlayer(true)-&gt;RoundWinTimer--;\n        GetMainPlayer(true)-&gt;PlayerFlags |= PLF_RoundWinInputLock;\n        if (BattleState.BattlePhase &lt; EBattlePhase::RoundEnd)\n            BattleState.BattlePhase = EBattlePhase::RoundEnd;\n        BattleState.PauseTimer = true;\n        if (GetMainPlayer(true)-&gt;RoundWinTimer == 0 &amp;&amp; !IsTagBattle())\n        {\n            GetMainPlayer(true)-&gt;JumpToStatePrimary(State_Universal_RoundWin);\n        }\n        NextRoundTransition(true);\n    }\n    else if (GetMainPlayer(false)-&gt;CurrentHealth &gt; 0 &amp;&amp; GetMainPlayer(true)-&gt;CurrentHealth &lt;= 0)\n    {\n        if ((GetMainPlayer(false)-&gt;PlayerFlags &amp; PLF_RoundWinInputLock) == 0)\n            BattleState.P2RoundsWon++;\n        GetMainPlayer(false)-&gt;RoundWinTimer--;\n        GetMainPlayer(false)-&gt;PlayerFlags |= PLF_RoundWinInputLock;\n        if (BattleState.BattlePhase &lt; EBattlePhase::RoundEnd)\n            BattleState.BattlePhase = EBattlePhase::RoundEnd;\n        BattleState.PauseTimer = true;\n        if (GetMainPlayer(false)-&gt;RoundWinTimer == 0 &amp;&amp; !IsTagBattle())\n        {\n            GetMainPlayer(false)-&gt;JumpToStatePrimary(State_Universal_RoundWin);\n        }\n        NextRoundTransition(false);\n    }\n    else if (GetMainPlayer(true)-&gt;CurrentHealth &lt;= 0 &amp;&amp; GetMainPlayer(false)-&gt;CurrentHealth &lt;= 0)\n    {\n        if ((GetMainPlayer(true)-&gt;PlayerFlags &amp; PLF_RoundWinInputLock) == 0)\n        {\n            BattleState.P1RoundsWon++;\n            BattleState.P2RoundsWon++;\n        }\n        GetMainPlayer(true)-&gt;PlayerFlags |= PLF_RoundWinInputLock;\n        GetMainPlayer(false)-&gt;PlayerFlags |= PLF_RoundWinInputLock;\n        GetMainPlayer(true)-&gt;RoundWinTimer--;\n        if (BattleState.BattlePhase &lt; EBattlePhase::RoundEnd)\n            BattleState.BattlePhase = EBattlePhase::RoundEnd;\n        BattleState.PauseTimer = true;\n        NextRoundTransition(true);\n    }\n    else if (BattleState.RoundTimer &lt;= 0)\n    {\n        if (GetMainPlayer(true)-&gt;CurrentHealth &gt; GetMainPlayer(false)-&gt;CurrentHealth)\n        {\n            if ((GetMainPlayer(true)-&gt;PlayerFlags &amp; PLF_RoundWinInputLock) == 0)\n                BattleState.P1RoundsWon++;\n            GetMainPlayer(true)-&gt;RoundWinTimer--;\n            GetMainPlayer(true)-&gt;PlayerFlags |= PLF_RoundWinInputLock;\n            GetMainPlayer(false)-&gt;PlayerFlags |= PLF_RoundWinInputLock;\n            if (BattleState.BattlePhase &lt; EBattlePhase::RoundEnd)\n                BattleState.BattlePhase = EBattlePhase::RoundEnd;\n            BattleState.PauseTimer = true;\n            if (GetMainPlayer(true)-&gt;RoundWinTimer == 0 &amp;&amp; !IsTagBattle())\n            {\n                GetMainPlayer(true)-&gt;JumpToStatePrimary(State_Universal_RoundWin);\n                GetMainPlayer(false)-&gt;JumpToStatePrimary(State_Universal_RoundLose);\n            }\n            NextRoundTransition(true);\n        }\n        else if (GetMainPlayer(false)-&gt;CurrentHealth &gt; GetMainPlayer(true)-&gt;CurrentHealth)\n        {\n            if ((GetMainPlayer(false)-&gt;PlayerFlags &amp; PLF_RoundWinInputLock) == 0)\n                BattleState.P2RoundsWon++;\n            GetMainPlayer(false)-&gt;RoundWinTimer--;\n            GetMainPlayer(true)-&gt;PlayerFlags |= PLF_RoundWinInputLock;\n            GetMainPlayer(false)-&gt;PlayerFlags |= PLF_RoundWinInputLock;\n            if (BattleState.BattlePhase &lt; EBattlePhase::RoundEnd)\n                BattleState.BattlePhase = EBattlePhase::RoundEnd;\n            BattleState.PauseTimer = true;\n            if (GetMainPlayer(false)-&gt;RoundWinTimer == 0 &amp;&amp; !IsTagBattle())\n            {\n                GetMainPlayer(false)-&gt;JumpToStatePrimary(State_Universal_RoundWin);\n                GetMainPlayer(true)-&gt;JumpToStatePrimary(State_Universal_RoundLose);\n            }\n            NextRoundTransition(false);\n        }\n        else if (GetMainPlayer(true)-&gt;CurrentHealth == GetMainPlayer(false)-&gt;CurrentHealth)\n        {\n            if ((GetMainPlayer(true)-&gt;PlayerFlags &amp; PLF_RoundWinInputLock) == 0)\n            {\n                BattleState.P1RoundsWon++;\n                BattleState.P2RoundsWon++;\n            }\n            GetMainPlayer(true)-&gt;PlayerFlags |= PLF_RoundWinInputLock;\n            GetMainPlayer(false)-&gt;PlayerFlags |= PLF_RoundWinInputLock;\n            if (BattleState.BattlePhase &lt; EBattlePhase::RoundEnd)\n                BattleState.BattlePhase = EBattlePhase::RoundEnd;\n            GetMainPlayer(true)-&gt;RoundWinTimer--;\n            BattleState.PauseTimer = true;\n            if (GetMainPlayer(true)-&gt;RoundWinTimer == 0 &amp;&amp; !IsTagBattle())\n            {\n                GetMainPlayer(true)-&gt;JumpToStatePrimary(State_Universal_RoundLose);\n                GetMainPlayer(false)-&gt;JumpToStatePrimary(State_Universal_RoundLose);\n            }\n            NextRoundTransition(true);\n        }\n    }\n}\n\nvoid ANightSkyGameState::NextRoundTransition(bool bIsP1)\n{\n    if (GetMainPlayer(bIsP1)-&gt;RoundWinTimer &lt;= 0)\n    {\n        if (IsTagBattle())\n        {\n            if (!HandleMatchWin())\n            {\n                RoundInit();\n            }\n        }\n        else if (!HandleMatchWin() &amp;&amp; GetMainPlayer(bIsP1)-&gt;RoundEndFlag == true)\n        {\n            if (BattleState.BattlePhase != EBattlePhase::Fade)\n            {\n                BattleHudActor-&gt;BottomWidget-&gt;PlayFadeAnim();\n                BattleState.BattlePhase = EBattlePhase::Fade;\n            }\n            BattleState.FadeTimer--;\n            if (BattleState.FadeTimer &lt;= 0)\n            {\n                RoundInit();\n                BattleHudActor-&gt;BottomWidget-&gt;PlayRoundInitAnim();\n            }\n        }\n    }\n}\n\nbool ANightSkyGameState::HandleMatchWin()\n{\n    if (BattleState.CurrentWinSide != WIN_None)\n    {\n        if (BattleState.BattlePhase == EBattlePhase::EndScreen) return true;\n        if (BattleState.CurrentWinSide == WIN_P2)\n        {\n            if (GetMainPlayer(false)-&gt;RoundEndFlag == true)\n            {\n                EndMatch();\n            }\n        }\n        else\n        {\n            if (GetMainPlayer(true)-&gt;RoundEndFlag == true)\n            {\n                EndMatch();\n            }\n        }\n        return true;\n    }\n    switch (BattleState.BattleFormat)\n    {\n    case EBattleFormat::Rounds:\n        {\n            if (BattleState.P1RoundsWon &gt;= BattleState.MaxRoundCount &amp;&amp; BattleState.P2RoundsWon &lt; BattleState.\n                P1RoundsWon)\n            {\n                GetMainPlayer(true)-&gt;JumpToStatePrimary(State_Universal_MatchWin);\n                GameInstance-&gt;EndRecordReplay();\n                BattleState.CurrentWinSide = WIN_P1;\n                return true;\n            }\n            if (BattleState.P2RoundsWon &gt;= BattleState.MaxRoundCount &amp;&amp; BattleState.P1RoundsWon &lt; BattleState.\n                P2RoundsWon)\n            {\n                GetMainPlayer(false)-&gt;JumpToStatePrimary(State_Universal_MatchWin);\n                GameInstance-&gt;EndRecordReplay();\n                BattleState.CurrentWinSide = WIN_P2;\n                return true;\n            }\n            if (BattleState.P1RoundsWon &gt; BattleState.MaxRoundCount &amp;&amp; BattleState.P2RoundsWon &gt; BattleState.\n                MaxRoundCount)\n            {\n                GameInstance-&gt;EndRecordReplay();\n                BattleState.CurrentWinSide = WIN_Draw;\n                return true;\n            }\n        }\n        return false;\n    case EBattleFormat::Tag:\n    case EBattleFormat::KOF:\n        {\n            if (BattleState.P1RoundsWon &gt;= BattleState.TeamData[1].TeamCount &amp;&amp; BattleState.P2RoundsWon &lt; BattleState.\n                P1RoundsWon)\n            {\n                GetMainPlayer(true)-&gt;JumpToStatePrimary(State_Universal_MatchWin);\n                GameInstance-&gt;EndRecordReplay();\n                BattleState.CurrentWinSide = WIN_P1;\n                return true;\n            }\n            if (BattleState.P2RoundsWon &gt;= BattleState.TeamData[0].TeamCount &amp;&amp; BattleState.P1RoundsWon &lt; BattleState.\n                P2RoundsWon)\n            {\n                GetMainPlayer(false)-&gt;JumpToStatePrimary(State_Universal_MatchWin);\n                GameInstance-&gt;EndRecordReplay();\n                BattleState.CurrentWinSide = WIN_P2;\n                return true;\n            }\n            if (BattleState.P1RoundsWon &gt;= BattleState.TeamData[1].TeamCount &amp;&amp; BattleState.P2RoundsWon &gt;= BattleState.\n                TeamData[0].TeamCount)\n            {\n                GameInstance-&gt;EndRecordReplay();\n                BattleState.CurrentWinSide = WIN_Draw;\n                return true;\n            }\n        }\n        return false;\n    default:\n        return false;\n    }\n}\n\nvoid ANightSkyGameState::CollisionView() const\n{\n    if (bViewCollision)\n    {\n        for (int i = 0; i &lt; BattleState.ActiveObjectCount; i++)\n        {\n            SortedObjects[i]-&gt;CollisionView();\n        }\n    }\n}\n\nint32 ANightSkyGameState::CreateChecksum()\n{\n    Checksum = 0;\n\n    for (const auto Player : Players)\n    {\n        Checksum += Player-&gt;ActionTime ^ Player-&gt;ActionTime &lt;&lt; 16;\n        Checksum += Player-&gt;PosX ^ Player-&gt;PosX &lt;&lt; 16;\n        Checksum += Player-&gt;PosY ^ Player-&gt;PosY &lt;&lt; 16;\n        Checksum += Player-&gt;CurrentHealth ^ Player-&gt;CurrentHealth &lt;&lt; 16;\n    }\n\n    Checksum += BattleState.Meter[0] ^ BattleState.Meter[0] &lt;&lt; 16;\n    Checksum += BattleState.Meter[1] ^ BattleState.Meter[1] &lt;&lt; 16;\n\n    for (const auto Gauge : BattleState.GaugeP1)\n    {\n        Checksum += Gauge ^ Gauge &lt;&lt; 16;\n    }\n    for (const auto Gauge : BattleState.GaugeP2)\n    {\n        Checksum += Gauge ^ Gauge &lt;&lt; 16;\n    }\n\n    return Checksum;\n}\n\nFGGPONetworkStats ANightSkyGameState::GetNetworkStats() const\n{\n    FGGPONetworkStats Stats{};\n    if (AFighterMultiplayerRunner* Runner = Cast&lt;AFighterMultiplayerRunner&gt;(FighterRunner))\n    {\n        if (Runner-&gt;Players[0]-&gt;type == GGPO_PLAYERTYPE_REMOTE)\n            GGPONet::ggpo_get_network_stats(Runner-&gt;ggpo, Runner-&gt;PlayerHandles[0], &amp;Stats);\n        else\n            GGPONet::ggpo_get_network_stats(Runner-&gt;ggpo, Runner-&gt;PlayerHandles[1], &amp;Stats);\n        return Stats;\n    }\n    return Stats;\n}\n\nvoid ANightSkyGameState::ResetTraining()\n{\n    if (GameInstance-&gt;IsTraining)\n    {\n        BattleState.RoundCount = 0;\n        RoundInit();\n    }\n\n    if (ANightSkyPlayerController* Controller = Cast&lt;ANightSkyPlayerController&gt;(\n    UGameplayStatics::GetPlayerController(GetWorld(), 0)); Controller != nullptr)\n    {\n        Controller-&gt;Inputs &amp;= ~INP_ResetTraining;\n    }\n    if (ANightSkyPlayerController* Controller = Cast&lt;ANightSkyPlayerController&gt;(\n        UGameplayStatics::GetPlayerController(GetWorld(), 1)); Controller != nullptr)\n    {\n        Controller-&gt;Inputs &amp;= ~INP_ResetTraining;\n    }\n}\n\nvoid ANightSkyGameState::SetScreenBounds() const\n{\n    for (int i = 0; i &lt; BattleState.ActiveObjectCount; i++)\n    {\n        if (SortedObjects[i] != nullptr)\n        {\n            if (SortedObjects[i]-&gt;MiscFlags &amp; MISC_WallCollisionActive)\n            {\n                const auto ScreenData = &amp;BattleState.ScreenData;\n\n                if (const auto Player = Cast&lt;APlayerObject&gt;(SortedObjects[i]))\n                {\n                    if (!(Player-&gt;PlayerFlags &amp; PLF_IsOnScreen)) continue;\n                    Player-&gt;PlayerFlags |= PLF_TouchingWall;\n                    Player-&gt;WallTouchTimer++;\n                }\n\n                SortedObjects[i]-&gt;CalculatePushbox();\n\n                if (SortedObjects[i]-&gt;PosX + 85000 &gt;= ScreenData-&gt;ScreenBoundsRight * 1000)\n                {\n                    SortedObjects[i]-&gt;PosX = ScreenData-&gt;ScreenBoundsRight * 1000 - 85000;\n                }\n                else if (SortedObjects[i]-&gt;PosX - 85000 &lt;= ScreenData-&gt;ScreenBoundsLeft * 1000)\n                {\n                    SortedObjects[i]-&gt;PosX = ScreenData-&gt;ScreenBoundsLeft * 1000 + 85000;\n                }\n                else\n                {\n                    if (const auto Player = Cast&lt;APlayerObject&gt;(SortedObjects[i]))\n                    {\n                        Player-&gt;PlayerFlags &amp;= ~PLF_TouchingWall;\n                        Player-&gt;WallTouchTimer = 0;\n                    }\n                }\n\n                if (SortedObjects[i]-&gt;PosY &gt;= ScreenData-&gt;ScreenBoundsTop * 1000)\n                {\n                    SortedObjects[i]-&gt;PosY = ScreenData-&gt;ScreenBoundsTop * 1000;\n                }\n            }\n        }\n    }\n}\n\nvoid ANightSkyGameState::StartSuperFreeze(int32 Duration, int32 SelfDuration, ABattleObject* CallingObject)\n{\n    BattleState.SuperFreezeDuration = Duration;\n    BattleState.SuperFreezeSelfDuration = SelfDuration;\n    BattleState.SuperFreezeCaller = CallingObject;\n    BattleState.PauseTimer = true;\n}\n\nABattleObject* ANightSkyGameState::AddBattleObject(\n    const UState* InState,\n    int PosX,\n    int PosY,\n    EObjDir Dir,\n    int32 ObjectStateIndex,\n    bool bIsCommonState,\n    APlayerObject* Parent) const\n{\n    for (int i = 0; i &lt; MaxBattleObjects; i++)\n    {\n        if (!Objects[i]-&gt;IsActive)\n        {\n            Objects[i]-&gt;ObjectState = DuplicateObject(InState, Objects[i]);\n            Objects[i]-&gt;ObjectState-&gt;Parent = Objects[i];\n            Objects[i]-&gt;IsActive = true;\n            Objects[i]-&gt;Direction = Dir;\n            Objects[i]-&gt;Player = Parent;\n            Objects[i]-&gt;PosX = PosX;\n            Objects[i]-&gt;PosY = PosY;\n            Objects[i]-&gt;ObjectStateIndex = ObjectStateIndex;\n            Objects[i]-&gt;bIsCommonState = bIsCommonState;\n            Objects[i]-&gt;InitObject();\n            return Objects[i];\n        }\n    }\n    return nullptr;\n}\n\nvoid ANightSkyGameState::UpdateCamera()\n{\n    if (CameraActor != nullptr)\n    {\n        const auto ScreenData = &amp;BattleState.ScreenData;\n\n        BattleState.CameraPosition = BattleSceneTransform.GetRotation().RotateVector(\n                FVector(ScreenData-&gt;FinalScreenX * 0.43, ScreenData-&gt;FinalScreenWidth * 0.43,\n                        ScreenData-&gt;FinalScreenY * 0.43 - ScreenData-&gt;ScreenYZoom + 150)) + BattleSceneTransform.\n            GetLocation();\n        FRotator CameraRotation = BattleSceneTransform.GetRotation().Rotator();\n        CameraRotation.Yaw -= 90;\n        CameraRotation.Pitch -= 2.5;\n        CameraActor-&gt;SetActorLocation(BattleState.CameraPosition);\n        CameraActor-&gt;SetActorRotation(CameraRotation);\n        if (BattleState.CurrentSequenceTime == -1)\n        {\n            BattleState.OrthoBlendActive = 1;\n            const FVector SequenceCameraLocation = BattleSceneTransform.GetRotation().RotateVector(\n                FVector(0, 1080, 175)) + BattleSceneTransform.GetLocation();\n            SequenceCameraActor-&gt;SetActorLocation(SequenceCameraLocation);\n            if (const auto PlayerController = UGameplayStatics::GetPlayerController(GetWorld(), 0); IsValid(\n                PlayerController))\n            {\n                PlayerController-&gt;SetViewTargetWithBlend(CameraActor);\n            }\n        }\n        else\n        {\n            if (BattleState.CurrentSequenceTime &gt;= SequenceActor-&gt;GetSequencePlayer()-&gt;GetEndTime().Time)\n            {\n                StopLevelSequence();\n                return;\n            }\n            const FMovieSceneSequencePlaybackParams Params = FMovieSceneSequencePlaybackParams(\n                FFrameTime(BattleState.CurrentSequenceTime),\n                EUpdatePositionMethod::Scrub);\n            SequenceActor-&gt;GetSequencePlayer()-&gt;SetPlaybackPosition(Params);\n            const FVector SequenceTargetVector = FVector(SequenceTarget-&gt;PosX / COORD_SCALE,\n                                                         SequenceTarget-&gt;PosZ / COORD_SCALE,\n                                                         SequenceTarget-&gt;PosY / COORD_SCALE);\n\n            FVector NewCamLocation = SequenceCameraActor-&gt;GetActorLocation();\n            NewCamLocation.Y = NewCamLocation.Y + SequenceTargetVector.Y;\n            NewCamLocation.Z = NewCamLocation.Z + SequenceTargetVector.Z;\n\n            if (SequenceTarget-&gt;Direction == DIR_Left)\n            {\n                NewCamLocation.X = -NewCamLocation.X + SequenceTargetVector.X;\n                auto NewCamRotation = SequenceCameraActor-&gt;GetActorForwardVector();\n                NewCamRotation.X *= -1;\n                SequenceCameraActor-&gt;SetActorRotation(UKismetMathLibrary::MakeRotFromX(NewCamRotation));\n            }\n            else\n            {\n                NewCamLocation.X = NewCamLocation.X + SequenceTargetVector.X;\n            }\n\n            BattleState.OrthoBlendActive = FMath::Clamp(FVector::DotProduct(CameraActor-&gt;GetActorForwardVector(),\n                                                                            SequenceCameraActor-&gt;\n                                                                            GetActorForwardVector()), 0, 1)\n                                            * FMath::Clamp(FVector::Dist(CameraActor-&gt;GetActorLocation(),\n                                                SequenceCameraActor-&gt;GetActorLocation()) / 500, 0, 1);\n\n            SequenceCameraActor-&gt;SetActorLocation(\n                BattleSceneTransform.GetRotation().RotateVector(NewCamLocation) + BattleSceneTransform.GetLocation());\n\n            const FRotator SequenceRotation = BattleSceneTransform.GetRotation().Rotator() + SequenceCameraActor-&gt;\n                GetActorRotation();\n\n            SequenceCameraActor-&gt;SetActorRotation(SequenceRotation);\n        }\n    }\n    bIsPlayingSequence = BattleState.IsPlayingSequence;\n}\n\nvoid ANightSkyGameState::PlayLevelSequence(APlayerObject* Target, APlayerObject* Enemy, ULevelSequence* Sequence)\n{\n    if (SequenceActor != nullptr)\n    {\n        SequenceActor-&gt;GetSequencePlayer()-&gt;Stop();\n        SequenceActor-&gt;SetSequence(Sequence);\n        for (int i = 0; i &lt; Sequence-&gt;GetMovieScene()-&gt;GetPossessableCount(); i++)\n        {\n            auto MovieSceneBinding = Sequence-&gt;GetMovieScene()-&gt;GetPossessable(i);\n            if (!MovieSceneBinding.GetName().Equals(\"Target\"))\n            {\n                continue;\n            }\n\n            FMovieSceneObjectBindingID BindingId = FMovieSceneObjectBindingID(MovieSceneBinding.GetGuid());\n            SequenceActor-&gt;SetBinding(BindingId, TArray&lt;AActor*&gt;{Target});\n\n            break;\n        }\n        for (int i = 0; i &lt; Sequence-&gt;GetMovieScene()-&gt;GetPossessableCount(); i++)\n        {\n            auto MovieSceneBinding = Sequence-&gt;GetMovieScene()-&gt;GetPossessable(i);\n            if (!MovieSceneBinding.GetName().Equals(\"Enemy\"))\n            {\n                continue;\n            }\n\n            FMovieSceneObjectBindingID BindingId = FMovieSceneObjectBindingID(MovieSceneBinding.GetGuid());\n            SequenceActor-&gt;SetBinding(BindingId, TArray&lt;AActor*&gt;{Enemy});\n\n            break;\n        }\n        for (int i = 0; i &lt; Sequence-&gt;GetMovieScene()-&gt;GetPossessableCount(); i++)\n        {\n            auto MovieSceneBinding = Sequence-&gt;GetMovieScene()-&gt;GetPossessable(i);\n            if (!MovieSceneBinding.GetName().Equals(\"CameraActor\"))\n            {\n                continue;\n            }\n\n            FMovieSceneObjectBindingID BindingId = FMovieSceneObjectBindingID(MovieSceneBinding.GetGuid());\n            SequenceActor-&gt;SetBinding(BindingId, TArray&lt;AActor*&gt;{CameraActor});\n\n            break;\n        }\n        for (int i = 0; i &lt; Sequence-&gt;GetMovieScene()-&gt;GetPossessableCount(); i++)\n        {\n            auto MovieSceneBinding = Sequence-&gt;GetMovieScene()-&gt;GetPossessable(i);\n            if (!MovieSceneBinding.GetName().Equals(\"SequenceCameraActor\"))\n            {\n                continue;\n            }\n\n            FMovieSceneObjectBindingID BindingId = FMovieSceneObjectBindingID(MovieSceneBinding.GetGuid());\n            SequenceActor-&gt;SetBinding(BindingId, TArray&lt;AActor*&gt;{SequenceCameraActor});\n\n            break;\n        }\n        SequenceTarget = Target;\n        SequenceEnemy = Enemy;\n        BattleState.CurrentSequenceTime = 0;\n        BattleState.IsPlayingSequence = true;\n    }\n}\n\nvoid ANightSkyGameState::StopLevelSequence()\n{\n    SequenceActor-&gt;GetSequencePlayer()-&gt;Stop();\n    BattleState.CurrentSequenceTime = -1;\n    BattleState.IsPlayingSequence = false;\n}\n\nvoid ANightSkyGameState::CameraShake(const TSubclassOf&lt;UCameraShakeBase&gt;&amp; Pattern, float Scale) const\n{\n    if (Pattern)\n    {\n        const auto PlayerCameraManager = UGameplayStatics::GetPlayerCameraManager(this, 0);\n        PlayerCameraManager-&gt;StopAllCameraShakes();\n        PlayerCameraManager-&gt;StartCameraShake(Pattern, Scale);\n    }\n}\n\nvoid ANightSkyGameState::HUDInit() const\n{\n    if (BattleHudActor != nullptr)\n    {\n        if (BattleHudActor-&gt;TopWidget != nullptr)\n        {\n            BattleHudActor-&gt;TopWidget-&gt;P1Health.Init(0, BattleState.TeamData[0].TeamCount);\n            BattleHudActor-&gt;TopWidget-&gt;P2Health.Init(0, BattleState.TeamData[1].TeamCount);\n            BattleHudActor-&gt;TopWidget-&gt;P1RecoverableHealth.Init(0, BattleState.TeamData[0].TeamCount);\n            BattleHudActor-&gt;TopWidget-&gt;P2RecoverableHealth.Init(0, BattleState.TeamData[1].TeamCount);\n        }\n    }\n}\n\nvoid ANightSkyGameState::UpdateHUD()\n{\n    if (BattleState.bHUDVisible)\n    {\n        BattleHudActor-&gt;TopWidget-&gt;SetVisibility(ESlateVisibility::Visible);\n        BattleHudActor-&gt;BottomWidget-&gt;SetVisibility(ESlateVisibility::Visible);\n    }\n    else\n    {\n        BattleHudActor-&gt;TopWidget-&gt;SetVisibility(ESlateVisibility::Hidden);\n        BattleHudActor-&gt;BottomWidget-&gt;SetVisibility(ESlateVisibility::Hidden);\n    }\n\n    if (BattleHudActor != nullptr)\n    {\n        if (BattleHudActor-&gt;TopWidget != nullptr)\n        {\n            for (int i = 0; i &lt; BattleState.TeamData[0].TeamCount; i++)\n            {\n                BattleHudActor-&gt;TopWidget-&gt;P1Health[i] = static_cast&lt;float&gt;(GetTeam(true)[i]-&gt;CurrentHealth) /\n                    static_cast&lt;float&gt;(GetTeam(true)[i]-&gt;MaxHealth);\n                BattleHudActor-&gt;TopWidget-&gt;P1RecoverableHealth[i] = static_cast&lt;float&gt;(GetTeam(true)[i]-&gt;CurrentHealth +\n                    GetTeam(true)[i]-&gt;RecoverableHealth) / static_cast&lt;float&gt;(GetTeam(true)[i]-&gt;MaxHealth);\n            }\n            for (int i = 0; i &lt; BattleState.TeamData[1].TeamCount; i++)\n            {\n                BattleHudActor-&gt;TopWidget-&gt;P2Health[i] = static_cast&lt;float&gt;(GetTeam(false)[i]-&gt;CurrentHealth) /\n                    static_cast&lt;float&gt;(GetTeam(false)[i]-&gt;MaxHealth);\n                BattleHudActor-&gt;TopWidget-&gt;P2RecoverableHealth[i] = static_cast&lt;float&gt;(GetTeam(false)[i]-&gt;CurrentHealth\n                    + GetTeam(false)[i]-&gt;RecoverableHealth) / static_cast&lt;float&gt;(GetTeam(false)[i]-&gt;MaxHealth);\n            }\n            BattleHudActor-&gt;TopWidget-&gt;P1RoundsWon = BattleState.P1RoundsWon;\n            BattleHudActor-&gt;TopWidget-&gt;P2RoundsWon = BattleState.P2RoundsWon;\n            BattleHudActor-&gt;TopWidget-&gt;Timer = static_cast&lt;float&gt;(BattleState.RoundTimer / 60);\n            BattleHudActor-&gt;TopWidget-&gt;P1ComboCounter = BattleState.MainPlayer[0]-&gt;ComboCounter;\n            BattleHudActor-&gt;TopWidget-&gt;P2ComboCounter = BattleState.MainPlayer[1]-&gt;ComboCounter;\n            BattleHudActor-&gt;TopWidget-&gt;Ping = NetworkStats.Ping;\n            BattleHudActor-&gt;TopWidget-&gt;RollbackFrames = NetworkStats.RollbackFrames;\n\n            if (BattleHudActor-&gt;TopWidget-&gt;P1Gauge.IsEmpty())\n                BattleHudActor-&gt;TopWidget-&gt;P1Gauge.SetNum(\n                    BattleState.MaxGauge.Num());\n            if (BattleHudActor-&gt;TopWidget-&gt;P2Gauge.IsEmpty())\n                BattleHudActor-&gt;TopWidget-&gt;P2Gauge.SetNum(\n                    BattleState.MaxGauge.Num());\n\n            for (int j = 0; j &lt; BattleState.MaxGauge.Num(); j++)\n            {\n                BattleHudActor-&gt;TopWidget-&gt;P1Gauge[j] = static_cast&lt;float&gt;(BattleState.GaugeP1[j]) / BattleState.\n                    MaxGauge[j];\n                BattleHudActor-&gt;TopWidget-&gt;P2Gauge[j] = static_cast&lt;float&gt;(BattleState.GaugeP2[j]) / BattleState.\n                    MaxGauge[j];\n            }\n        }\n        if (BattleHudActor-&gt;BottomWidget != nullptr)\n        {\n            BattleHudActor-&gt;BottomWidget-&gt;P1Meter = static_cast&lt;float&gt;(BattleState.Meter[0]) / 10000;\n            BattleHudActor-&gt;BottomWidget-&gt;P2Meter = static_cast&lt;float&gt;(BattleState.Meter[1]) / 10000;\n\n            if (BattleHudActor-&gt;BottomWidget-&gt;P1Gauge.IsEmpty())\n                BattleHudActor-&gt;BottomWidget-&gt;P1Gauge.SetNum(\n                    BattleState.MaxGauge.Num());\n            if (BattleHudActor-&gt;BottomWidget-&gt;P2Gauge.IsEmpty())\n                BattleHudActor-&gt;BottomWidget-&gt;P2Gauge.SetNum(\n                    BattleState.MaxGauge.Num());\n\n            for (int j = 0; j &lt; BattleState.MaxGauge.Num(); j++)\n            {\n                BattleHudActor-&gt;BottomWidget-&gt;P1Gauge[j] = static_cast&lt;float&gt;(BattleState.GaugeP1[j]) / BattleState.\n                    MaxGauge[j];\n                BattleHudActor-&gt;BottomWidget-&gt;P2Gauge[j] = static_cast&lt;float&gt;(BattleState.GaugeP2[j]) / BattleState.\n                    MaxGauge[j];\n            }\n        }\n        UpdateHUD_BP();\n    }\n\n    UpdateHUDAnimations_BP();\n\n    BattleHudActor-&gt;TopWidget-&gt;PlayStandardAnimations();\n    BattleHudActor-&gt;TopWidget-&gt;SetAnimationRollbackData();\n    BattleHudActor-&gt;BottomWidget-&gt;PlayStandardAnimations();\n    BattleHudActor-&gt;BottomWidget-&gt;SetAnimationRollbackData();\n\n    for (auto&amp; [Anim, Time, bPlaying] : BattleHudActor-&gt;TopWidget-&gt;WidgetAnimationRollback)\n    {\n        bPlaying = BattleHudActor-&gt;TopWidget-&gt;IsAnimationPlaying(Anim);\n        Time = BattleHudActor-&gt;TopWidget-&gt;GetAnimationCurrentTime(Anim);\n    }\n\n    for (auto&amp; [Anim, Time, bPlaying] : BattleHudActor-&gt;BottomWidget-&gt;WidgetAnimationRollback)\n    {\n        bPlaying = BattleHudActor-&gt;BottomWidget-&gt;IsAnimationPlaying(Anim);\n        Time = BattleHudActor-&gt;BottomWidget-&gt;GetAnimationCurrentTime(Anim);\n    }\n}\n\nvoid ANightSkyGameState::SetDrawPriorityFront(ABattleObject* InObject) const\n{\n    if (InObject-&gt;IsPlayer)\n    {\n        for (int i = 0; i &lt; Players.Num(); i++)\n        {\n            if (SortedObjects[i] == InObject) continue;\n            if (SortedObjects[i]-&gt;DrawPriority &lt;= InObject-&gt;DrawPriority)\n                SortedObjects[i]-&gt;DrawPriority++;\n            SortedObjects[i]-&gt;DrawPriority = FMath::Min(SortedObjects[i]-&gt;DrawPriority, MaxDrawPriority);\n        }\n        InObject-&gt;DrawPriority = 0;\n        return;\n    }\n    for (int i = Players.Num(); i &lt; BattleState.ActiveObjectCount; i++)\n    {\n        if (SortedObjects[i] == InObject) continue;\n        if (SortedObjects[i]-&gt;DrawPriority &lt;= InObject-&gt;DrawPriority)\n            SortedObjects[i]-&gt;DrawPriority++;\n        SortedObjects[i]-&gt;DrawPriority = FMath::Min(SortedObjects[i]-&gt;DrawPriority, MaxDrawPriority);\n    }\n    InObject-&gt;DrawPriority = 0;\n}\n\nvoid ANightSkyGameState::SetDrawPriorityBack(ABattleObject* InObject) const\n{\n    if (InObject-&gt;IsPlayer)\n    {\n        for (int i = 0; i &lt; Players.Num(); i++)\n        {\n            if (SortedObjects[i] == InObject) continue;\n            if (SortedObjects[i]-&gt;DrawPriority &gt; InObject-&gt;DrawPriority)\n                SortedObjects[i]-&gt;DrawPriority--;\n        }\n        InObject-&gt;DrawPriority = Players.Num();\n        return;\n    }\n    for (int i = Players.Num(); i &lt; BattleState.ActiveObjectCount; i++)\n    {\n        if (SortedObjects[i] == InObject) continue;\n        if (SortedObjects[i]-&gt;DrawPriority &gt; InObject-&gt;DrawPriority)\n            SortedObjects[i]-&gt;DrawPriority--;\n        InObject-&gt;DrawPriority = Players.Num();\n    }\n}\n\nAPlayerObject* ANightSkyGameState::SwitchMainPlayer(APlayerObject* InPlayer, const int TeamIndex, const bool bForce,\n                                                    const bool bEvenOnScreen)\n{\n    if (TeamIndex == 0) return nullptr;\n    const bool IsP1 = InPlayer-&gt;PlayerIndex == 0;\n    if (BattleState.BattleFormat != EBattleFormat::Tag &amp;&amp; TeamIndex &gt;= BattleState.TeamData[IsP1 == false].TeamCount)\n        return nullptr;\n    if (BattleState.TeamData[IsP1 == false].CooldownTimer[TeamIndex] &gt; 0 &amp;&amp; !bForce) return nullptr;\n\n    const auto NewPlayer = GetTeam(IsP1)[TeamIndex];\n    if (NewPlayer-&gt;CurrentHealth == 0) return nullptr;\n    if (NewPlayer-&gt;PlayerFlags &amp; PLF_IsOnScreen)\n    {\n        if (!bEvenOnScreen) return nullptr;\n    }\n    NewPlayer-&gt;TeamIndex = 0;\n    InPlayer-&gt;TeamIndex = TeamIndex;\n    BattleState.ScreenData.TargetObjects.Remove(InPlayer);\n    BattleState.ScreenData.TargetObjects.Add(NewPlayer);\n    NewPlayer-&gt;JumpToStatePrimary(State_Universal_TagIn);\n    if (!(NewPlayer-&gt;PlayerFlags &amp; PLF_IsOnScreen))\n    {\n        NewPlayer-&gt;PosX = InPlayer-&gt;PosX;\n        NewPlayer-&gt;PosY = InPlayer-&gt;PosY;\n        NewPlayer-&gt;Direction = InPlayer-&gt;Direction;\n    }\n    NewPlayer-&gt;SetOnScreen(true);\n    NewPlayer-&gt;CalculatePushbox();\n    NewPlayer-&gt;ComboCounter = InPlayer-&gt;ComboCounter;\n    NewPlayer-&gt;ComboTimer = InPlayer-&gt;ComboTimer;\n    NewPlayer-&gt;StoredInputBuffer = InPlayer-&gt;StoredInputBuffer;\n    for (const auto EnemyPlayer : GetTeam(!IsP1))\n    {\n        EnemyPlayer-&gt;Enemy = NewPlayer;\n    }\n    BattleState.MainPlayer[!IsP1] = NewPlayer;\n    SetDrawPriorityFront(NewPlayer);\n    return NewPlayer;\n}\n\nAPlayerObject* ANightSkyGameState::CallAssist(const bool IsP1, const int AssistIndex, const FGameplayTag AssistName)\n{\n    if (AssistIndex == 0) return nullptr;\n    if (BattleState.BattleFormat != EBattleFormat::Tag &amp;&amp; AssistIndex &gt;= BattleState.TeamData[IsP1 == false].TeamCount)\n        return nullptr;\n    if (BattleState.TeamData[IsP1 == 0].CooldownTimer[AssistIndex] &gt; 0) return nullptr;\n\n    const auto NewPlayer = GetTeam(IsP1)[AssistIndex];\n    if (NewPlayer-&gt;CurrentHealth == 0) return nullptr;\n    if (NewPlayer-&gt;PlayerFlags &amp; PLF_IsOnScreen) return nullptr;\n    if (!NewPlayer-&gt;PrimaryStateMachine.StateNames.Contains(AssistName)) return nullptr;\n    NewPlayer-&gt;SetOnScreen(true);\n    NewPlayer-&gt;PosX = GetMainPlayer(IsP1)-&gt;PosX;\n    NewPlayer-&gt;FaceOpponent();\n    NewPlayer-&gt;JumpToStatePrimary(AssistName);\n    SetDrawPriorityBack(NewPlayer);\n    return NewPlayer;\n}\n\nvoid ANightSkyGameState::SetTeamCooldown(const bool IsP1, const int TeamIndex, const int Cooldown)\n{\n    BattleState.TeamData[IsP1 == 0].CooldownTimer[TeamIndex] = Cooldown;\n}\n\nbool ANightSkyGameState::CanTag(const APlayerObject* InPlayer, int TeamIndex) const\n{\n    if (InPlayer-&gt;PlayerFlags &amp; PLF_RoundWinInputLock) return false;\n\n    if (TeamIndex == 0) return false;\n    const bool IsP1 = InPlayer-&gt;PlayerIndex == 0;\n    if (BattleState.BattleFormat != EBattleFormat::Tag || TeamIndex &gt;= BattleState.TeamData[IsP1 == false].TeamCount)\n        return false;\n\n    if (BattleState.TeamData[IsP1 == 0].CooldownTimer[TeamIndex] &gt; 0) return false;\n\n    const auto NewPlayer = GetTeam(IsP1)[TeamIndex];\n    if (NewPlayer-&gt;CurrentHealth == 0) return false;\n    if (NewPlayer-&gt;PlayerFlags &amp; PLF_IsOnScreen) return false;\n\n    return true;\n}\n\nint ANightSkyGameState::GetLocalInputs(int Index) const\n{\n    if (const ANightSkyPlayerController* Controller = Cast&lt;ANightSkyPlayerController&gt;(\n        UGameplayStatics::GetPlayerController(GetWorld(), Index)); Controller != nullptr)\n    {\n        return Controller-&gt;Inputs;\n    }\n    return 0;\n}\n\nvoid ANightSkyGameState::SetOtherChecksum(uint32 RemoteChecksum, int32 InFrame)\n{\n    OtherChecksum = RemoteChecksum;\n    OtherChecksumFrame = InFrame;\n}\n\nvoid ANightSkyGameState::PlayAnnouncerVoice(const FGameplayTag Name)\n{\n    if (!IsValid(GameInstance))\n        return;\n    if (GameInstance-&gt;AnnouncerData != nullptr)\n    {\n        for (FSoundStruct SoundStruct : GameInstance-&gt;AnnouncerData-&gt;SoundDatas)\n        {\n            if (SoundStruct.Name == Name)\n            {\n                PlayAnnouncerVoice(SoundStruct.SoundWave, SoundStruct.MaxDuration);\n                break;\n            }\n        }\n    }\n}\n\nTArray&lt;APlayerObject*&gt; ANightSkyGameState::GetTeam(bool IsP1) const\n{\n    if (IsP1)\n    {\n        TArray&lt;APlayerObject*&gt; PlayerObjects;\n        for (int i = 0; i &lt; BattleState.TeamData[0].TeamCount; i++)\n        {\n            PlayerObjects.Add(Players[i]);\n            for (int j = 0; j &lt; PlayerObjects.Num() - 1; j++)\n            {\n                if (PlayerObjects[i]-&gt;TeamIndex &lt; PlayerObjects[j]-&gt;TeamIndex)\n                {\n                    PlayerObjects.Swap(i, j);\n                }\n            }\n        }\n        return PlayerObjects;\n    }\n    TArray&lt;APlayerObject*&gt; PlayerObjects;\n    for (int i = BattleState.TeamData[1].TeamCount; i &lt; Players.Num(); i++)\n    {\n        PlayerObjects.Add(Players[i]);\n        for (int j = 0; j &lt; PlayerObjects.Num() - 1; j++)\n        {\n            if (PlayerObjects[i - BattleState.TeamData[0].TeamCount]-&gt;TeamIndex &lt; PlayerObjects[j]-&gt;TeamIndex)\n            {\n                PlayerObjects.Swap(i - BattleState.TeamData[0].TeamCount, j);\n            }\n        }\n    }\n    return PlayerObjects;\n}\n\nAPlayerObject* ANightSkyGameState::GetMainPlayer(bool IsP1) const\n{\n    if (IsP1) return BattleState.MainPlayer[0];\n    return BattleState.MainPlayer[1];\n}\n\nvoid ANightSkyGameState::CallBattleExtension(FGameplayTag Name)\n{\n    if (BattleExtensionNames.Find(FGameplayTag(Name)) != INDEX_NONE)\n    {\n        BattleExtensions[BattleExtensionNames.Find(FGameplayTag(Name))]-&gt;Exec();\n    }\n}\n\nint32 ANightSkyGameState::GetGauge(bool IsP1, int32 GaugeIndex) const\n{\n    if (GaugeIndex &lt; BattleState.MaxGauge.Num())\n    {\n        if (IsP1) return BattleState.GaugeP1[GaugeIndex];\n        return BattleState.GaugeP2[GaugeIndex];\n    }\n\n    return -1;\n}\n\nvoid ANightSkyGameState::SetGauge(bool IsP1, int32 GaugeIndex, int32 Value)\n{\n    if (GaugeIndex &lt; BattleState.MaxGauge.Num())\n    {\n        if (IsP1) BattleState.GaugeP1[GaugeIndex] = Value;\n        else BattleState.GaugeP2[GaugeIndex] = Value;\n    }\n}\n\nvoid ANightSkyGameState::UseGauge(bool IsP1, int32 GaugeIndex, int32 Value)\n{\n    if (GaugeIndex &lt; BattleState.MaxGauge.Num())\n    {\n        if (IsP1) BattleState.GaugeP1[GaugeIndex] -= Value;\n        else BattleState.GaugeP2[GaugeIndex] -= Value;\n    }\n}\n\nEScreenFlag ANightSkyGameState::GetScreenFlags() const\n{\n    return BattleState.ScreenData.Flags;\n}\n\nvoid ANightSkyGameState::SetScreenFlags(int32 InFlags)\n{\n    BattleState.ScreenData.Flags = (EScreenFlag)InFlags;\n}\n\nbool ANightSkyGameState::IsTagBattle() const\n{\n    return BattleState.BattleFormat == EBattleFormat::Tag;\n}\n\nint32 ANightSkyGameState::GetTeamCount(const bool bIsP1) const\n{\n    return BattleState.TeamData[bIsP1 == false].TeamCount;\n}\n\nbool ANightSkyGameState::GetPaused() const\n{\n    return bPauseGame;\n}\n\nvoid ANightSkyGameState::SetPaused(bool bPause)\n{\n    bPauseGame = bPause;\n    if (GameInstance-&gt;FighterRunner == LocalPlay)\n    {\n        UGameplayStatics::SetGamePaused(this, bPause);\n    }\n}\n\nvoid ANightSkyGameState::ScreenPosToWorldPos(const int32 X, const int32 Y, int32&amp; OutX, int32&amp; OutY) const\n{\n    const auto ScreenYSize = BattleState.ScreenData.FinalScreenWidth * 360 / 1280;\n\n    OutX = BattleState.ScreenData.ScreenWorldCenterX * 1000 + BattleState.ScreenData.FinalScreenWidth * (X - 500);\n    OutY = BattleState.ScreenData.ScreenWorldCenterY * 1000 + ScreenYSize * Y;\n}\n\nvoid ANightSkyGameState::BattleHudVisibility(bool Visible)\n{\n    BattleState.bHUDVisible = Visible;\n}\n\nvoid ANightSkyGameState::PlayCommonAudio(USoundBase* InSoundWave, float MaxDuration)\n{\n    for (int i = 0; i &lt; CommonAudioChannelCount; i++)\n    {\n        if (BattleState.CommonAudioChannels[i].Finished)\n        {\n            BattleState.CommonAudioChannels[i].SoundWave = InSoundWave;\n            BattleState.CommonAudioChannels[i].StartingFrame = BattleState.FrameNumber;\n            BattleState.CommonAudioChannels[i].MaxDuration = MaxDuration;\n            BattleState.CommonAudioChannels[i].Finished = false;\n            if (!bIsResimulating)\n            {\n                AudioManager-&gt;CommonAudioPlayers[i]-&gt;SetSound(InSoundWave);\n                AudioManager-&gt;CommonAudioPlayers[i]-&gt;Play();\n            }\n            return;\n        }\n    }\n}\n\nvoid ANightSkyGameState::PlayCharaAudio(USoundBase* InSoundWave, float MaxDuration)\n{\n    for (int i = 0; i &lt; CharaAudioChannelCount; i++)\n    {\n        if (BattleState.CharaAudioChannels[i].Finished)\n        {\n            BattleState.CharaAudioChannels[i].SoundWave = InSoundWave;\n            BattleState.CharaAudioChannels[i].StartingFrame = BattleState.FrameNumber;\n            BattleState.CharaAudioChannels[i].MaxDuration = MaxDuration;\n            BattleState.CharaAudioChannels[i].Finished = false;\n            if (!bIsResimulating)\n            {\n                AudioManager-&gt;CharaAudioPlayers[i]-&gt;SetSound(InSoundWave);\n                AudioManager-&gt;CharaAudioPlayers[i]-&gt;Play();\n            }\n            return;\n        }\n    }\n}\n\nvoid ANightSkyGameState::PlayVoiceLine(USoundBase* InSoundWave, float MaxDuration, int Player)\n{\n    BattleState.CharaVoiceChannels[Player].SoundWave = InSoundWave;\n    BattleState.CharaVoiceChannels[Player].StartingFrame = BattleState.FrameNumber;\n    BattleState.CharaVoiceChannels[Player].MaxDuration = MaxDuration;\n    BattleState.CharaVoiceChannels[Player].Finished = false;\n    if (!bIsResimulating)\n    {\n        AudioManager-&gt;CharaVoicePlayers[Player]-&gt;SetSound(InSoundWave);\n        AudioManager-&gt;CharaVoicePlayers[Player]-&gt;Play();\n    }\n}\n\nvoid ANightSkyGameState::PlayAnnouncerVoice(USoundBase* InSoundWave, float MaxDuration)\n{\n    BattleState.AnnouncerVoiceChannel.SoundWave = InSoundWave;\n    BattleState.AnnouncerVoiceChannel.StartingFrame = BattleState.FrameNumber;\n    BattleState.AnnouncerVoiceChannel.MaxDuration = MaxDuration;\n    BattleState.AnnouncerVoiceChannel.Finished = false;\n    if (!bIsResimulating)\n    {\n        AudioManager-&gt;AnnouncerVoicePlayer-&gt;SetSound(InSoundWave);\n        AudioManager-&gt;AnnouncerVoicePlayer-&gt;Play();\n    }\n}\n\nvoid ANightSkyGameState::PlayMusic(const FGameplayTag Name)\n{\n    if (!IsValid(GameInstance))\n        return;\n    if (GameInstance-&gt;MusicData != nullptr)\n    {\n        for (FSoundStruct SoundStruct : GameInstance-&gt;MusicData-&gt;SoundDatas)\n        {\n            if (SoundStruct.Name == Name)\n            {\n                PlayMusic(SoundStruct.SoundWave, SoundStruct.MaxDuration);\n                break;\n            }\n        }\n    }\n}\n\nvoid ANightSkyGameState::PlayMusic(USoundBase* InSoundWave, float MaxDuration)\n{\n    BattleState.MusicChannel.SoundWave = InSoundWave;\n    BattleState.MusicChannel.StartingFrame = BattleState.FrameNumber;\n    BattleState.MusicChannel.MaxDuration = MaxDuration;\n    if (!bIsResimulating)\n    {\n        AudioManager-&gt;MusicPlayer-&gt;SetSound(InSoundWave);\n        AudioManager-&gt;MusicPlayer-&gt;Play();\n    }\n}\n\nvoid ANightSkyGameState::ManageAudio()\n{\n    for (int i = 0; i &lt; CommonAudioChannelCount; i++)\n    {\n        const int CurrentAudioTime = BattleState.FrameNumber - BattleState.CommonAudioChannels[i].StartingFrame;\n        if (!BattleState.CommonAudioChannels[i].Finished &amp;&amp; static_cast&lt;int&gt;(BattleState.CommonAudioChannels[i].\n            MaxDuration * 60) &lt; CurrentAudioTime)\n        {\n            BattleState.CommonAudioChannels[i].Finished = true;\n            BattleState.CommonAudioChannels[i].SoundWave = nullptr;\n            if (bIsResimulating) continue;\n            AudioManager-&gt;CommonAudioPlayers[i]-&gt;Stop();\n            AudioManager-&gt;CommonAudioPlayers[i]-&gt;SetSound(nullptr);\n        }\n    }\n    for (int i = 0; i &lt; CharaAudioChannelCount; i++)\n    {\n        const int CurrentAudioTime = BattleState.FrameNumber - BattleState.CharaAudioChannels[i].StartingFrame;\n        if (!BattleState.CharaAudioChannels[i].Finished &amp;&amp; static_cast&lt;int&gt;(BattleState.CharaAudioChannels[i].\n            MaxDuration * 60) &lt; CurrentAudioTime)\n        {\n            BattleState.CharaAudioChannels[i].Finished = true;\n            BattleState.CharaAudioChannels[i].SoundWave = nullptr;\n            if (bIsResimulating) continue;\n            AudioManager-&gt;CharaAudioPlayers[i]-&gt;Stop();\n            AudioManager-&gt;CharaAudioPlayers[i]-&gt;SetSound(nullptr);\n        }\n    }\n    for (int i = 0; i &lt; CharaVoiceChannelCount; i++)\n    {\n        const int CurrentAudioTime = BattleState.FrameNumber - BattleState.CharaVoiceChannels[i].StartingFrame;\n        if (!BattleState.CharaVoiceChannels[i].Finished &amp;&amp; static_cast&lt;int&gt;(BattleState.CharaVoiceChannels[i].\n            MaxDuration * 60) &lt; CurrentAudioTime)\n        {\n            BattleState.CharaVoiceChannels[i].Finished = true;\n            BattleState.CharaVoiceChannels[i].SoundWave = nullptr;\n            if (bIsResimulating) continue;\n            AudioManager-&gt;CharaVoicePlayers[i]-&gt;Stop();\n            AudioManager-&gt;CharaVoicePlayers[i]-&gt;SetSound(nullptr);\n        }\n    }\n    {\n        const int CurrentAudioTime = BattleState.FrameNumber - BattleState.AnnouncerVoiceChannel.StartingFrame;\n        if (!BattleState.AnnouncerVoiceChannel.Finished &amp;&amp; static_cast&lt;int&gt;(BattleState.AnnouncerVoiceChannel.\n            MaxDuration * 60) &lt; CurrentAudioTime)\n        {\n            BattleState.AnnouncerVoiceChannel.Finished = true;\n            BattleState.AnnouncerVoiceChannel.SoundWave = nullptr;\n            if (!bIsResimulating)\n            {\n                AudioManager-&gt;AnnouncerVoicePlayer-&gt;Stop();\n                AudioManager-&gt;AnnouncerVoicePlayer-&gt;SetSound(nullptr);\n            }\n        }\n    }\n    {\n        const int CurrentAudioTime = BattleState.FrameNumber - BattleState.MusicChannel.StartingFrame;\n        if (static_cast&lt;int&gt;(BattleState.MusicChannel.MaxDuration * 60) &lt; CurrentAudioTime)\n        {\n            PlayMusic(BattleState.MusicChannel.SoundWave, BattleState.MusicChannel.MaxDuration);\n        }\n    }\n}\n\nvoid ANightSkyGameState::RollbackStartAudio(int32 InFrame)\n{\n    ManageAudio();\n\n    for (int i = 0; i &lt; CommonAudioChannelCount; i++)\n    {\n        if (BattleState.CommonAudioChannels[i].Finished) continue;\n        if (BattleState.CommonAudioChannels[i].SoundWave == AudioManager-&gt;CommonAudioPlayers[i]-&gt;GetSound()) continue;\n\n        AudioManager-&gt;CommonAudioPlayers[i]-&gt;Stop();\n        AudioManager-&gt;CommonAudioPlayers[i]-&gt;SetSound(BattleState.CommonAudioChannels[i].SoundWave);\n        const float CurrentAudioTime = static_cast&lt;float&gt;(InFrame - BattleState.CommonAudioChannels[i].StartingFrame) /\n            60.f;\n        if (BattleState.CommonAudioChannels[i].MaxDuration &gt; CurrentAudioTime)\n            AudioManager-&gt;CommonAudioPlayers[i]-&gt;Play(CurrentAudioTime);\n    }\n    for (int i = 0; i &lt; CharaAudioChannelCount; i++)\n    {\n        if (BattleState.CharaAudioChannels[i].Finished) continue;\n        if (BattleState.CharaAudioChannels[i].SoundWave == AudioManager-&gt;CharaAudioPlayers[i]-&gt;GetSound()) continue;\n\n        AudioManager-&gt;CharaAudioPlayers[i]-&gt;Stop();\n        AudioManager-&gt;CharaAudioPlayers[i]-&gt;SetSound(BattleState.CharaAudioChannels[i].SoundWave);\n        const float CurrentAudioTime = static_cast&lt;float&gt;(InFrame - BattleState.CharaAudioChannels[i].StartingFrame) /\n            60.f;\n        if (BattleState.CharaAudioChannels[i].MaxDuration &gt; CurrentAudioTime)\n            AudioManager-&gt;CharaAudioPlayers[i]-&gt;Play(CurrentAudioTime);\n    }\n    for (int i = 0; i &lt; CharaVoiceChannelCount; i++)\n    {\n        if (BattleState.CharaVoiceChannels[i].Finished) continue;\n        if (BattleState.CharaVoiceChannels[i].SoundWave == AudioManager-&gt;CharaVoicePlayers[i]-&gt;GetSound()) continue;\n\n        AudioManager-&gt;CharaVoicePlayers[i]-&gt;Stop();\n        AudioManager-&gt;CharaVoicePlayers[i]-&gt;SetSound(BattleState.CharaVoiceChannels[i].SoundWave);\n        const float CurrentAudioTime = static_cast&lt;float&gt;(InFrame - BattleState.CharaVoiceChannels[i].StartingFrame) /\n            60.f;\n        if (BattleState.CharaVoiceChannels[i].MaxDuration &gt; CurrentAudioTime)\n            AudioManager-&gt;CharaVoicePlayers[i]-&gt;Play(CurrentAudioTime);\n    }\n    if (!BattleState.AnnouncerVoiceChannel.Finished &amp;&amp; BattleState.AnnouncerVoiceChannel.SoundWave != AudioManager-&gt;\n        AnnouncerVoicePlayer-&gt;GetSound())\n    {\n        AudioManager-&gt;AnnouncerVoicePlayer-&gt;Stop();\n        AudioManager-&gt;AnnouncerVoicePlayer-&gt;SetSound(BattleState.AnnouncerVoiceChannel.SoundWave);\n        const float CurrentAudioTime = static_cast&lt;float&gt;(InFrame - BattleState.AnnouncerVoiceChannel.StartingFrame) /\n            60.f;\n        if (BattleState.AnnouncerVoiceChannel.MaxDuration &gt; CurrentAudioTime)\n            AudioManager-&gt;AnnouncerVoicePlayer-&gt;Play(CurrentAudioTime);\n    }\n    if (BattleState.MusicChannel.SoundWave != AudioManager-&gt;MusicPlayer-&gt;GetSound())\n    {\n        AudioManager-&gt;MusicPlayer-&gt;Stop();\n        AudioManager-&gt;MusicPlayer-&gt;SetSound(BattleState.MusicChannel.SoundWave);\n        const float CurrentAudioTime = static_cast&lt;float&gt;(InFrame - BattleState.MusicChannel.StartingFrame) / 60.f;\n        if (BattleState.MusicChannel.MaxDuration &gt; CurrentAudioTime)\n            AudioManager-&gt;MusicPlayer-&gt;Play(CurrentAudioTime);\n    }\n}\n\nvoid ANightSkyGameState::SaveGameState(FRollbackData&amp; RollbackData, int32* InChecksum)\n{\n    RollbackData.BattleStateBuffer.AddUninitialized(SizeOfBattleState);\n    FMemory::Memcpy(RollbackData.BattleStateBuffer.GetData(), &amp;BattleState.BattleStateSync, SizeOfBattleState);\n    RollbackData.BattleStateData = SaveForRollback();\n    for (int i = 0; i &lt; BattleExtensions.Num(); i++)\n    {\n        RollbackData.ExtensionData.Add(BattleExtensions[i]-&gt;SaveForRollback());\n    }\n    if (BattleExtensions.Num() == 0)\n    {\n        RollbackData.ExtensionData.Add(TArray&lt;uint8&gt;{1});\n    }\n    for (int i = 0; i &lt; MaxBattleObjects; i++)\n    {\n        if (Objects[i]-&gt;IsActive)\n        {\n            RollbackData.ObjBuffer.AddDefaulted();\n            RollbackData.ObjBuffer.Last().AddUninitialized(SizeOfBattleObject);\n            Objects[i]-&gt;SaveForRollback(RollbackData.ObjBuffer[i].GetData());\n            RollbackData.StateData.Add(Objects[i]-&gt;ObjectState-&gt;SaveForRollback());\n            RollbackData.ObjActive.AddDefaulted();\n            RollbackData.ObjActive[i] = true;\n        }\n        else\n        {\n            RollbackData.ObjBuffer.AddDefaulted();\n            RollbackData.ObjActive.AddDefaulted();\n            RollbackData.ObjActive[i] = false;\n            RollbackData.StateData.Add(TArray&lt;uint8&gt;{1});\n        }\n    }\n    for (int i = 0; i &lt; Players.Num(); i++)\n    {\n        RollbackData.ObjBuffer.AddDefaulted();\n        RollbackData.ObjBuffer.Last().AddUninitialized(SizeOfBattleObject);\n        Players[i]-&gt;SaveForRollback(RollbackData.ObjBuffer[i + MaxBattleObjects].GetData());\n        if (Players[i]-&gt;PlayerFlags &amp; PLF_IsOnScreen)\n        {\n            RollbackData.StateData.Add(Players[i]-&gt;PrimaryStateMachine.CurrentState-&gt;SaveForRollback());\n        }\n        else\n        {\n            RollbackData.StateData.Add(TArray&lt;uint8&gt;{1});\n        }\n        RollbackData.CharBuffer.AddDefaulted();\n        RollbackData.CharBuffer.Last().AddUninitialized(SizeOfPlayerObject);\n        Players[i]-&gt;SaveForRollbackPlayer(RollbackData.CharBuffer[i].GetData());\n        RollbackData.PlayerData.Add(Players[i]-&gt;SaveForRollbackBP());\n    }\n\n    RollbackData.WidgetAnimationData.Add(BattleHudActor-&gt;TopWidget-&gt;SaveForRollback());\n    RollbackData.WidgetAnimationData.Add(BattleHudActor-&gt;BottomWidget-&gt;SaveForRollback());\n\n    *InChecksum = CreateChecksum();\n}\n\nvoid ANightSkyGameState::LoadGameState(FRollbackData&amp; RollbackData)\n{\n    const int CurrentFrame = BattleState.FrameNumber;\n    FMemory::Memcpy(&amp;BattleState.BattleStateSync, RollbackData.BattleStateBuffer.GetData(), SizeOfBattleState);\n    LoadForRollback(RollbackData.BattleStateData);\n    for (int i = 0; i &lt; BattleExtensions.Num(); i++)\n    {\n        BattleExtensions[i]-&gt;LoadForRollback(RollbackData.ExtensionData[i]);\n    }\n    for (int i = 0; i &lt; MaxBattleObjects; i++)\n    {\n        if (RollbackData.ObjActive[i])\n        {\n            Objects[i]-&gt;LoadForRollback(RollbackData.ObjBuffer[i].GetData());\n            Objects[i]-&gt;ObjectState-&gt;LoadForRollback(RollbackData.StateData[i]);\n        }\n        else\n        {\n            if (Objects[i]-&gt;IsActive)\n                Objects[i]-&gt;ResetObject();\n        }\n    }\n    for (int i = 0; i &lt; Players.Num(); i++)\n    {\n        Players[i]-&gt;LoadForRollback(RollbackData.ObjBuffer[i + MaxBattleObjects].GetData());\n        if (Players[i]-&gt;PlayerFlags &amp; PLF_IsOnScreen)\n        {\n            Players[i]-&gt;PrimaryStateMachine.CurrentState-&gt;LoadForRollback(\n                RollbackData.StateData[i + MaxBattleObjects]);\n        }\n        Players[i]-&gt;LoadForRollbackPlayer(RollbackData.CharBuffer[i].GetData());\n        Players[i]-&gt;LoadForRollbackBP(RollbackData.PlayerData[i]);\n    }\n    SortObjects();\n    ParticleManager-&gt;RollbackParticles(CurrentFrame - BattleState.FrameNumber);\n\n    BattleHudActor-&gt;TopWidget-&gt;LoadForRollback(RollbackData.WidgetAnimationData[0]);\n    BattleHudActor-&gt;BottomWidget-&gt;LoadForRollback(RollbackData.WidgetAnimationData[1]);\n\n    BattleHudActor-&gt;TopWidget-&gt;RollbackAnimations();\n    BattleHudActor-&gt;BottomWidget-&gt;RollbackAnimations();\n\n    if (!FighterRunner-&gt;IsA(AFighterSynctestRunner::StaticClass()))\n        GameInstance-&gt;RollbackReplay(CurrentFrame - BattleState.FrameNumber);\n}\n\nTArray&lt;uint8&gt; ANightSkyGameState::SaveForRollback()\n{\n    TArray&lt;uint8&gt; SaveData;\n    FObjectWriter Writer(SaveData);\n    Writer.ArIsSaveGame = true;\n    GetClass()-&gt;SerializeBin(Writer, this);\n    return SaveData;\n}\n\nvoid ANightSkyGameState::LoadForRollback(const TArray&lt;uint8&gt;&amp; InBytes)\n{\n    if (InBytes.Num() &lt;= 1) return;\n    FObjectReader Reader(InBytes);\n    Reader.ArIsSaveGame = true;\n    GetClass()-&gt;SerializeBin(Reader, this);\n}\n\nvoid ANightSkyGameState::EndMatch()\n{\n    EndMatch_BP();\n    BattleState.BattlePhase = EBattlePhase::EndScreen;\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_game_state_8h/","title":"File NightSkyGameState.h","text":"<p>FileList &gt; Battle &gt; NightSkyGameState.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Actors/AudioManager.h\"</code></li> <li><code>#include \"Objects/PlayerObject.h\"</code></li> <li><code>#include \"GameFramework/GameStateBase.h\"</code></li> <li><code>#include \"include/ggponet.h\"</code></li> <li><code>#include \"Misc/RandomManager.h\"</code></li> <li><code>#include \"NightSkyGameState.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_game_state_8h/#classes","title":"Classes","text":"Type Name class ANightSkyGameState struct FAudioChannel struct FBattleState struct FNetworkStats struct FRollbackData struct FScreenData struct FTeamData"},{"location":"NightSkyEngine/_night_sky_game_state_8h/#public-types","title":"Public Types","text":"Type Name enum uint8 EBattleFormat enum EBattlePhase enum EIntroSide enum EScreenFlag enum EWinSide"},{"location":"NightSkyEngine/_night_sky_game_state_8h/#public-attributes","title":"Public Attributes","text":"Type Name int32 MaxRollbackFrames   = <code>1</code> float OneFrame   = <code>0.0166666666</code> size_t SizeOfBattleState   = <code>/* multi line expression */</code>"},{"location":"NightSkyEngine/_night_sky_game_state_8h/#public-functions","title":"Public Functions","text":"Type Name ENUM_CLASS_FLAGS (EScreenFlag)"},{"location":"NightSkyEngine/_night_sky_game_state_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"NightSkyEngine/_night_sky_game_state_8h/#enum-ebattleformat","title":"enum EBattleFormat","text":"<pre><code>enum EBattleFormat {\n    Rounds,\n    Tag,\n    KOF\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_game_state_8h/#enum-ebattlephase","title":"enum EBattlePhase","text":"<pre><code>enum EBattlePhase {\n    Intro,\n    Battle,\n    RoundEnd,\n    Fade,\n    Outro,\n    EndScreen\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_game_state_8h/#enum-eintroside","title":"enum EIntroSide","text":"<pre><code>enum EIntroSide {\n    INT_P1,\n    INT_P2,\n    INT_None\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_game_state_8h/#enum-escreenflag","title":"enum EScreenFlag","text":"<pre><code>enum EScreenFlag {\n    SCR_None,\n    SCR_Lock = 1 &lt;&lt; 0,\n    SCR_LockXPos = 1 &lt;&lt; 1,\n    SCR_LockYPos = 1 &lt;&lt; 2,\n    SCR_LockWidth = 1 &lt;&lt; 3,\n    SCR_DisableScreenSides = 1 &lt;&lt; 4\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_game_state_8h/#enum-ewinside","title":"enum EWinSide","text":"<pre><code>enum EWinSide {\n    WIN_None,\n    WIN_P1,\n    WIN_P2,\n    WIN_Draw\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_game_state_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/_night_sky_game_state_8h/#variable-maxrollbackframes","title":"variable MaxRollbackFrames","text":"<pre><code>int32 MaxRollbackFrames;\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_game_state_8h/#variable-oneframe","title":"variable OneFrame","text":"<pre><code>float OneFrame;\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_game_state_8h/#variable-sizeofbattlestate","title":"variable SizeOfBattleState","text":"<pre><code>size_t SizeOfBattleState;\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_game_state_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_night_sky_game_state_8h/#function-enum_class_flags","title":"function ENUM_CLASS_FLAGS","text":"<pre><code>ENUM_CLASS_FLAGS (\n    EScreenFlag\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyGameState.h</code></p>"},{"location":"NightSkyEngine/_night_sky_game_state_8h_source/","title":"File NightSkyGameState.h","text":"<p>File List &gt; Battle &gt; NightSkyGameState.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Actors/AudioManager.h\"\n#include \"Objects/PlayerObject.h\"\n#include \"GameFramework/GameStateBase.h\"\n#include \"include/ggponet.h\"\n#include \"Misc/RandomManager.h\"\n#include \"NightSkyGameState.generated.h\"\n\nclass UBattleExtensionData;\nclass UBattleExtension;\nconstexpr int32 MaxRollbackFrames = 1;\nconstexpr float OneFrame = 0.0166666666;\n\nclass ANightSkyBattleHudActor;\n\n// Battle data\n\nUENUM(BlueprintType)\nenum class EBattleFormat : uint8\n{\n    Rounds,\n    Tag,\n    KOF,\n};\n\nenum EIntroSide\n{\n    INT_P1,\n    INT_P2,\n    INT_None,\n};\n\nUENUM(BlueprintType)\nenum EWinSide \n{\n    WIN_None,\n    WIN_P1,\n    WIN_P2,\n    WIN_Draw,\n};\n\nUENUM()\nenum class EBattlePhase\n{\n    Intro,\n    Battle,\n    RoundEnd,\n    Fade,\n    Outro,\n    EndScreen,\n};\n\nUSTRUCT()\nstruct FAudioChannel\n{\n    GENERATED_BODY()\n\n    UPROPERTY()\n    USoundBase* SoundWave;\n    int StartingFrame;\n    float MaxDuration = 1.0f;\n    bool Finished = true;\n};\n\nUSTRUCT()\nstruct FTeamData\n{\n    GENERATED_BODY()\n\n    UPROPERTY(SaveGame)\n    int TeamCount = 0;\n\n    UPROPERTY(SaveGame)\n    TArray&lt;int32&gt; CooldownTimer;\n};\n\nUENUM(Meta = (Bitflags, UseEnumValuesAsMaskValuesInEditor = \"true\"))\nenum EScreenFlag \n{\n    SCR_None,\n    SCR_Lock = 1 &lt;&lt; 0,\n    SCR_LockXPos = 1 &lt;&lt; 1,\n    SCR_LockYPos = 1 &lt;&lt; 2,\n    SCR_LockWidth = 1 &lt;&lt; 3,\n    SCR_DisableScreenSides = 1 &lt;&lt; 4,\n};\n\nENUM_CLASS_FLAGS(EScreenFlag);\n\nUSTRUCT(BlueprintType)\nstruct FScreenData \n{\n    GENERATED_BODY()\n\n    TEnumAsByte&lt;EScreenFlag&gt; Flags;\n    bool bTouchingWorldSide;\n\n    UPROPERTY(EditAnywhere)\n    int DefaultMaxWidth = 1689;\n    UPROPERTY(EditAnywhere)\n    int DefaultWidth = 1280;\n\n    int MaxZoomOutWidth = 1689;\n    int ZoomOutBeginX = 1280;\n    int ZoomOutBeginY = 180;\n    int ZoomOutBeginH = 360;\n\n    UPROPERTY(SaveGame)\n    TArray&lt;ABattleObject*&gt; TargetObjects{};\n\n    int ObjTop = 0;\n    int ObjBottom = 0;\n    int HigherObjBottom = 0;\n    int ObjLeft = 0;\n    int ObjRight = 0;\n    int ObjLength = 0;\n    int ObjHeight = 0;\n    int ObjDistanceY = 0;\n\n    int ScreenWorldCenterX = 0;\n    int ScreenWorldCenterY = 0;\n    int ScreenWorldWidth = 1280;\n\n    int TargetCenterX = 0;\n    int TargetCenterY = 0;\n    int TargetWidth = 1280;\n\n    int CenterXVelocity = 0;\n    int CenterYVelocity = 0;\n    int WidthVelocity = 0;\n\n    int FinalScreenX = 0;\n    int FinalScreenY = 0;\n    int FinalScreenWidth = 1280;\n\n    float ScreenYZoom = 0;\n\n    int TargetOffsetY = 350;\n    int TargetOffsetLandYMax = 250;\n    int TargetOffsetLandYAdd = 6;\n    int TargetOffsetAirYMax = 180;\n    int TargetOffsetAirYAdd = 3;\n    int TargetOffsetAirYPos = 400;\n    int TargetOffsetAirYDist = 570;\n\n    int ScreenBoundsLeft = -640;\n    int ScreenBoundsRight = 640;\n    int ScreenBoundsTop = 0;\n\n    UPROPERTY(EditAnywhere)\n    int StageBoundsLeft = -3200;\n    UPROPERTY(EditAnywhere)\n    int StageBoundsRight = 3200;\n    UPROPERTY(EditAnywhere)\n    int StageBoundsTop = 5400;\n};\n\nUSTRUCT(BlueprintType)\nstruct FBattleState\n{\n    GENERATED_BODY()\n\n    char BattleStateSync;\n\n    int32 FrameNumber = 0;\n    int32 TimeUntilRoundStart = 0;\n\n    UPROPERTY(EditAnywhere)\n    int32 TagCooldown = 300;\n    UPROPERTY(EditAnywhere)\n    int32 AssistCooldown = 180;\n\n    UPROPERTY(EditAnywhere)\n    int32 RoundStartPos = 297500;\n\n    UPROPERTY(EditAnywhere, SaveGame)\n    FScreenData ScreenData;\n\n    FVector CameraPosition = FVector();\n    bool bHUDVisible = true;\n\n    UPROPERTY(BlueprintReadOnly)\n    int32 RoundTimer = 0;\n\n    bool PauseTimer = false;\n    bool PauseParticles = false;\n    bool IsPlayingSequence = false;\n\n    FRandomManager RandomManager;\n\n    int32 Meter[2] {0, 0};\n    int32 MaxMeter[2] {10000, 10000};\n\n    int32 SuperFreezeDuration = 0;\n    int32 SuperFreezeSelfDuration = 0;\n\n    UPROPERTY()\n    ABattleObject* SuperFreezeCaller = nullptr;\n    UPROPERTY()\n    APlayerObject* MainPlayer[2];\n\n    int32 P1RoundsWon = 0;\n    int32 P2RoundsWon = 0;\n    UPROPERTY(BlueprintReadOnly)\n    int32 RoundCount = 0;\n    int32 FadeTimer;\n\n    EIntroSide CurrentIntroSide = INT_None;\n    UPROPERTY(BlueprintReadOnly)\n    TEnumAsByte&lt;EWinSide&gt; CurrentWinSide = WIN_None;\n    EBattlePhase BattlePhase = EBattlePhase::Intro;\n\n    int32 ActiveObjectCount = 0;\n    int32 CurrentSequenceTime = -1;\n\n    FAudioChannel CommonAudioChannels[CommonAudioChannelCount];\n    FAudioChannel CharaAudioChannels[CharaAudioChannelCount];\n    FAudioChannel CharaVoiceChannels[CharaVoiceChannelCount];\n    FAudioChannel AnnouncerVoiceChannel;\n    FAudioChannel MusicChannel;\n\n    UPROPERTY(BlueprintReadOnly)\n    float OrthoBlendActive;\n\n    char BattleStateSyncEnd;\n\n    UPROPERTY(SaveGame)\n    FTeamData TeamData[2];\n\n    UPROPERTY(SaveGame)\n    TArray&lt;int32&gt; GaugeP1;\n    UPROPERTY(SaveGame)\n    TArray&lt;int32&gt; GaugeP2;\n    UPROPERTY(EditAnywhere, SaveGame)\n    TArray&lt;int32&gt; MaxGauge;\n\n    UPROPERTY(BlueprintReadOnly)\n    EBattleFormat BattleFormat = EBattleFormat::Rounds;\n    UPROPERTY(BlueprintReadOnly)\n    int32 MaxRoundCount;\n    UPROPERTY(BlueprintReadOnly)\n    int32 MaxTimeUntilRoundStart;\n    UPROPERTY(EditAnywhere)\n    int32 MaxFadeTimer = 12;\n};\n\nconstexpr size_t SizeOfBattleState = offsetof(FBattleState, BattleStateSyncEnd) - offsetof(\n    FBattleState, BattleStateSync);\n\nUSTRUCT()\nstruct FRollbackData\n{\n    GENERATED_BODY()\n\n    UPROPERTY()\n    TArray&lt;bool&gt; ObjActive;\n    TArray&lt;TArray&lt;uint8&gt;&gt; ObjBuffer;\n    TArray&lt;TArray&lt;uint8&gt;&gt; CharBuffer;\n    TArray&lt;uint8&gt; BattleStateBuffer;\n    TArray&lt;TArray&lt;uint8&gt;&gt; PlayerData;\n    TArray&lt;uint8&gt; BattleStateData;\n    TArray&lt;TArray&lt;uint8&gt;&gt; StateData;\n    TArray&lt;TArray&lt;uint8&gt;&gt; ExtensionData;\n    TArray&lt;TArray&lt;uint8&gt;&gt; WidgetAnimationData;\n\n    void Serialize(FArchive&amp; Ar);\n};\n\n// Network\n\nUSTRUCT(BlueprintType)\nstruct FNetworkStats\n{\n    GENERATED_BODY()\n\n    UPROPERTY(BlueprintReadOnly)\n    int32 Ping;\n    UPROPERTY(BlueprintReadOnly)\n    int32 RollbackFrames;\n};\n\n// Main class\n\nUCLASS()\nclass NIGHTSKYENGINE_API ANightSkyGameState : public AGameStateBase\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ANightSkyGameState();\n\n    UPROPERTY(EditAnywhere, Category=Defaults)\n    int MaxBattleObjects = 400;\n    UPROPERTY(EditAnywhere, Category=Defaults)\n    TSubclassOf&lt;ABattleObject&gt; BattleObjectClass = ABattleObject::StaticClass();\n    UPROPERTY()\n    TArray&lt;ABattleObject*&gt; Objects {};\n    UPROPERTY()\n    TArray&lt;APlayerObject*&gt; Players {};\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, SaveGame, Category=Battle)\n    FBattleState BattleState {};\n\n    UPROPERTY()\n    TArray&lt;ABattleObject*&gt; SortedObjects {};\n\n    UPROPERTY(BlueprintReadWrite)\n    FTransform BattleSceneTransform;\n\n    UPROPERTY()\n    TArray&lt;UBattleExtension*&gt; BattleExtensions = {};\n    TArray&lt;FGameplayTag&gt; BattleExtensionNames = {};\n\n    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category=Assets)\n    UBattleExtensionData* BattleExtensionData = {};\n\n    UPROPERTY()\n    class UNightSkyGameInstance* GameInstance = nullptr;\n\n    UPROPERTY()\n    class AParticleManager* ParticleManager = nullptr;\n    UPROPERTY()\n    AAudioManager* AudioManager = nullptr;\n\n    UPROPERTY(BlueprintReadWrite)\n    class ALevelSequenceActor* SequenceActor = nullptr;\n    UPROPERTY(BlueprintReadWrite)\n    ACameraActor* CameraActor = nullptr;\n    UPROPERTY(BlueprintReadWrite)\n    ACameraActor* SequenceCameraActor = nullptr;\n    UPROPERTY(EditDefaultsOnly, Category=Defaults)\n    TSubclassOf&lt;ACameraActor&gt; SequenceCameraActorClass;\n    UPROPERTY(BlueprintReadOnly)\n    APlayerObject* SequenceTarget = nullptr;\n    UPROPERTY(BlueprintReadOnly)\n    APlayerObject* SequenceEnemy = nullptr;\n    UPROPERTY(BlueprintGetter=GetPaused, BlueprintSetter=SetPaused)\n    bool bPauseGame = false;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=Debug)\n    bool bViewCollision = false;\n\n    UPROPERTY(BlueprintReadOnly)\n    bool bIsPlayingSequence = false;\n\n    UPROPERTY()\n    class AFighterLocalRunner* FighterRunner = nullptr;;\n    UPROPERTY(BlueprintReadWrite)\n    ANightSkyBattleHudActor* BattleHudActor = nullptr;;\n\n    int32 LocalFrame = 0;\n    int32 RemoteFrame = 0;\n\nprivate:\n    int32 LocalInputs[2] = {};\n    int32 Checksum = 0;\n    int32 OtherChecksum = 0;\n    int32 OtherChecksumFrame = 0;\n    int32 PrevOtherChecksumFrame = 0;\n    FNetworkStats NetworkStats = FNetworkStats();\n    bool bIsResimulating = false;\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n    virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;\n    void Init();\n    void PlayIntros();\n    void UpdateLocalInput(); //updates local input\n    void SortObjects();\n    void HandlePushCollision() const; //for each active object, handle push collision\n    void HandleHitCollision() const;\n    void UpdateVisuals(bool bShouldResimulate) const;\n    void HandleRoundWin();\n    void NextRoundTransition(bool bIsP1);\n    bool HandleMatchWin();\n    void CollisionView() const;\n    int32 CreateChecksum();\n    FGGPONetworkStats GetNetworkStats() const;\n    void ResetTraining();\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable)\n    void MatchInit();\n    void RoundInit();\n\n    void AssignEnemy();\n\n    void UpdateGameState();\n    void UpdateGameState(int32 Input1, int32 Input2, bool bShouldResimulate);\n\n    void SetScreenCorners();\n    void UpdateScreen();\n    void SetScreenBounds() const; //forces wall collision\n    void StartSuperFreeze(int32 Duration, int32 SelfDuration, ABattleObject* CallingObject);\n    void ScreenPosToWorldPos(int32 X, int32 Y, int32&amp; OutX, int32&amp; OutY) const;\n    ABattleObject* AddBattleObject(const UState* InState, int PosX, int PosY, EObjDir Dir, int32 ObjectStateIndex, bool bIsCommonState, APlayerObject* Parent) const;\n    void SetDrawPriorityFront(ABattleObject* InObject) const;\n    void SetDrawPriorityBack(ABattleObject* InObject) const;\n    APlayerObject* SwitchMainPlayer(APlayerObject* InPlayer, int TeamIndex, bool bForce = false, bool bEvenOnScreen = false);\n    APlayerObject* CallAssist(const bool IsP1, int AssistIndex, const FGameplayTag AssistName);\n    void SetTeamCooldown(const bool IsP1, const int TeamIndex, const int Cooldown);\n    bool CanTag(const APlayerObject* InPlayer, int TeamIndex) const;\n\n    void SaveGameState(FRollbackData&amp; RollbackData, int32* InChecksum); //saves game state\n    void LoadGameState(FRollbackData&amp; RollbackData); //loads game state\n\n    TArray&lt;uint8&gt; SaveForRollback();\n    void LoadForRollback(const TArray&lt;uint8&gt;&amp; InBytes);\n    void EndMatch();\n\n    void UpdateCamera();\n    void PlayLevelSequence(APlayerObject* Target, APlayerObject* Enemy, ULevelSequence* Sequence);\n    void StopLevelSequence();\n    void CameraShake(const TSubclassOf&lt;UCameraShakeBase&gt;&amp; Pattern, float Scale) const;\n\n    void HUDInit() const;\n    void UpdateHUD();\n    void BattleHudVisibility(bool Visible);\n\n    void PlayCommonAudio(USoundBase* InSoundWave, float MaxDuration);\n    void PlayCharaAudio(USoundBase* InSoundWave, float MaxDuration);\n    void PlayVoiceLine(USoundBase* InSoundWave, float MaxDuration, int Player);\n    void PlayAnnouncerVoice(USoundBase* InSoundWave, float MaxDuration);\n    void PlayMusic(USoundBase* InSoundWave, float MaxDuration);\n    void ManageAudio();\n    void RollbackStartAudio(int32 InFrame);\n\n    int GetLocalInputs(int Index) const; //get local inputs from player controller\n    void SetOtherChecksum(uint32 RemoteChecksum, int32 InFrame);\n\n    UFUNCTION(BlueprintCallable)\n    void PlayAnnouncerVoice(const FGameplayTag Name);\n    UFUNCTION(BlueprintCallable)\n    void PlayMusic(const FGameplayTag Name);\n\n    UFUNCTION(BlueprintCallable)\n    TArray&lt;APlayerObject*&gt; GetTeam(bool IsP1) const;\n    UFUNCTION(BlueprintCallable)\n    APlayerObject* GetMainPlayer(bool IsP1) const;\n    UFUNCTION(BlueprintCallable)\n    void CallBattleExtension(FGameplayTag Name);\n    UFUNCTION(BlueprintPure)\n    int32 GetGauge(bool IsP1, int32 GaugeIndex) const;\n    UFUNCTION(BlueprintCallable)\n    void SetGauge(bool IsP1, int32 GaugeIndex, int32 Value);\n    UFUNCTION(BlueprintCallable)\n    void UseGauge(bool IsP1, int32 GaugeIndex, int32 Value);\n    UFUNCTION(BlueprintPure)\n    EScreenFlag GetScreenFlags() const;\n    UFUNCTION(BlueprintCallable)\n    void SetScreenFlags(UPARAM(meta = (Bitmask, BitmaskEnum = \"/Script/NightSkyEngine.EScreenFlag\")) int32 InFlags);\n    UFUNCTION(BlueprintPure)\n    bool IsTagBattle() const;\n    UFUNCTION(BlueprintPure)\n    int32 GetTeamCount(bool bIsP1) const;\n\n    UFUNCTION(BlueprintPure)\n    bool GetPaused() const;\n    UFUNCTION(BlueprintCallable)\n    void SetPaused(bool bPause);\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void EndMatch_BP();\n    UFUNCTION(BlueprintImplementableEvent)\n    void UpdateHUD_BP();\n    UFUNCTION(BlueprintImplementableEvent)\n    void UpdateHUDAnimations_BP();\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_player_controller_8cpp/","title":"File NightSkyPlayerController.cpp","text":"<p>FileList &gt; Battle &gt; NightSkyPlayerController.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyPlayerController.h\"</code></li> <li><code>#include \"EngineUtils.h\"</code></li> <li><code>#include \"EnhancedInputComponent.h\"</code></li> <li><code>#include \"EnhancedInputSubsystems.h\"</code></li> <li><code>#include \"InputMappingContext.h\"</code></li> <li><code>#include \"NightSkyGameState.h\"</code></li> <li><code>#include \"FighterRunners/FighterMultiplayerRunner.h\"</code></li> <li><code>#include \"GameFramework/InputSettings.h\"</code></li> <li><code>#include \"Kismet/GameplayStatics.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Misc/Bitflags.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/PrimaryCharaData.h\"</code></li> <li><code>#include \"NightSkyEngine/Network/NetworkPawn.h\"</code></li> <li><code>#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"</code></li> <li><code>#include \"NightSkyEngine/Network/RpcConnectionManager.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyPlayerController.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_player_controller_8cpp_source/","title":"File NightSkyPlayerController.cpp","text":"<p>File List &gt; Battle &gt; NightSkyPlayerController.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyPlayerController.h\"\n\n#include \"EngineUtils.h\"\n#include \"EnhancedInputComponent.h\"\n#include \"EnhancedInputSubsystems.h\"\n#include \"InputMappingContext.h\"\n#include \"NightSkyGameState.h\"\n#include \"FighterRunners/FighterMultiplayerRunner.h\"\n#include \"GameFramework/InputSettings.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"NightSkyEngine/Battle/Misc/Bitflags.h\"\n#include \"NightSkyEngine/Data/PrimaryCharaData.h\"\n#include \"NightSkyEngine/Network/NetworkPawn.h\"\n#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"\n#include \"NightSkyEngine/Network/RpcConnectionManager.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyPlayerController)\n\n// Sets default values\nANightSkyPlayerController::ANightSkyPlayerController()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    Inputs = 0;\n    Frame = 0;\n    NetworkPawn = nullptr;\n    bRematch = false;\n}\n\n// Called when the game starts or when spawned\nvoid ANightSkyPlayerController::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\n// Called every frame\nvoid ANightSkyPlayerController::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n\n    NetworkPawn = Cast&lt;ANetworkPawn&gt;(GetPawn());\n\n    if (NetworkPawn != nullptr)\n    {\n        const int PlayerIndex = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance())-&gt;PlayerIndex;\n        TArray&lt;ANetworkPawn*&gt; NetworkPawns;\n        for (TActorIterator&lt;ANetworkPawn&gt; It(GetWorld()); It; ++It)\n        {\n            NetworkPawns.Add(*It);\n        }\n        if (NetworkPawns.Num() &gt; 1)\n        {\n            if (PlayerIndex == 0)\n            {\n                SendGgpo(NetworkPawns[1], true);\n            }\n            else\n            {\n                SendGgpo(NetworkPawns[0], false);\n            }\n        }\n        if (NetworkPawn-&gt;bRematchAccepted &amp;&amp; bRematch)\n        {\n            Inputs |= INP_Rematch;\n        }\n        else\n        {\n            Inputs = Inputs &amp; ~INP_Rematch;         \n        }\n    }\n}\n\n\nvoid ANightSkyPlayerController::SetupInputComponent()\n{\n    if (GetLocalPlayer())\n    {\n        if (UEnhancedInputLocalPlayerSubsystem* InputSystem = GetLocalPlayer()-&gt;GetSubsystem&lt;UEnhancedInputLocalPlayerSubsystem&gt;())\n        {\n            if (!InputMapping.IsNull())\n            {\n                InputSystem-&gt;AddMappingContext(InputMapping.LoadSynchronous(), 0);\n            }\n        }\n    }\n\n    if (InputComponent == NULL)\n    {\n        InputComponent = NewObject&lt;UEnhancedInputComponent&gt;(this, UInputSettings::GetDefaultInputComponentClass(), TEXT(\"PC_InputComponent0\"));\n        InputComponent-&gt;RegisterComponent();\n    }\n\n    UEnhancedInputComponent* Input = Cast&lt;UEnhancedInputComponent&gt;(InputComponent);\n\n    if (IsValid(InputActions.PressUp))\n        Input-&gt;BindAction(InputActions.PressUp.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::PressUp);\n    if (IsValid(InputActions.ReleaseUp))\n        Input-&gt;BindAction(InputActions.ReleaseUp.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::ReleaseUp);\n    if (IsValid(InputActions.PressDown))\n        Input-&gt;BindAction(InputActions.PressDown.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::PressDown);\n    if (IsValid(InputActions.ReleaseDown))\n        Input-&gt;BindAction(InputActions.ReleaseDown.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::ReleaseDown);\n    if (IsValid(InputActions.PressLeft))\n        Input-&gt;BindAction(InputActions.PressLeft.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::PressLeft);\n    if (IsValid(InputActions.ReleaseLeft))\n        Input-&gt;BindAction(InputActions.ReleaseLeft.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::ReleaseLeft);\n    if (IsValid(InputActions.PressRight))\n        Input-&gt;BindAction(InputActions.PressRight.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::PressRight);\n    if (IsValid(InputActions.ReleaseRight))\n        Input-&gt;BindAction(InputActions.ReleaseRight.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::ReleaseRight);\n    if (IsValid(InputActions.PressA))\n        Input-&gt;BindAction(InputActions.PressA.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::PressA);\n    if (IsValid(InputActions.ReleaseA))\n        Input-&gt;BindAction(InputActions.ReleaseA.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::ReleaseA);\n    if (IsValid(InputActions.PressA))\n        Input-&gt;BindAction(InputActions.PressB.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::PressB);\n    if (IsValid(InputActions.ReleaseB))\n        Input-&gt;BindAction(InputActions.ReleaseB.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::ReleaseB);\n    if (IsValid(InputActions.PressC))\n        Input-&gt;BindAction(InputActions.PressC.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::PressC);\n    if (IsValid(InputActions.ReleaseC))\n        Input-&gt;BindAction(InputActions.ReleaseC.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::ReleaseC);\n    if (IsValid(InputActions.PressD))\n        Input-&gt;BindAction(InputActions.PressD.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::PressD);\n    if (IsValid(InputActions.ReleaseD))\n        Input-&gt;BindAction(InputActions.ReleaseD.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::ReleaseD);\n    if (IsValid(InputActions.PressE))\n        Input-&gt;BindAction(InputActions.PressE.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::PressE);\n    if (IsValid(InputActions.ReleaseE))\n        Input-&gt;BindAction(InputActions.ReleaseE.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::ReleaseE);\n    if (IsValid(InputActions.PressF))\n        Input-&gt;BindAction(InputActions.PressF.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::PressF);\n    if (IsValid(InputActions.ReleaseF))\n        Input-&gt;BindAction(InputActions.ReleaseF.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::ReleaseF);\n    if (IsValid(InputActions.PressG))\n        Input-&gt;BindAction(InputActions.PressG.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::PressG);\n    if (IsValid(InputActions.ReleaseG))\n        Input-&gt;BindAction(InputActions.ReleaseG.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::ReleaseG);\n    if (IsValid(InputActions.PressH))\n        Input-&gt;BindAction(InputActions.PressH.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::PressH);\n    if (IsValid(InputActions.ReleaseH))\n        Input-&gt;BindAction(InputActions.ReleaseH.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::ReleaseH);\n    if (IsValid(InputActions.PauseGame))\n        Input-&gt;BindAction(InputActions.PauseGame.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::PauseGame);\n    if (IsValid(InputActions.ResetTraining))\n        Input-&gt;BindAction(InputActions.ResetTraining.Get(), ETriggerEvent::Triggered, this, &amp;ANightSkyPlayerController::ResetTraining);\n}\n\nvoid ANightSkyPlayerController::PressUp()\n{\n    Inputs |= INP_Up;\n}\n\nvoid ANightSkyPlayerController::ReleaseUp()\n{\n    Inputs = Inputs &amp; ~INP_Up;\n}\n\nvoid ANightSkyPlayerController::PressDown()\n{\n    Inputs |= INP_Down;\n}\n\nvoid ANightSkyPlayerController::ReleaseDown()\n{\n    Inputs = Inputs &amp; ~INP_Down;\n}\n\nvoid ANightSkyPlayerController::PressLeft()\n{\n    Inputs |= INP_Left;\n}\n\nvoid ANightSkyPlayerController::ReleaseLeft()\n{\n    Inputs = Inputs &amp; ~INP_Left;\n}\n\nvoid ANightSkyPlayerController::PressRight()\n{\n    Inputs |= INP_Right;\n}\n\nvoid ANightSkyPlayerController::ReleaseRight()\n{\n    Inputs = Inputs &amp; ~INP_Right;\n}\n\nvoid ANightSkyPlayerController::PressA()\n{\n    Inputs |= INP_A;\n}\n\nvoid ANightSkyPlayerController::ReleaseA()\n{\n    Inputs = Inputs &amp; ~INP_A;\n}\n\nvoid ANightSkyPlayerController::PressB()\n{\n    Inputs |= INP_B;\n}\n\nvoid ANightSkyPlayerController::ReleaseB()\n{\n    Inputs = Inputs &amp; ~INP_B;\n}\n\nvoid ANightSkyPlayerController::PressC()\n{\n    Inputs |= INP_C;\n}\n\nvoid ANightSkyPlayerController::ReleaseC()\n{\n    Inputs = Inputs &amp; ~INP_C;\n}\n\nvoid ANightSkyPlayerController::PressD()\n{\n    Inputs |= INP_D;\n}\n\nvoid ANightSkyPlayerController::ReleaseD()\n{\n    Inputs = Inputs &amp; ~INP_D;\n}\n\nvoid ANightSkyPlayerController::PressE()\n{\n    Inputs |= INP_E;    \n}\n\nvoid ANightSkyPlayerController::ReleaseE()\n{\n    Inputs = Inputs &amp; ~INP_E;\n}\n\nvoid ANightSkyPlayerController::PressF()\n{\n    Inputs |= INP_F;    \n}\n\nvoid ANightSkyPlayerController::ReleaseF()\n{\n    Inputs = Inputs &amp; ~INP_F;\n}\n\nvoid ANightSkyPlayerController::PressG()\n{\n    Inputs |= INP_G;\n}\n\nvoid ANightSkyPlayerController::ReleaseG()\n{\n    Inputs = Inputs &amp; ~INP_G;\n}\n\n\nvoid ANightSkyPlayerController::PressH()\n{\n    Inputs |= INP_H;\n}\n\nvoid ANightSkyPlayerController::ReleaseH()\n{\n    Inputs = Inputs &amp; ~INP_H;\n}\n\nvoid ANightSkyPlayerController::PauseGame()\n{\n    const auto GameState = Cast&lt;ANightSkyGameState&gt;(GetWorld()-&gt;GetGameState());\n    if (!GameState) return;\n\n    if (!GameState-&gt;bPauseGame)\n    {\n        GameState-&gt;SetPaused(true);\n        OpenPauseMenu();\n    }\n}\n\nvoid ANightSkyPlayerController::ResetTraining()\n{\n    Inputs |= INP_ResetTraining;\n}\n\nvoid ANightSkyPlayerController::SendGgpo(ANetworkPawn* InNetworkPawn, bool Client) const\n{\n    if(InNetworkPawn-&gt;FighterMultiplayerRunner==nullptr)//TODO: CHECK IF MULTIPLAYERRUNNER IS SPAWNED BEFORE THIS, IF SO DO THIS IN BEGINPLAY\n    {\n        TArray&lt;AActor*&gt; FoundFighterGameStates;\n        UGameplayStatics::GetAllActorsOfClass(GetWorld(), AFighterMultiplayerRunner::StaticClass(), FoundFighterGameStates);\n        if(FoundFighterGameStates.Num()&gt;0)\n        {\n            InNetworkPawn-&gt;FighterMultiplayerRunner = Cast&lt;AFighterMultiplayerRunner&gt;(FoundFighterGameStates[0]);\n        }\n    }\n\n    if (InNetworkPawn-&gt;FighterMultiplayerRunner &amp;&amp; InNetworkPawn-&gt;FighterMultiplayerRunner-&gt;connectionManager)\n    {\n        while(InNetworkPawn-&gt;FighterMultiplayerRunner-&gt;connectionManager-&gt;sendSchedule.Num()&gt;0)\n        {\n            const auto SendVal = InNetworkPawn-&gt;FighterMultiplayerRunner-&gt;connectionManager-&gt;sendSchedule.GetTail();\n            if(Client)\n            {\n                InNetworkPawn-&gt;SendGgpoToClient(SendVal-&gt;GetValue());\n            }\n            else\n            {\n                InNetworkPawn-&gt;SendGgpoToServer(SendVal-&gt;GetValue());\n            }\n            InNetworkPawn-&gt;FighterMultiplayerRunner-&gt;connectionManager-&gt;sendSchedule.Empty();\n            //InNetworkPawn-&gt;FighterMultiplayerRunner-&gt;connectionManager-&gt;sendSchedule.RemoveNode(SendVal);\n        }\n    }\n}\n\nvoid ANightSkyPlayerController::SendBattleData()\n{\n    if (bSentCharaData) return;\n\n    int PlayerIndex = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance())-&gt;PlayerIndex;\n    TArray&lt;ANetworkPawn*&gt; NetworkPawns;\n    for (TActorIterator&lt;ANetworkPawn&gt; It(GetWorld()); It; ++It)\n    {\n        NetworkPawns.Add(*It);\n    }\n    if (NetworkPawns.Num() &gt; 1)\n    {\n        FNetworkMirror NetworkMirror{};\n        UNightSkyGameInstance* GameInstance = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance());\n        if (PlayerIndex == 0)\n        {\n            if (NetworkPawns[1]-&gt;CharaDataReceived) return;\n            for (const auto CharaData : GameInstance-&gt;BattleData.PlayerListP1)\n            {\n                NetworkMirror.PlayerList.Add(CharaData-&gt;GetPrimaryAssetId());\n            }\n            NetworkPawns[1]-&gt;ClientGetBattleData(GameInstance-&gt;BattleData, NetworkMirror);\n            NetworkPawns[1]-&gt;CharaDataReceived = true;\n            bSentCharaData = true;\n        }\n        else\n        {\n            for (const auto CharaData : GameInstance-&gt;BattleData.PlayerListP2)\n            {\n                NetworkMirror.PlayerList.Add(CharaData-&gt;GetPrimaryAssetId());\n            }\n            NetworkPawns[0]-&gt;ServerGetBattleData(GameInstance-&gt;BattleData, NetworkMirror);\n            bSentCharaData = true;\n        }\n    }\n}\n\nvoid ANightSkyPlayerController::Rematch()\n{\n    bRematch = true;\n    if (const UNightSkyGameInstance* GameInstance = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance()); GameInstance-&gt;\n        FighterRunner != Multiplayer)\n    {\n        Cast&lt;ANightSkyGameState&gt;(GetWorld()-&gt;GetGameState())-&gt;MatchInit();\n        bRematch = false;\n    }\n    else\n    {\n        int PlayerIndex = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance())-&gt;PlayerIndex;\n        TArray&lt;ANetworkPawn*&gt; NetworkPawns;\n        for (TActorIterator&lt;ANetworkPawn&gt; It(GetWorld()); It; ++It)\n        {\n            NetworkPawns.Add(*It);\n        }\n        if (NetworkPawns.Num() &gt; 1)\n        {\n            if (PlayerIndex != 0) NetworkPawns[0]-&gt;SendRematchToServer();\n            else NetworkPawns[1]-&gt;bRematchAccepted = true;\n        }\n    }\n}\n\nvoid ANightSkyPlayerController::PostRematch()\n{\n    NetworkPawn-&gt;bRematchAccepted = false;\n    bRematch = false;\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_player_controller_8h/","title":"File NightSkyPlayerController.h","text":"<p>FileList &gt; Battle &gt; NightSkyPlayerController.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameFramework/PlayerController.h\"</code></li> <li><code>#include \"NightSkyPlayerController.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_player_controller_8h/#classes","title":"Classes","text":"Type Name class ANightSkyPlayerController struct FBattleInputActions <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Battle/NightSkyPlayerController.h</code></p>"},{"location":"NightSkyEngine/_night_sky_player_controller_8h_source/","title":"File NightSkyPlayerController.h","text":"<p>File List &gt; Battle &gt; NightSkyPlayerController.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/PlayerController.h\"\n#include \"NightSkyPlayerController.generated.h\"\n\nclass UInputAction;\nclass UInputMappingContext;\nclass ANetworkPawn;\n\nUSTRUCT()\nstruct FBattleInputActions\n{\n    GENERATED_BODY()\n\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; PressUp;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; ReleaseUp;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; PressDown;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; ReleaseDown;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; PressLeft;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; ReleaseLeft;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; PressRight;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; ReleaseRight;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; PressA;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; ReleaseA;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; PressB;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; ReleaseB;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; PressC;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; ReleaseC;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; PressD;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; ReleaseD;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; PressE;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; ReleaseE;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; PressF;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; ReleaseF;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; PressG;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; ReleaseG;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; PressH;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; ReleaseH;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; PauseGame;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;const UInputAction&gt; ResetTraining;\n};\n\nUCLASS()\nclass NIGHTSKYENGINE_API ANightSkyPlayerController : public APlayerController\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ANightSkyPlayerController();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    virtual void SetupInputComponent() override;\n\n    int Inputs;\n    int Frame;\n    bool bRematch;\n    bool bRematchAccepted;\n    bool bSentCharaData;\n\n    UPROPERTY(EditAnywhere, Category=\"Input\")\n    TSoftObjectPtr&lt;UInputMappingContext&gt; InputMapping;\n    UPROPERTY(EditAnywhere, Category=\"Input\")\n    FBattleInputActions InputActions;\n\n    void PressUp();\n    void ReleaseUp();\n    void PressDown();\n    void ReleaseDown();\n    void PressLeft();\n    void ReleaseLeft();\n    void PressRight();\n    void ReleaseRight();\n    void PressA();\n    void ReleaseA();\n    void PressB();\n    void ReleaseB();\n    void PressC();\n    void ReleaseC();\n    void PressD();\n    void ReleaseD();\n    void PressE();\n    void ReleaseE();\n    void PressF();\n    void ReleaseF();\n    void PressG();\n    void ReleaseG();\n    void PressH();\n    void ReleaseH();\n\n    void PauseGame();\n    void ResetTraining();\n\n    void SendGgpo(ANetworkPawn* InNetworkPawn, bool Client) const;\n\n    UFUNCTION(BlueprintCallable)\n    void SendBattleData();\n    UFUNCTION(BlueprintCallable)\n    void Rematch();\n\n    void PostRematch();\n\n    UPROPERTY(BlueprintReadOnly)\n    ANetworkPawn* NetworkPawn;\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void OpenPauseMenu();\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void ClosePauseMenu();\n};\n</code></pre>"},{"location":"NightSkyEngine/dir_6b9168031f99509f1c8b2ee0b61f41f7/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/CharaSelect","text":"<p>FileList &gt; CharaSelect</p>"},{"location":"NightSkyEngine/dir_6b9168031f99509f1c8b2ee0b61f41f7/#files","title":"Files","text":"Type Name file NightSkyCharaSelectGameState.cpp file NightSkyCharaSelectGameState.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/CharaSelect/</code></p>"},{"location":"NightSkyEngine/_night_sky_chara_select_game_state_8cpp/","title":"File NightSkyCharaSelectGameState.cpp","text":"<p>FileList &gt; CharaSelect &gt; NightSkyCharaSelectGameState.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyCharaSelectGameState.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/NightSkyGameState.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/PrimaryCharaData.h\"</code></li> <li><code>#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/CharaSelect/NightSkyCharaSelectGameState.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_chara_select_game_state_8cpp_source/","title":"File NightSkyCharaSelectGameState.cpp","text":"<p>File List &gt; CharaSelect &gt; NightSkyCharaSelectGameState.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyCharaSelectGameState.h\"\n#include \"NightSkyEngine/Battle/NightSkyGameState.h\"\n#include \"NightSkyEngine/Data/PrimaryCharaData.h\"\n#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyCharaSelectGameState)\n\n// Sets default values\nANightSkyCharaSelectGameState::ANightSkyCharaSelectGameState()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n\n    P1Positions.Add(FVector(-150, -100, 0));\n    P1Positions.Add(FVector(-220, -50, 0));\n    P1Positions.Add(FVector(-300, 0, 0));\n\n    P2Positions.Add(FVector(150, -100, 0));\n    P2Positions.Add(FVector(220, -50, 0));\n    P2Positions.Add(FVector(300, 0, 0));\n}\n\n// Called when the game starts or when spawned\nvoid ANightSkyCharaSelectGameState::BeginPlay()\n{\n    Super::BeginPlay();\n    GameInstance = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance());\n}\n\n// Called every frame\nvoid ANightSkyCharaSelectGameState::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n    for (const auto Chara : P1Charas)\n        Chara-&gt;UpdateNotBattle();\n    for (const auto Chara : P2Charas)\n    {\n        Chara-&gt;UpdateNotBattle();\n    }\n}\n\nvoid ANightSkyCharaSelectGameState::AddPlayerObject(UPrimaryCharaData* Player, bool IsP1)\n{\n    if (IsP1)\n    {\n        if (P1Charas.Num() &gt;= GameInstance-&gt;BattleData.PlayerListP1.Num())\n            return;\n        P1Charas.Add(GetWorld()-&gt;SpawnActor&lt;APlayerObject&gt;(Player-&gt;PlayerClass));\n        P1Charas.Last()-&gt;InitPlayer();\n        P1Charas.Last()-&gt;CharaSelectGameState = this;\n        P1Charas.Last()-&gt;SetDefaultComponentVisibility();\n        P1Charas.Last()-&gt;PlayerFlags = PLF_IsOnScreen;\n        P1Charas.Last()-&gt;SetActorLocation(P1Positions[P1Charas.Num() - 1]);\n        GameInstance-&gt;BattleData.PlayerListP1[P1Charas.Num() - 1] = Player;\n    }\n    else\n    {\n        if (P2Charas.Num() &gt;= GameInstance-&gt;BattleData.PlayerListP2.Num())\n            return;\n        P2Charas.Add(GetWorld()-&gt;SpawnActor&lt;APlayerObject&gt;(Player-&gt;PlayerClass));\n        P2Charas.Last()-&gt;InitPlayer();\n        P2Charas.Last()-&gt;CharaSelectGameState = this;\n        P2Charas.Last()-&gt;SetDefaultComponentVisibility();\n        P2Charas.Last()-&gt;PlayerFlags = PLF_IsOnScreen;\n        P2Charas.Last()-&gt;SetActorLocation(P2Positions[P2Charas.Num() - 1]);\n        P2Charas.Last()-&gt;Direction = DIR_Left;\n        GameInstance-&gt;BattleData.PlayerListP2[P2Charas.Num() - 1] = Player;\n    }\n}\n\nvoid ANightSkyCharaSelectGameState::AddColorIndex(int InColor, bool IsP1)\n{\n    if (IsP1)\n    {\n        if (P1Charas.Num() &gt;= GameInstance-&gt;BattleData.PlayerListP1.Num())\n            return;\n        GameInstance-&gt;BattleData.ColorIndicesP1[P1Charas.Num() - 1] = InColor;\n    }\n    else\n    {\n        if (P2Charas.Num() &gt;= GameInstance-&gt;BattleData.PlayerListP2.Num())\n            return;\n        GameInstance-&gt;BattleData.ColorIndicesP2[P2Charas.Num() - 1] = InColor;\n    }\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_chara_select_game_state_8h/","title":"File NightSkyCharaSelectGameState.h","text":"<p>FileList &gt; CharaSelect &gt; NightSkyCharaSelectGameState.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameFramework/GameStateBase.h\"</code></li> <li><code>#include \"NightSkyCharaSelectGameState.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_chara_select_game_state_8h/#classes","title":"Classes","text":"Type Name class ANightSkyCharaSelectGameState <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/CharaSelect/NightSkyCharaSelectGameState.h</code></p>"},{"location":"NightSkyEngine/_night_sky_chara_select_game_state_8h_source/","title":"File NightSkyCharaSelectGameState.h","text":"<p>File List &gt; CharaSelect &gt; NightSkyCharaSelectGameState.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameStateBase.h\"\n#include \"NightSkyCharaSelectGameState.generated.h\"\n\nclass UPrimaryCharaData;\nclass UNightSkyGameInstance;\nclass APlayerObject;\n\nUCLASS()\nclass NIGHTSKYENGINE_API ANightSkyCharaSelectGameState : public AGameStateBase\n{\n    GENERATED_BODY()\n\nprivate:\n    UPROPERTY()\n    TObjectPtr&lt;UNightSkyGameInstance&gt; GameInstance;\npublic:\n    // Sets default values for this actor's properties\n    ANightSkyCharaSelectGameState();\n\n    UPROPERTY(BlueprintReadWrite)\n    TArray&lt;APlayerObject*&gt; P1Charas;\n    UPROPERTY(EditAnywhere)\n    TArray&lt;FVector&gt; P1Positions;\n    UPROPERTY(BlueprintReadWrite)\n    TArray&lt;APlayerObject*&gt; P2Charas;\n    UPROPERTY(EditAnywhere)\n    TArray&lt;FVector&gt; P2Positions;\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    UFUNCTION(BlueprintCallable)\n    void AddPlayerObject(UPrimaryCharaData* Player, bool IsP1 = true);\n    UFUNCTION(BlueprintCallable)\n    void AddColorIndex(int InColor, bool IsP1 = true);\n};\n</code></pre>"},{"location":"NightSkyEngine/dir_856985a2681c172443de4762aa082512/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data","text":"<p>FileList &gt; Data</p>"},{"location":"NightSkyEngine/dir_856985a2681c172443de4762aa082512/#files","title":"Files","text":"Type Name file BattleExtensionData.cpp file BattleExtensionData.h file CameraShakeData.h file CollisionData.cpp file CollisionData.h file FlipbookData.h file LinkActorData.h file MaterialData.h file ParticleData.cpp file ParticleData.h file PrimaryCharaData.h file PrimaryStageData.h file SequenceData.h file SoundData.cpp file SoundData.h file StateData.cpp file StateData.h file SubroutineData.cpp file SubroutineData.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/</code></p>"},{"location":"NightSkyEngine/_battle_extension_data_8cpp/","title":"File BattleExtensionData.cpp","text":"<p>FileList &gt; Data &gt; BattleExtensionData.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"BattleExtensionData.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_battle_extension_data_8cpp/#public-functions","title":"Public Functions","text":"Type Name UE_DEFINE_GAMEPLAY_TAG_COMMENT (BattleExtension_MatchInit, \"BattleExtension.MatchInit\", \"Battle Extension Match Init\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (BattleExtension_RoundInit, \"BattleExtension.RoundInit\", \"Battle Extension Round Init\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (BattleExtension_Update, \"BattleExtension.Update\", \"Battle Extension Update\")"},{"location":"NightSkyEngine/_battle_extension_data_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_battle_extension_data_8cpp/#function-ue_define_gameplay_tag_comment","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    BattleExtension_MatchInit,\n    \"BattleExtension.MatchInit\",\n    \"Battle Extension Match Init\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_battle_extension_data_8cpp/#function-ue_define_gameplay_tag_comment_1","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    BattleExtension_RoundInit,\n    \"BattleExtension.RoundInit\",\n    \"Battle Extension Round Init\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_battle_extension_data_8cpp/#function-ue_define_gameplay_tag_comment_2","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    BattleExtension_Update,\n    \"BattleExtension.Update\",\n    \"Battle Extension Update\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/BattleExtensionData.cpp</code></p>"},{"location":"NightSkyEngine/_battle_extension_data_8cpp_source/","title":"File BattleExtensionData.cpp","text":"<p>File List &gt; Data &gt; BattleExtensionData.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"BattleExtensionData.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(BattleExtensionData)\n\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(BattleExtension_MatchInit, \"BattleExtension.MatchInit\", \"Battle Extension Match Init\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(BattleExtension_RoundInit, \"BattleExtension.RoundInit\", \"Battle Extension Round Init\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(BattleExtension_Update, \"BattleExtension.Update\", \"Battle Extension Update\");\n</code></pre>"},{"location":"NightSkyEngine/_battle_extension_data_8h/","title":"File BattleExtensionData.h","text":"<p>FileList &gt; Data &gt; BattleExtensionData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Engine/DataAsset.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Script/BattleExtension.h\"</code></li> <li><code>#include \"BattleExtensionData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_battle_extension_data_8h/#classes","title":"Classes","text":"Type Name class UBattleExtensionData"},{"location":"NightSkyEngine/_battle_extension_data_8h/#public-functions","title":"Public Functions","text":"Type Name UE_DECLARE_GAMEPLAY_TAG_EXTERN (BattleExtension_MatchInit)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (BattleExtension_RoundInit)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (BattleExtension_Update)"},{"location":"NightSkyEngine/_battle_extension_data_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_battle_extension_data_8h/#function-ue_declare_gameplay_tag_extern","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    BattleExtension_MatchInit\n) \n</code></pre>"},{"location":"NightSkyEngine/_battle_extension_data_8h/#function-ue_declare_gameplay_tag_extern_1","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    BattleExtension_RoundInit\n) \n</code></pre>"},{"location":"NightSkyEngine/_battle_extension_data_8h/#function-ue_declare_gameplay_tag_extern_2","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    BattleExtension_Update\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/BattleExtensionData.h</code></p>"},{"location":"NightSkyEngine/_battle_extension_data_8h_source/","title":"File BattleExtensionData.h","text":"<p>File List &gt; Data &gt; BattleExtensionData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Engine/DataAsset.h\"\n#include \"NightSkyEngine/Battle/Script/BattleExtension.h\"\n#include \"BattleExtensionData.generated.h\"\n\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(BattleExtension_MatchInit);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(BattleExtension_RoundInit);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(BattleExtension_Update);\n\nUCLASS()\nclass NIGHTSKYENGINE_API UBattleExtensionData : public UDataAsset\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(EditAnywhere, BlueprintReadOnly)\n    TArray&lt;TSubclassOf&lt;UBattleExtension&gt;&gt; ExtensionArray;\n};\n</code></pre>"},{"location":"NightSkyEngine/_camera_shake_data_8h/","title":"File CameraShakeData.h","text":"<p>FileList &gt; Data &gt; CameraShakeData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Engine/DataAsset.h\"</code></li> <li><code>#include \"GameplayTagContainer.h\"</code></li> <li><code>#include \"CameraShakeData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_camera_shake_data_8h/#classes","title":"Classes","text":"Type Name struct FCameraShakeStruct class UCameraShakeData <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/CameraShakeData.h</code></p>"},{"location":"NightSkyEngine/_camera_shake_data_8h_source/","title":"File CameraShakeData.h","text":"<p>File List &gt; Data &gt; CameraShakeData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Engine/DataAsset.h\"\n#include \"GameplayTagContainer.h\"\n#include \"CameraShakeData.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FCameraShakeStruct\n{\n    GENERATED_BODY()\n\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    FGameplayTag Name;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    TSubclassOf&lt;UCameraShakeBase&gt; CameraShake;\n};\n\n\nUCLASS()\nclass NIGHTSKYENGINE_API UCameraShakeData : public UDataAsset\n{\n    GENERATED_BODY()\npublic:\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    TArray&lt;FCameraShakeStruct&gt; CameraShakeStructs;\n};\n</code></pre>"},{"location":"NightSkyEngine/_collision_data_8cpp/","title":"File CollisionData.cpp","text":"<p>FileList &gt; Data &gt; CollisionData.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CollisionData.h\"</code></li> <li><code>#include \"Misc/DataValidation.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_collision_data_8cpp/#macros","title":"Macros","text":"Type Name define LOCTEXT_NAMESPACE <code>\"NightSkyEngine\"</code>"},{"location":"NightSkyEngine/_collision_data_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"NightSkyEngine/_collision_data_8cpp/#define-loctext_namespace","title":"define LOCTEXT_NAMESPACE","text":"<pre><code>#define LOCTEXT_NAMESPACE `\"NightSkyEngine\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/CollisionData.cpp</code></p>"},{"location":"NightSkyEngine/_collision_data_8cpp_source/","title":"File CollisionData.cpp","text":"<p>File List &gt; Data &gt; CollisionData.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"CollisionData.h\"\n\n#include \"Misc/DataValidation.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(CollisionData)\n\n#define LOCTEXT_NAMESPACE \"NightSkyEngine\"\n\n#if WITH_EDITOR\n\nEDataValidationResult UCollisionData::IsDataValid(FDataValidationContext&amp; Context) const\n{\n    EDataValidationResult Result = CombineDataValidationResults(Super::IsDataValid(Context), EDataValidationResult::Valid);\n    if (Result == EDataValidationResult::Valid)\n    {\n        // Check for duplicates and empty names\n        TSet&lt;FGameplayTag&gt; CelNames;\n        for (const auto&amp; CollisionFrame : CollisionFrames)\n        {\n            if (!CollisionFrame.CelName.IsValid())\n            {\n                Context.AddError(LOCTEXT(\"InvalidCelName\", \"Invalid Cel name found (not named)\"));\n                Result = EDataValidationResult::Invalid;\n            }\n            else\n            {\n                bool bIsDuplicate = false;\n                CelNames.Add(CollisionFrame.CelName, &amp;bIsDuplicate);\n                if (bIsDuplicate)\n                {\n                    Context.AddError(LOCTEXT(\"DuplicateCelName\", \"Duplicate Cel name found\"));\n                    Result = EDataValidationResult::Invalid;\n                }\n            }\n        }\n    }\n    return Result;\n}\n\n#endif // WITH_EDITOR\n\n#undef LOCTEXT_NAMESPACE\n</code></pre>"},{"location":"NightSkyEngine/_collision_data_8h/","title":"File CollisionData.h","text":"<p>FileList &gt; Data &gt; CollisionData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Engine/DataAsset.h\"</code></li> <li><code>#include \"GameplayTagContainer.h\"</code></li> <li><code>#include \"PaperFlipbook.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Misc/CollisionBox.h\"</code></li> <li><code>#include \"CollisionData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_collision_data_8h/#classes","title":"Classes","text":"Type Name struct FAnimStruct struct FCollisionStruct class UCollisionData"},{"location":"NightSkyEngine/_collision_data_8h/#public-functions","title":"Public Functions","text":"Type Name DECLARE_MULTICAST_DELEGATE (FOnCollisionFramesChanged)"},{"location":"NightSkyEngine/_collision_data_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_collision_data_8h/#function-declare_multicast_delegate","title":"function DECLARE_MULTICAST_DELEGATE","text":"<pre><code>DECLARE_MULTICAST_DELEGATE (\n    FOnCollisionFramesChanged\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/CollisionData.h</code></p>"},{"location":"NightSkyEngine/_collision_data_8h_source/","title":"File CollisionData.h","text":"<p>File List &gt; Data &gt; CollisionData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Engine/DataAsset.h\"\n#include \"GameplayTagContainer.h\"\n#include \"PaperFlipbook.h\"\n#include \"NightSkyEngine/Battle/Misc/CollisionBox.h\"\n#include \"CollisionData.generated.h\"\n\nclass APlayerObject;\n\nDECLARE_MULTICAST_DELEGATE(FOnCollisionFramesChanged);\n\nUSTRUCT()\nstruct FAnimStruct\n{\n    GENERATED_BODY()\n\n    UPROPERTY(EditAnywhere)\n    FName PartName = \"Body\";\n    UPROPERTY(EditAnywhere)\n    UAnimSequenceBase* AnimSequence;\n    UPROPERTY(EditAnywhere)\n    UPaperFlipbook* Flipbook;\n};\n\nUSTRUCT()\nstruct FCollisionStruct\n{\n    GENERATED_BODY()\n\n    UPROPERTY(EditAnywhere)\n    FGameplayTag CelName;\n    UPROPERTY(EditAnywhere)\n    TArray&lt;FAnimStruct&gt; Anim;\n    UPROPERTY(EditAnywhere)\n    int32 AnimFrame = 0;\n    UPROPERTY(EditAnywhere)\n    float AnimBlendIn = 0.25;\n    UPROPERTY(EditAnywhere)\n    float AnimBlendOut = 0.25;\n    UPROPERTY(EditAnywhere)\n    TArray&lt;FCollisionBox&gt; Boxes;\n};\n\nUCLASS()\nclass NIGHTSKYENGINE_API UCollisionData : public UDataAsset\n{\n    GENERATED_BODY()\npublic:\n    UPROPERTY(EditAnywhere)\n    TArray&lt;FCollisionStruct&gt; CollisionFrames;\n\n    FCollisionStruct GetByCelName(const FGameplayTag&amp; CelName)\n    {\n        for (auto&amp; CollisionFrame : CollisionFrames)\n        {\n            if (CollisionFrame.CelName == CelName) return CollisionFrame;\n        }\n        return FCollisionStruct();\n    }\n\n    int32 GetIndexByCelName(const FGameplayTag&amp; CelName) const\n    {\n        for (int32 i = 0; i &lt; CollisionFrames.Num(); ++i)\n        {\n            if (CollisionFrames[i].CelName == CelName) return i;\n        }\n        return INDEX_NONE;\n    }\n\n#if WITH_EDITORONLY_DATA\n    // Transient selection state for editor - not saved with asset\n    UPROPERTY(Transient)\n    int32 EditorSelectedIndex = INDEX_NONE;\n\n    // UPROPERTY()\n    // FGameplayTag SelectedCharacterTag = FGameplayTag::EmptyTag;\n\n    // UPROPERTY()\n    // TSubclassOf&lt;APlayerObject&gt; SelectedPlayerObjectClass = nullptr;\n\n    // Delegate broadcast when CollisionFrames array is modified\n    FOnCollisionFramesChanged OnCollisionFramesChanged;\n\n    void NotifyCollisionFramesChanged()\n    {\n        OnCollisionFramesChanged.Broadcast();\n    }\n\n    virtual void PostEditChangeProperty(FPropertyChangedEvent&amp; PropertyChangedEvent) override\n    {\n        Super::PostEditChangeProperty(PropertyChangedEvent);\n        for (auto&amp; Collision : CollisionFrames)\n        {\n            for (auto&amp; Box : Collision.Boxes)\n            {\n                Box.PostEditChangeProperty();\n            }\n        }\n    }\n#endif\n\n#if WITH_EDITOR\n    virtual EDataValidationResult IsDataValid(FDataValidationContext&amp; Context) const override;\n#endif\n};\n</code></pre>"},{"location":"NightSkyEngine/_flipbook_data_8h/","title":"File FlipbookData.h","text":"<p>FileList &gt; Data &gt; FlipbookData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameplayTagContainer.h\"</code></li> <li><code>#include \"Engine/DataAsset.h\"</code></li> <li><code>#include \"PaperFlipbook.h\"</code></li> <li><code>#include \"FlipbookData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_flipbook_data_8h/#classes","title":"Classes","text":"Type Name struct FFlipbookStruct class UFlipbookData <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/FlipbookData.h</code></p>"},{"location":"NightSkyEngine/_flipbook_data_8h_source/","title":"File FlipbookData.h","text":"<p>File List &gt; Data &gt; FlipbookData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameplayTagContainer.h\"\n#include \"Engine/DataAsset.h\"\n#include \"PaperFlipbook.h\"\n#include \"FlipbookData.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FFlipbookStruct\n{\n    GENERATED_BODY()\n\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    FGameplayTag Name;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    UPaperFlipbook* Flipbook;\n};\n\nUCLASS()\nclass NIGHTSKYENGINE_API UFlipbookData : public UDataAsset\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    TArray&lt;FFlipbookStruct&gt; FlipbookStructs;\n};\n</code></pre>"},{"location":"NightSkyEngine/_link_actor_data_8h/","title":"File LinkActorData.h","text":"<p>FileList &gt; Data &gt; LinkActorData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameplayTagContainer.h\"</code></li> <li><code>#include \"Engine/DataAsset.h\"</code></li> <li><code>#include \"LinkActorData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_link_actor_data_8h/#classes","title":"Classes","text":"Type Name struct FLinkActorStruct class ULinkActorData <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/LinkActorData.h</code></p>"},{"location":"NightSkyEngine/_link_actor_data_8h_source/","title":"File LinkActorData.h","text":"<p>File List &gt; Data &gt; LinkActorData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameplayTagContainer.h\"\n#include \"Engine/DataAsset.h\"\n#include \"LinkActorData.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FLinkActorStruct\n{\n    GENERATED_BODY()\n\n    UPROPERTY(EditAnywhere)\n    FGameplayTag Name;\n    UPROPERTY(EditAnywhere)\n    TSubclassOf&lt;ALinkActor&gt; ActorClass;\n    UPROPERTY(EditAnywhere)\n    int32 MaxInstances = 1;\n};\n\nUCLASS()\nclass NIGHTSKYENGINE_API ULinkActorData : public UDataAsset\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(EditAnywhere)\n    TArray&lt;FLinkActorStruct&gt; LinkedActorStructs;\n};\n</code></pre>"},{"location":"NightSkyEngine/_material_data_8h/","title":"File MaterialData.h","text":"<p>FileList &gt; Data &gt; MaterialData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameplayTagContainer.h\"</code></li> <li><code>#include \"Engine/DataAsset.h\"</code></li> <li><code>#include \"MaterialData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_material_data_8h/#classes","title":"Classes","text":"Type Name struct FMaterialStruct class UMaterialData <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/MaterialData.h</code></p>"},{"location":"NightSkyEngine/_material_data_8h_source/","title":"File MaterialData.h","text":"<p>File List &gt; Data &gt; MaterialData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameplayTagContainer.h\"\n#include \"Engine/DataAsset.h\"\n#include \"MaterialData.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FMaterialStruct\n{\n    GENERATED_BODY()\n\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    FName Name;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    TArray&lt;UMaterialInterface*&gt; Material;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    UMaterialInterface* OverlayMaterial;\n};\n\nUCLASS()\nclass NIGHTSKYENGINE_API UMaterialData : public UDataAsset\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    TArray&lt;FMaterialStruct&gt; MaterialStructs;\n};\n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8cpp/","title":"File ParticleData.cpp","text":"<p>FileList &gt; Data &gt; ParticleData.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ParticleData.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_particle_data_8cpp/#public-functions","title":"Public Functions","text":"Type Name UE_DEFINE_GAMEPLAY_TAG_COMMENT (Particle_Hit_S, \"Particle.Hit.S\", \"Hit (Small) Particle\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Particle_Hit_M, \"Particle.Hit.M\", \"Hit (Medium) Particle\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Particle_Hit_L, \"Particle.Hit.L\", \"Hit (Large) Particle\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Particle_Hit_SP, \"Particle.Hit.SP\", \"Hit (Special) Particle\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Particle_Hit_Clash, \"Particle.Hit.Clash\", \"Hit Clash Particle\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Particle_Guard, \"Particle.Guard\", \"Guard Particle\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Particle_ThrowTech, \"Particle.ThrowTech\", \"Throw Tech Particle\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Particle_JumpSmoke_Land, \"Particle.JumpSmoke.Land\", \"Jump Smoke (Land) Particle\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Particle_WallBounce, \"Particle.WallBounce\", \"Wall Bounce Particle\")"},{"location":"NightSkyEngine/_particle_data_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_particle_data_8cpp/#function-ue_define_gameplay_tag_comment","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Particle_Hit_S,\n    \"Particle.Hit.S\",\n    \"Hit (Small) Particle\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8cpp/#function-ue_define_gameplay_tag_comment_1","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Particle_Hit_M,\n    \"Particle.Hit.M\",\n    \"Hit (Medium) Particle\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8cpp/#function-ue_define_gameplay_tag_comment_2","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Particle_Hit_L,\n    \"Particle.Hit.L\",\n    \"Hit (Large) Particle\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8cpp/#function-ue_define_gameplay_tag_comment_3","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Particle_Hit_SP,\n    \"Particle.Hit.SP\",\n    \"Hit (Special) Particle\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8cpp/#function-ue_define_gameplay_tag_comment_4","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Particle_Hit_Clash,\n    \"Particle.Hit.Clash\",\n    \"Hit Clash Particle\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8cpp/#function-ue_define_gameplay_tag_comment_5","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Particle_Guard,\n    \"Particle.Guard\",\n    \"Guard Particle\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8cpp/#function-ue_define_gameplay_tag_comment_6","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Particle_ThrowTech,\n    \"Particle.ThrowTech\",\n    \"Throw Tech Particle\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8cpp/#function-ue_define_gameplay_tag_comment_7","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Particle_JumpSmoke_Land,\n    \"Particle.JumpSmoke.Land\",\n    \"Jump Smoke (Land) Particle\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8cpp/#function-ue_define_gameplay_tag_comment_8","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Particle_WallBounce,\n    \"Particle.WallBounce\",\n    \"Wall Bounce Particle\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/ParticleData.cpp</code></p>"},{"location":"NightSkyEngine/_particle_data_8cpp_source/","title":"File ParticleData.cpp","text":"<p>File List &gt; Data &gt; ParticleData.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"ParticleData.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(ParticleData)\n\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_Hit_S, \"Particle.Hit.S\", \"Hit (Small) Particle\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_Hit_M, \"Particle.Hit.M\", \"Hit (Medium) Particle\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_Hit_L, \"Particle.Hit.L\", \"Hit (Large) Particle\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_Hit_SP, \"Particle.Hit.SP\", \"Hit (Special) Particle\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_Hit_Clash, \"Particle.Hit.Clash\", \"Hit Clash Particle\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_Guard, \"Particle.Guard\", \"Guard Particle\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_ThrowTech, \"Particle.ThrowTech\", \"Throw Tech Particle\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_JumpSmoke_Land, \"Particle.JumpSmoke.Land\", \"Jump Smoke (Land) Particle\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Particle_WallBounce, \"Particle.WallBounce\", \"Wall Bounce Particle\");\n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8h/","title":"File ParticleData.h","text":"<p>FileList &gt; Data &gt; ParticleData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"NativeGameplayTags.h\"</code></li> <li><code>#include \"Engine/DataAsset.h\"</code></li> <li><code>#include \"ParticleData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_particle_data_8h/#classes","title":"Classes","text":"Type Name struct FParticleStruct class UParticleData"},{"location":"NightSkyEngine/_particle_data_8h/#public-functions","title":"Public Functions","text":"Type Name UE_DECLARE_GAMEPLAY_TAG_EXTERN (Particle_Hit_S)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Particle_Hit_M)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Particle_Hit_L)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Particle_Hit_SP)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Particle_Hit_Clash)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Particle_Guard)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Particle_ThrowTech)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Particle_JumpSmoke_Land)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Particle_WallBounce)"},{"location":"NightSkyEngine/_particle_data_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_particle_data_8h/#function-ue_declare_gameplay_tag_extern","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Particle_Hit_S\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8h/#function-ue_declare_gameplay_tag_extern_1","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Particle_Hit_M\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8h/#function-ue_declare_gameplay_tag_extern_2","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Particle_Hit_L\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8h/#function-ue_declare_gameplay_tag_extern_3","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Particle_Hit_SP\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8h/#function-ue_declare_gameplay_tag_extern_4","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Particle_Hit_Clash\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8h/#function-ue_declare_gameplay_tag_extern_5","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Particle_Guard\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8h/#function-ue_declare_gameplay_tag_extern_6","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Particle_ThrowTech\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8h/#function-ue_declare_gameplay_tag_extern_7","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Particle_JumpSmoke_Land\n) \n</code></pre>"},{"location":"NightSkyEngine/_particle_data_8h/#function-ue_declare_gameplay_tag_extern_8","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Particle_WallBounce\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/ParticleData.h</code></p>"},{"location":"NightSkyEngine/_particle_data_8h_source/","title":"File ParticleData.h","text":"<p>File List &gt; Data &gt; ParticleData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NativeGameplayTags.h\"\n#include \"Engine/DataAsset.h\"\n#include \"ParticleData.generated.h\"\n\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_Hit_S);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_Hit_M);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_Hit_L);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_Hit_SP);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_Hit_Clash);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_Guard);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_ThrowTech);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_JumpSmoke_Land);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Particle_WallBounce);\n\nUSTRUCT(BlueprintType)\nstruct FParticleStruct\n{\n    GENERATED_BODY()\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    FGameplayTag Name;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    class UNiagaraSystem* ParticleSystem;\n};\n\nUCLASS()\nclass NIGHTSKYENGINE_API UParticleData : public UDataAsset\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    TArray&lt;FParticleStruct&gt; ParticleStructs;\n};\n</code></pre>"},{"location":"NightSkyEngine/_primary_chara_data_8h/","title":"File PrimaryCharaData.h","text":"<p>FileList &gt; Data &gt; PrimaryCharaData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Engine/DataAsset.h\"</code></li> <li><code>#include \"PrimaryCharaData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_primary_chara_data_8h/#classes","title":"Classes","text":"Type Name class UPrimaryCharaData <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/PrimaryCharaData.h</code></p>"},{"location":"NightSkyEngine/_primary_chara_data_8h_source/","title":"File PrimaryCharaData.h","text":"<p>File List &gt; Data &gt; PrimaryCharaData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Engine/DataAsset.h\"\n#include \"PrimaryCharaData.generated.h\"\n\nclass APlayerObject;\n\nUCLASS()\nclass NIGHTSKYENGINE_API UPrimaryCharaData : public UPrimaryDataAsset\n{\n    GENERATED_BODY()\n\npublic:\n    virtual FPrimaryAssetId GetPrimaryAssetId() const override\n    {\n        return FPrimaryAssetId(\"PrimaryCharaData\", GetFName());\n    }\n\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    FName CharaName;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    FText CharaFriendlyName;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    FText CharaDescription;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    UTexture2D* CharaHUDIcon;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    UTexture2D* CharaSelectIcon;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    UTexture2D* CharaSplashIcon;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    TSubclassOf&lt;APlayerObject&gt; PlayerClass;\n};\n</code></pre>"},{"location":"NightSkyEngine/_primary_stage_data_8h/","title":"File PrimaryStageData.h","text":"<p>FileList &gt; Data &gt; PrimaryStageData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Engine/DataAsset.h\"</code></li> <li><code>#include \"PrimaryStageData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_primary_stage_data_8h/#classes","title":"Classes","text":"Type Name class UPrimaryStageData <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/PrimaryStageData.h</code></p>"},{"location":"NightSkyEngine/_primary_stage_data_8h_source/","title":"File PrimaryStageData.h","text":"<p>File List &gt; Data &gt; PrimaryStageData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Engine/DataAsset.h\"\n#include \"PrimaryStageData.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API UPrimaryStageData : public UPrimaryDataAsset\n{\n    GENERATED_BODY()\n\npublic:\n    virtual FPrimaryAssetId GetPrimaryAssetId() const override\n    {\n        return FPrimaryAssetId(\"PrimaryStageData\", GetFName());\n    }\n\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    FName StageName;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    FText StageFriendlyName;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    FText StageDescription;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    UTexture2D* StageSelectIcon;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    UTexture2D* StageSplashIcon;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    FString StageURL;\n};\n</code></pre>"},{"location":"NightSkyEngine/_sequence_data_8h/","title":"File SequenceData.h","text":"<p>FileList &gt; Data &gt; SequenceData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameplayTagContainer.h\"</code></li> <li><code>#include \"Engine/DataAsset.h\"</code></li> <li><code>#include \"LevelSequence.h\"</code></li> <li><code>#include \"SequenceData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_sequence_data_8h/#classes","title":"Classes","text":"Type Name struct FSequenceStruct class USequenceData <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SequenceData.h</code></p>"},{"location":"NightSkyEngine/_sequence_data_8h_source/","title":"File SequenceData.h","text":"<p>File List &gt; Data &gt; SequenceData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameplayTagContainer.h\"\n#include \"Engine/DataAsset.h\"\n#include \"LevelSequence.h\"\n#include \"SequenceData.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FSequenceStruct\n{\n    GENERATED_BODY()\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    FGameplayTag Name;\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    ULevelSequence* Sequence;\n};\n\nUCLASS()\nclass NIGHTSKYENGINE_API USequenceData : public UDataAsset\n{\n    GENERATED_BODY()\npublic:\n    UPROPERTY(BlueprintReadOnly, EditAnywhere)\n    TArray&lt;FSequenceStruct&gt; SequenceStructs;\n};\n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/","title":"File SoundData.cpp","text":"<p>FileList &gt; Data &gt; SoundData.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"SoundData.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_sound_data_8cpp/#public-functions","title":"Public Functions","text":"Type Name UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Hit_Punch_S, \"Sound.Hit.Punch.S\", \"Punch Hit (Small) Sound\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Hit_Punch_M, \"Sound.Hit.Punch.M\", \"Punch Hit (Medium) Sound\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Hit_Punch_L, \"Sound.Hit.Punch.L\", \"Punch Hit (Large) Sound\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Hit_Punch_SP, \"Sound.Hit.Punch.SP\", \"Punch Hit (Special) Sound\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Hit_Kick_S, \"Sound.Hit.Kick.S\", \"Kick Hit (Small) Sound\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Hit_Kick_M, \"Sound.Hit.Kick.M\", \"Kick Hit (Medium) Sound\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Hit_Kick_L, \"Sound.Hit.Kick.L\", \"Kick Hit (Large) Sound\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Hit_Kick_SP, \"Sound.Hit.Kick.SP\", \"Kick Hit (Special) Sound\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Hit_Slash_S, \"Sound.Hit.Slash.S\", \"Slash Hit (Small) Sound\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Hit_Slash_M, \"Sound.Hit.Slash.M\", \"Slash Hit (Medium) Sound\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Hit_Slash_L, \"Sound.Hit.Slash.L\", \"Slash Hit (Large) Sound\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Hit_Slash_SP, \"Sound.Hit.Slash.SP\", \"Slash Hit (Special) Sound\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Hit_Clash, \"Sound.Hit.Clash\", \"Hit Clash Sound\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Land, \"Sound.Land\", \"Landing Sound\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Sound_Landing_Crash, \"Sound.Landing.Crash\", \"Landing Sound (Crash)\")"},{"location":"NightSkyEngine/_sound_data_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Hit_Punch_S,\n    \"Sound.Hit.Punch.S\",\n    \"Punch Hit (Small) Sound\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment_1","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Hit_Punch_M,\n    \"Sound.Hit.Punch.M\",\n    \"Punch Hit (Medium) Sound\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment_2","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Hit_Punch_L,\n    \"Sound.Hit.Punch.L\",\n    \"Punch Hit (Large) Sound\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment_3","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Hit_Punch_SP,\n    \"Sound.Hit.Punch.SP\",\n    \"Punch Hit (Special) Sound\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment_4","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Hit_Kick_S,\n    \"Sound.Hit.Kick.S\",\n    \"Kick Hit (Small) Sound\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment_5","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Hit_Kick_M,\n    \"Sound.Hit.Kick.M\",\n    \"Kick Hit (Medium) Sound\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment_6","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Hit_Kick_L,\n    \"Sound.Hit.Kick.L\",\n    \"Kick Hit (Large) Sound\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment_7","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Hit_Kick_SP,\n    \"Sound.Hit.Kick.SP\",\n    \"Kick Hit (Special) Sound\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment_8","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Hit_Slash_S,\n    \"Sound.Hit.Slash.S\",\n    \"Slash Hit (Small) Sound\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment_9","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Hit_Slash_M,\n    \"Sound.Hit.Slash.M\",\n    \"Slash Hit (Medium) Sound\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment_10","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Hit_Slash_L,\n    \"Sound.Hit.Slash.L\",\n    \"Slash Hit (Large) Sound\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment_11","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Hit_Slash_SP,\n    \"Sound.Hit.Slash.SP\",\n    \"Slash Hit (Special) Sound\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment_12","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Hit_Clash,\n    \"Sound.Hit.Clash\",\n    \"Hit Clash Sound\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment_13","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Land,\n    \"Sound.Land\",\n    \"Landing Sound\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8cpp/#function-ue_define_gameplay_tag_comment_14","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Sound_Landing_Crash,\n    \"Sound.Landing.Crash\",\n    \"Landing Sound (Crash)\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SoundData.cpp</code></p>"},{"location":"NightSkyEngine/_sound_data_8cpp_source/","title":"File SoundData.cpp","text":"<p>File List &gt; Data &gt; SoundData.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"SoundData.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(SoundData)\n\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Punch_S, \"Sound.Hit.Punch.S\", \"Punch Hit (Small) Sound\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Punch_M, \"Sound.Hit.Punch.M\", \"Punch Hit (Medium) Sound\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Punch_L, \"Sound.Hit.Punch.L\", \"Punch Hit (Large) Sound\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Punch_SP, \"Sound.Hit.Punch.SP\", \"Punch Hit (Special) Sound\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Kick_S, \"Sound.Hit.Kick.S\", \"Kick Hit (Small) Sound\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Kick_M, \"Sound.Hit.Kick.M\", \"Kick Hit (Medium) Sound\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Kick_L, \"Sound.Hit.Kick.L\", \"Kick Hit (Large) Sound\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Kick_SP, \"Sound.Hit.Kick.SP\", \"Kick Hit (Special) Sound\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Slash_S, \"Sound.Hit.Slash.S\", \"Slash Hit (Small) Sound\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Slash_M, \"Sound.Hit.Slash.M\", \"Slash Hit (Medium) Sound\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Slash_L, \"Sound.Hit.Slash.L\", \"Slash Hit (Large) Sound\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Slash_SP, \"Sound.Hit.Slash.SP\", \"Slash Hit (Special) Sound\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Hit_Clash, \"Sound.Hit.Clash\", \"Hit Clash Sound\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Land, \"Sound.Land\", \"Landing Sound\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Sound_Landing_Crash, \"Sound.Landing.Crash\", \"Landing Sound (Crash)\");\n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/","title":"File SoundData.h","text":"<p>FileList &gt; Data &gt; SoundData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"NativeGameplayTags.h\"</code></li> <li><code>#include \"Engine/DataAsset.h\"</code></li> <li><code>#include \"SoundData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_sound_data_8h/#classes","title":"Classes","text":"Type Name struct FSoundStruct class USoundData"},{"location":"NightSkyEngine/_sound_data_8h/#public-functions","title":"Public Functions","text":"Type Name UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Hit_Punch_S)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Hit_Punch_M)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Hit_Punch_L)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Hit_Punch_SP)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Hit_Kick_S)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Hit_Kick_M)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Hit_Kick_L)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Hit_Kick_SP)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Hit_Slash_S)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Hit_Slash_M)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Hit_Slash_L)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Hit_Slash_SP)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Hit_Clash)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Guard)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Land)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Sound_Landing_Crash)"},{"location":"NightSkyEngine/_sound_data_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Hit_Punch_S\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_1","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Hit_Punch_M\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_2","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Hit_Punch_L\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_3","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Hit_Punch_SP\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_4","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Hit_Kick_S\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_5","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Hit_Kick_M\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_6","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Hit_Kick_L\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_7","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Hit_Kick_SP\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_8","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Hit_Slash_S\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_9","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Hit_Slash_M\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_10","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Hit_Slash_L\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_11","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Hit_Slash_SP\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_12","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Hit_Clash\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_13","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Guard\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_14","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Land\n) \n</code></pre>"},{"location":"NightSkyEngine/_sound_data_8h/#function-ue_declare_gameplay_tag_extern_15","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Sound_Landing_Crash\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SoundData.h</code></p>"},{"location":"NightSkyEngine/_sound_data_8h_source/","title":"File SoundData.h","text":"<p>File List &gt; Data &gt; SoundData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NativeGameplayTags.h\"\n#include \"Engine/DataAsset.h\"\n#include \"SoundData.generated.h\"\n\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Punch_S);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Punch_M);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Punch_L);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Punch_SP);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Kick_S);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Kick_M);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Kick_L);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Kick_SP);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Slash_S);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Slash_M);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Slash_L);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Slash_SP);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Hit_Clash);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Guard);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Land);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Sound_Landing_Crash);\n\nUSTRUCT()\nstruct FSoundStruct\n{\n    GENERATED_BODY()\n\n    UPROPERTY(EditAnywhere)\n    FGameplayTag Name;\n    UPROPERTY(EditAnywhere)\n    USoundBase* SoundWave;\n    UPROPERTY(EditAnywhere)\n    float MaxDuration = 60;\n\n};\n\nUCLASS()\nclass NIGHTSKYENGINE_API USoundData : public UDataAsset\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(EditAnywhere)\n    TArray&lt;FSoundStruct&gt; SoundDatas;\n};\n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/","title":"File StateData.cpp","text":"<p>FileList &gt; Data &gt; StateData.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"StateData.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_state_data_8cpp/#public-functions","title":"Public Functions","text":"Type Name UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Stand, \"State.Universal.Stand\", \"Stand State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Crouch, \"State.Universal.Crouch\", \"Crouch State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Jump_V, \"State.Universal.Jump.V\", \"Vertical Jump State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_JumpLanding, \"State.Universal.JumpLanding\", \"Jump Landing State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_StandFlip, \"State.Universal.StandFlip\", \"Stand Flip State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_CrouchFlip, \"State.Universal.CrouchFlip\", \"Crouch Flip State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_JumpFlip, \"State.Universal.AirFlip\", \"Jump Flip State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_StandBlock, \"State.Universal.Block.Stand\", \"Stand Block State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_CrouchBlock, \"State.Universal.Block.Crouch\", \"Crouch Block State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_AirBlock, \"State.Universal.Block.Air\", \"Jump Block State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_StandBlockEnd, \"State.Universal.Block.Stand.End\", \"Stand Block (End) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_CrouchBlockEnd, \"State.Universal.Block.Crouch.End\", \"Crouch Block (End) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_AirBlockEnd, \"State.Universal.Block.Air.End\", \"Jump Block (End) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_GuardBreakStand, \"State.Universal.GuardBreak.Stand\", \"Guard Break (Stand) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_GuardBreakCrouch, \"State.Universal.GuardBreak.Crouch\", \"Guard Break (Crouch) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_GuardBreakAir, \"State.Universal.GuardBreak.Air\", \"Guard Break (Jump) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Hitstun_0, \"State.Universal.Hitstun.0\", \"Hitstun (Level 0) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Hitstun_1, \"State.Universal.Hitstun.1\", \"Hitstun (Level 1) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Hitstun_2, \"State.Universal.Hitstun.2\", \"Hitstun (Level 2) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Hitstun_3, \"State.Universal.Hitstun.3\", \"Hitstun (Level 3) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Hitstun_4, \"State.Universal.Hitstun.4\", \"Hitstun (Level 4) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Hitstun_5, \"State.Universal.Hitstun.5\", \"Hitstun (Level 5) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_CrouchHitstun_0, \"State.Universal.Hitstun.Crouch.0\", \"Crouch Hitstun (Level 0) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_CrouchHitstun_1, \"State.Universal.Hitstun.Crouch.1\", \"Crouch Hitstun (Level 1) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_CrouchHitstun_2, \"State.Universal.Hitstun.Crouch.2\", \"Crouch Hitstun (Level 2) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_CrouchHitstun_3, \"State.Universal.Hitstun.Crouch.3\", \"Crouch Hitstun (Level 3) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_CrouchHitstun_4, \"State.Universal.Hitstun.Crouch.4\", \"Crouch Hitstun (Level 4) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_CrouchHitstun_5, \"State.Universal.Hitstun.Crouch.5\", \"Crouch Hitstun (Level 5) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Launch_B, \"State.Universal.Launch.B\", \"Backward Launch State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Launch_V, \"State.Universal.Launch.V\", \"Vertical Launch State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Launch_F, \"State.Universal.Launch.F\", \"Forward Launch State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Blowback, \"State.Universal.Blowback\", \"Blowback State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Tailspin, \"State.Universal.Tailspin\", \"Tailspin State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Crumple, \"State.Universal.Crumple\", \"Crumple State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_FloatingCrumpleBody, \"State.Universal.FloatingCrumple.Body\", \"Floating Crumple (Body) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_FloatingCrumpleHead, \"State.Universal.FloatingCrumple.Head\", \"Floating Crumple (Head) State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_WallBounce, \"State.Universal.WallBounce\", \"Wall Bounce State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_FaceDownBounce, \"State.Universal.FaceDown.Bounce\", \"Face Down Bounce State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_FaceUpBounce, \"State.Universal.FaceUp.Bounce\", \"Face Up Bounce State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_FaceDownLoop, \"State.Universal.FaceDown.Loop\", \"Face Down Loop State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_FaceUpLoop, \"State.Universal.FaceUp.Loop\", \"Face Up Loop State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_FaceDownWakeUp, \"State.Universal.FaceDown.WakeUp\", \"Face Down Wake Up State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_FaceUpWakeUp, \"State.Universal.FaceUp.WakeUp\", \"Face Up Wake Up State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_Throw, \"State.Universal.Throw\", \"Throw State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_ThrowLock, \"State.Universal.ThrowLock\", \"Throw Lock State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_TagIn, \"State.Universal.TagIn\", \"Tag In State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_RoundWin, \"State.Universal.RoundWin\", \"Round Win State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_RoundLose, \"State.Universal.RoundLose\", \"Round Lose State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_Universal_MatchWin, \"State.Universal.MatchWin\", \"Match Win State\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_BattleObject_KO_S, \"State.BattleObject.KO.S\", \"KO (Small) Battle Object\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_BattleObject_KO_M, \"State.BattleObject.KO.M\", \"KO (Small) Battle Object\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_BattleObject_KO_L, \"State.BattleObject.KO.L\", \"KO (Small) Battle Object\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (State_BattleObject_KO_Draw, \"State.BattleObject.KO.Draw\", \"KO (Draw) Battle Object\")"},{"location":"NightSkyEngine/_state_data_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Stand,\n    \"State.Universal.Stand\",\n    \"Stand State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_1","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Crouch,\n    \"State.Universal.Crouch\",\n    \"Crouch State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_2","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Jump_V,\n    \"State.Universal.Jump.V\",\n    \"Vertical Jump State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_3","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_JumpLanding,\n    \"State.Universal.JumpLanding\",\n    \"Jump Landing State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_4","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_StandFlip,\n    \"State.Universal.StandFlip\",\n    \"Stand Flip State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_5","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_CrouchFlip,\n    \"State.Universal.CrouchFlip\",\n    \"Crouch Flip State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_6","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_JumpFlip,\n    \"State.Universal.AirFlip\",\n    \"Jump Flip State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_7","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_StandBlock,\n    \"State.Universal.Block.Stand\",\n    \"Stand Block State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_8","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_CrouchBlock,\n    \"State.Universal.Block.Crouch\",\n    \"Crouch Block State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_9","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_AirBlock,\n    \"State.Universal.Block.Air\",\n    \"Jump Block State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_10","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_StandBlockEnd,\n    \"State.Universal.Block.Stand.End\",\n    \"Stand Block (End) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_11","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_CrouchBlockEnd,\n    \"State.Universal.Block.Crouch.End\",\n    \"Crouch Block (End) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_12","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_AirBlockEnd,\n    \"State.Universal.Block.Air.End\",\n    \"Jump Block (End) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_13","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_GuardBreakStand,\n    \"State.Universal.GuardBreak.Stand\",\n    \"Guard Break (Stand) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_14","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_GuardBreakCrouch,\n    \"State.Universal.GuardBreak.Crouch\",\n    \"Guard Break (Crouch) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_15","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_GuardBreakAir,\n    \"State.Universal.GuardBreak.Air\",\n    \"Guard Break (Jump) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_16","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Hitstun_0,\n    \"State.Universal.Hitstun.0\",\n    \"Hitstun (Level 0) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_17","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Hitstun_1,\n    \"State.Universal.Hitstun.1\",\n    \"Hitstun (Level 1) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_18","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Hitstun_2,\n    \"State.Universal.Hitstun.2\",\n    \"Hitstun (Level 2) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_19","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Hitstun_3,\n    \"State.Universal.Hitstun.3\",\n    \"Hitstun (Level 3) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_20","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Hitstun_4,\n    \"State.Universal.Hitstun.4\",\n    \"Hitstun (Level 4) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_21","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Hitstun_5,\n    \"State.Universal.Hitstun.5\",\n    \"Hitstun (Level 5) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_22","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_CrouchHitstun_0,\n    \"State.Universal.Hitstun.Crouch.0\",\n    \"Crouch Hitstun (Level 0) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_23","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_CrouchHitstun_1,\n    \"State.Universal.Hitstun.Crouch.1\",\n    \"Crouch Hitstun (Level 1) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_24","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_CrouchHitstun_2,\n    \"State.Universal.Hitstun.Crouch.2\",\n    \"Crouch Hitstun (Level 2) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_25","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_CrouchHitstun_3,\n    \"State.Universal.Hitstun.Crouch.3\",\n    \"Crouch Hitstun (Level 3) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_26","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_CrouchHitstun_4,\n    \"State.Universal.Hitstun.Crouch.4\",\n    \"Crouch Hitstun (Level 4) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_27","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_CrouchHitstun_5,\n    \"State.Universal.Hitstun.Crouch.5\",\n    \"Crouch Hitstun (Level 5) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_28","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Launch_B,\n    \"State.Universal.Launch.B\",\n    \"Backward Launch State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_29","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Launch_V,\n    \"State.Universal.Launch.V\",\n    \"Vertical Launch State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_30","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Launch_F,\n    \"State.Universal.Launch.F\",\n    \"Forward Launch State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_31","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Blowback,\n    \"State.Universal.Blowback\",\n    \"Blowback State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_32","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Tailspin,\n    \"State.Universal.Tailspin\",\n    \"Tailspin State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_33","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Crumple,\n    \"State.Universal.Crumple\",\n    \"Crumple State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_34","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_FloatingCrumpleBody,\n    \"State.Universal.FloatingCrumple.Body\",\n    \"Floating Crumple (Body) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_35","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_FloatingCrumpleHead,\n    \"State.Universal.FloatingCrumple.Head\",\n    \"Floating Crumple (Head) State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_36","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_WallBounce,\n    \"State.Universal.WallBounce\",\n    \"Wall Bounce State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_37","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_FaceDownBounce,\n    \"State.Universal.FaceDown.Bounce\",\n    \"Face Down Bounce State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_38","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_FaceUpBounce,\n    \"State.Universal.FaceUp.Bounce\",\n    \"Face Up Bounce State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_39","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_FaceDownLoop,\n    \"State.Universal.FaceDown.Loop\",\n    \"Face Down Loop State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_40","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_FaceUpLoop,\n    \"State.Universal.FaceUp.Loop\",\n    \"Face Up Loop State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_41","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_FaceDownWakeUp,\n    \"State.Universal.FaceDown.WakeUp\",\n    \"Face Down Wake Up State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_42","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_FaceUpWakeUp,\n    \"State.Universal.FaceUp.WakeUp\",\n    \"Face Up Wake Up State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_43","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_Throw,\n    \"State.Universal.Throw\",\n    \"Throw State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_44","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_ThrowLock,\n    \"State.Universal.ThrowLock\",\n    \"Throw Lock State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_45","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_TagIn,\n    \"State.Universal.TagIn\",\n    \"Tag In State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_46","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_RoundWin,\n    \"State.Universal.RoundWin\",\n    \"Round Win State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_47","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_RoundLose,\n    \"State.Universal.RoundLose\",\n    \"Round Lose State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_48","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_Universal_MatchWin,\n    \"State.Universal.MatchWin\",\n    \"Match Win State\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_49","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_BattleObject_KO_S,\n    \"State.BattleObject.KO.S\",\n    \"KO (Small) Battle Object\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_50","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_BattleObject_KO_M,\n    \"State.BattleObject.KO.M\",\n    \"KO (Small) Battle Object\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_51","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_BattleObject_KO_L,\n    \"State.BattleObject.KO.L\",\n    \"KO (Small) Battle Object\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8cpp/#function-ue_define_gameplay_tag_comment_52","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    State_BattleObject_KO_Draw,\n    \"State.BattleObject.KO.Draw\",\n    \"KO (Draw) Battle Object\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/StateData.cpp</code></p>"},{"location":"NightSkyEngine/_state_data_8cpp_source/","title":"File StateData.cpp","text":"<p>File List &gt; Data &gt; StateData.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"StateData.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(StateData)\n\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Stand, \"State.Universal.Stand\", \"Stand State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Crouch, \"State.Universal.Crouch\", \"Crouch State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Jump_V, \"State.Universal.Jump.V\", \"Vertical Jump State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_JumpLanding, \"State.Universal.JumpLanding\", \"Jump Landing State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_StandFlip, \"State.Universal.StandFlip\", \"Stand Flip State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchFlip, \"State.Universal.CrouchFlip\", \"Crouch Flip State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_JumpFlip, \"State.Universal.AirFlip\", \"Jump Flip State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_StandBlock, \"State.Universal.Block.Stand\", \"Stand Block State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchBlock, \"State.Universal.Block.Crouch\", \"Crouch Block State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_AirBlock, \"State.Universal.Block.Air\", \"Jump Block State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_StandBlockEnd, \"State.Universal.Block.Stand.End\", \"Stand Block (End) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchBlockEnd, \"State.Universal.Block.Crouch.End\", \"Crouch Block (End) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_AirBlockEnd, \"State.Universal.Block.Air.End\", \"Jump Block (End) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_GuardBreakStand, \"State.Universal.GuardBreak.Stand\", \"Guard Break (Stand) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_GuardBreakCrouch, \"State.Universal.GuardBreak.Crouch\", \"Guard Break (Crouch) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_GuardBreakAir, \"State.Universal.GuardBreak.Air\", \"Guard Break (Jump) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Hitstun_0, \"State.Universal.Hitstun.0\", \"Hitstun (Level 0) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Hitstun_1, \"State.Universal.Hitstun.1\", \"Hitstun (Level 1) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Hitstun_2, \"State.Universal.Hitstun.2\", \"Hitstun (Level 2) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Hitstun_3, \"State.Universal.Hitstun.3\", \"Hitstun (Level 3) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Hitstun_4, \"State.Universal.Hitstun.4\", \"Hitstun (Level 4) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Hitstun_5, \"State.Universal.Hitstun.5\", \"Hitstun (Level 5) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchHitstun_0, \"State.Universal.Hitstun.Crouch.0\", \"Crouch Hitstun (Level 0) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchHitstun_1, \"State.Universal.Hitstun.Crouch.1\", \"Crouch Hitstun (Level 1) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchHitstun_2, \"State.Universal.Hitstun.Crouch.2\", \"Crouch Hitstun (Level 2) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchHitstun_3, \"State.Universal.Hitstun.Crouch.3\", \"Crouch Hitstun (Level 3) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchHitstun_4, \"State.Universal.Hitstun.Crouch.4\", \"Crouch Hitstun (Level 4) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_CrouchHitstun_5, \"State.Universal.Hitstun.Crouch.5\", \"Crouch Hitstun (Level 5) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Launch_B, \"State.Universal.Launch.B\", \"Backward Launch State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Launch_V, \"State.Universal.Launch.V\", \"Vertical Launch State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Launch_F, \"State.Universal.Launch.F\", \"Forward Launch State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Blowback, \"State.Universal.Blowback\", \"Blowback State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Tailspin, \"State.Universal.Tailspin\", \"Tailspin State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Crumple, \"State.Universal.Crumple\", \"Crumple State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FloatingCrumpleBody, \"State.Universal.FloatingCrumple.Body\", \"Floating Crumple (Body) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FloatingCrumpleHead, \"State.Universal.FloatingCrumple.Head\", \"Floating Crumple (Head) State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_WallBounce, \"State.Universal.WallBounce\", \"Wall Bounce State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FaceDownBounce, \"State.Universal.FaceDown.Bounce\", \"Face Down Bounce State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FaceUpBounce, \"State.Universal.FaceUp.Bounce\", \"Face Up Bounce State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FaceDownLoop, \"State.Universal.FaceDown.Loop\", \"Face Down Loop State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FaceUpLoop, \"State.Universal.FaceUp.Loop\", \"Face Up Loop State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FaceDownWakeUp, \"State.Universal.FaceDown.WakeUp\", \"Face Down Wake Up State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_FaceUpWakeUp, \"State.Universal.FaceUp.WakeUp\", \"Face Up Wake Up State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_Throw, \"State.Universal.Throw\", \"Throw State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_ThrowLock, \"State.Universal.ThrowLock\", \"Throw Lock State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_TagIn, \"State.Universal.TagIn\", \"Tag In State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_RoundWin, \"State.Universal.RoundWin\", \"Round Win State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_RoundLose, \"State.Universal.RoundLose\", \"Round Lose State\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_Universal_MatchWin, \"State.Universal.MatchWin\", \"Match Win State\");\n\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_BattleObject_KO_S, \"State.BattleObject.KO.S\", \"KO (Small) Battle Object\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_BattleObject_KO_M, \"State.BattleObject.KO.M\", \"KO (Small) Battle Object\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_BattleObject_KO_L, \"State.BattleObject.KO.L\", \"KO (Small) Battle Object\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(State_BattleObject_KO_Draw, \"State.BattleObject.KO.Draw\", \"KO (Draw) Battle Object\");\n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/","title":"File StateData.h","text":"<p>FileList &gt; Data &gt; StateData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"NativeGameplayTags.h\"</code></li> <li><code>#include \"Engine/DataAsset.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Script/State.h\"</code></li> <li><code>#include \"StateData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_state_data_8h/#classes","title":"Classes","text":"Type Name class UStateData"},{"location":"NightSkyEngine/_state_data_8h/#public-functions","title":"Public Functions","text":"Type Name UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Stand)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Crouch)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Jump_V)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_JumpLanding)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_StandFlip)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_CrouchFlip)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_JumpFlip)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_StandBlock)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_CrouchBlock)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_AirBlock)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_StandBlockEnd)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_CrouchBlockEnd)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_AirBlockEnd)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_GuardBreakStand)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_GuardBreakCrouch)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_GuardBreakAir)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Hitstun_0)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Hitstun_1)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Hitstun_2)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Hitstun_3)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Hitstun_4)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Hitstun_5)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_CrouchHitstun_0)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_CrouchHitstun_1)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_CrouchHitstun_2)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_CrouchHitstun_3)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_CrouchHitstun_4)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_CrouchHitstun_5)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Launch_B)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Launch_V)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Launch_F)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Blowback)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Tailspin)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Crumple)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_FloatingCrumpleBody)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_FloatingCrumpleHead)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_WallBounce)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_FaceDownBounce)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_FaceUpBounce)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_FaceDownLoop)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_FaceUpLoop)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_FaceDownWakeUp)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_FaceUpWakeUp)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_Throw)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_ThrowLock)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_TagIn)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_RoundWin)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_RoundLose)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_Universal_MatchWin)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_BattleObject_KO_S)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_BattleObject_KO_M)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_BattleObject_KO_L)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (State_BattleObject_KO_Draw)"},{"location":"NightSkyEngine/_state_data_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Stand\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_1","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Crouch\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_2","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Jump_V\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_3","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_JumpLanding\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_4","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_StandFlip\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_5","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_CrouchFlip\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_6","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_JumpFlip\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_7","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_StandBlock\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_8","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_CrouchBlock\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_9","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_AirBlock\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_10","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_StandBlockEnd\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_11","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_CrouchBlockEnd\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_12","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_AirBlockEnd\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_13","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_GuardBreakStand\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_14","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_GuardBreakCrouch\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_15","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_GuardBreakAir\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_16","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Hitstun_0\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_17","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Hitstun_1\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_18","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Hitstun_2\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_19","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Hitstun_3\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_20","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Hitstun_4\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_21","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Hitstun_5\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_22","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_CrouchHitstun_0\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_23","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_CrouchHitstun_1\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_24","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_CrouchHitstun_2\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_25","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_CrouchHitstun_3\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_26","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_CrouchHitstun_4\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_27","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_CrouchHitstun_5\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_28","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Launch_B\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_29","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Launch_V\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_30","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Launch_F\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_31","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Blowback\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_32","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Tailspin\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_33","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Crumple\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_34","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_FloatingCrumpleBody\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_35","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_FloatingCrumpleHead\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_36","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_WallBounce\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_37","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_FaceDownBounce\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_38","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_FaceUpBounce\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_39","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_FaceDownLoop\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_40","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_FaceUpLoop\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_41","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_FaceDownWakeUp\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_42","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_FaceUpWakeUp\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_43","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_Throw\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_44","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_ThrowLock\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_45","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_TagIn\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_46","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_RoundWin\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_47","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_RoundLose\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_48","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_Universal_MatchWin\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_49","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_BattleObject_KO_S\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_50","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_BattleObject_KO_M\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_51","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_BattleObject_KO_L\n) \n</code></pre>"},{"location":"NightSkyEngine/_state_data_8h/#function-ue_declare_gameplay_tag_extern_52","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    State_BattleObject_KO_Draw\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/StateData.h</code></p>"},{"location":"NightSkyEngine/_state_data_8h_source/","title":"File StateData.h","text":"<p>File List &gt; Data &gt; StateData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NativeGameplayTags.h\"\n#include \"Engine/DataAsset.h\"\n#include \"NightSkyEngine/Battle/Script/State.h\"\n#include \"StateData.generated.h\"\n\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Stand);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Crouch);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Jump_V);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_JumpLanding);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_StandFlip);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchFlip);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_JumpFlip);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_StandBlock);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchBlock);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_AirBlock);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_StandBlockEnd);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchBlockEnd);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_AirBlockEnd);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_GuardBreakStand);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_GuardBreakCrouch);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_GuardBreakAir);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Hitstun_0);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Hitstun_1);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Hitstun_2);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Hitstun_3);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Hitstun_4);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Hitstun_5);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchHitstun_0);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchHitstun_1);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchHitstun_2);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchHitstun_3);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchHitstun_4);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_CrouchHitstun_5);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Launch_B);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Launch_V);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Launch_F);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Blowback);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Tailspin);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Crumple);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FloatingCrumpleBody);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FloatingCrumpleHead);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_WallBounce);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FaceDownBounce);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FaceUpBounce);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FaceDownLoop);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FaceUpLoop);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FaceDownWakeUp);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_FaceUpWakeUp);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_Throw);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_ThrowLock);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_TagIn);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_RoundWin);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_RoundLose);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_Universal_MatchWin);\n\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_BattleObject_KO_S);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_BattleObject_KO_M);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_BattleObject_KO_L);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(State_BattleObject_KO_Draw);\n\nUCLASS()\nclass NIGHTSKYENGINE_API UStateData : public UDataAsset\n{\n    GENERATED_BODY()\npublic:\n    UPROPERTY(EditAnywhere, BlueprintReadOnly)\n    TArray&lt;TSubclassOf&lt;UState&gt;&gt; StateArray;\n\n    UFUNCTION(BlueprintPure)\n    const UState* GetByStateName(const FGameplayTag&amp; StateName) const\n    {\n        for (const auto&amp; StateClass : StateArray)\n        {\n            const auto State = GetDefault&lt;UState&gt;(StateClass);\n            if (State-&gt;Name == StateName) return State;\n        }\n        return nullptr;\n    }\n};\n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/","title":"File SubroutineData.cpp","text":"<p>FileList &gt; Data &gt; SubroutineData.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"SubroutineData.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#public-functions","title":"Public Functions","text":"Type Name UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_Cmn_MatchInit, \"Subroutine.Cmn.MatchInit\", \"Subroutine Common Match Init\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_MatchInit, \"Subroutine.MatchInit\", \"Subroutine Match Init\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_Cmn_RoundInit, \"Subroutine.Cmn.RoundInit\", \"Subroutine Common Round Init\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_RoundInit, \"Subroutine.RoundInit\", \"Subroutine Round Init\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_Cmn_OnUpdate, \"Subroutine.Cmn.OnUpdate\", \"Subroutine Common On Update\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_OnUpdate, \"Subroutine.OnUpdate\", \"Subroutine On Update\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_Cmn_OnStateChange, \"Subroutine.Cmn.OnStateChange\", \"Subroutine Common On State Change\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_OnStateChange, \"Subroutine.OnStateChange\", \"Subroutine On State Change\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_Cmn_PostStateChange, \"Subroutine.Cmn.PostStateChange\", \"Subroutine Common Post State Change\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_PostStateChange, \"Subroutine.PostStateChange\", \"Subroutine Post State Change\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_Cmn_OnComboEnd, \"Subroutine.Cmn.OnComboEnd\", \"Subroutine Common On Combo End\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_OnComboEnd, \"Subroutine.OnComboEnd\", \"Subroutine On Combo End\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_Cmn_AnyCancel_Air, \"Subroutine.Cmn.AnyCancel.Air\", \"Subroutine Common Any Cancel (Air)\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_Cmn_OnLanding, \"Subroutine.Cmn.OnLanding\", \"Subroutine Common On Landing\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_OnLanding, \"Subroutine.OnLanding\", \"Subroutine On Landing\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_ThrowParam_Ground, \"Subroutine.ThrowParam.Ground\", \"Subroutine Throw Param (Ground)\")  UE_DEFINE_GAMEPLAY_TAG_COMMENT (Subroutine_ThrowParam_Air, \"Subroutine.ThrowParam.Air\", \"Subroutine Throw Param (Air)\")"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_Cmn_MatchInit,\n    \"Subroutine.Cmn.MatchInit\",\n    \"Subroutine Common Match Init\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_1","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_MatchInit,\n    \"Subroutine.MatchInit\",\n    \"Subroutine Match Init\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_2","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_Cmn_RoundInit,\n    \"Subroutine.Cmn.RoundInit\",\n    \"Subroutine Common Round Init\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_3","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_RoundInit,\n    \"Subroutine.RoundInit\",\n    \"Subroutine Round Init\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_4","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_Cmn_OnUpdate,\n    \"Subroutine.Cmn.OnUpdate\",\n    \"Subroutine Common On Update\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_5","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_OnUpdate,\n    \"Subroutine.OnUpdate\",\n    \"Subroutine On Update\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_6","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_Cmn_OnStateChange,\n    \"Subroutine.Cmn.OnStateChange\",\n    \"Subroutine Common On State Change\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_7","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_OnStateChange,\n    \"Subroutine.OnStateChange\",\n    \"Subroutine On State Change\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_8","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_Cmn_PostStateChange,\n    \"Subroutine.Cmn.PostStateChange\",\n    \"Subroutine Common Post State Change\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_9","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_PostStateChange,\n    \"Subroutine.PostStateChange\",\n    \"Subroutine Post State Change\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_10","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_Cmn_OnComboEnd,\n    \"Subroutine.Cmn.OnComboEnd\",\n    \"Subroutine Common On Combo End\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_11","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_OnComboEnd,\n    \"Subroutine.OnComboEnd\",\n    \"Subroutine On Combo End\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_12","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_Cmn_AnyCancel_Air,\n    \"Subroutine.Cmn.AnyCancel.Air\",\n    \"Subroutine Common Any Cancel (Air)\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_13","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_Cmn_OnLanding,\n    \"Subroutine.Cmn.OnLanding\",\n    \"Subroutine Common On Landing\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_14","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_OnLanding,\n    \"Subroutine.OnLanding\",\n    \"Subroutine On Landing\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_15","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_ThrowParam_Ground,\n    \"Subroutine.ThrowParam.Ground\",\n    \"Subroutine Throw Param (Ground)\"\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8cpp/#function-ue_define_gameplay_tag_comment_16","title":"function UE_DEFINE_GAMEPLAY_TAG_COMMENT","text":"<pre><code>UE_DEFINE_GAMEPLAY_TAG_COMMENT (\n    Subroutine_ThrowParam_Air,\n    \"Subroutine.ThrowParam.Air\",\n    \"Subroutine Throw Param (Air)\"\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SubroutineData.cpp</code></p>"},{"location":"NightSkyEngine/_subroutine_data_8cpp_source/","title":"File SubroutineData.cpp","text":"<p>File List &gt; Data &gt; SubroutineData.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"SubroutineData.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(SubroutineData)\n\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_MatchInit, \"Subroutine.Cmn.MatchInit\", \"Subroutine Common Match Init\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_MatchInit, \"Subroutine.MatchInit\", \"Subroutine Match Init\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_RoundInit, \"Subroutine.Cmn.RoundInit\", \"Subroutine Common Round Init\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_RoundInit, \"Subroutine.RoundInit\", \"Subroutine Round Init\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_OnUpdate, \"Subroutine.Cmn.OnUpdate\", \"Subroutine Common On Update\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_OnUpdate, \"Subroutine.OnUpdate\", \"Subroutine On Update\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_OnStateChange, \"Subroutine.Cmn.OnStateChange\", \"Subroutine Common On State Change\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_OnStateChange, \"Subroutine.OnStateChange\", \"Subroutine On State Change\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_PostStateChange, \"Subroutine.Cmn.PostStateChange\", \"Subroutine Common Post State Change\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_PostStateChange, \"Subroutine.PostStateChange\", \"Subroutine Post State Change\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_OnComboEnd, \"Subroutine.Cmn.OnComboEnd\", \"Subroutine Common On Combo End\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_OnComboEnd, \"Subroutine.OnComboEnd\", \"Subroutine On Combo End\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_AnyCancel_Air, \"Subroutine.Cmn.AnyCancel.Air\", \"Subroutine Common Any Cancel (Air)\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_Cmn_OnLanding, \"Subroutine.Cmn.OnLanding\", \"Subroutine Common On Landing\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_OnLanding, \"Subroutine.OnLanding\", \"Subroutine On Landing\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_ThrowParam_Ground, \"Subroutine.ThrowParam.Ground\", \"Subroutine Throw Param (Ground)\");\nUE_DEFINE_GAMEPLAY_TAG_COMMENT(Subroutine_ThrowParam_Air, \"Subroutine.ThrowParam.Air\", \"Subroutine Throw Param (Air)\");\n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/","title":"File SubroutineData.h","text":"<p>FileList &gt; Data &gt; SubroutineData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"NativeGameplayTags.h\"</code></li> <li><code>#include \"Engine/DataAsset.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Script/Subroutine.h\"</code></li> <li><code>#include \"SubroutineData.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_subroutine_data_8h/#classes","title":"Classes","text":"Type Name class USubroutineData"},{"location":"NightSkyEngine/_subroutine_data_8h/#public-functions","title":"Public Functions","text":"Type Name UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_Cmn_MatchInit)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_MatchInit)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_Cmn_RoundInit)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_RoundInit)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_Cmn_OnUpdate)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_OnUpdate)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_Cmn_OnStateChange)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_OnStateChange)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_Cmn_PostStateChange)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_PostStateChange)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_Cmn_OnComboEnd)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_OnComboEnd)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_Cmn_AnyCancel_Air)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_Cmn_OnLanding)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_OnLanding)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_ThrowParam_Ground)  UE_DECLARE_GAMEPLAY_TAG_EXTERN (Subroutine_ThrowParam_Air)"},{"location":"NightSkyEngine/_subroutine_data_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_Cmn_MatchInit\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_1","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_MatchInit\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_2","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_Cmn_RoundInit\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_3","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_RoundInit\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_4","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_Cmn_OnUpdate\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_5","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_OnUpdate\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_6","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_Cmn_OnStateChange\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_7","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_OnStateChange\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_8","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_Cmn_PostStateChange\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_9","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_PostStateChange\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_10","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_Cmn_OnComboEnd\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_11","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_OnComboEnd\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_12","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_Cmn_AnyCancel_Air\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_13","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_Cmn_OnLanding\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_14","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_OnLanding\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_15","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_ThrowParam_Ground\n) \n</code></pre>"},{"location":"NightSkyEngine/_subroutine_data_8h/#function-ue_declare_gameplay_tag_extern_16","title":"function UE_DECLARE_GAMEPLAY_TAG_EXTERN","text":"<pre><code>UE_DECLARE_GAMEPLAY_TAG_EXTERN (\n    Subroutine_ThrowParam_Air\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Data/SubroutineData.h</code></p>"},{"location":"NightSkyEngine/_subroutine_data_8h_source/","title":"File SubroutineData.h","text":"<p>File List &gt; Data &gt; SubroutineData.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NativeGameplayTags.h\"\n#include \"Engine/DataAsset.h\"\n#include \"NightSkyEngine/Battle/Script/Subroutine.h\"\n#include \"SubroutineData.generated.h\"\n\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_MatchInit);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_MatchInit);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_RoundInit);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_RoundInit);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_OnUpdate);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_OnUpdate);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_OnStateChange);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_OnStateChange);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_PostStateChange);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_PostStateChange);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_OnComboEnd);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_OnComboEnd);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_AnyCancel_Air);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_Cmn_OnLanding);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_OnLanding);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_ThrowParam_Ground);\nUE_DECLARE_GAMEPLAY_TAG_EXTERN(Subroutine_ThrowParam_Air);\n\n\nUCLASS()\nclass NIGHTSKYENGINE_API USubroutineData : public UDataAsset\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(EditAnywhere, BlueprintReadOnly)\n    TArray&lt;TSubclassOf&lt;USubroutine&gt;&gt; SubroutineArray;\n};\n</code></pre>"},{"location":"NightSkyEngine/dir_80ad56285f8ebf3da6163cdc63ed7343/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Input","text":"<p>FileList &gt; Input</p>"},{"location":"NightSkyEngine/dir_80ad56285f8ebf3da6163cdc63ed7343/#files","title":"Files","text":"Type Name file NSEEnhancedInputUserSettings.cpp file NSEEnhancedInputUserSettings.h file NSEPlayerMappableKeyProfile.cpp file NSEPlayerMappableKeyProfile.h file NSEPlayerMappableKeySettings.cpp file NSEPlayerMappableKeySettings.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Input/</code></p>"},{"location":"NightSkyEngine/_n_s_e_enhanced_input_user_settings_8cpp/","title":"File NSEEnhancedInputUserSettings.cpp","text":"<p>FileList &gt; Input &gt; NSEEnhancedInputUserSettings.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NSEEnhancedInputUserSettings.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEEnhancedInputUserSettings.cpp</code></p>"},{"location":"NightSkyEngine/_n_s_e_enhanced_input_user_settings_8cpp_source/","title":"File NSEEnhancedInputUserSettings.cpp","text":"<p>File List &gt; Input &gt; NSEEnhancedInputUserSettings.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NSEEnhancedInputUserSettings.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NSEEnhancedInputUserSettings)\n</code></pre>"},{"location":"NightSkyEngine/_n_s_e_enhanced_input_user_settings_8h/","title":"File NSEEnhancedInputUserSettings.h","text":"<p>FileList &gt; Input &gt; NSEEnhancedInputUserSettings.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"UserSettings/EnhancedInputUserSettings.h\"</code></li> <li><code>#include \"NSEEnhancedInputUserSettings.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_n_s_e_enhanced_input_user_settings_8h/#classes","title":"Classes","text":"Type Name class UNSEEnhancedInputUserSettings <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEEnhancedInputUserSettings.h</code></p>"},{"location":"NightSkyEngine/_n_s_e_enhanced_input_user_settings_8h_source/","title":"File NSEEnhancedInputUserSettings.h","text":"<p>File List &gt; Input &gt; NSEEnhancedInputUserSettings.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UserSettings/EnhancedInputUserSettings.h\"\n#include \"NSEEnhancedInputUserSettings.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API UNSEEnhancedInputUserSettings : public UEnhancedInputUserSettings\n{\n    GENERATED_BODY()\n};\n</code></pre>"},{"location":"NightSkyEngine/_n_s_e_player_mappable_key_profile_8cpp/","title":"File NSEPlayerMappableKeyProfile.cpp","text":"<p>FileList &gt; Input &gt; NSEPlayerMappableKeyProfile.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NSEPlayerMappableKeyProfile.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEPlayerMappableKeyProfile.cpp</code></p>"},{"location":"NightSkyEngine/_n_s_e_player_mappable_key_profile_8cpp_source/","title":"File NSEPlayerMappableKeyProfile.cpp","text":"<p>File List &gt; Input &gt; NSEPlayerMappableKeyProfile.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NSEPlayerMappableKeyProfile.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NSEPlayerMappableKeyProfile)\n</code></pre>"},{"location":"NightSkyEngine/_n_s_e_player_mappable_key_profile_8h/","title":"File NSEPlayerMappableKeyProfile.h","text":"<p>FileList &gt; Input &gt; NSEPlayerMappableKeyProfile.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"UserSettings/EnhancedInputUserSettings.h\"</code></li> <li><code>#include \"NSEPlayerMappableKeyProfile.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_n_s_e_player_mappable_key_profile_8h/#classes","title":"Classes","text":"Type Name class UNSEPlayerMappableKeyProfile <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEPlayerMappableKeyProfile.h</code></p>"},{"location":"NightSkyEngine/_n_s_e_player_mappable_key_profile_8h_source/","title":"File NSEPlayerMappableKeyProfile.h","text":"<p>File List &gt; Input &gt; NSEPlayerMappableKeyProfile.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"UserSettings/EnhancedInputUserSettings.h\"\n#include \"NSEPlayerMappableKeyProfile.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API UNSEPlayerMappableKeyProfile : public UEnhancedPlayerMappableKeyProfile\n{\n    GENERATED_BODY()\n};\n</code></pre>"},{"location":"NightSkyEngine/_n_s_e_player_mappable_key_settings_8cpp/","title":"File NSEPlayerMappableKeySettings.cpp","text":"<p>FileList &gt; Input &gt; NSEPlayerMappableKeySettings.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NSEPlayerMappableKeySettings.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEPlayerMappableKeySettings.cpp</code></p>"},{"location":"NightSkyEngine/_n_s_e_player_mappable_key_settings_8cpp_source/","title":"File NSEPlayerMappableKeySettings.cpp","text":"<p>File List &gt; Input &gt; NSEPlayerMappableKeySettings.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NSEPlayerMappableKeySettings.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NSEPlayerMappableKeySettings)\n</code></pre>"},{"location":"NightSkyEngine/_n_s_e_player_mappable_key_settings_8h/","title":"File NSEPlayerMappableKeySettings.h","text":"<p>FileList &gt; Input &gt; NSEPlayerMappableKeySettings.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"PlayerMappableKeySettings.h\"</code></li> <li><code>#include \"NSEPlayerMappableKeySettings.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_n_s_e_player_mappable_key_settings_8h/#classes","title":"Classes","text":"Type Name class UNSEPlayerMappableKeySettings <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Input/NSEPlayerMappableKeySettings.h</code></p>"},{"location":"NightSkyEngine/_n_s_e_player_mappable_key_settings_8h_source/","title":"File NSEPlayerMappableKeySettings.h","text":"<p>File List &gt; Input &gt; NSEPlayerMappableKeySettings.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"PlayerMappableKeySettings.h\"\n#include \"NSEPlayerMappableKeySettings.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API UNSEPlayerMappableKeySettings : public UPlayerMappableKeySettings\n{\n    GENERATED_BODY()\n\n};\n</code></pre>"},{"location":"NightSkyEngine/dir_3028ef8e315fbc532032c32a50fd3ba1/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous","text":"<p>FileList &gt; Miscellaneous</p>"},{"location":"NightSkyEngine/dir_3028ef8e315fbc532032c32a50fd3ba1/#files","title":"Files","text":"Type Name file NightSkyEngineGameModeBase.cpp file NightSkyEngineGameModeBase.h file NightSkyGameInstance.cpp file NightSkyGameInstance.h file NightSkySaveInfo.cpp file NightSkySaveInfo.h file NightSkySettingsInfo.h file ReplayInfo.cpp file ReplayInfo.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/</code></p>"},{"location":"NightSkyEngine/_night_sky_engine_game_mode_base_8cpp/","title":"File NightSkyEngineGameModeBase.cpp","text":"<p>FileList &gt; Miscellaneous &gt; NightSkyEngineGameModeBase.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyEngineGameModeBase.h\"</code></li> <li><code>#include \"OnlineSubsystem.h\"</code></li> <li><code>#include \"OnlineSubsystemUtils.h\"</code></li> <li><code>#include \"Kismet/GameplayStatics.h\"</code></li> <li><code>#include \"NightSkyGameInstance.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkyEngineGameModeBase.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_engine_game_mode_base_8cpp_source/","title":"File NightSkyEngineGameModeBase.cpp","text":"<p>File List &gt; Miscellaneous &gt; NightSkyEngineGameModeBase.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright Epic Games, Inc. All Rights Reserved.\n\n\n#include \"NightSkyEngineGameModeBase.h\"\n#include \"OnlineSubsystem.h\"\n#include \"OnlineSubsystemUtils.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"NightSkyGameInstance.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyEngineGameModeBase)\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_engine_game_mode_base_8h/","title":"File NightSkyEngineGameModeBase.h","text":"<p>FileList &gt; Miscellaneous &gt; NightSkyEngineGameModeBase.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameFramework/GameModeBase.h\"</code></li> <li><code>#include \"NightSkyEngineGameModeBase.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_engine_game_mode_base_8h/#classes","title":"Classes","text":"Type Name class ANightSkyEngineGameModeBase <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkyEngineGameModeBase.h</code></p>"},{"location":"NightSkyEngine/_night_sky_engine_game_mode_base_8h_source/","title":"File NightSkyEngineGameModeBase.h","text":"<p>File List &gt; Miscellaneous &gt; NightSkyEngineGameModeBase.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameModeBase.h\"\n#include \"NightSkyEngineGameModeBase.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API ANightSkyEngineGameModeBase : public AGameModeBase\n{\n    GENERATED_BODY()\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_game_instance_8cpp/","title":"File NightSkyGameInstance.cpp","text":"<p>FileList &gt; Miscellaneous &gt; NightSkyGameInstance.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyGameInstance.h\"</code></li> <li><code>#include \"NightSkySettingsInfo.h\"</code></li> <li><code>#include \"ReplayInfo.h\"</code></li> <li><code>#include \"Kismet/GameplayStatics.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/PrimaryStageData.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkyGameInstance.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_game_instance_8cpp_source/","title":"File NightSkyGameInstance.cpp","text":"<p>File List &gt; Miscellaneous &gt; NightSkyGameInstance.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyGameInstance.h\"\n\n#include \"NightSkySettingsInfo.h\"\n#include \"ReplayInfo.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"NightSkyEngine/Data/PrimaryStageData.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyGameInstance)\n\nvoid UNightSkyGameInstance::Init()\n{\n    Super::Init();\n\n    BattleData.Random = FRandomManager(FGenericPlatformMath::Rand());\n\n    SettingsInfo = Cast&lt;UNightSkySettingsInfo&gt;(UGameplayStatics::LoadGameFromSlot(\"SYSTEM\", 0));\n    if (!SettingsInfo)\n    {\n        SettingsInfo = Cast&lt;UNightSkySettingsInfo&gt;(UGameplayStatics::CreateSaveGameObject(UNightSkySettingsInfo::StaticClass()));\n        UGameplayStatics::SaveGameToSlot(SettingsInfo, \"SYSTEM\", 0);\n    }\n\n    const FString AntiAliasingCommand = \"r.AntiAliasingMethod \" + FString::FromInt(SettingsInfo-&gt;AntiAliasingMethod);\n    const FString GlobalIlluminationCommand = \"r.DynamicGlobalIlluminationMethod \" + FString::FromInt(SettingsInfo-&gt;GlobalIlluminationMethod);\n\n    GetWorld()-&gt;Exec(GetWorld(), *AntiAliasingCommand);\n    GetWorld()-&gt;Exec(GetWorld(), *GlobalIlluminationCommand);\n}\n\nvoid UNightSkyGameInstance::TravelToVSInfo() const\n{\n    this-&gt;GetWorld()-&gt;ServerTravel(\"VSInfo_PL\", true);\n}\n\nvoid UNightSkyGameInstance::TravelToBattleMap() const\n{\n    this-&gt;GetWorld()-&gt;ServerTravel(BattleData.Stage-&gt;StageURL, true);\n}\n\nvoid UNightSkyGameInstance::LoadReplay()\n{\n    BattleData = CurrentReplay-&gt;BattleData;\n}\n\nvoid UNightSkyGameInstance::PlayReplayToGameState(int32 FrameNumber, int32&amp; OutP1Input, int32&amp; OutP2Input) const\n{\n    if (FrameNumber &gt;= CurrentReplay-&gt;LengthInFrames)\n    {\n        UGameplayStatics::OpenLevel(this, FName(TEXT(\"MainMenu_PL\")));\n        return;\n    }\n    OutP1Input = CurrentReplay-&gt;InputsP1[FrameNumber];\n    OutP2Input = CurrentReplay-&gt;InputsP2[FrameNumber];\n}\n\nvoid UNightSkyGameInstance::RecordReplay()\n{\n    CurrentReplay = Cast&lt;UReplaySaveInfo&gt;(UGameplayStatics::CreateSaveGameObject(UReplaySaveInfo::StaticClass()));\n    CurrentReplay-&gt;BattleData = BattleData;\n    CurrentReplay-&gt;Version = BattleVersion;\n    CurrentReplay-&gt;bIsTraining = IsTraining;\n}\n\nvoid UNightSkyGameInstance::UpdateReplay(int32 InputsP1, int32 InputsP2) const\n{\n    if (!CurrentReplay) return;\n    CurrentReplay-&gt;LengthInFrames++;\n    CurrentReplay-&gt;InputsP1.Add(InputsP1);\n    CurrentReplay-&gt;InputsP2.Add(InputsP2);\n}\n\nvoid UNightSkyGameInstance::RollbackReplay(int32 FramesToRollback) const\n{\n    for (int i = 0; i &lt; FramesToRollback; i++)\n    {\n        CurrentReplay-&gt;LengthInFrames--;\n        CurrentReplay-&gt;InputsP1.Pop();\n        CurrentReplay-&gt;InputsP2.Pop();\n    }\n}\n\nvoid UNightSkyGameInstance::EndRecordReplay() const\n{\n    if (IsReplay) return;\n    FString ReplayName = \"REPLAY\";\n    for (int i = 0; i &lt; MaxReplays; i++)\n    {\n        ReplayName = \"REPLAY\";\n        ReplayName.AppendInt(i);\n        if (!UGameplayStatics::DoesSaveGameExist(ReplayName, 0))\n        {\n            break;\n        }\n    }\n    UGameplayStatics::SaveGameToSlot(CurrentReplay, ReplayName, 0);\n}\n\nvoid UNightSkyGameInstance::PlayReplayFromBP(FString ReplayName)\n{\n    FighterRunner = Multiplayer;\n    IsReplay = true;\n    CurrentReplay = Cast&lt;UReplaySaveInfo&gt;(UGameplayStatics::LoadGameFromSlot(ReplayName, 0));\n    IsTraining = CurrentReplay-&gt;bIsTraining;\n    LoadReplay();\n}\n\nvoid UNightSkyGameInstance::FindReplays()\n{\n    ReplayList.Empty();\n    for (int i = 0; i &lt; MaxReplays; i++)\n    {\n        FString ReplayName = \"REPLAY\";\n        ReplayName.AppendInt(i);\n        if (!UGameplayStatics::DoesSaveGameExist(ReplayName, 0))\n        {\n            continue;\n        }\n        ReplayList.Add(Cast&lt;UReplaySaveInfo&gt;(UGameplayStatics::LoadGameFromSlot(ReplayName, 0)));\n        ReplayList.Last()-&gt;ReplayIndex = i;\n        if (ReplayList.Last()-&gt;Version != BattleVersion)\n        {\n            ReplayList.Pop();\n            UGameplayStatics::DeleteGameInSlot(ReplayName, 0);\n        }\n    }\n    BP_OnFindReplaysComplete(ReplayList);\n}\n\nvoid UNightSkyGameInstance::DeleteReplay(const FString&amp; ReplayName)\n{\n    if (UGameplayStatics::DoesSaveGameExist(ReplayName, 0))\n    {\n        UGameplayStatics::DeleteGameInSlot(ReplayName, 0);\n    }\n    FindReplays();\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_game_instance_8h/","title":"File NightSkyGameInstance.h","text":"<p>FileList &gt; Miscellaneous &gt; NightSkyGameInstance.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"NightSkyEngine/Network/FighterRunners.h\"</code></li> <li><code>#include \"GameplayTagContainer.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Misc/RandomManager.h\"</code></li> <li><code>#include \"Engine/GameInstance.h\"</code></li> <li><code>#include \"NightSkyGameInstance.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_game_instance_8h/#classes","title":"Classes","text":"Type Name struct FBattleData class UNightSkyGameInstance"},{"location":"NightSkyEngine/_night_sky_game_instance_8h/#public-attributes","title":"Public Attributes","text":"Type Name int32 MaxReplays   = <code>999</code>"},{"location":"NightSkyEngine/_night_sky_game_instance_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"NightSkyEngine/_night_sky_game_instance_8h/#variable-maxreplays","title":"variable MaxReplays","text":"<pre><code>int32 MaxReplays;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkyGameInstance.h</code></p>"},{"location":"NightSkyEngine/_night_sky_game_instance_8h_source/","title":"File NightSkyGameInstance.h","text":"<p>File List &gt; Miscellaneous &gt; NightSkyGameInstance.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NightSkyEngine/Network/FighterRunners.h\"\n#include \"GameplayTagContainer.h\"\n#include \"NightSkyEngine/Battle/Misc/RandomManager.h\"\n#include \"Engine/GameInstance.h\"\n#include \"NightSkyGameInstance.generated.h\"\n\nclass UPrimaryStageData;\nclass UPrimaryCharaData;\nclass UNightSkySettingsInfo;\nclass USoundData;\nconstexpr int32 MaxReplays = 999;\n\nclass APlayerObject;\nclass UReplaySaveInfo;\nenum class EBattleFormat : uint8;\n\nUSTRUCT(BlueprintType)\nstruct FBattleData\n{\n    GENERATED_BODY()\n\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    TArray&lt;UPrimaryCharaData*&gt; PlayerListP1;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    TArray&lt;UPrimaryCharaData*&gt; PlayerListP2;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    TArray&lt;int32&gt; ColorIndicesP1;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    TArray&lt;int32&gt; ColorIndicesP2;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    EBattleFormat BattleFormat;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    int32 TimeUntilRoundStart = 180;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    int32 RoundCount;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    int32 StartRoundTimer;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    UPrimaryStageData* Stage;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    FGameplayTag MusicName;\n    UPROPERTY()\n    FRandomManager Random;\n};\n\nUCLASS()\nclass NIGHTSKYENGINE_API UNightSkyGameInstance : public UGameInstance\n{\n    GENERATED_BODY()\n\n    UPROPERTY()\n    UReplaySaveInfo* CurrentReplay;\n\n    virtual void Init() override;\n\nprotected:\n    UFUNCTION(BlueprintImplementableEvent, Category = \"Replays\")  \n    void BP_OnFindReplaysComplete(const TArray&lt;UReplaySaveInfo*&gt; &amp;AllReplays);\n\npublic:\n    bool FinishedLoadingForNetworkBattle = false;\n\n    UPROPERTY(EditAnywhere, BlueprintReadOnly)\n    FString GameVersion;\n    UPROPERTY(EditAnywhere, BlueprintReadOnly)\n    FString BattleVersion;\n\n    UPROPERTY(BlueprintReadOnly)\n    TObjectPtr&lt;UNightSkySettingsInfo&gt; SettingsInfo;\n\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;USoundData&gt; AnnouncerData;\n    UPROPERTY(EditAnywhere)\n    TObjectPtr&lt;USoundData&gt; MusicData;\n\n    UPROPERTY()\n    TArray&lt;UReplaySaveInfo*&gt; ReplayList;\n    UPROPERTY(BlueprintReadWrite)\n    int PlayerIndex;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    FBattleData BattleData;\n\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    bool IsTraining = false;\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    bool IsCPUBattle = false;\n    UPROPERTY(BlueprintReadWrite)\n    bool IsReplay = false;\n\n    UPROPERTY(BlueprintReadWrite, EditAnywhere)\n    TEnumAsByte&lt;EFighterRunners&gt; FighterRunner; \n\n    UFUNCTION(BlueprintCallable)\n    void TravelToVSInfo() const;\n    void TravelToBattleMap() const;\n\n    void LoadReplay();\n    void PlayReplayToGameState(int32 FrameNumber, int32&amp; OutP1Input, int32&amp; OutP2Input) const;\n\n    void RecordReplay();\n    void UpdateReplay(int32 InputsP1, int32 InputsP2) const;\n    void RollbackReplay(int32 FramesToRollback) const;\n    void EndRecordReplay() const;\n\n    UFUNCTION(BlueprintCallable, Category = \"Replays\")   \n    void PlayReplayFromBP(FString ReplayName);   \n\n    UFUNCTION(BlueprintCallable, Category = \"Replays\")  \n    void FindReplays(); \n\n    UFUNCTION(BlueprintCallable, Category = \"Replays\")\n    void DeleteReplay(const FString &amp;ReplayName);\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_save_info_8cpp/","title":"File NightSkySaveInfo.cpp","text":"<p>FileList &gt; Miscellaneous &gt; NightSkySaveInfo.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkySaveInfo.h\"</code></li> <li><code>#include \"GameFramework/Actor.h\"</code></li> <li><code>#include \"Serialization/MemoryReader.h\"</code></li> <li><code>#include \"Serialization/MemoryWriter.h\"</code></li> <li><code>#include \"Engine/World.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkySaveInfo.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_save_info_8cpp_source/","title":"File NightSkySaveInfo.cpp","text":"<p>File List &gt; Miscellaneous &gt; NightSkySaveInfo.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"NightSkySaveInfo.h\"\n#include \"GameFramework/Actor.h\"\n#include \"Serialization/MemoryReader.h\"\n#include \"Serialization/MemoryWriter.h\"\n#include \"Engine/World.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkySaveInfo)\n\nvoid UNightSkySaveInfo::ActorArraySaver(TArray&lt;AActor*&gt;&amp; SaveActors)\n{\n    for (AActor* SaveActor : SaveActors)\n    {\n        ActorSaver(SaveActor);\n    }\n}\n\nvoid UNightSkySaveInfo::ActorSaver(AActor* SaveActor)\n{\n    const int32 Index = ObjectRecords.Emplace();\n    FObjectRecord&amp; ObjectRecord = ObjectRecords[Index];\n\n    ObjectRecord.Name = SaveActor-&gt;GetFName();\n    ObjectRecord.Transform = SaveActor-&gt;GetTransform();\n    ObjectRecord.Class = SaveActor-&gt;GetClass();\n    ObjectRecord.bActor = true;\n\n    SaveData(SaveActor, ObjectRecord.Data);\n\n    this-&gt;TempObjects.Add(SaveActor);\n    UE_LOG(LogTemp, Display, TEXT(\"Complete Save Actor %s\"), *SaveActor-&gt;GetName())\n}\n\nvoid UNightSkySaveInfo::ActorPreloader(AActor* WorldActor, FObjectRecord&amp; ActorRecord)\n{\n    FActorSpawnParameters SpawnParams;\n    SpawnParams.Name = ActorRecord.Name;\n\n    // TODO: change this to SpawnActorDeferred so you can de-serialize and apply data before it calls constructor\\BeginPlay\n    AActor* NewActor = WorldActor-&gt;GetWorld()-&gt;SpawnActor(ActorRecord.Class, &amp;ActorRecord.Transform, SpawnParams);\n    //AActor* NewActor = WorldActor-&gt;GetWorld()-&gt;SpawnActorDeferred\n\n    // BUG? actor doesn't appear to load scale correctly using transform so I specifically apply the scale after loading\n    NewActor-&gt;SetActorScale3D(ActorRecord.Transform.GetScale3D());\n\n    // don't load now, load after all objects are preloaded\n    //LoadData(LoadObject, ObjectRecord.Data);\n\n    // add to temp array for lookup it another object using already loaded objects as outers (array gets cleared once all objects loaded)\n    this-&gt;TempObjects.Add(NewActor);\n\n    UE_LOG(LogTemp, Display, TEXT(\"Complete Load Actor %s\"), *NewActor-&gt;GetPathName())\n}\n\nvoid UNightSkySaveInfo::UObjectArraySaver(TArray&lt;UObject*&gt;&amp; SaveObjects)\n{\n    for (UObject* SaveObject : SaveObjects)\n    {\n        UObjectSaver(SaveObject);\n    }\n}\n\nvoid UNightSkySaveInfo::UObjectSaver(UObject* SaveObject)\n{\n    if (SaveObject == nullptr)\n    {\n        UE_LOG(LogTemp, Error, TEXT(\"Invalid Save Object!\"))\n        return;\n    }\n\n    if (SaveObject-&gt;HasAnyFlags(EObjectFlags::RF_Transient))\n    {\n        UE_LOG(LogTemp, Warning, TEXT(\"Saving RF_Transient object\"))\n        return;\n    }\n\n    if (SaveObject-&gt;IsA(AActor::StaticClass()))\n    {\n        ActorSaver(Cast&lt;AActor&gt;(SaveObject));\n        return;\n    }\n\n    const int32 Index = ObjectRecords.Emplace();\n    FObjectRecord&amp; ObjectRecord = ObjectRecords[Index];\n\n    // Use custom IDs for save / retrieving outer pointers\n    // * Negative IDs if outer is a permanent map object (i.e. not loaded from SaveGame)\n    // * Negative IDs start from -2 because -1 is already assigned to INDEX_NONE, and 0+ is used for SaveGame loaded objects\n    ObjectRecord.OuterID = TempObjects.Find(SaveObject-&gt;GetOuter());\n    ObjectRecord.bActor = false;\n\n    // if outer is a saved object then don't try to save the direct object pointer\n    if (ObjectRecord.OuterID == INDEX_NONE)\n    {\n        ObjectRecord.OuterID = PersistentOuters.Find(SaveObject-&gt;GetOuter());\n        if (ObjectRecord.OuterID != INDEX_NONE)\n        {\n            ObjectRecord.OuterID = -(ObjectRecord.OuterID + 2);\n        }\n        else\n        {\n            const int32 Index2 = PersistentOuters.Add(SaveObject-&gt;GetOuter());\n            ObjectRecord.OuterID = -(Index2 + 2);\n            UE_LOG(LogTemp, Display, TEXT(\"Save Outer %s\"), *SaveObject-&gt;GetOuter()-&gt;GetPathName())\n\n        }\n    }\n\n    ObjectRecord.Name = SaveObject-&gt;GetFName();\n    ObjectRecord.Class = SaveObject-&gt;GetClass();\n\n    SaveData(SaveObject, ObjectRecord.Data);\n\n    this-&gt;TempObjects.Add(SaveObject);\n\n    UE_LOG(LogTemp, Display, TEXT(\"Complete Save UObject %s\"), *SaveObject-&gt;GetName())\n}\n\nvoid UNightSkySaveInfo::UObjectsPreloader(AActor* WorldActor)\n{\n    UObject* LoadOuter = nullptr;\n\n    for (FObjectRecord&amp; ObjectRecord : ObjectRecords)\n    {\n        if (ObjectRecord.bActor == false)\n        {\n            if (ObjectRecord.OuterID != INDEX_NONE)\n            {\n                if (TempObjects.IsValidIndex(ObjectRecord.OuterID) == true)\n                {\n                    LoadOuter = TempObjects[ObjectRecord.OuterID];\n                    if (LoadOuter == nullptr)\n                    {\n                        UE_LOG(LogTemp, Error, TEXT(\"Unable to find Outer for object (invalid array object)\"))\n                    }\n                }\n                else\n                {\n                    const int32 NewIndex = FMath::Abs(ObjectRecord.OuterID) - 2;\n\n                    if (PersistentOuters.IsValidIndex(NewIndex)) \n                    {\n                        LoadOuter = PersistentOuters[NewIndex];\n                    }\n                    else \n                    {\n                        UE_LOG(LogTemp, Error, TEXT(\"Unable to find Outer for object (invalid ID)\"))\n                    }   \n                }\n            }\n            if (LoadOuter == nullptr)\n            {\n                UE_LOG(LogTemp, Error, TEXT(\"Unable to find Outer for object (no pointer)\"))\n                continue;\n            }\n\n            UObject* LoadObject = NewObject&lt;UObject&gt;(LoadOuter, ObjectRecord.Class, ObjectRecord.Name);\n\n            if (LoadObject == nullptr) return;\n\n            // don't load now, load after all objects are preloaded\n            //LoadData(LoadObject, ObjectRecord.Data);\n\n            // add to here to cycle through and keep a pointer temporarily to avoid garbage collection (not sure if required but to be safe)\n            this-&gt;TempObjects.Add(LoadObject);\n\n            UE_LOG(LogTemp, Display, TEXT(\"Complete Load UObject %s %d\"), *LoadObject-&gt;GetPathName(), this-&gt;TempObjects.Num() - 1)\n        }\n\n        else\n        {\n            ActorPreloader(WorldActor, ObjectRecord);\n        }\n    }\n}\n\nvoid UNightSkySaveInfo::UObjectDataLoader()\n{\n    for (int32 a = 0 ; ObjectRecords.IsValidIndex(a) ; a++)\n    {\n        // Load now after all objects are preloaded\n        LoadData(TempObjects[a], ObjectRecords[a].Data);\n    }\n}\n\nvoid UNightSkySaveInfo::SaveData(UObject* Object, TArray&lt;uint8&gt;&amp; InData)\n{\n    if (Object == nullptr) return;\n\n    FMemoryWriter MemoryWriter = FMemoryWriter(Data, true);\n    FNightSkySaveArchive MyArchive = FNightSkySaveArchive(MemoryWriter);\n\n    Object-&gt;Serialize(MyArchive);\n}\n\nvoid UNightSkySaveInfo::LoadData(UObject* Object, TArray&lt;uint8&gt;&amp; InData)\n{\n    if (Object == nullptr) return;\n\n    FMemoryReader MemoryReader(Data, true);\n\n    FNightSkySaveArchive Ar(MemoryReader);\n    Object-&gt;Serialize(Ar);\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_save_info_8h/","title":"File NightSkySaveInfo.h","text":"<p>FileList &gt; Miscellaneous &gt; NightSkySaveInfo.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GameFramework/SaveGame.h\"</code></li> <li><code>#include \"Serialization/ObjectAndNameAsStringProxyArchive.h\"</code></li> <li><code>#include \"NightSkySaveInfo.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_save_info_8h/#classes","title":"Classes","text":"Type Name struct FNightSkySaveArchive struct FObjectRecord class UNightSkySaveInfo <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkySaveInfo.h</code></p>"},{"location":"NightSkyEngine/_night_sky_save_info_8h_source/","title":"File NightSkySaveInfo.h","text":"<p>File List &gt; Miscellaneous &gt; NightSkySaveInfo.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n#include \"GameFramework/SaveGame.h\"\n#include \"Serialization/ObjectAndNameAsStringProxyArchive.h\"\n#include \"NightSkySaveInfo.generated.h\"\n\nstruct FNightSkySaveArchive : FObjectAndNameAsStringProxyArchive\n{\n    FNightSkySaveArchive(FArchive&amp; InInnerArchive)\n        : FObjectAndNameAsStringProxyArchive(InInnerArchive, true)\n    {\n        ArIsSaveGame = true;\n        ArNoDelta = true;\n    }\n};\n\nUSTRUCT(BlueprintType)\nstruct FObjectRecord\n{\n    GENERATED_BODY()\n\n    // class that this object is\n    UPROPERTY(BlueprintReadWrite)\n    UClass* Class;\n\n    // save the outer used for object so they get loaded back in the correct hierarchy\n    UPROPERTY(BlueprintReadWrite)\n    UObject* Outer;\n\n    // save the outer used for object so they get loaded back in the correct hierarchy\n    UPROPERTY(BlueprintReadWrite)\n    int32 OuterID;\n\n    // if the outer is an actor otherwise will be UObject\n    UPROPERTY(BlueprintReadWrite)\n    bool bActor;\n\n    // this is for loading only, store a pointer for the loaded object here so you can loop for the records later to de-serialize all the data\n    UPROPERTY(BlueprintReadWrite)\n    UObject* Self;\n\n    // Name of the object\n    UPROPERTY(BlueprintReadWrite)\n    FName Name;\n\n    // serialized data for all UProperties that are 'SaveGame' enabled\n    UPROPERTY(BlueprintReadWrite)\n    TArray&lt;uint8&gt; Data;\n\n    // Spawn location if it's an actor\n    UPROPERTY(BlueprintReadWrite)\n    FTransform Transform;\n\n    FObjectRecord()\n    {\n        Class = nullptr;\n        Outer = nullptr;\n        Self = nullptr;\n    }\n};\n\nUCLASS()\nclass UNightSkySaveInfo : public USaveGame\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    TArray&lt;uint8&gt; Data;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    TArray&lt;FObjectRecord&gt; ObjectRecords;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    TArray&lt;UObject*&gt; TempObjects;\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n    TArray&lt;UObject*&gt; PersistentOuters;\n\n    // basically just a wrapper so you don't have to do a for loop in blueprints\n    UFUNCTION(BlueprintCallable)\n    void ActorArraySaver(UPARAM(ref)TArray&lt;AActor*&gt;&amp; SaveActors);\n\n    // Save individual Actors\n    UFUNCTION(BlueprintCallable)\n    void ActorSaver(AActor* SaveActor);\n\n    // Create all saved actors without any data serialized yet\n    UFUNCTION(BlueprintCallable)\n    void ActorPreloader(AActor* WorldActor, FObjectRecord&amp; ActorRecord);\n\n    // basically just a wrapper so you don't have to do a for loop in blueprints\n    UFUNCTION(BlueprintCallable)\n    void UObjectArraySaver(UPARAM(ref) TArray&lt;UObject*&gt;&amp; SaveObjects);\n\n    // Save individual objects\n    UFUNCTION(BlueprintCallable)\n    void UObjectSaver(UObject* SaveObject);\n\n    // create all saved objects without any data serialized yet\n    UFUNCTION(BlueprintCallable)\n    void UObjectsPreloader(AActor* WorldActor);\n\n    // load all data after all objects exist so all pointers will load\n    UFUNCTION(BlueprintCallable)\n    void UObjectDataLoader();\n\n    // serialize the data\n    UFUNCTION(BlueprintCallable)\n    void SaveData(UObject* Object, TArray&lt;uint8&gt;&amp; InData);\n\n    // de-serialize the data\n    UFUNCTION(BlueprintCallable)\n    void LoadData(UObject* Object, UPARAM(ref) TArray&lt;uint8&gt;&amp; InData);\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_settings_info_8h/","title":"File NightSkySettingsInfo.h","text":"<p>FileList &gt; Miscellaneous &gt; NightSkySettingsInfo.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"NightSkySaveInfo.h\"</code></li> <li><code>#include \"NightSkySettingsInfo.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_settings_info_8h/#classes","title":"Classes","text":"Type Name class UNightSkySettingsInfo <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/NightSkySettingsInfo.h</code></p>"},{"location":"NightSkyEngine/_night_sky_settings_info_8h_source/","title":"File NightSkySettingsInfo.h","text":"<p>File List &gt; Miscellaneous &gt; NightSkySettingsInfo.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NightSkySaveInfo.h\"\n#include \"NightSkySettingsInfo.generated.h\"\n\nclass UInputAction;\n\nUCLASS()\nclass NIGHTSKYENGINE_API UNightSkySettingsInfo : public UNightSkySaveInfo\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(BlueprintReadWrite)\n    int32 AntiAliasingMethod;\n    UPROPERTY(BlueprintReadWrite)\n    int32 GlobalIlluminationMethod;\n};\n</code></pre>"},{"location":"NightSkyEngine/_replay_info_8cpp/","title":"File ReplayInfo.cpp","text":"<p>FileList &gt; Miscellaneous &gt; ReplayInfo.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ReplayInfo.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/ReplayInfo.cpp</code></p>"},{"location":"NightSkyEngine/_replay_info_8cpp_source/","title":"File ReplayInfo.cpp","text":"<p>File List &gt; Miscellaneous &gt; ReplayInfo.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"ReplayInfo.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(ReplayInfo)\n</code></pre>"},{"location":"NightSkyEngine/_replay_info_8h/","title":"File ReplayInfo.h","text":"<p>FileList &gt; Miscellaneous &gt; ReplayInfo.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"NightSkyGameInstance.h\"</code></li> <li><code>#include \"NightSkySaveInfo.h\"</code></li> <li><code>#include \"ReplayInfo.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_replay_info_8h/#classes","title":"Classes","text":"Type Name class UReplaySaveInfo <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Miscellaneous/ReplayInfo.h</code></p>"},{"location":"NightSkyEngine/_replay_info_8h_source/","title":"File ReplayInfo.h","text":"<p>File List &gt; Miscellaneous &gt; ReplayInfo.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NightSkyGameInstance.h\"\n#include \"NightSkySaveInfo.h\"\n#include \"ReplayInfo.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API UReplaySaveInfo : public UNightSkySaveInfo\n{\n    GENERATED_BODY()\n\npublic:\n    UReplaySaveInfo()  \n    {\n        Timestamp = FDateTime::Now();\n        BattleData = FBattleData();  \n        Version = \"\";\n        ReplayIndex = -1;\n        LengthInFrames = 0;\n    }\n\n    UPROPERTY(BlueprintReadOnly)  \n    FDateTime Timestamp;\n    UPROPERTY(BlueprintReadOnly)  \n    FBattleData BattleData;\n    UPROPERTY(BlueprintReadOnly)  \n    FString Version;\n    UPROPERTY(BlueprintReadOnly)\n    int32 ReplayIndex;\n    UPROPERTY()\n    int32 LengthInFrames;\n    UPROPERTY()\n    TArray&lt;int32&gt; InputsP1;\n    UPROPERTY()\n    TArray&lt;int32&gt; InputsP2;\n    UPROPERTY()\n    bool bIsTraining;\n};\n</code></pre>"},{"location":"NightSkyEngine/dir_261b7ff0e57c151ad26fd5c163777bbe/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Network","text":"<p>FileList &gt; Network</p>"},{"location":"NightSkyEngine/dir_261b7ff0e57c151ad26fd5c163777bbe/#files","title":"Files","text":"Type Name file FighterRunners.h file NSESessionSubsystem.cpp file NSESessionSubsystem.h file NetworkPawn.cpp file NetworkPawn.h file RpcConnectionManager.cpp file RpcConnectionManager.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Network/</code></p>"},{"location":"NightSkyEngine/_fighter_runners_8h/","title":"File FighterRunners.h","text":"<p>FileList &gt; Network &gt; FighterRunners.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"FighterRunners.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_fighter_runners_8h/#public-types","title":"Public Types","text":"Type Name enum EFighterRunners"},{"location":"NightSkyEngine/_fighter_runners_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"NightSkyEngine/_fighter_runners_8h/#enum-efighterrunners","title":"enum EFighterRunners","text":"<pre><code>enum EFighterRunners {\n    LocalPlay,\n    Multiplayer,\n    SyncTest\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Network/FighterRunners.h</code></p>"},{"location":"NightSkyEngine/_fighter_runners_8h_source/","title":"File FighterRunners.h","text":"<p>File List &gt; Network &gt; FighterRunners.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"FighterRunners.generated.h\"\n\nUENUM(BlueprintType)\nenum EFighterRunners {\n    LocalPlay,\n    Multiplayer,\n    SyncTest\n};\n</code></pre>"},{"location":"NightSkyEngine/_n_s_e_session_subsystem_8cpp/","title":"File NSESessionSubsystem.cpp","text":"<p>FileList &gt; Network &gt; NSESessionSubsystem.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NSESessionSubsystem.h\"</code></li> <li><code>#include \"OnlineSessionSettings.h\"</code></li> <li><code>#include \"OnlineSubsystemUtils.h\"</code></li> <li><code>#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"</code></li> <li><code>#include \"Online/OnlineSessionNames.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Network/NSESessionSubsystem.cpp</code></p>"},{"location":"NightSkyEngine/_n_s_e_session_subsystem_8cpp_source/","title":"File NSESessionSubsystem.cpp","text":"<p>File List &gt; Network &gt; NSESessionSubsystem.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NSESessionSubsystem.h\"\n\n#include \"OnlineSessionSettings.h\"\n#include \"OnlineSubsystemUtils.h\"\n#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"\n#include \"Online/OnlineSessionNames.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NSESessionSubsystem)\n\nFNSESessionInfo::FNSESessionInfo(const FOnlineSessionSearchResult&amp; Result, const FString&amp; Name, int32 OpenPrivate, int32 OpenPublic)\n    : SessionSearchResult(Result), OwningUserName(Name), NumOpenPrivateConnections(OpenPrivate),\n      NumOpenPublicConnections(OpenPublic)\n{\n}\n\nUNSESessionSubsystem::UNSESessionSubsystem() : CreateSessionCompleteDelegate(\n                                                   FOnCreateSessionCompleteDelegate::CreateUObject(\n                                                       this, &amp;ThisClass::OnCreateSessionComplete)),\n                                               UpdateSessionCompleteDelegate(\n                                                   FOnUpdateSessionCompleteDelegate::CreateUObject(\n                                                       this, &amp;ThisClass::OnUpdateSessionComplete)),\n                                               StartSessionCompleteDelegate(\n                                                   FOnStartSessionCompleteDelegate::CreateUObject(\n                                                       this, &amp;ThisClass::OnStartSessionComplete)),\n                                               DestroySessionCompleteDelegate(\n                                                   FOnDestroySessionCompleteDelegate::CreateUObject(\n                                                       this, &amp;ThisClass::OnDestroySessionComplete)),\n                                               FindSessionsCompleteDelegate(\n                                                   FOnFindSessionsCompleteDelegate::CreateUObject(\n                                                       this, &amp;ThisClass::OnFindSessionsComplete)),\n                                               JoinSessionCompleteDelegate(\n                                                   FOnJoinSessionCompleteDelegate::CreateUObject(\n                                                       this, &amp;ThisClass::OnJoinSessionComplete)),\n                                               SessionUserInviteAcceptedDelegate(\n                                                   FOnSessionUserInviteAcceptedDelegate::CreateUObject(\n                                                       this, &amp;ThisClass::OnSessionInviteAccepted)\n                                               )\n{\n    const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());\n    if (!SessionInterface.IsValid()) return;\n\n    SessionUserInviteAcceptedDelegateHandle = SessionInterface-&gt;AddOnSessionUserInviteAcceptedDelegate_Handle(SessionUserInviteAcceptedDelegate);\n}\n\nvoid UNSESessionSubsystem::Login()\n{\n    IOnlineSubsystem* Subsystem = Online::GetSubsystem(GetWorld());\n    IOnlineIdentityPtr Identity = Subsystem-&gt;GetIdentityInterface(); // This is the generic OSS interface that will access the EOS OSS.\n\n    // If you're logged in, don't try to login again.\n    // This can happen if your player travels to a dedicated server or different maps as BeginPlay() will be called each time.\n\n    FUniqueNetIdPtr NetId = Identity-&gt;GetUniquePlayerId(0);\n\n    if (NetId != nullptr &amp;&amp; Identity-&gt;GetLoginStatus(0) == ELoginStatus::LoggedIn)\n    {\n        return; \n    }\n\n    LoginDelegateHandle = Identity-&gt;AddOnLoginCompleteDelegate_Handle(\n        0,\n        FOnLoginCompleteDelegate::CreateUObject(\n            this,\n            &amp;ThisClass::OnLoginCompleted));\n\n    FString AuthType; \n    FParse::Value(FCommandLine::Get(), TEXT(\"AUTH_TYPE=\"), AuthType);\n\n    if (!AuthType.IsEmpty()) //If parameter is NOT empty we can autologin.\n    {\n        /* \n        In most situations you will want to automatically log a player in using the parameters passed via CLI.\n        For example, using the exchange code for the Epic Games Store.\n        */\n        UE_LOG(LogTemp, Log, TEXT(\"Logging into EOS...\")); // Log to the UE logs that we are trying to log in. \n\n        if (!Identity-&gt;AutoLogin(0))\n        {\n            UE_LOG(LogTemp, Warning, TEXT(\"Failed to login... \")); // Log to the UE logs that we are trying to log in.\n            // Clear our handle and reset the delegate.\n            Identity-&gt;ClearOnLoginCompleteDelegate_Handle(0, LoginDelegateHandle);\n            LoginDelegateHandle.Reset();            \n        }\n    }\n    else\n    {\n        /* \n        Fallback if the CLI parameters are empty.Useful for PIE.\n        The type here could be developer if using the DevAuthTool, ExchangeCode if the game is launched via the Epic Games Launcher, etc...\n        */\n        FOnlineAccountCredentials Credentials(\"accountportal\",\"\", \"SteamAppTicket\");\n\n        UE_LOG(LogTemp, Log, TEXT(\"Logging into EOS...\")); // Log to the UE logs that we are trying to log in. \n\n        if (!Identity-&gt;Login(0, Credentials))\n        {\n            UE_LOG(LogTemp, Warning, TEXT(\"Failed to login... \")); // Log to the UE logs that we are trying to log in.\n            // Clear our handle and reset the delegate. \n            Identity-&gt;ClearOnLoginCompleteDelegate_Handle(0, LoginDelegateHandle);\n            LoginDelegateHandle.Reset();\n        }        \n    }\n}\n\nbool UNSESessionSubsystem::IsLoggedIn() const\n{\n    IOnlineSubsystem* Subsystem = Online::GetSubsystem(GetWorld());\n    IOnlineIdentityPtr Identity = Subsystem-&gt;GetIdentityInterface(); // This is the generic OSS interface that will access the EOS OSS.\n\n    FUniqueNetIdPtr NetId = Identity-&gt;GetUniquePlayerId(0);\n\n    if (NetId != nullptr &amp;&amp; Identity-&gt;GetLoginStatus(0) == ELoginStatus::LoggedIn)\n    {\n        return true; \n    }\n\n    return false;\n}\n\nvoid UNSESessionSubsystem::CreateSession(int32 NumPublicConnections, bool bIsLANMatch)\n{\n    const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());\n    if (!SessionInterface.IsValid())\n    {\n        OnCreateSessionCompleteDelegate.Broadcast(false);\n        return;\n    }\n\n    LastSessionSettings = MakeShareable(new FOnlineSessionSettings());\n    LastSessionSettings-&gt;NumPrivateConnections = 0;\n    LastSessionSettings-&gt;NumPublicConnections = NumPublicConnections;\n    LastSessionSettings-&gt;bAllowInvites = true;\n    LastSessionSettings-&gt;bAllowJoinInProgress = true;\n    LastSessionSettings-&gt;bAllowJoinViaPresence = true;\n    LastSessionSettings-&gt;bAllowJoinViaPresenceFriendsOnly = false;\n    LastSessionSettings-&gt;bIsDedicated = false;\n    LastSessionSettings-&gt;bUsesPresence = true;\n    LastSessionSettings-&gt;bUseLobbiesIfAvailable = true;\n    LastSessionSettings-&gt;bIsLANMatch = bIsLANMatch;\n    LastSessionSettings-&gt;bShouldAdvertise = true;\n\n    LastSessionSettings-&gt;Set(SEARCH_LOBBIES, true, EOnlineDataAdvertisementType::ViaOnlineServiceAndPing);\n\n    CreateSessionCompleteDelegateHandle = SessionInterface-&gt;AddOnCreateSessionCompleteDelegate_Handle(\n        CreateSessionCompleteDelegate);\n\n    if (!SessionInterface-&gt;CreateSession(0, NAME_GameSession, *LastSessionSettings))\n    {\n        SessionInterface-&gt;ClearOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegateHandle);\n\n        OnCreateSessionCompleteDelegate.Broadcast(false);\n    }\n}\n\nvoid UNSESessionSubsystem::UpdateSession()\n{\n    const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());\n    if (!SessionInterface.IsValid())\n    {\n        OnUpdateSessionCompleteEvent.Broadcast(false);\n        return;\n    }\n\n    const TSharedPtr&lt;FOnlineSessionSettings&gt; UpdatedSessionSettings = MakeShareable(\n        new FOnlineSessionSettings(*LastSessionSettings));\n\n    UpdateSessionCompleteDelegateHandle =\n        SessionInterface-&gt;AddOnUpdateSessionCompleteDelegate_Handle(UpdateSessionCompleteDelegate);\n\n    if (!SessionInterface-&gt;UpdateSession(NAME_GameSession, *UpdatedSessionSettings))\n    {\n        SessionInterface-&gt;ClearOnUpdateSessionCompleteDelegate_Handle(UpdateSessionCompleteDelegateHandle);\n\n        OnUpdateSessionCompleteEvent.Broadcast(false);\n    }\n    else\n    {\n        LastSessionSettings = UpdatedSessionSettings;\n    }\n}\n\nvoid UNSESessionSubsystem::StartSession()\n{\n    const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());\n    if (!SessionInterface.IsValid())\n    {\n        OnStartSessionCompleteEvent.Broadcast(false);\n        return;\n    }\n\n    StartSessionCompleteDelegateHandle =\n        SessionInterface-&gt;AddOnStartSessionCompleteDelegate_Handle(StartSessionCompleteDelegate);\n\n    if (!SessionInterface-&gt;StartSession(NAME_GameSession))\n    {\n        SessionInterface-&gt;ClearOnStartSessionCompleteDelegate_Handle(StartSessionCompleteDelegateHandle);\n\n        OnStartSessionCompleteEvent.Broadcast(false);\n    }\n}\n\nvoid UNSESessionSubsystem::DestroySession()\n{\n    const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());\n    if (!SessionInterface.IsValid())\n    {\n        OnDestroySessionCompleteEvent.Broadcast(false);\n        return;\n    }\n\n    DestroySessionCompleteDelegateHandle =\n        SessionInterface-&gt;AddOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegate);\n\n    if (!SessionInterface-&gt;DestroySession(NAME_GameSession))\n    {\n        SessionInterface-&gt;ClearOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegateHandle);\n\n        OnDestroySessionCompleteEvent.Broadcast(false);\n    }\n}\n\nvoid UNSESessionSubsystem::FindSessions(int32 MaxSearchResults, bool IsLANQuery)\n{\n    const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());\n    if (!SessionInterface.IsValid())\n    {\n        OnFindSessionsCompleteEvent.Broadcast(TArray&lt;FNSESessionInfo&gt;(), false);\n        return;\n    }\n\n    FindSessionsCompleteDelegateHandle =\n        SessionInterface-&gt;AddOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegate);\n\n    LastSessionSearch = MakeShareable(new FOnlineSessionSearch());\n    LastSessionSearch-&gt;MaxSearchResults = MaxSearchResults;\n    LastSessionSearch-&gt;bIsLanQuery = IsLANQuery;\n\n    LastSessionSearch-&gt;QuerySettings.Set(SEARCH_LOBBIES, true, EOnlineComparisonOp::Equals);\n\n    if (!SessionInterface-&gt;FindSessions(0, LastSessionSearch.ToSharedRef()))\n    {\n        SessionInterface-&gt;ClearOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegateHandle);\n\n        OnFindSessionsCompleteEvent.Broadcast(TArray&lt;FNSESessionInfo&gt;(), false);\n    }\n}\n\nvoid UNSESessionSubsystem::JoinGameSession_BP(FNSESessionInfo Info)\n{\n    JoinGameSession(Info.SessionSearchResult);\n}\n\nvoid UNSESessionSubsystem::JoinGameSession(const FOnlineSessionSearchResult&amp; SessionResult)\n{\n    const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());\n    if (!SessionInterface.IsValid())\n    {\n        OnJoinGameSessionCompleteEvent.Broadcast(EOnJoinSessionCompleteResult::UnknownError);\n        return;\n    }\n\n    JoinSessionCompleteDelegateHandle =\n        SessionInterface-&gt;AddOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegate);\n\n    auto ModResult = SessionResult;\n\n    ModResult.Session.SessionSettings.bUsesPresence = true;\n    ModResult.Session.SessionSettings.bUseLobbiesIfAvailable = true;\n    if (!SessionInterface-&gt;JoinSession(0, NAME_GameSession, ModResult))\n    {\n        SessionInterface-&gt;ClearOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegateHandle);\n\n        OnJoinGameSessionCompleteEvent.Broadcast(EOnJoinSessionCompleteResult::UnknownError);\n    }\n}\n\nvoid UNSESessionSubsystem::OnLoginCompleted(int32 LocalUserNum, bool bWasSuccessful, const FUniqueNetId&amp; UserId,\n    const FString&amp; Error)\n{\n    IOnlineSubsystem* Subsystem = Online::GetSubsystem(GetWorld());\n    IOnlineIdentityPtr Identity = Subsystem-&gt;GetIdentityInterface();\n    if (bWasSuccessful)\n    {\n        UE_LOG(LogTemp, Log, TEXT(\"Login callback completed!\"));; \n    }\n    else //Login failed\n    {\n        // TODO: set login failed message\n        UE_LOGFMT(LogTemp, Error, \"EOS login failed. Error: {0}\", Error); //Print sign in failure in logs as an error\n    }\n\n    Identity-&gt;ClearOnLoginCompleteDelegate_Handle(LocalUserNum, LoginDelegateHandle);\n    LoginDelegateHandle.Reset();\n}\n\nvoid UNSESessionSubsystem::OnCreateSessionComplete(FName SessionName, bool bSuccess)\n{\n    if (const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld()))\n    {\n        SessionInterface-&gt;ClearOnCreateSessionCompleteDelegate_Handle(CreateSessionCompleteDelegateHandle);\n    }\n\n    OnCreateSessionCompleteDelegate.Broadcast(bSuccess);\n}\n\nvoid UNSESessionSubsystem::OnUpdateSessionComplete(FName SessionName, bool bSuccess)\n{\n    if (const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld()))\n    {\n        SessionInterface-&gt;ClearOnUpdateSessionCompleteDelegate_Handle(UpdateSessionCompleteDelegateHandle);\n    }\n\n    OnUpdateSessionCompleteEvent.Broadcast(bSuccess);\n}\n\nvoid UNSESessionSubsystem::OnStartSessionComplete(FName SessionName, bool bSuccess)\n{\n    if (const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld()))\n    {\n        SessionInterface-&gt;ClearOnStartSessionCompleteDelegate_Handle(StartSessionCompleteDelegateHandle);\n    }\n\n    OnStartSessionCompleteEvent.Broadcast(bSuccess);\n}\n\nvoid UNSESessionSubsystem::OnDestroySessionComplete(FName SessionName, bool bSuccess)\n{\n    if (const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld()))\n    {\n        SessionInterface-&gt;ClearOnDestroySessionCompleteDelegate_Handle(DestroySessionCompleteDelegateHandle);\n    }\n\n    OnDestroySessionCompleteEvent.Broadcast(bSuccess);\n}\n\nvoid UNSESessionSubsystem::OnFindSessionsComplete(bool bSuccess)\n{\n    if (const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld()))\n    {\n        SessionInterface-&gt;ClearOnFindSessionsCompleteDelegate_Handle(FindSessionsCompleteDelegateHandle);\n    }\n\n    if (LastSessionSearch-&gt;SearchResults.Num() &lt;= 0)\n    {\n        OnFindSessionsCompleteEvent.Broadcast(TArray&lt;FNSESessionInfo&gt;(), bSuccess);\n        return;\n    }\n\n    TArray&lt;FNSESessionInfo&gt; Sessions{};\n    for (auto SearchResult : LastSessionSearch-&gt;SearchResults)\n    {\n        Sessions.Add(FNSESessionInfo(\n            SearchResult, SearchResult.Session.OwningUserName, SearchResult.Session.NumOpenPrivateConnections,\n            SearchResult.Session.NumOpenPublicConnections\n        ));\n    }\n\n    OnFindSessionsCompleteEvent.Broadcast(Sessions, bSuccess);\n}\n\nvoid UNSESessionSubsystem::OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result)\n{\n    if (const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld()))\n    {\n        SessionInterface-&gt;ClearOnJoinSessionCompleteDelegate_Handle(JoinSessionCompleteDelegateHandle);\n    }\n\n    OnJoinGameSessionCompleteEvent.Broadcast(Result);\n\n    TryTravelToCurrentSession();\n}\n\nvoid UNSESessionSubsystem::OnSessionInviteAccepted(const bool bSuccess, const int32 ControllerId,\n                                                   FUniqueNetIdPtr UserId,\n                                                   const FOnlineSessionSearchResult&amp; InviteResult)\n{\n    const auto GameInstance = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance());\n    if (!IsValid(GameInstance))\n    {\n        UE_LOG(LogTemp, Error, TEXT(\"OnSessionInviteAccepted: Invalid GameInstance\"));\n        return;\n    }\n    if (GameInstance-&gt;BattleData.PlayerListP2.IsEmpty()) return;\n\n    JoinGameSession(InviteResult);\n}\n\nbool UNSESessionSubsystem::TryTravelToCurrentSession()\n{\n    const IOnlineSessionPtr SessionInterface = Online::GetSessionInterface(GetWorld());\n    if (!SessionInterface.IsValid())\n    {\n        return false;\n    }\n\n    FString ConnectString;\n    if (!SessionInterface-&gt;GetResolvedConnectString(NAME_GameSession, ConnectString))\n    {\n        return false;\n    }\n\n    APlayerController* PlayerController = GetWorld()-&gt;GetFirstPlayerController();\n    PlayerController-&gt;ClientTravel(ConnectString, TRAVEL_Absolute);\n    return true;\n}\n</code></pre>"},{"location":"NightSkyEngine/_n_s_e_session_subsystem_8h/","title":"File NSESessionSubsystem.h","text":"<p>FileList &gt; Network &gt; NSESessionSubsystem.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"OnlineSessionSettings.h\"</code></li> <li><code>#include \"Subsystems/GameInstanceSubsystem.h\"</code></li> <li><code>#include \"Interfaces/OnlineSessionInterface.h\"</code></li> <li><code>#include \"NSESessionSubsystem.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_n_s_e_session_subsystem_8h/#classes","title":"Classes","text":"Type Name struct FNSESessionInfo class UNSESessionSubsystem"},{"location":"NightSkyEngine/_n_s_e_session_subsystem_8h/#public-functions","title":"Public Functions","text":"Type Name DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam (FNSEOnCreateSessionComplete, bool, bSuccess)  DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam (FNSEOnUpdateSessionComplete, bool, bSuccess)  DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam (FNSEOnStartSessionComplete, bool, bSuccess)  DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam (FNSEOnDestroySessionComplete, bool, bSuccess)  DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams (FNSEOnFindSessionsComplete, const TArray&lt; FNSESessionInfo &gt; &amp;, SessionResults, bool, bSuccess)  DECLARE_MULTICAST_DELEGATE_OneParam (FNSEOnJoinSessionComplete, EOnJoinSessionCompleteResult::Type Result)"},{"location":"NightSkyEngine/_n_s_e_session_subsystem_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_n_s_e_session_subsystem_8h/#function-declare_dynamic_multicast_delegate_oneparam","title":"function DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam","text":"<pre><code>DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam (\n    FNSEOnCreateSessionComplete,\n    bool,\n    bSuccess\n) \n</code></pre>"},{"location":"NightSkyEngine/_n_s_e_session_subsystem_8h/#function-declare_dynamic_multicast_delegate_oneparam_1","title":"function DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam","text":"<pre><code>DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam (\n    FNSEOnUpdateSessionComplete,\n    bool,\n    bSuccess\n) \n</code></pre>"},{"location":"NightSkyEngine/_n_s_e_session_subsystem_8h/#function-declare_dynamic_multicast_delegate_oneparam_2","title":"function DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam","text":"<pre><code>DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam (\n    FNSEOnStartSessionComplete,\n    bool,\n    bSuccess\n) \n</code></pre>"},{"location":"NightSkyEngine/_n_s_e_session_subsystem_8h/#function-declare_dynamic_multicast_delegate_oneparam_3","title":"function DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam","text":"<pre><code>DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam (\n    FNSEOnDestroySessionComplete,\n    bool,\n    bSuccess\n) \n</code></pre>"},{"location":"NightSkyEngine/_n_s_e_session_subsystem_8h/#function-declare_dynamic_multicast_delegate_twoparams","title":"function DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams","text":"<pre><code>DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams (\n    FNSEOnFindSessionsComplete,\n    const TArray&lt; FNSESessionInfo &gt; &amp;,\n    SessionResults,\n    bool,\n    bSuccess\n) \n</code></pre>"},{"location":"NightSkyEngine/_n_s_e_session_subsystem_8h/#function-declare_multicast_delegate_oneparam","title":"function DECLARE_MULTICAST_DELEGATE_OneParam","text":"<pre><code>DECLARE_MULTICAST_DELEGATE_OneParam (\n    FNSEOnJoinSessionComplete,\n    EOnJoinSessionCompleteResult::Type Result\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Network/NSESessionSubsystem.h</code></p>"},{"location":"NightSkyEngine/_n_s_e_session_subsystem_8h_source/","title":"File NSESessionSubsystem.h","text":"<p>File List &gt; Network &gt; NSESessionSubsystem.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"OnlineSessionSettings.h\"\n#include \"Subsystems/GameInstanceSubsystem.h\"\n#include \"Interfaces/OnlineSessionInterface.h\"\n#include \"NSESessionSubsystem.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FNSESessionInfo\n{\n    GENERATED_BODY()\n\n    FNSESessionInfo() = default;\n    FNSESessionInfo(const FOnlineSessionSearchResult&amp; Result, const FString&amp; Name, int32 OpenPrivate, int32 OpenPublic);\n\n    FOnlineSessionSearchResult SessionSearchResult{};\n    UPROPERTY(BlueprintReadOnly)\n    FString OwningUserName;\n    UPROPERTY(BlueprintReadOnly)\n    int32 NumOpenPrivateConnections;\n    UPROPERTY(BlueprintReadOnly)\n    int32 NumOpenPublicConnections;\n};\n\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FNSEOnCreateSessionComplete, bool, bSuccess);\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FNSEOnUpdateSessionComplete, bool, bSuccess);\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FNSEOnStartSessionComplete, bool, bSuccess);\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FNSEOnDestroySessionComplete, bool, bSuccess);\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FNSEOnFindSessionsComplete, const TArray&lt;FNSESessionInfo&gt;&amp;, SessionResults, bool, bSuccess);\nDECLARE_MULTICAST_DELEGATE_OneParam(FNSEOnJoinSessionComplete, EOnJoinSessionCompleteResult::Type Result);\n\nUCLASS()\nclass NIGHTSKYENGINE_API UNSESessionSubsystem : public UGameInstanceSubsystem\n{\n    GENERATED_BODY()\n\npublic:\n    UNSESessionSubsystem();\n\n    UFUNCTION(BlueprintCallable)\n    void Login();\n    FDelegateHandle LoginDelegateHandle;\n\n    UFUNCTION(BlueprintPure)\n    bool IsLoggedIn() const;\n\n    UFUNCTION(BlueprintCallable)\n    void CreateSession(int32 NumPublicConnections, bool bIsLANMatch);\n    FNSEOnCreateSessionComplete OnCreateSessionCompleteDelegate;\n\n    UFUNCTION(BlueprintCallable)\n    void UpdateSession();\n    FNSEOnUpdateSessionComplete OnUpdateSessionCompleteEvent;\n\n    UFUNCTION(BlueprintCallable)\n    void StartSession();\n    FNSEOnStartSessionComplete OnStartSessionCompleteEvent;\n\n    UFUNCTION(BlueprintCallable)\n    void DestroySession();\n    FNSEOnDestroySessionComplete OnDestroySessionCompleteEvent;\n\n    UFUNCTION(BlueprintCallable)\n    void FindSessions(int32 MaxSearchResults, bool IsLANQuery);\n    UPROPERTY(BlueprintAssignable)\n    FNSEOnFindSessionsComplete OnFindSessionsCompleteEvent;\n\n    UFUNCTION(BlueprintCallable)\n    void JoinGameSession_BP(FNSESessionInfo Info);\n\n    void JoinGameSession(const FOnlineSessionSearchResult&amp; SessionResult);\n    FNSEOnJoinSessionComplete OnJoinGameSessionCompleteEvent;\n\nprotected:\n    void OnLoginCompleted(int32 LocalUserNum, bool bWasSuccessful, const FUniqueNetId&amp; UserId, const FString&amp; Error);\n    void OnCreateSessionComplete(FName SessionName, bool bSuccess);\n    void OnUpdateSessionComplete(FName SessionName, bool bSuccess);\n    void OnStartSessionComplete(FName SessionName, bool bSuccess);\n    void OnDestroySessionComplete(FName SessionName, bool bSuccess);\n    void OnFindSessionsComplete(bool bSuccess);\n    void OnJoinSessionComplete(FName SessionName, EOnJoinSessionCompleteResult::Type Result);\n    void OnSessionInviteAccepted(const bool bSuccess, const int32 ControllerId, FUniqueNetIdPtr UserId, const FOnlineSessionSearchResult&amp; InviteResult);\n    bool TryTravelToCurrentSession();\n\nprivate:\n    FOnCreateSessionCompleteDelegate CreateSessionCompleteDelegate;\n    FDelegateHandle CreateSessionCompleteDelegateHandle;;\n\n    FOnUpdateSessionCompleteDelegate UpdateSessionCompleteDelegate;\n    FDelegateHandle UpdateSessionCompleteDelegateHandle;\n\n    FOnStartSessionCompleteDelegate StartSessionCompleteDelegate;\n    FDelegateHandle StartSessionCompleteDelegateHandle;\n\n    FOnDestroySessionCompleteDelegate DestroySessionCompleteDelegate;\n    FDelegateHandle DestroySessionCompleteDelegateHandle;\n\n    FOnFindSessionsCompleteDelegate FindSessionsCompleteDelegate;\n    FDelegateHandle FindSessionsCompleteDelegateHandle;\n    TSharedPtr&lt;FOnlineSessionSearch&gt; LastSessionSearch;\n\n    FOnJoinSessionCompleteDelegate JoinSessionCompleteDelegate;\n    FDelegateHandle JoinSessionCompleteDelegateHandle;\n\n    FOnSessionUserInviteAcceptedDelegate SessionUserInviteAcceptedDelegate;\n    FDelegateHandle SessionUserInviteAcceptedDelegateHandle;\n\n    TSharedPtr&lt;FOnlineSessionSettings&gt; LastSessionSettings;\n};\n</code></pre>"},{"location":"NightSkyEngine/_network_pawn_8cpp/","title":"File NetworkPawn.cpp","text":"<p>FileList &gt; Network &gt; NetworkPawn.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NetworkPawn.h\"</code></li> <li><code>#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"</code></li> <li><code>#include \"RpcConnectionManager.h\"</code></li> <li><code>#include \"Engine/AssetManager.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/NightSkyGameState.h\"</code></li> <li><code>#include \"Net/UnrealNetwork.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/NightSkyPlayerController.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/FighterRunners/FighterMultiplayerRunner.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/PrimaryCharaData.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Network/NetworkPawn.cpp</code></p>"},{"location":"NightSkyEngine/_network_pawn_8cpp_source/","title":"File NetworkPawn.cpp","text":"<p>File List &gt; Network &gt; NetworkPawn.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NetworkPawn.h\"\n\n#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"\n#include \"RpcConnectionManager.h\"\n#include \"Engine/AssetManager.h\"\n#include \"NightSkyEngine/Battle/NightSkyGameState.h\"\n#include \"Net/UnrealNetwork.h\"\n#include \"NightSkyEngine/Battle/NightSkyPlayerController.h\"\n#include \"NightSkyEngine/Battle/FighterRunners/FighterMultiplayerRunner.h\"\n#include \"NightSkyEngine/Data/PrimaryCharaData.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NetworkPawn)\n\n// Sets default values\nANetworkPawn::ANetworkPawn()\n{\n    // Set this pawn to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n    bReplicates = true;\n}\n\n// Called when the game starts or when spawned\nvoid ANetworkPawn::BeginPlay()\n{\n    Super::BeginPlay();\n}\n\nvoid ANetworkPawn::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const\n{\n    Super::GetLifetimeReplicatedProps(OutLifetimeProps);\n\n    DOREPLIFETIME(ANetworkPawn, CharaDataReceived)\n    DOREPLIFETIME(ANetworkPawn, bRematchAccepted)\n}\n\nvoid ANetworkPawn::ServerGetCharaData(TArray&lt;FPrimaryAssetId&gt; Assets)\n{\n    auto NetworkPawn = Cast&lt;ANightSkyPlayerController&gt;(GetWorld()-&gt;GetFirstPlayerController())-&gt;NetworkPawn;\n    if (NetworkPawn-&gt;CharaDataReceived) return;\n\n    UNightSkyGameInstance* GameInstance = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance());\n\n    GameInstance-&gt;BattleData.PlayerListP2.Empty();\n    for (const auto CharaData : Assets)\n    {\n        GameInstance-&gt;BattleData.PlayerListP2.Add(Cast&lt;UPrimaryCharaData&gt;(UAssetManager::Get().GetPrimaryAssetObject(CharaData)));\n    }\n\n    NetworkPawn-&gt;CharaDataReceived = true;\n}\n\nvoid ANetworkPawn::ClientGetCharaData(TArray&lt;FPrimaryAssetId&gt; Assets)\n{\n    if (CharaDataReceived) return;\n\n    UNightSkyGameInstance* GameInstance = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance());\n\n    GameInstance-&gt;BattleData.PlayerListP1.Empty();\n    for (const auto CharaData : Assets)\n    {\n        GameInstance-&gt;BattleData.PlayerListP1.Add(Cast&lt;UPrimaryCharaData&gt;(UAssetManager::Get().GetPrimaryAssetObject(CharaData)));\n    }\n}\n\nvoid ANetworkPawn::SendRematchToServer_Implementation()\n{\n    Cast&lt;ANightSkyPlayerController&gt;(GetWorld()-&gt;GetFirstPlayerController())-&gt;NetworkPawn-&gt;bRematchAccepted = true;\n}\n\nvoid ANetworkPawn::ServerGetFinishedLoading_Implementation(bool Finished)\n{\n    const UNightSkyGameInstance* GameInstance = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance());\n    if (Finished == true &amp;&amp; Finished == GameInstance-&gt;FinishedLoadingForNetworkBattle)\n        GameInstance-&gt;TravelToBattleMap();\n}\n\nvoid ANetworkPawn::SendGgpoToClient_Implementation(const TArray&lt;int8&gt; &amp;GgpoMessage)\n{\n     if(FighterMultiplayerRunner)\n        FighterMultiplayerRunner-&gt;connectionManager-&gt;receiveSchedule.AddTail(GgpoMessage);\n}\n\nvoid ANetworkPawn::SendGgpoToServer_Implementation(const TArray&lt;int8&gt; &amp;GgpoMessage)\n{\n     if(FighterMultiplayerRunner)\n        FighterMultiplayerRunner-&gt;connectionManager-&gt;receiveSchedule.AddTail(GgpoMessage);\n}\n\nvoid ANetworkPawn::ClientGetBattleData_Implementation(FBattleData InBattleData, FNetworkMirror Mirror)\n{\n    UNightSkyGameInstance* GameInstance = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance());\n    UAssetManager::Get().LoadPrimaryAssets(Mirror.PlayerList, TArray&lt;FName&gt;(), FStreamableDelegate::CreateUObject(this, &amp;ANetworkPawn::ClientGetCharaData, Mirror.PlayerList));\n    GameInstance-&gt;BattleData.ColorIndicesP1 = InBattleData.ColorIndicesP1;\n    GameInstance-&gt;BattleData.BattleFormat = InBattleData.BattleFormat;\n    GameInstance-&gt;BattleData.RoundCount = InBattleData.RoundCount;\n    GameInstance-&gt;BattleData.StartRoundTimer = InBattleData.StartRoundTimer;\n    GameInstance-&gt;BattleData.Random = InBattleData.Random;\n    GameInstance-&gt;BattleData.Stage = InBattleData.Stage;\n    GameInstance-&gt;BattleData.MusicName = InBattleData.MusicName;\n}\n\nvoid ANetworkPawn::ServerGetBattleData_Implementation(FBattleData InBattleData, FNetworkMirror Mirror)\n{\n    UNightSkyGameInstance* GameInstance = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance());\n    UAssetManager::Get().LoadPrimaryAssets(Mirror.PlayerList, TArray&lt;FName&gt;(), FStreamableDelegate::CreateUObject(this, &amp;ANetworkPawn::ServerGetCharaData, Mirror.PlayerList));\n    GameInstance-&gt;BattleData.ColorIndicesP2 = InBattleData.ColorIndicesP2;\n}\n\nvoid ANetworkPawn::ServerChecksumCheck_Implementation(uint32 Checksum, int32 InFrame)\n{\n    if (ANightSkyGameState* GameState = Cast&lt;ANightSkyGameState&gt;(GetWorld()-&gt;GetGameState()))\n    {\n        if (GameState != nullptr)\n        {\n            GameState-&gt;SetOtherChecksum(Checksum, InFrame);\n        }\n    }\n}\n\nvoid ANetworkPawn::ClientChecksumCheck_Implementation(uint32 Checksum, int32 InFrame)\n{\n    if (ANightSkyGameState* GameState = Cast&lt;ANightSkyGameState&gt;(GetWorld()-&gt;GetGameState()))\n    {\n        if (GameState != nullptr)\n        {\n            GameState-&gt;SetOtherChecksum(Checksum, InFrame);\n        }\n    }\n}\n</code></pre>"},{"location":"NightSkyEngine/_network_pawn_8h/","title":"File NetworkPawn.h","text":"<p>FileList &gt; Network &gt; NetworkPawn.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameFramework/Pawn.h\"</code></li> <li><code>#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"</code></li> <li><code>#include \"NetworkPawn.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_network_pawn_8h/#classes","title":"Classes","text":"Type Name class ANetworkPawn struct FNetworkMirror <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Network/NetworkPawn.h</code></p>"},{"location":"NightSkyEngine/_network_pawn_8h_source/","title":"File NetworkPawn.h","text":"<p>File List &gt; Network &gt; NetworkPawn.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Pawn.h\"\n#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"\n#include \"NetworkPawn.generated.h\"\n\nclass APlayerObject;\n\nUSTRUCT()\nstruct FNetworkMirror\n{\n    GENERATED_BODY()\n\n    UPROPERTY()\n    TArray&lt;FPrimaryAssetId&gt; PlayerList;\n    UPROPERTY()\n    FPrimaryAssetId Stage;\n};\n\nUCLASS()\nclass NIGHTSKYENGINE_API ANetworkPawn : public APawn\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this pawn's properties\n    ANetworkPawn();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    virtual void GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const override;\n\n    UPROPERTY(BlueprintReadOnly, Replicated)\n    bool CharaDataReceived = false;\n    UPROPERTY(BlueprintReadOnly, Replicated)\n    bool bRematchAccepted = false;\n\n    UFUNCTION( Server, Reliable )\n    void ServerChecksumCheck(uint32 Checksum, int32 InFrame);\n    UFUNCTION( Client, Reliable )\n    void ClientChecksumCheck(uint32 Checksum, int32 InFrame);\n    UFUNCTION( Server, Reliable )\n    void ServerGetBattleData(FBattleData InBattleData, FNetworkMirror Mirror);\n    UFUNCTION( Client, Reliable )\n    void ClientGetBattleData(FBattleData InBattleData, FNetworkMirror Mirror);\n    UFUNCTION( Server, Reliable )\n    void ServerGetFinishedLoading(bool Finished);\n\n    void ServerGetCharaData(TArray&lt;FPrimaryAssetId&gt; Assets);\n    void ClientGetCharaData(TArray&lt;FPrimaryAssetId&gt; Assets);\n\n    UPROPERTY()\n    class AFighterMultiplayerRunner* FighterMultiplayerRunner = nullptr;\n\n    UFUNCTION( Server, Reliable )\n    void SendGgpoToServer(const TArray&lt;int8&gt; &amp;GgpoMessage);\n    UFUNCTION( Client, Reliable )\n    void SendGgpoToClient(const TArray&lt;int8&gt; &amp;GgpoMessage);\n\n    UFUNCTION( Server, Reliable )\n    void SendRematchToServer();\n};\n</code></pre>"},{"location":"NightSkyEngine/_rpc_connection_manager_8cpp/","title":"File RpcConnectionManager.cpp","text":"<p>FileList &gt; Network &gt; RpcConnectionManager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"RpcConnectionManager.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Network/RpcConnectionManager.cpp</code></p>"},{"location":"NightSkyEngine/_rpc_connection_manager_8cpp_source/","title":"File RpcConnectionManager.cpp","text":"<p>File List &gt; Network &gt; RpcConnectionManager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"RpcConnectionManager.h\"\n\n\nRpcConnectionManager::RpcConnectionManager()\n{\n    playerIndex = 0;\n}\n\nRpcConnectionManager::~RpcConnectionManager()\n{\n}\n\nint RpcConnectionManager::SendTo(const char* buffer, int len, int flags, int connection_id)\n{\n    const TArray scheduledMessage((int8*)buffer,len);\n    sendSchedule.AddTail(scheduledMessage);\n\n    return 0;\n}\n\nint RpcConnectionManager::RecvFrom(char* buffer, int len, int flags, int* connection_id)\n{\n    if (receiveSchedule.Num() == 0)\n        return -1;\n    auto msg = receiveSchedule.GetTail();\n\n    auto msgVal = msg-&gt;GetValue();\n    auto rec = (char*)msgVal.GetData();\n    auto leng = msgVal.Num(); // int* to char* size\n    if (leng == 0)\n        return -1;\n    memcpy(buffer, rec, leng);\n    receiveSchedule.Empty();\n    *connection_id = playerIndex;\n    return leng;\n}\n</code></pre>"},{"location":"NightSkyEngine/_rpc_connection_manager_8h/","title":"File RpcConnectionManager.h","text":"<p>FileList &gt; Network &gt; RpcConnectionManager.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"include/connection_manager.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_rpc_connection_manager_8h/#classes","title":"Classes","text":"Type Name class RpcConnectionManager <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/Network/RpcConnectionManager.h</code></p>"},{"location":"NightSkyEngine/_rpc_connection_manager_8h_source/","title":"File RpcConnectionManager.h","text":"<p>File List &gt; Network &gt; RpcConnectionManager.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"include/connection_manager.h\"\n\nclass NIGHTSKYENGINE_API RpcConnectionManager: public ConnectionManager\n{\npublic:\n    RpcConnectionManager();\n    virtual ~RpcConnectionManager() override;\n\n    virtual int SendTo(const char* buffer, int len, int flags, int connection_id);\n    virtual int RecvFrom(char* buffer, int len, int flags, int* connection_id);\n\n    int playerIndex;\n    TDoubleLinkedList&lt;TArray&lt;int8&gt;&gt; sendSchedule;\n    TDoubleLinkedList&lt;TArray&lt;int8&gt;&gt; receiveSchedule;\n};\n</code></pre>"},{"location":"NightSkyEngine/dir_a40c408bd590fbad9d640bb5832ac49f/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/UI","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; UI</p>"},{"location":"NightSkyEngine/dir_a40c408bd590fbad9d640bb5832ac49f/#files","title":"Files","text":"Type Name file ExtendedCommonActivatableWidget.cpp file ExtendedCommonActivatableWidget.h file NightSkyBattleHudActor.cpp file NightSkyBattleHudActor.h file NightSkyBattleWidget.cpp file NightSkyBattleWidget.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/UI/</code></p>"},{"location":"NightSkyEngine/_extended_common_activatable_widget_8cpp/","title":"File ExtendedCommonActivatableWidget.cpp","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; UI &gt; ExtendedCommonActivatableWidget.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ExtendedCommonActivatableWidget.h\"</code></li> <li><code>#include \"Editor/WidgetCompilerLog.h\"</code></li> <li><code>#include \"Input/CommonUIInputTypes.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_extended_common_activatable_widget_8cpp/#macros","title":"Macros","text":"Type Name define LOCTEXT_NAMESPACE <code>\"NightSkyEngine\"</code>"},{"location":"NightSkyEngine/_extended_common_activatable_widget_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"NightSkyEngine/_extended_common_activatable_widget_8cpp/#define-loctext_namespace","title":"define LOCTEXT_NAMESPACE","text":"<pre><code>#define LOCTEXT_NAMESPACE `\"NightSkyEngine\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/UI/ExtendedCommonActivatableWidget.cpp</code></p>"},{"location":"NightSkyEngine/_extended_common_activatable_widget_8cpp_source/","title":"File ExtendedCommonActivatableWidget.cpp","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; UI &gt; ExtendedCommonActivatableWidget.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"ExtendedCommonActivatableWidget.h\"\n\n#include \"Editor/WidgetCompilerLog.h\"\n#include \"Input/CommonUIInputTypes.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(ExtendedCommonActivatableWidget)\n\n#define LOCTEXT_NAMESPACE \"NightSkyEngine\"\n\nUExtendedCommonActivatableWidget::UExtendedCommonActivatableWidget(const FObjectInitializer&amp; ObjectInitializer)\n    : Super(ObjectInitializer)\n{\n}\n\nTOptional&lt;FUIInputConfig&gt; UExtendedCommonActivatableWidget::GetDesiredInputConfig() const\n{\n    const auto Result = Super::GetDesiredInputConfig();\n\n    if (Result.IsSet())\n    {\n        return Result;\n    }\n\n    switch (DefaultInputConfig)\n    {\n    case ENightSkyWidgetInputMode::GameAndMenu:\n        return FUIInputConfig(ECommonInputMode::All, GameMouseCaptureMode);\n    case ENightSkyWidgetInputMode::Game:\n        return FUIInputConfig(ECommonInputMode::Game, GameMouseCaptureMode);\n    case ENightSkyWidgetInputMode::Menu:\n        return FUIInputConfig(ECommonInputMode::Menu, EMouseCaptureMode::NoCapture);\n    case ENightSkyWidgetInputMode::Default:\n    default:\n        return TOptional&lt;FUIInputConfig&gt;();\n    }\n}\n\nvoid UExtendedCommonActivatableWidget::NativeDestruct()\n{\n    for (FUIActionBindingHandle Handle : BindingHandles)\n    {\n        if (Handle.IsValid())\n        {\n            Handle.Unregister();\n        }\n    }\n    BindingHandles.Empty();\n\n    Super::NativeDestruct();\n}\n\nvoid UExtendedCommonActivatableWidget::RegisterBinding(FDataTableRowHandle InputAction, const FInputActionExecutedDelegate&amp; Callback, FInputActionBindingHandle&amp; BindingHandle)\n{\n    FBindUIActionArgs BindArgs(InputAction, FSimpleDelegate::CreateLambda([InputAction, Callback]()\n    {\n        Callback.ExecuteIfBound(InputAction.RowName);\n    }));\n    BindArgs.bDisplayInActionBar = true;\n\n    BindingHandle.Handle = RegisterUIActionBinding(BindArgs);\n    BindingHandles.Add(BindingHandle.Handle);\n}\n\nvoid UExtendedCommonActivatableWidget::UnregisterBinding(FInputActionBindingHandle BindingHandle)\n{\n    if (BindingHandle.Handle.IsValid())\n    {\n        BindingHandle.Handle.Unregister();\n        BindingHandles.Remove(BindingHandle.Handle);\n    }\n}\n\nvoid UExtendedCommonActivatableWidget::UnregisterAllBindings()\n{\n    for (FUIActionBindingHandle Handle : BindingHandles)\n    {\n        Handle.Unregister();\n    }\n    BindingHandles.Empty();\n}\n\n#if WITH_EDITOR\n\nvoid UExtendedCommonActivatableWidget::ValidateCompiledWidgetTree(const UWidgetTree&amp; BlueprintWidgetTree, IWidgetCompilerLog&amp; CompileLog) const\n{\n    Super::ValidateCompiledWidgetTree(BlueprintWidgetTree, CompileLog);\n\n    if (!GetClass()-&gt;IsFunctionImplementedInScript(GET_FUNCTION_NAME_CHECKED(UExtendedCommonActivatableWidget, BP_GetDesiredFocusTarget)))\n    {\n        if (GetParentNativeClass(GetClass()) == UExtendedCommonActivatableWidget::StaticClass())\n        {\n            CompileLog.Warning(LOCTEXT(\"ValidateGetDesiredFocusTarget_Warning\", \"GetDesiredFocusTarget wasn't implemented, you're going to have trouble using gamepads on this screen.\"));\n        }\n        else\n        {\n            // We can't guarantee it isn't implemented in a native subclass of this one.\n            // Native subclasses should override ValidateCompiledWidgetTree, skipping this and invoking the base UUserWidget version\n            CompileLog.Note(LOCTEXT(\"ValidateGetDesiredFocusTarget_Note\", \"GetDesiredFocusTarget wasn't implemented in Blueprint, you will have issues with gamepads if a native subclass did not implement it.\"));\n        }\n    }\n}\n\n#endif\n\n#undef LOCTEXT_NAMESPACE\n</code></pre>"},{"location":"NightSkyEngine/_extended_common_activatable_widget_8h/","title":"File ExtendedCommonActivatableWidget.h","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; UI &gt; ExtendedCommonActivatableWidget.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"CommonActivatableWidget.h\"</code></li> <li><code>#include \"ExtendedCommonActivatableWidget.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_extended_common_activatable_widget_8h/#classes","title":"Classes","text":"Type Name struct FInputActionBindingHandle class UExtendedCommonActivatableWidget"},{"location":"NightSkyEngine/_extended_common_activatable_widget_8h/#public-types","title":"Public Types","text":"Type Name enum uint8 ENightSkyWidgetInputMode"},{"location":"NightSkyEngine/_extended_common_activatable_widget_8h/#public-functions","title":"Public Functions","text":"Type Name DECLARE_DYNAMIC_DELEGATE_OneParam (FInputActionExecutedDelegate, FName, ActionName)"},{"location":"NightSkyEngine/_extended_common_activatable_widget_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"NightSkyEngine/_extended_common_activatable_widget_8h/#enum-enightskywidgetinputmode","title":"enum ENightSkyWidgetInputMode","text":"<pre><code>enum ENightSkyWidgetInputMode {\n    Default,\n    GameAndMenu,\n    Game,\n    Menu\n};\n</code></pre>"},{"location":"NightSkyEngine/_extended_common_activatable_widget_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_extended_common_activatable_widget_8h/#function-declare_dynamic_delegate_oneparam","title":"function DECLARE_DYNAMIC_DELEGATE_OneParam","text":"<pre><code>DECLARE_DYNAMIC_DELEGATE_OneParam (\n    FInputActionExecutedDelegate,\n    FName,\n    ActionName\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/UI/ExtendedCommonActivatableWidget.h</code></p>"},{"location":"NightSkyEngine/_extended_common_activatable_widget_8h_source/","title":"File ExtendedCommonActivatableWidget.h","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; UI &gt; ExtendedCommonActivatableWidget.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"CommonActivatableWidget.h\"\n#include \"ExtendedCommonActivatableWidget.generated.h\"\n\nDECLARE_DYNAMIC_DELEGATE_OneParam(FInputActionExecutedDelegate, FName, ActionName);\n\nUENUM(BlueprintType)\nenum class ENightSkyWidgetInputMode : uint8\n{\n    Default,\n    GameAndMenu,\n    Game,\n    Menu\n};\n\nUSTRUCT(BlueprintType)\nstruct FInputActionBindingHandle\n{\n    GENERATED_BODY()\n\npublic:\n    FUIActionBindingHandle Handle;\n};\n\nUCLASS(Abstract, Blueprintable, meta = (DisableNativeTick))\nclass UExtendedCommonActivatableWidget : public UCommonActivatableWidget\n{\n    GENERATED_BODY()\n\npublic:\n    UExtendedCommonActivatableWidget(const FObjectInitializer&amp; ObjectInitializer = FObjectInitializer::Get());\n\n    //~UCommonActivatableWidget interface\n    virtual TOptional&lt;FUIInputConfig&gt; GetDesiredInputConfig() const override;\n    //~End of UCommonActivatableWidget interface\n\n#if WITH_EDITOR\n    virtual void ValidateCompiledWidgetTree(const UWidgetTree&amp; BlueprintWidgetTree, IWidgetCompilerLog&amp; CompileLog) const override;\n#endif\n\nprotected:\n    virtual void NativeDestruct() override;\n\n    UFUNCTION(BlueprintCallable, Category = ExtendedActivatableWidget)\n    void RegisterBinding(FDataTableRowHandle InputAction, const FInputActionExecutedDelegate&amp; Callback, FInputActionBindingHandle&amp; BindingHandle);\n\n    UFUNCTION(BlueprintCallable, Category = ExtendedActivatableWidget)\n    void UnregisterBinding(FInputActionBindingHandle BindingHandle);\n\n    UFUNCTION(BlueprintCallable, Category = ExtendedActivatableWidget)\n    void UnregisterAllBindings();\n\n    UPROPERTY(EditDefaultsOnly, Category = Input)\n    ENightSkyWidgetInputMode DefaultInputConfig = ENightSkyWidgetInputMode::Default;\n\n    UPROPERTY(EditDefaultsOnly, Category = Input)\n    EMouseCaptureMode GameMouseCaptureMode = EMouseCaptureMode::CapturePermanently;\n\nprivate:\n    TArray&lt;FUIActionBindingHandle&gt; BindingHandles;\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_battle_hud_actor_8cpp/","title":"File NightSkyBattleHudActor.cpp","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; UI &gt; NightSkyBattleHudActor.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyBattleHudActor.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/UI/NightSkyBattleHudActor.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_battle_hud_actor_8cpp_source/","title":"File NightSkyBattleHudActor.cpp","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; UI &gt; NightSkyBattleHudActor.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyBattleHudActor.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyBattleHudActor)\n\n// Sets default values\nANightSkyBattleHudActor::ANightSkyBattleHudActor()\n{\n    PrimaryActorTick.bCanEverTick = true;\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_battle_hud_actor_8h/","title":"File NightSkyBattleHudActor.h","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; UI &gt; NightSkyBattleHudActor.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameFramework/Actor.h\"</code></li> <li><code>#include \"NightSkyBattleHudActor.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_battle_hud_actor_8h/#classes","title":"Classes","text":"Type Name class ANightSkyBattleHudActor <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/UI/NightSkyBattleHudActor.h</code></p>"},{"location":"NightSkyEngine/_night_sky_battle_hud_actor_8h_source/","title":"File NightSkyBattleHudActor.h","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; UI &gt; NightSkyBattleHudActor.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Actor.h\"\n#include \"NightSkyBattleHudActor.generated.h\"\n\nclass UNightSkyBattleWidget;\n\nUCLASS()\nclass NIGHTSKYENGINE_API ANightSkyBattleHudActor : public AActor\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ANightSkyBattleHudActor();\n\n    UPROPERTY(BlueprintReadWrite)\n    UNightSkyBattleWidget* TopWidget;\n    UPROPERTY(BlueprintReadWrite)\n    UNightSkyBattleWidget* BottomWidget;\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_battle_widget_8cpp/","title":"File NightSkyBattleWidget.cpp","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; UI &gt; NightSkyBattleWidget.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyBattleWidget.h\"</code></li> <li><code>#include \"Serialization/ObjectReader.h\"</code></li> <li><code>#include \"Serialization/ObjectWriter.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/UI/NightSkyBattleWidget.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_battle_widget_8cpp_source/","title":"File NightSkyBattleWidget.cpp","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; UI &gt; NightSkyBattleWidget.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyBattleWidget.h\"\n\n#include \"Serialization/ObjectReader.h\"\n#include \"Serialization/ObjectWriter.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyBattleWidget)\n\nvoid UNightSkyBattleWidget::PlayStandardAnimations()\n{\n    PlayHealthAnim();\n    PlayRecoverableHealthAnim();\n    PlayTimerAnim();\n    PlayMeterAnim();\n    PlayGaugeAnim();\n    PlayComboCounterAnim();\n}\n\nvoid UNightSkyBattleWidget::SetAnimationRollbackData()\n{\n    for (auto&amp; [Anim, Time, bPlaying] : WidgetAnimationRollback)\n    {\n        if (IsAnimationPlaying(Anim))\n        {\n            bPlaying = true;\n            Time = GetAnimationCurrentTime(Anim);\n        }\n    }\n}\n\nvoid UNightSkyBattleWidget::RollbackAnimations()\n{\n    for (const auto&amp; [Anim, Time, bPlaying] : WidgetAnimationRollback)\n    {\n        if (bPlaying)\n            PlayAnimation(Anim, Time);\n        else\n            SetAnimationCurrentTime(Anim, Time);\n    }\n}\n\nTArray&lt;uint8&gt; UNightSkyBattleWidget::SaveForRollback()\n{\n    TArray&lt;uint8&gt; SaveData;\n    FObjectWriter Writer(SaveData);\n    Writer.ArIsSaveGame = true;\n    GetClass()-&gt;SerializeBin(Writer, this);\n    return SaveData;\n}\n\nvoid UNightSkyBattleWidget::LoadForRollback(const TArray&lt;uint8&gt;&amp; InBytes)\n{\n    if (InBytes.Num() &lt;= 1) return;\n    FObjectReader Reader(InBytes);\n    Reader.ArIsSaveGame = true;\n    GetClass()-&gt;SerializeBin(Reader, this);\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_battle_widget_8h/","title":"File NightSkyBattleWidget.h","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; UI &gt; NightSkyBattleWidget.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Blueprint/UserWidget.h\"</code></li> <li><code>#include \"NightSkyBattleWidget.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_battle_widget_8h/#classes","title":"Classes","text":"Type Name struct FRollbackAnimation class UNightSkyBattleWidget <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/UI/NightSkyBattleWidget.h</code></p>"},{"location":"NightSkyEngine/_night_sky_battle_widget_8h_source/","title":"File NightSkyBattleWidget.h","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; UI &gt; NightSkyBattleWidget.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Blueprint/UserWidget.h\"\n#include \"NightSkyBattleWidget.generated.h\"\n\nUSTRUCT(BlueprintType)\nstruct FRollbackAnimation\n{\n    GENERATED_BODY()\n\n    UPROPERTY(BlueprintReadWrite)\n    UWidgetAnimation* Anim;\n\n    UPROPERTY(BlueprintReadWrite, SaveGame)\n    float Time;\n\n    UPROPERTY(BlueprintReadWrite, SaveGame)\n    bool bPlaying;\n};\n\nUCLASS()\nclass NIGHTSKYENGINE_API UNightSkyBattleWidget : public UUserWidget\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(BlueprintReadOnly)\n    TArray&lt;float&gt; P1Health;\n    UPROPERTY(BlueprintReadOnly)\n    TArray&lt;float&gt; P2Health;\n    UPROPERTY(BlueprintReadOnly)\n    TArray&lt;float&gt; P1RecoverableHealth;\n    UPROPERTY(BlueprintReadOnly)\n    TArray&lt;float&gt; P2RecoverableHealth;\n    UPROPERTY(BlueprintReadOnly)\n    float Timer;\n    UPROPERTY(BlueprintReadOnly)\n    float P1Meter;\n    UPROPERTY(BlueprintReadOnly)\n    float P2Meter;\n    UPROPERTY(BlueprintReadOnly)\n    TArray&lt;float&gt; P1Gauge;\n    UPROPERTY(BlueprintReadOnly)\n    TArray&lt;float&gt; P2Gauge;\n    UPROPERTY(BlueprintReadOnly)\n    int P1RoundsWon;\n    UPROPERTY(BlueprintReadOnly)\n    int P2RoundsWon;\n    UPROPERTY(BlueprintReadOnly)\n    int P1ComboCounter;\n    UPROPERTY(BlueprintReadOnly)\n    int P2ComboCounter;\n    UPROPERTY(BlueprintReadOnly)\n    int Ping;\n    UPROPERTY(BlueprintReadOnly)\n    int RollbackFrames;\n\n    UPROPERTY(BlueprintReadWrite, SaveGame)\n    TArray&lt;FRollbackAnimation&gt; WidgetAnimationRollback;\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void RegisterAnimationsForRollback();\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void PlayFadeAnim();\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void PlayFadeOutAnim();\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void PlayHealthAnim();\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void PlayRecoverableHealthAnim();\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void PlayTimerAnim();\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void PlayMeterAnim();\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void PlayGaugeAnim();\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void PlayRoundInitAnim();\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void PlayRoundWinAnim(bool bIsP1);\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void PlayMatchWinAnim(bool bIsP1);\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void PlayComboCounterAnim();\n\n    void PlayStandardAnimations();\n    void SetAnimationRollbackData();\n    void RollbackAnimations();\n\n    TArray&lt;uint8&gt; SaveForRollback();\n    void LoadForRollback(const TArray&lt;uint8&gt;&amp; InBytes);\n};\n</code></pre>"},{"location":"NightSkyEngine/dir_0a96afba4f006b77d5cb7d94a414ba7d/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/VSInfo","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; VSInfo</p>"},{"location":"NightSkyEngine/dir_0a96afba4f006b77d5cb7d94a414ba7d/#files","title":"Files","text":"Type Name file NightSkyVSInfoGameState.cpp file NightSkyVSInfoGameState.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/VSInfo/</code></p>"},{"location":"NightSkyEngine/_night_sky_v_s_info_game_state_8cpp/","title":"File NightSkyVSInfoGameState.cpp","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; VSInfo &gt; NightSkyVSInfoGameState.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyVSInfoGameState.h\"</code></li> <li><code>#include \"NightSkyEngine/Network/NetworkPawn.h\"</code></li> <li><code>#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"</code></li> <li><code>#include \"Kismet/GameplayStatics.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Objects/PlayerObject.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/PrimaryCharaData.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/PrimaryStageData.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/VSInfo/NightSkyVSInfoGameState.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_v_s_info_game_state_8cpp_source/","title":"File NightSkyVSInfoGameState.cpp","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; VSInfo &gt; NightSkyVSInfoGameState.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyVSInfoGameState.h\"\n\n#include \"NightSkyEngine/Network/NetworkPawn.h\"\n#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"\n#include \"Kismet/GameplayStatics.h\"\n#include \"NightSkyEngine/Battle/Objects/PlayerObject.h\"\n#include \"NightSkyEngine/Data/PrimaryCharaData.h\"\n#include \"NightSkyEngine/Data/PrimaryStageData.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyVSInfoGameState)\n\nANightSkyVSInfoGameState::ANightSkyVSInfoGameState()\n{\n    PrimaryActorTick.bCanEverTick = true;\n\n    VSInfoTime = 0;\n    MapLoaded = false;\n    LoadedCharaPackageCount = 0;\n    TotalCharaPackageCount = 0;\n}\n\nvoid ANightSkyVSInfoGameState::BeginPlay()\n{\n    Super::BeginPlay();\n\n    GameInstance = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance());\n    LoadPackageAsync(GameInstance-&gt;BattleData.Stage-&gt;StageURL,\n        FLoadPackageAsyncDelegate::CreateUObject(this,\n            &amp;ANightSkyVSInfoGameState::OnMapPackageLoaded),\n        0, PKG_ContainsMap);\n    for (const auto PrimaryCharaData : GameInstance-&gt;BattleData.PlayerListP1)\n    {\n        if (PrimaryCharaData == nullptr) continue;\n        ++TotalCharaPackageCount;\n        LoadPackageAsync(PrimaryCharaData-&gt;PlayerClass-&gt;GetPathName(),\n            FLoadPackageAsyncDelegate::CreateUObject(this,\n                &amp;ANightSkyVSInfoGameState::OnCharaPackageLoaded));\n    }\n    for (const auto PrimaryCharaData : GameInstance-&gt;BattleData.PlayerListP2)\n    {\n        if (PrimaryCharaData == nullptr) continue;\n        ++TotalCharaPackageCount;\n        LoadPackageAsync(PrimaryCharaData-&gt;PlayerClass-&gt;GetPathName(),\n            FLoadPackageAsyncDelegate::CreateUObject(this,\n                &amp;ANightSkyVSInfoGameState::OnCharaPackageLoaded));\n    }\n}\n\nvoid ANightSkyVSInfoGameState::Tick(float DeltaSeconds)\n{\n    Super::Tick(DeltaSeconds);\n\n    VSInfoTime += DeltaSeconds;\n    if (VSInfoTime &gt;= MaxVSInfoTime &amp;&amp; MapLoaded &amp;&amp; LoadedCharaPackageCount == TotalCharaPackageCount)\n    {\n        if (GameInstance-&gt;FighterRunner != Multiplayer || GameInstance-&gt;IsReplay)\n            GameInstance-&gt;TravelToBattleMap();\n        else\n        {\n            GameInstance-&gt;FinishedLoadingForNetworkBattle = true;\n            if (GetWorld()-&gt;GetNetMode() == NM_Client)\n            {\n                const auto NetworkPawn = Cast&lt;ANetworkPawn&gt;(UGameplayStatics::GetPlayerController(GetWorld(), 0)-&gt;GetPawn());\n                if (IsValid(NetworkPawn))\n                {\n                    NetworkPawn-&gt;ServerGetFinishedLoading(true);\n                }\n            }\n        }\n    }\n}\n\nvoid ANightSkyVSInfoGameState::OnMapPackageLoaded(const FName&amp; PackageName, UPackage* LoadedPackage,\n    EAsyncLoadingResult::Type Result)\n{\n    MapLoaded = true;\n    Packages.Add(LoadedPackage);\n}\n\nvoid ANightSkyVSInfoGameState::OnCharaPackageLoaded(const FName&amp; PackageName, UPackage* LoadedPackage,\n    EAsyncLoadingResult::Type Result)\n{\n    ++LoadedCharaPackageCount;\n    Packages.Add(LoadedPackage);\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_v_s_info_game_state_8h/","title":"File NightSkyVSInfoGameState.h","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; VSInfo &gt; NightSkyVSInfoGameState.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameFramework/GameStateBase.h\"</code></li> <li><code>#include \"NightSkyVSInfoGameState.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_v_s_info_game_state_8h/#classes","title":"Classes","text":"Type Name class ANightSkyVSInfoGameState <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/VSInfo/NightSkyVSInfoGameState.h</code></p>"},{"location":"NightSkyEngine/_night_sky_v_s_info_game_state_8h_source/","title":"File NightSkyVSInfoGameState.h","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; VSInfo &gt; NightSkyVSInfoGameState.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameStateBase.h\"\n#include \"NightSkyVSInfoGameState.generated.h\"\n\nclass UNightSkyGameInstance;\nUCLASS()\nclass NIGHTSKYENGINE_API ANightSkyVSInfoGameState : public AGameStateBase\n{\n    GENERATED_BODY()\n\n    double VSInfoTime;\n    bool MapLoaded;\n    int32 LoadedCharaPackageCount;\n    int32 TotalCharaPackageCount;\n\n    UPROPERTY()\n    TArray&lt;TObjectPtr&lt;UPackage&gt;&gt; Packages;\n    UPROPERTY()\n    TObjectPtr&lt;UNightSkyGameInstance&gt; GameInstance;\n\npublic:\n    ANightSkyVSInfoGameState();\n\n    UPROPERTY(EditAnywhere)\n    double MaxVSInfoTime = 6;\n\n    virtual void BeginPlay() override;\n    virtual void Tick(float DeltaSeconds) override;\n\n    void OnMapPackageLoaded(const FName&amp; PackageName, UPackage* LoadedPackage, EAsyncLoadingResult::Type Result);\n    void OnCharaPackageLoaded(const FName&amp; PackageName, UPackage* LoadedPackage, EAsyncLoadingResult::Type Result);\n};\n</code></pre>"},{"location":"NightSkyEngine/dir_cd88faa59062fd9190839afeb0d4d29a/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/WT","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; WT</p>"},{"location":"NightSkyEngine/dir_cd88faa59062fd9190839afeb0d4d29a/#files","title":"Files","text":"Type Name file NightSkyWTGameState.cpp file NightSkyWTGameState.h file NightSkyWTPlayerController.cpp file NightSkyWTPlayerController.h file WTCharacter.cpp file WTCharacter.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/WT/</code></p>"},{"location":"NightSkyEngine/_night_sky_w_t_game_state_8cpp/","title":"File NightSkyWTGameState.cpp","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; WT &gt; NightSkyWTGameState.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyWTGameState.h\"</code></li> <li><code>#include \"Camera/CameraActor.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Actors/ParticleManager.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/FighterRunners/FighterLocalRunner.h\"</code></li> <li><code>#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"</code></li> <li><code>#include \"CineCameraActor.h\"</code></li> <li><code>#include \"Camera/CameraComponent.h\"</code></li> <li><code>#include \"LevelSequenceActor.h\"</code></li> <li><code>#include \"NightSkyEngine/Data/BattleExtensionData.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/WT/NightSkyWTGameState.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_w_t_game_state_8cpp_source/","title":"File NightSkyWTGameState.cpp","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; WT &gt; NightSkyWTGameState.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyWTGameState.h\"\n\n#include \"Camera/CameraActor.h\"\n#include \"NightSkyEngine/Battle/Actors/ParticleManager.h\"\n#include \"NightSkyEngine/Battle/FighterRunners/FighterLocalRunner.h\"\n#include \"NightSkyEngine/Miscellaneous/NightSkyGameInstance.h\"\n#include \"CineCameraActor.h\"\n#include \"Camera/CameraComponent.h\"\n#include \"LevelSequenceActor.h\"\n#include \"NightSkyEngine/Data/BattleExtensionData.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyWTGameState)\n\n// Sets default values\nANightSkyWTGameState::ANightSkyWTGameState()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n    BattleSceneTransform = FTransform();\n    bIsBattling = false;\n    bIsMatchEnd = false;\n}\n\n// Called when the game starts or when spawned\nvoid ANightSkyWTGameState::BeginPlay()\n{\n    AActor::BeginPlay();\n\n    FActorSpawnParameters SpawnParameters;\n    ParticleManager = GetWorld()-&gt;SpawnActor&lt;AParticleManager&gt;();\n    AudioManager = GetWorld()-&gt;SpawnActor&lt;AAudioManager&gt;();\n    GameInstance = Cast&lt;UNightSkyGameInstance&gt;(GetGameInstance());\n    CameraActor = GetWorld()-&gt;SpawnActor&lt;ACameraActor&gt;(ACameraActor::StaticClass());\n    CameraActor-&gt;GetCameraComponent()-&gt;SetFieldOfView(54);\n    SequenceCameraActor = GetWorld()-&gt;SpawnActor&lt;ACineCameraActor&gt;(ACineCameraActor::StaticClass());\n    SequenceActor = GetWorld()-&gt;SpawnActor&lt;ALevelSequenceActor&gt;(ALevelSequenceActor::StaticClass());\n}\n\nvoid ANightSkyWTGameState::Init(APlayerObject* P1, APlayerObject* P2)\n{\n    bIsBattling = true;\n\n    if (IsValid(BattleExtensionData))\n    {\n        for (auto Extension : BattleExtensionData-&gt;ExtensionArray)\n        {\n            BattleExtensions.Add(NewObject&lt;UBattleExtension&gt;(this, Extension));\n            BattleExtensions.Last()-&gt;Parent = this;\n            BattleExtensionNames.Add(BattleExtensions.Last()-&gt;Name);\n        }\n    }\n\n    {\n        Players.Add(P1);\n        P1-&gt;SetActorTransform(BattleSceneTransform);\n        P1-&gt;PlayerFlags |= PLF_IsOnScreen;\n        SortedObjects.Add(P1);\n        P1-&gt;InitPlayer();\n        P1-&gt;GameState = this;\n    }\n    {\n        Players.Add(P2);\n        P2-&gt;SetActorTransform(BattleSceneTransform);\n        P2-&gt;PlayerFlags |= PLF_IsOnScreen;\n        SortedObjects.Add(P2);\n        P2-&gt;InitPlayer();\n        P2-&gt;GameState = this;\n    }\n\n    for (int i = 0; i &lt; MaxBattleObjects; i++)\n    {\n        Objects.Add(GetWorld()-&gt;SpawnActor&lt;ABattleObject&gt;(ABattleObject::StaticClass(), BattleSceneTransform));\n        Objects[i]-&gt;GameState = this;\n        SortedObjects.Add(Objects.Last());\n    }\n\n    const FVector NewCameraLocation = BattleSceneTransform.GetRotation().RotateVector(FVector(0, 1080, 175)) + BattleSceneTransform.GetLocation();\n    FRotator CameraRotation = BattleSceneTransform.GetRotation().Rotator();\n    CameraRotation.Yaw -= 90;\n\n    CameraActor-&gt;SetActorLocation(NewCameraLocation);\n    CameraActor-&gt;SetActorRotation(CameraRotation);\n    SequenceCameraActor-&gt;SetActorLocation(NewCameraLocation);\n\n    MatchInit();\n    HUDInit();\n}\n\n// Called every frame\nvoid ANightSkyWTGameState::Tick(float DeltaTime)\n{\n    AActor::Tick(DeltaTime);\n\n    if (bIsBattling &amp;&amp; IsValid(FighterRunner))\n        FighterRunner-&gt;Update(DeltaTime);\n\n    if (bIsMatchEnd)\n    {\n        bIsBattling = false;\n        bIsMatchEnd = false;\n        Objects.Empty();\n        Players.Empty();\n        SortedObjects.Empty();\n        OnBattleEndDelegate.Broadcast();\n    }\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_w_t_game_state_8h/","title":"File NightSkyWTGameState.h","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; WT &gt; NightSkyWTGameState.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/NightSkyGameState.h\"</code></li> <li><code>#include \"NightSkyWTGameState.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_w_t_game_state_8h/#classes","title":"Classes","text":"Type Name class ANightSkyWTGameState"},{"location":"NightSkyEngine/_night_sky_w_t_game_state_8h/#public-functions","title":"Public Functions","text":"Type Name DECLARE_DYNAMIC_MULTICAST_DELEGATE (FOnBattleEndDelegate)"},{"location":"NightSkyEngine/_night_sky_w_t_game_state_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_night_sky_w_t_game_state_8h/#function-declare_dynamic_multicast_delegate","title":"function DECLARE_DYNAMIC_MULTICAST_DELEGATE","text":"<pre><code>DECLARE_DYNAMIC_MULTICAST_DELEGATE (\n    FOnBattleEndDelegate\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/WT/NightSkyWTGameState.h</code></p>"},{"location":"NightSkyEngine/_night_sky_w_t_game_state_8h_source/","title":"File NightSkyWTGameState.h","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; WT &gt; NightSkyWTGameState.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NightSkyEngine/Battle/NightSkyGameState.h\"\n#include \"NightSkyWTGameState.generated.h\"\n\nUDELEGATE()\nDECLARE_DYNAMIC_MULTICAST_DELEGATE(FOnBattleEndDelegate);\n\nUCLASS()\nclass NIGHTSKYENGINE_API ANightSkyWTGameState : public ANightSkyGameState\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ANightSkyWTGameState();\n\n    UPROPERTY(BlueprintReadWrite)\n    bool bIsMatchEnd;\n\n    UPROPERTY(BlueprintReadOnly)\n    bool bIsBattling;\n\n    UPROPERTY()\n    FOnBattleEndDelegate OnBattleEndDelegate;\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    void Init(APlayerObject* P1, APlayerObject* P2);\n\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_w_t_player_controller_8cpp/","title":"File NightSkyWTPlayerController.cpp","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; WT &gt; NightSkyWTPlayerController.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyWTPlayerController.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/WT/NightSkyWTPlayerController.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_w_t_player_controller_8cpp_source/","title":"File NightSkyWTPlayerController.cpp","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; WT &gt; NightSkyWTPlayerController.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyWTPlayerController.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyWTPlayerController)\n\n// Sets default values\nANightSkyWTPlayerController::ANightSkyWTPlayerController()\n{\n    // Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid ANightSkyWTPlayerController::BeginPlay()\n{\n    Super::BeginPlay();\n\n}\n\n// Called every frame\nvoid ANightSkyWTPlayerController::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_w_t_player_controller_8h/","title":"File NightSkyWTPlayerController.h","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; WT &gt; NightSkyWTPlayerController.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/NightSkyPlayerController.h\"</code></li> <li><code>#include \"NightSkyWTPlayerController.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_w_t_player_controller_8h/#classes","title":"Classes","text":"Type Name class ANightSkyWTPlayerController <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/WT/NightSkyWTPlayerController.h</code></p>"},{"location":"NightSkyEngine/_night_sky_w_t_player_controller_8h_source/","title":"File NightSkyWTPlayerController.h","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; WT &gt; NightSkyWTPlayerController.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"NightSkyEngine/Battle/NightSkyPlayerController.h\"\n#include \"NightSkyWTPlayerController.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINE_API ANightSkyWTPlayerController : public ANightSkyPlayerController\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this actor's properties\n    ANightSkyWTPlayerController();\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n};\n</code></pre>"},{"location":"NightSkyEngine/_w_t_character_8cpp/","title":"File WTCharacter.cpp","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; WT &gt; WTCharacter.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"WTCharacter.h\"</code></li> <li><code>#include \"NightSkyWTGameState.h\"</code></li> <li><code>#include \"NightSkyEngine/Battle/Objects/PlayerObject.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/WT/WTCharacter.cpp</code></p>"},{"location":"NightSkyEngine/_w_t_character_8cpp_source/","title":"File WTCharacter.cpp","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; WT &gt; WTCharacter.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"WTCharacter.h\"\n\n#include \"NightSkyWTGameState.h\"\n#include \"NightSkyEngine/Battle/Objects/PlayerObject.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(WTCharacter)\n\n// Sets default values\nAWTCharacter::AWTCharacter()\n{\n    // Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n    PrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AWTCharacter::BeginPlay()\n{\n    Super::BeginPlay();\n\n    GameState = Cast&lt;ANightSkyWTGameState&gt;(GetWorld()-&gt;GetGameState());\n    if (GameState)\n        GameState-&gt;OnBattleEndDelegate.AddUniqueDynamic(this, &amp;AWTCharacter::EndBattle);\n\n    BattlePlayer = GetWorld()-&gt;SpawnActor&lt;APlayerObject&gt;(BattlePlayerClass);\n    BattlePlayer-&gt;SetActorHiddenInGame(true);\n}\n\n// Called every frame\nvoid AWTCharacter::Tick(float DeltaTime)\n{\n    Super::Tick(DeltaTime);\n}\n\n// Called to bind functionality to input\nvoid AWTCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\n{\n    Super::SetupPlayerInputComponent(PlayerInputComponent);\n}\n\nvoid AWTCharacter::StartBattle(AWTCharacter* Opponent)\n{\n    // Hide WT character and show battle player.\n    SetActorHiddenInGame(true);\n    BattlePlayer-&gt;SetActorHiddenInGame(false);\n    Opponent-&gt;SetActorHiddenInGame(true);\n    Opponent-&gt;BattlePlayer-&gt;SetActorHiddenInGame(false);\n\n    GameState-&gt;Init(BattlePlayer, Opponent-&gt;BattlePlayer);\n}\n\nvoid AWTCharacter::EndBattle()\n{\n    SetActorHiddenInGame(false);\n    BattlePlayer-&gt;SetActorHiddenInGame(true);\n    EndBattle_BP();\n}\n</code></pre>"},{"location":"NightSkyEngine/_w_t_character_8h/","title":"File WTCharacter.h","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; WT &gt; WTCharacter.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameFramework/Character.h\"</code></li> <li><code>#include \"WTCharacter.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_w_t_character_8h/#classes","title":"Classes","text":"Type Name class AWTCharacter <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/WT/WTCharacter.h</code></p>"},{"location":"NightSkyEngine/_w_t_character_8h_source/","title":"File WTCharacter.h","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; WT &gt; WTCharacter.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/Character.h\"\n#include \"WTCharacter.generated.h\"\n\nclass ANightSkyWTGameState;\nclass APlayerObject;\n\nUCLASS()\nclass NIGHTSKYENGINE_API AWTCharacter : public ACharacter\n{\n    GENERATED_BODY()\n\npublic:\n    // Sets default values for this character's properties\n    AWTCharacter();\n\n    UPROPERTY(BlueprintReadOnly)\n    ANightSkyWTGameState* GameState;\n\n    UPROPERTY(EditAnywhere)\n    TSubclassOf&lt;APlayerObject&gt; BattlePlayerClass;\n\n    UPROPERTY(BlueprintReadOnly)\n    APlayerObject* BattlePlayer;\n\nprotected:\n    // Called when the game starts or when spawned\n    virtual void BeginPlay() override;\n\npublic:\n    // Called every frame\n    virtual void Tick(float DeltaTime) override;\n\n    // Called to bind functionality to input\n    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\n\n    UFUNCTION(BlueprintCallable)\n    void StartBattle(AWTCharacter* Opponent);\n\n    UFUNCTION()\n    void EndBattle();\n\n    UFUNCTION(BlueprintImplementableEvent)\n    void EndBattle_BP();\n};\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_engine_8cpp/","title":"File NightSkyEngine.cpp","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; NightSkyEngine.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyEngine.h\"</code></li> <li><code>#include \"Modules/ModuleManager.h\"</code></li> </ul>"},{"location":"NightSkyEngine/_night_sky_engine_8cpp/#public-functions","title":"Public Functions","text":"Type Name IMPLEMENT_MODULE (FDefaultModuleImpl, NightSkyEngine)"},{"location":"NightSkyEngine/_night_sky_engine_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngine/_night_sky_engine_8cpp/#function-implement_module","title":"function IMPLEMENT_MODULE","text":"<pre><code>IMPLEMENT_MODULE (\n    FDefaultModuleImpl,\n    NightSkyEngine\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/NightSkyEngine.cpp</code></p>"},{"location":"NightSkyEngine/_night_sky_engine_8cpp_source/","title":"File NightSkyEngine.cpp","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; NightSkyEngine.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"NightSkyEngine.h\"\n#include \"Modules/ModuleManager.h\"\n\nIMPLEMENT_MODULE(FDefaultModuleImpl, NightSkyEngine);\n</code></pre>"},{"location":"NightSkyEngine/_night_sky_engine_8h/","title":"File NightSkyEngine.h","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; NightSkyEngine.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngine/NightSkyEngine.h</code></p>"},{"location":"NightSkyEngine/_night_sky_engine_8h_source/","title":"File NightSkyEngine.h","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngine &gt; NightSkyEngine.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n</code></pre>"},{"location":"NightSkyEngine/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"NightSkyEngine/classes/","title":"Class Index","text":""},{"location":"NightSkyEngine/classes/#a","title":"a","text":"<ul> <li>AAudioManager</li> <li>ABattleObject</li> <li>AFighterLocalRunner</li> <li>AFighterMultiplayerRunner</li> <li>AFighterReplayRunner</li> <li>AFighterSynctestRunner</li> <li>ALinkActor</li> <li>ANetworkPawn</li> <li>ANightSkyAIController</li> <li>ANightSkyBattleHudActor</li> <li>ANightSkyCharaSelectGameState</li> <li>ANightSkyEngineGameModeBase</li> <li>ANightSkyGameState</li> <li>ANightSkyPlayerController</li> <li>ANightSkyVSInfoGameState</li> <li>ANightSkyWTGameState</li> <li>ANightSkyWTPlayerController</li> <li>AParticleManager</li> <li>APlayerObject</li> <li>AWTCharacter</li> </ul>"},{"location":"NightSkyEngine/classes/#f","title":"f","text":"<ul> <li>FAnimRotator</li> <li>FAnimStruct</li> <li>FAnimTransform</li> <li>FAnimVector</li> <li>FAudioChannel</li> <li>FBattleData</li> <li>FBattleInputActions</li> <li>FBattleObjectLog</li> <li>FBattleParticle</li> <li>FBattleState</li> <li>FCameraShakeStruct</li> <li>FCollisionBox</li> <li>FCollisionStruct</li> <li>FEventHandler</li> <li>FExtraGauge</li> <li>FFlipbookStruct</li> <li>FGroundBounceData</li> <li>FHitData</li> <li>FHitDataCommon</li> <li>FHitPosition</li> <li>FHitValueOverTime</li> <li>FHomingParams</li> <li>FInputActionBindingHandle</li> <li>FInputBitmask</li> <li>FInputBuffer</li> <li>FInputCondition</li> <li>FInputConditionList</li> <li>FLinkActorStruct</li> <li>FLinkedActorContainer</li> <li>FMaterialStruct</li> <li>FNetworkMirror</li> <li>FNetworkStats</li> <li>FNightSkySaveArchive</li> <li>FNSESessionInfo</li> <li>FObjectRecord</li> <li>FParticleStruct</li> <li>FPlayerObjectLog</li> <li>FRandomManager</li> <li>FRollbackAnimation</li> <li>FRollbackData</li> <li>FScreenData</li> <li>FSequenceStruct</li> <li>FSoundStruct</li> <li>FStateCPUData</li> <li>FStateMachine</li> <li>FSuperArmorData</li> <li>FTeamData</li> <li>FWallBounceData</li> </ul>"},{"location":"NightSkyEngine/classes/#r","title":"r","text":"<ul> <li>RpcConnectionManager</li> </ul>"},{"location":"NightSkyEngine/classes/#u","title":"u","text":"<ul> <li>UBattleExtension</li> <li>UBattleExtensionData</li> <li>UCameraShakeData</li> <li>UCollisionData</li> <li>UExtendedCommonActivatableWidget</li> <li>UFlipbookData</li> <li>ULinkActorData</li> <li>UMaterialData</li> <li>UNightSkyAnimInstance</li> <li>UNightSkyAnimMetaData</li> <li>UNightSkyAnimSequenceUserData</li> <li>UNightSkyBattleWidget</li> <li>UNightSkyBlueprintFunctionLibrary</li> <li>UNightSkyGameInstance</li> <li>UNightSkySaveInfo</li> <li>UNightSkySettingsInfo</li> <li>UNSEEnhancedInputUserSettings</li> <li>UNSEPlayerMappableKeyProfile</li> <li>UNSEPlayerMappableKeySettings</li> <li>UNSESessionSubsystem</li> <li>UParticleData</li> <li>UPrimaryCharaData</li> <li>UPrimaryStageData</li> <li>UReplaySaveInfo</li> <li>USequenceData</li> <li>USerializableObj</li> <li>USoundData</li> <li>UState</li> <li>UStateAlias</li> <li>UStateData</li> <li>USubroutine</li> <li>USubroutineData</li> <li>USubroutineState</li> </ul>"},{"location":"NightSkyEngine/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>struct FAnimRotator </li> <li>struct FAnimStruct </li> <li>struct FAnimTransform </li> <li>struct FAnimVector </li> <li>struct FAudioChannel </li> <li>struct FBattleData </li> <li>struct FBattleInputActions </li> <li>struct FBattleObjectLog <ul> <li>struct FPlayerObjectLog </li> </ul> </li> <li>struct FBattleParticle </li> <li>struct FBattleState </li> <li>struct FCameraShakeStruct </li> <li>struct FCollisionBox A collision box. </li> <li>struct FCollisionStruct </li> <li>struct FEventHandler </li> <li>struct FExtraGauge </li> <li>struct FFlipbookStruct </li> <li>struct FGroundBounceData </li> <li>struct FHitData </li> <li>struct FHitDataCommon </li> <li>struct FHitPosition </li> <li>struct FHitValueOverTime </li> <li>struct FHomingParams </li> <li>struct FInputActionBindingHandle </li> <li>struct FInputBitmask </li> <li>struct FInputBuffer The input buffer for a player object. </li> <li>struct FInputCondition </li> <li>struct FInputConditionList </li> <li>struct FLinkActorStruct </li> <li>struct FLinkedActorContainer </li> <li>struct FMaterialStruct </li> <li>struct FNSESessionInfo </li> <li>struct FNetworkMirror </li> <li>struct FNetworkStats </li> <li>struct FObjectRecord </li> <li>struct FParticleStruct </li> <li>struct FRandomManager </li> <li>struct FRollbackAnimation </li> <li>struct FRollbackData </li> <li>struct FScreenData </li> <li>struct FSequenceStruct </li> <li>struct FSoundStruct </li> <li>struct FStateCPUData </li> <li>struct FStateMachine The player object's state machine. </li> <li>struct FSuperArmorData </li> <li>struct FTeamData </li> <li>struct FWallBounceData </li> <li>class AActor <ul> <li>class AAudioManager </li> <li>class AFighterLocalRunner <ul> <li>class AFighterMultiplayerRunner <ul> <li>class AFighterSynctestRunner </li> </ul> </li> <li>class AFighterReplayRunner </li> </ul> </li> <li>class AFighterLocalRunner <ul> <li>class AFighterMultiplayerRunner <ul> <li>class AFighterSynctestRunner </li> </ul> </li> <li>class AFighterReplayRunner </li> </ul> </li> <li>class AFighterLocalRunner <ul> <li>class AFighterMultiplayerRunner <ul> <li>class AFighterSynctestRunner </li> </ul> </li> <li>class AFighterReplayRunner </li> </ul> </li> <li>class AFighterLocalRunner <ul> <li>class AFighterMultiplayerRunner <ul> <li>class AFighterSynctestRunner </li> </ul> </li> <li>class AFighterReplayRunner </li> </ul> </li> <li>class ALinkActor </li> <li>class ANightSkyBattleHudActor </li> <li>class AParticleManager </li> </ul> </li> <li>class APawn <ul> <li>class ABattleObject <ul> <li>class APlayerObject </li> </ul> </li> <li>class ANetworkPawn </li> <li>class ABattleObject <ul> <li>class APlayerObject </li> </ul> </li> </ul> </li> <li>class AAIController <ul> <li>class ANightSkyAIController </li> </ul> </li> <li>class AGameStateBase <ul> <li>class ANightSkyCharaSelectGameState </li> <li>class ANightSkyGameState <ul> <li>class ANightSkyWTGameState </li> </ul> </li> <li>class ANightSkyVSInfoGameState </li> <li>class ANightSkyGameState <ul> <li>class ANightSkyWTGameState </li> </ul> </li> </ul> </li> <li>class AGameModeBase <ul> <li>class ANightSkyEngineGameModeBase </li> </ul> </li> <li>class APlayerController <ul> <li>class ANightSkyPlayerController <ul> <li>class ANightSkyWTPlayerController </li> </ul> </li> <li>class ANightSkyPlayerController <ul> <li>class ANightSkyWTPlayerController </li> </ul> </li> </ul> </li> <li>class ACharacter <ul> <li>class AWTCharacter </li> </ul> </li> <li>class ConnectionManager <ul> <li>class RpcConnectionManager </li> </ul> </li> <li>class UObject <ul> <li>class USerializableObj <ul> <li>class UBattleExtension A customizable extension to the battle ruleset. </li> <li>class UState A character state that determines behavior. <ul> <li>class UStateAlias </li> <li>class USubroutineState </li> </ul> </li> <li>class USubroutine A subroutine callable from any player or object state. </li> </ul> </li> <li>class USerializableObj <ul> <li>class UBattleExtension A customizable extension to the battle ruleset. </li> <li>class UState A character state that determines behavior. <ul> <li>class UStateAlias </li> <li>class USubroutineState </li> </ul> </li> <li>class USubroutine A subroutine callable from any player or object state. </li> </ul> </li> <li>class USerializableObj <ul> <li>class UBattleExtension A customizable extension to the battle ruleset. </li> <li>class UState A character state that determines behavior. <ul> <li>class UStateAlias </li> <li>class USubroutineState </li> </ul> </li> <li>class USubroutine A subroutine callable from any player or object state. </li> </ul> </li> <li>class USerializableObj <ul> <li>class UBattleExtension A customizable extension to the battle ruleset. </li> <li>class UState A character state that determines behavior. <ul> <li>class UStateAlias </li> <li>class USubroutineState </li> </ul> </li> <li>class USubroutine A subroutine callable from any player or object state. </li> </ul> </li> <li>class USerializableObj <ul> <li>class UBattleExtension A customizable extension to the battle ruleset. </li> <li>class UState A character state that determines behavior. <ul> <li>class UStateAlias </li> <li>class USubroutineState </li> </ul> </li> <li>class USubroutine A subroutine callable from any player or object state. </li> </ul> </li> <li>class USerializableObj <ul> <li>class UBattleExtension A customizable extension to the battle ruleset. </li> <li>class UState A character state that determines behavior. <ul> <li>class UStateAlias </li> <li>class USubroutineState </li> </ul> </li> <li>class USubroutine A subroutine callable from any player or object state. </li> </ul> </li> </ul> </li> <li>class UDataAsset <ul> <li>class UBattleExtensionData </li> <li>class UCameraShakeData </li> <li>class UCollisionData </li> <li>class UFlipbookData </li> <li>class ULinkActorData </li> <li>class UMaterialData </li> <li>class UParticleData </li> <li>class USequenceData </li> <li>class USoundData </li> <li>class UStateData </li> <li>class USubroutineData </li> </ul> </li> <li>class UCommonActivatableWidget <ul> <li>class UExtendedCommonActivatableWidget </li> </ul> </li> <li>class UEnhancedInputUserSettings <ul> <li>class UNSEEnhancedInputUserSettings </li> </ul> </li> <li>class UEnhancedPlayerMappableKeyProfile <ul> <li>class UNSEPlayerMappableKeyProfile </li> </ul> </li> <li>class UPlayerMappableKeySettings <ul> <li>class UNSEPlayerMappableKeySettings </li> </ul> </li> <li>class UGameInstanceSubsystem <ul> <li>class UNSESessionSubsystem </li> </ul> </li> <li>class UAnimInstance <ul> <li>class UNightSkyAnimInstance </li> </ul> </li> <li>class UAnimMetaData <ul> <li>class UNightSkyAnimMetaData </li> </ul> </li> <li>class UAssetUserData <ul> <li>class UNightSkyAnimSequenceUserData </li> </ul> </li> <li>class UUserWidget <ul> <li>class UNightSkyBattleWidget </li> </ul> </li> <li>class UBlueprintFunctionLibrary <ul> <li>class UNightSkyBlueprintFunctionLibrary </li> </ul> </li> <li>class UGameInstance <ul> <li>class UNightSkyGameInstance </li> </ul> </li> <li>class USaveGame <ul> <li>class UNightSkySaveInfo <ul> <li>class UNightSkySettingsInfo </li> <li>class UReplaySaveInfo </li> </ul> </li> <li>class UNightSkySaveInfo <ul> <li>class UNightSkySettingsInfo </li> <li>class UReplaySaveInfo </li> </ul> </li> <li>class UNightSkySaveInfo <ul> <li>class UNightSkySettingsInfo </li> <li>class UReplaySaveInfo </li> </ul> </li> </ul> </li> <li>class UPrimaryDataAsset <ul> <li>class UPrimaryCharaData </li> <li>class UPrimaryStageData </li> </ul> </li> <li>class FObjectAndNameAsStringProxyArchive <ul> <li>struct FNightSkySaveArchive </li> </ul> </li> </ul>"},{"location":"NightSkyEngine/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"NightSkyEngine/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"NightSkyEngine/class_members/","title":"Class Members","text":""},{"location":"NightSkyEngine/class_members/#a","title":"a","text":"<ul> <li>AAudioManager (AAudioManager)</li> <li>AnnouncerVoicePlayer (AAudioManager)</li> <li>ABattleObject (ABattleObject)</li> <li>ActionReg1 (ABattleObject, FBattleObjectLog)</li> <li>ActionReg2 (ABattleObject, FBattleObjectLog)</li> <li>ActionReg3 (ABattleObject, FBattleObjectLog)</li> <li>ActionReg4 (ABattleObject, FBattleObjectLog)</li> <li>ActionReg5 (ABattleObject, FBattleObjectLog)</li> <li>ActionReg6 (ABattleObject, FBattleObjectLog)</li> <li>ActionReg7 (ABattleObject, FBattleObjectLog)</li> <li>ActionReg8 (ABattleObject, FBattleObjectLog)</li> <li>ActionTime (ABattleObject, FBattleObjectLog)</li> <li>AddBattleObject (ABattleObject, ANightSkyGameState)</li> <li>AddColor (ABattleObject, FBattleObjectLog)</li> <li>AddCommonBattleObject (ABattleObject)</li> <li>AddFadeColor (ABattleObject, FBattleObjectLog)</li> <li>AddFadeSpeed (ABattleObject, FBattleObjectLog)</li> <li>AddPosXWithDir (ABattleObject)</li> <li>AddSpeedXRaw (ABattleObject)</li> <li>AnglePitch_x1000 (ABattleObject)</li> <li>AngleRoll_x1000 (ABattleObject)</li> <li>AngleYaw_x1000 (ABattleObject)</li> <li>AnimBlendIn (ABattleObject, FBattleObjectLog, FCollisionStruct)</li> <li>AnimBlendOut (ABattleObject, FBattleObjectLog, FCollisionStruct)</li> <li>AnimFrame (ABattleObject, FBattleObjectLog, FCollisionStruct)</li> <li>AnimStructs (ABattleObject)</li> <li>AttachToSocketOfObject (ABattleObject)</li> <li>AttackFlags (ABattleObject, FBattleObjectLog)</li> <li>AttackOwner (ABattleObject, FBattleObjectLog)</li> <li>AttackTarget (ABattleObject, FBattleObjectLog)</li> <li>AFighterLocalRunner (AFighterLocalRunner)</li> <li>AFighterMultiplayerRunner (AFighterMultiplayerRunner)</li> <li>AdvanceFrameCallback (AFighterMultiplayerRunner)</li> <li>AFighterReplayRunner (AFighterReplayRunner)</li> <li>AFighterSynctestRunner (AFighterSynctestRunner)</li> <li>ALinkActor (ALinkActor)</li> <li>ANetworkPawn (ANetworkPawn)</li> <li>ANightSkyAIController (ANightSkyAIController)</li> <li>ANightSkyBattleHudActor (ANightSkyBattleHudActor)</li> <li>ANightSkyCharaSelectGameState (ANightSkyCharaSelectGameState)</li> <li>AddColorIndex (ANightSkyCharaSelectGameState)</li> <li>AddPlayerObject (ANightSkyCharaSelectGameState)</li> <li>ANightSkyGameState (ANightSkyGameState)</li> <li>AssignEnemy (ANightSkyGameState)</li> <li>AudioManager (ANightSkyGameState)</li> <li>ANightSkyPlayerController (ANightSkyPlayerController)</li> <li>ANightSkyVSInfoGameState (ANightSkyVSInfoGameState)</li> <li>ANightSkyWTGameState (ANightSkyWTGameState)</li> <li>ANightSkyWTPlayerController (ANightSkyWTPlayerController)</li> <li>AParticleManager (AParticleManager)</li> <li>APlayerObject (APlayerObject)</li> <li>AddAirDash (APlayerObject)</li> <li>AddAirJump (APlayerObject)</li> <li>AddAutoComboCancel (APlayerObject)</li> <li>AddBattleObjectToStorage (APlayerObject)</li> <li>AddChainCancelOption (APlayerObject)</li> <li>AddHealth (APlayerObject)</li> <li>AddMeter (APlayerObject)</li> <li>AddObjectState (APlayerObject)</li> <li>AddRecoverableHealth (APlayerObject)</li> <li>AddState (APlayerObject, FStateMachine)</li> <li>AddSubroutine (APlayerObject)</li> <li>AddWhiffCancelOption (APlayerObject)</li> <li>AirDashCount (APlayerObject, FPlayerObjectLog)</li> <li>AirDashMinimumHeight (APlayerObject, FPlayerObjectLog)</li> <li>AirDashNoAttackTime (APlayerObject, FPlayerObjectLog)</li> <li>AirDashTimer (APlayerObject, FPlayerObjectLog)</li> <li>AirDashTimerMax (APlayerObject, FPlayerObjectLog)</li> <li>AirJumpCount (APlayerObject, FPlayerObjectLog)</li> <li>AirPushHeight (APlayerObject, FPlayerObjectLog)</li> <li>AirPushHeightLow (APlayerObject, FPlayerObjectLog)</li> <li>AirPushWidth (APlayerObject, FPlayerObjectLog)</li> <li>AutoComboCancels (APlayerObject, FPlayerObjectLog)</li> <li>AWTCharacter (AWTCharacter)</li> <li>AnimSequence (FAnimStruct)</li> <li>AnglePitch_x10 (FBattleObjectLog)</li> <li>AngleRoll_x10 (FBattleObjectLog)</li> <li>AngleYaw_x10 (FBattleObjectLog)</li> <li>ActiveObjectCount (FBattleState)</li> <li>AnnouncerVoiceChannel (FBattleState)</li> <li>AssistCooldown (FBattleState)</li> <li>Anim (FCollisionStruct, FRollbackAnimation)</li> <li>AirHitAction (FHitData)</li> <li>AirPushbackX (FHitData)</li> <li>AirPushbackXOverTime (FHitData)</li> <li>AirPushbackY (FHitData)</li> <li>AirPushbackYOverTime (FHitData)</li> <li>AirGuardPushbackX (FHitDataCommon)</li> <li>AirGuardPushbackY (FHitDataCommon)</li> <li>AttackLevel (FHitDataCommon)</li> <li>ActorClass (FLinkActorStruct)</li> <li>AttackSpeed (FStateCPUData)</li> <li>AttackXBeginRange (FStateCPUData)</li> <li>AttackXEndRange (FStateCPUData)</li> <li>AttackYBeginRange (FStateCPUData)</li> <li>AttackYEndRange (FStateCPUData)</li> <li>ArmorDamagePercent (FSuperArmorData)</li> <li>ArmorHits (FSuperArmorData)</li> <li>AnnouncerData (UNightSkyGameInstance)</li> <li>ActorArraySaver (UNightSkySaveInfo)</li> <li>ActorPreloader (UNightSkySaveInfo)</li> <li>ActorSaver (UNightSkySaveInfo)</li> <li>AntiAliasingMethod (UNightSkySettingsInfo)</li> </ul>"},{"location":"NightSkyEngine/class_members/#b","title":"b","text":"<ul> <li>BeginPlay (AAudioManager, ABattleObject, AFighterLocalRunner, AFighterMultiplayerRunner, AFighterReplayRunner, AFighterSynctestRunner, ALinkActor, ANetworkPawn, ANightSkyAIController, ANightSkyCharaSelectGameState, ANightSkyGameState, ANightSkyPlayerController, ANightSkyVSInfoGameState, ANightSkyWTGameState, ANightSkyWTPlayerController, AParticleManager, APlayerObject, AWTCharacter)</li> <li>B (ABattleObject, FBattleObjectLog)</li> <li>BlendAnimFrame (ABattleObject, FBattleObjectLog)</li> <li>BlendCelName (ABattleObject, FBattleObjectLog)</li> <li>BlendOffset (ABattleObject, FBattleObjectLog)</li> <li>Boxes (ABattleObject, FCollisionStruct)</li> <li>bIsCommonState (ABattleObject, FBattleObjectLog)</li> <li>bRender (ABattleObject, FBattleObjectLog)</li> <li>BeginGameCallback (AFighterMultiplayerRunner)</li> <li>bRematchAccepted (ANetworkPawn, ANightSkyPlayerController)</li> <li>bBlock (ANightSkyAIController)</li> <li>BottomWidget (ANightSkyBattleHudActor)</li> <li>BattleExtensionData (ANightSkyGameState)</li> <li>BattleExtensionNames (ANightSkyGameState)</li> <li>BattleExtensions (ANightSkyGameState)</li> <li>BattleHudActor (ANightSkyGameState)</li> <li>BattleHudVisibility (ANightSkyGameState, APlayerObject)</li> <li>BattleObjectClass (ANightSkyGameState)</li> <li>BattleSceneTransform (ANightSkyGameState)</li> <li>BattleState (ANightSkyGameState)</li> <li>bIsPlayingSequence (ANightSkyGameState)</li> <li>bIsResimulating (ANightSkyGameState)</li> <li>bPauseGame (ANightSkyGameState)</li> <li>bViewCollision (ANightSkyGameState)</li> <li>bRematch (ANightSkyPlayerController)</li> <li>bSentCharaData (ANightSkyPlayerController)</li> <li>bIsBattling (ANightSkyWTGameState)</li> <li>bIsMatchEnd (ANightSkyWTGameState)</li> <li>BattleParticles (AParticleManager)</li> <li>BAirDashNoAttackTime (APlayerObject, FPlayerObjectLog)</li> <li>BAirDashSpeed (APlayerObject, FPlayerObjectLog)</li> <li>BAirDashTime (APlayerObject, FPlayerObjectLog)</li> <li>BDashGravity (APlayerObject, FPlayerObjectLog)</li> <li>BDashHeight (APlayerObject, FPlayerObjectLog)</li> <li>BDashSpeed (APlayerObject, FPlayerObjectLog)</li> <li>BJumpSpeed (APlayerObject, FPlayerObjectLog)</li> <li>BSuperJumpSpeed (APlayerObject, FPlayerObjectLog)</li> <li>BWalkSpeed (APlayerObject, FPlayerObjectLog)</li> <li>BufferedStateName (APlayerObject, FPlayerObjectLog)</li> <li>bCrumpled (APlayerObject, FPlayerObjectLog)</li> <li>bIsAutoCombo (APlayerObject, FPlayerObjectLog)</li> <li>bIsCpu (APlayerObject)</li> <li>bLimitCrumple (APlayerObject, FPlayerObjectLog)</li> <li>bMirrorWhenFlip (APlayerObject)</li> <li>BattlePlayer (AWTCharacter)</li> <li>BattlePlayerClass (AWTCharacter)</li> <li>BattleFormat (FBattleData, FBattleState)</li> <li>BattlePhase (FBattleState)</li> <li>BattleStateSync (FBattleState)</li> <li>BattleStateSyncEnd (FBattleState)</li> <li>bHUDVisible (FBattleState)</li> <li>BlowbackLevel (FHitData)</li> <li>BlockType (FHitDataCommon, FStateCPUData)</li> <li>BlockstopModifier (FHitDataCommon)</li> <li>Blockstun (FHitDataCommon)</li> <li>BeginFrame (FHitValueOverTime)</li> <li>bIsActive (FLinkedActorContainer)</li> <li>bActor (FObjectRecord)</li> <li>bPlaying (FRollbackAnimation)</li> <li>BattleStateBuffer (FRollbackData)</li> <li>BattleStateData (FRollbackData)</li> <li>bTouchingWorldSide (FScreenData)</li> <li>bAntiAir (FStateCPUData)</li> <li>bAttack (FStateCPUData)</li> <li>bBigDamage (FStateCPUData)</li> <li>bBlockstring (FStateCPUData)</li> <li>bCombo (FStateCPUData)</li> <li>bInvuln (FStateCPUData)</li> <li>bNoCombo (FStateCPUData)</li> <li>bProjectile (FStateCPUData)</li> <li>bPunish (FStateCPUData)</li> <li>bThrow (FStateCPUData)</li> <li>bUsesResource (FStateCPUData)</li> <li>bPrimary (FStateMachine)</li> <li>bArmorHead (FSuperArmorData)</li> <li>bArmorLow (FSuperArmorData)</li> <li>bArmorMid (FSuperArmorData)</li> <li>bArmorOverhead (FSuperArmorData)</li> <li>bArmorProjectile (FSuperArmorData)</li> <li>bArmorStrike (FSuperArmorData)</li> <li>bArmorTakeChipDamage (FSuperArmorData)</li> <li>bArmorThrow (FSuperArmorData)</li> <li>BindingHandles (UExtendedCommonActivatableWidget)</li> <li>BP_OnFindReplaysComplete (UNightSkyGameInstance)</li> <li>BattleData (UNightSkyGameInstance, UReplaySaveInfo)</li> <li>BattleVersion (UNightSkyGameInstance)</li> <li>bIsTraining (UReplaySaveInfo)</li> <li>bCPUUsable (UState)</li> <li>bEnableReverseBeat (UState)</li> <li>bHumanUsable (UState)</li> </ul>"},{"location":"NightSkyEngine/class_members/#c","title":"c","text":"<ul> <li>CharaAudioPlayers (AAudioManager)</li> <li>CharaVoicePlayers (AAudioManager)</li> <li>CommonAudioPlayers (AAudioManager)</li> <li>CalculateAngleBetweenPoints (ABattleObject)</li> <li>CalculateDistanceBetweenPoints (ABattleObject)</li> <li>CalculateHoming (ABattleObject)</li> <li>CalculatePushbox (ABattleObject)</li> <li>CalculateSpeedAngle (ABattleObject)</li> <li>CallSubroutine (ABattleObject)</li> <li>CallSubroutineWithArgs (ABattleObject)</li> <li>CameraShake (ABattleObject, ANightSkyGameState, FCameraShakeStruct)</li> <li>CelIndex (ABattleObject, FBattleObjectLog, UState)</li> <li>CelName (ABattleObject, FBattleObjectLog, FCollisionStruct)</li> <li>CharaSelectGameState (ABattleObject)</li> <li>CheckBoxOverlap (ABattleObject)</li> <li>CheckIsGrounded (ABattleObject)</li> <li>ColPosX (ABattleObject, FBattleObjectLog)</li> <li>ColPosY (ABattleObject, FBattleObjectLog)</li> <li>CollisionView (ABattleObject, ANightSkyGameState)</li> <li>CounterHit (ABattleObject, FBattleObjectLog)</li> <li>CreateCharaParticle (ABattleObject)</li> <li>CreateCommonParticle (ABattleObject)</li> <li>CreateCallbacks (AFighterMultiplayerRunner)</li> <li>connectionManager (AFighterMultiplayerRunner)</li> <li>CharaDataReceived (ANetworkPawn)</li> <li>ClientChecksumCheck (ANetworkPawn)</li> <li>ClientGetBattleData (ANetworkPawn)</li> <li>ClientGetCharaData (ANetworkPawn)</li> <li>CheckAttackWeight (ANightSkyAIController)</li> <li>CheckBasicWeight (ANightSkyAIController)</li> <li>CheckDefenseWeight (ANightSkyAIController)</li> <li>CallAssist (ANightSkyGameState, APlayerObject)</li> <li>CallBattleExtension (ANightSkyGameState)</li> <li>CameraActor (ANightSkyGameState)</li> <li>CanTag (ANightSkyGameState)</li> <li>Checksum (ANightSkyGameState)</li> <li>CreateChecksum (ANightSkyGameState)</li> <li>ClosePauseMenu (ANightSkyPlayerController)</li> <li>CameraShakeData (APlayerObject)</li> <li>CanEnterState (APlayerObject, UState)</li> <li>CanProximityThrow (APlayerObject, FPlayerObjectLog)</li> <li>CanReverseBeat (APlayerObject, FPlayerObjectLog)</li> <li>CancelFlags (APlayerObject, FPlayerObjectLog)</li> <li>ChainCancelOptions (APlayerObject)</li> <li>CharaParticleData (APlayerObject)</li> <li>CharaStateData (APlayerObject)</li> <li>CharaSubroutineData (APlayerObject)</li> <li>CheckEnemyInRange (APlayerObject)</li> <li>CheckHasHit (APlayerObject)</li> <li>CheckInput (APlayerObject)</li> <li>CheckIsAttacking (APlayerObject)</li> <li>CheckIsStunned (APlayerObject)</li> <li>CheckKaraCancel (APlayerObject)</li> <li>CheckMovesUsedInChain (APlayerObject)</li> <li>CheckObjectPreventingState (APlayerObject)</li> <li>CheckReverseBeat (APlayerObject)</li> <li>CheckStateEnabled (APlayerObject)</li> <li>CloseNormalRange (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg1 (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg2 (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg3 (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg4 (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg5 (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg6 (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg7 (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg8 (APlayerObject, FPlayerObjectLog)</li> <li>CollisionData (APlayerObject)</li> <li>ColorIndex (APlayerObject)</li> <li>ComboCounter (APlayerObject, FPlayerObjectLog)</li> <li>ComboRate (APlayerObject, FPlayerObjectLog)</li> <li>ComboTimer (APlayerObject, FPlayerObjectLog)</li> <li>CommonCollisionData (APlayerObject)</li> <li>CommonLinkActorData (APlayerObject)</li> <li>CommonObjectStateData (APlayerObject)</li> <li>CommonObjectStateNames (APlayerObject)</li> <li>CommonObjectStates (APlayerObject)</li> <li>CommonParticleData (APlayerObject)</li> <li>CommonSequenceData (APlayerObject)</li> <li>CommonSoundData (APlayerObject)</li> <li>CommonSubroutineData (APlayerObject)</li> <li>CommonSubroutineNames (APlayerObject)</li> <li>CommonSubroutines (APlayerObject)</li> <li>ComponentVisible (APlayerObject, FPlayerObjectLog)</li> <li>CrouchPushHeight (APlayerObject, FPlayerObjectLog)</li> <li>CrouchPushWidth (APlayerObject, FPlayerObjectLog)</li> <li>CurrentAirDashCount (APlayerObject, FPlayerObjectLog)</li> <li>CurrentAirJumpCount (APlayerObject, FPlayerObjectLog)</li> <li>CurrentHealth (APlayerObject, FPlayerObjectLog)</li> <li>ColorIndicesP1 (FBattleData)</li> <li>ColorIndicesP2 (FBattleData)</li> <li>CameraPosition (FBattleState)</li> <li>CharaAudioChannels (FBattleState)</li> <li>CharaVoiceChannels (FBattleState)</li> <li>CommonAudioChannels (FBattleState)</li> <li>CurrentIntroSide (FBattleState)</li> <li>CurrentSequenceTime (FBattleState)</li> <li>CurrentWinSide (FBattleState)</li> <li>CustomType (FCollisionBox)</li> <li>CustomHitAction (FHitData)</li> <li>ChipDamagePercent (FHitDataCommon)</li> <li>CheckInputCondition (FInputBuffer)</li> <li>CheckInputSequence (FInputBuffer)</li> <li>CheckInputSequenceNegative (FInputBuffer)</li> <li>CheckInputSequenceNegativeStrict (FInputBuffer)</li> <li>CheckInputSequenceOnce (FInputBuffer)</li> <li>CheckInputSequenceOnceStrict (FInputBuffer)</li> <li>CheckInputSequencePressAndRelease (FInputBuffer)</li> <li>CheckInputSequencePressAndReleaseStrict (FInputBuffer)</li> <li>CheckInputSequenceStrict (FInputBuffer)</li> <li>Class (FObjectRecord)</li> <li>CharBuffer (FRollbackData)</li> <li>CenterXVelocity (FScreenData)</li> <li>CenterYVelocity (FScreenData)</li> <li>CheckStateStanceCondition (FStateMachine)</li> <li>CurrentState (FStateMachine)</li> <li>CooldownTimer (FTeamData)</li> <li>CameraShakeStructs (UCameraShakeData)</li> <li>CollisionFrames (UCollisionData)</li> <li>CreateSession (UNSESessionSubsystem)</li> <li>CreateSessionCompleteDelegate (UNSESessionSubsystem)</li> <li>CreateSessionCompleteDelegateHandle (UNSESessionSubsystem)</li> <li>CreateRootMontage (UNightSkyAnimInstance)</li> <li>CurrentAnimTime (UNightSkyAnimInstance)</li> <li>CachedBoneNames (UNightSkyAnimMetaData)</li> <li>Cos_x1000 (UNightSkyBlueprintFunctionLibrary)</li> <li>CurrentReplay (UNightSkyGameInstance)</li> <li>CharaDescription (UPrimaryCharaData)</li> <li>CharaFriendlyName (UPrimaryCharaData)</li> <li>CharaHUDIcon (UPrimaryCharaData)</li> <li>CharaName (UPrimaryCharaData)</li> <li>CharaSelectIcon (UPrimaryCharaData)</li> <li>CharaSplashIcon (UPrimaryCharaData)</li> <li>CPUData (UState)</li> <li>CallExec (UState, UStateAlias, USubroutineState)</li> <li>CustomStateType (UState)</li> </ul>"},{"location":"NightSkyEngine/class_members/#d","title":"d","text":"<ul> <li>DamageColor (ABattleObject, FBattleObjectLog, FHitDataCommon)</li> <li>DamageColor2 (ABattleObject, FBattleObjectLog, FHitDataCommon)</li> <li>DeactivateObject (ABattleObject)</li> <li>DetachFromSocket (ABattleObject)</li> <li>Direction (ABattleObject, FBattleObjectLog)</li> <li>DisableInertia (ABattleObject)</li> <li>DrawPriority (ABattleObject, FBattleObjectLog)</li> <li>DrawPriorityLinkObj (ABattleObject, FBattleObjectLog)</li> <li>DamageReactionCels (APlayerObject)</li> <li>DisableAll (APlayerObject)</li> <li>DisableCustomState (APlayerObject)</li> <li>DisableState (APlayerObject)</li> <li>Damage (FHitData)</li> <li>DeathCamOverride (FHitDataCommon)</li> <li>DisallowedInputs (FInputBitmask, FInputBuffer, FInputCondition)</li> <li>Data (FObjectRecord, UNightSkySaveInfo)</li> <li>DefaultMaxWidth (FScreenData)</li> <li>DefaultWidth (FScreenData)</li> <li>DefaultInputConfig (UExtendedCommonActivatableWidget)</li> <li>DestroySession (UNSESessionSubsystem)</li> <li>DestroySessionCompleteDelegate (UNSESessionSubsystem)</li> <li>DestroySessionCompleteDelegateHandle (UNSESessionSubsystem)</li> <li>DeleteReplay (UNightSkyGameInstance)</li> </ul>"},{"location":"NightSkyEngine/class_members/#e","title":"e","text":"<ul> <li>EnableDeactivateIfBeyondBounds (ABattleObject)</li> <li>EnableDeactivateOnReceiveHit (ABattleObject)</li> <li>EnableDeactivateOnStateChange (ABattleObject)</li> <li>EnableFlip (ABattleObject)</li> <li>EnableHit (ABattleObject)</li> <li>EnableInertia (ABattleObject)</li> <li>EventHandlers (ABattleObject, FBattleObjectLog)</li> <li>ElapsedTime (AFighterLocalRunner)</li> <li>EndPlay (AFighterMultiplayerRunner, ANightSkyGameState)</li> <li>Exit (ALinkActor)</li> <li>EndMatch (ANightSkyGameState, APlayerObject)</li> <li>EndMatch_BP (ANightSkyGameState)</li> <li>EditorUpdate (APlayerObject)</li> <li>EmptyStateMachine (APlayerObject)</li> <li>EnableAll (APlayerObject)</li> <li>EnableAttacks (APlayerObject)</li> <li>EnableCancelIntoSelf (APlayerObject)</li> <li>EnableChainCancel (APlayerObject)</li> <li>EnableCustomState (APlayerObject)</li> <li>EnableForwardAirdashCancel (APlayerObject)</li> <li>EnableJumpCancel (APlayerObject)</li> <li>EnableReverseBeat (APlayerObject)</li> <li>EnableSpecialCancel (APlayerObject)</li> <li>EnableState (APlayerObject)</li> <li>EnableSuperCancel (APlayerObject)</li> <li>EnableWhiffCancel (APlayerObject)</li> <li>EndRound (APlayerObject)</li> <li>Enemy (APlayerObject, FPlayerObjectLog)</li> <li>ExeStateName (APlayerObject, FPlayerObjectLog)</li> <li>ExtraGauges (APlayerObject)</li> <li>EndBattle (AWTCharacter)</li> <li>EndBattle_BP (AWTCharacter)</li> <li>EnemyHitstopModifier (FHitData)</li> <li>EnemyBlockstopModifier (FHitDataCommon)</li> <li>EndFrame (FHitValueOverTime)</li> <li>Emplace (FInputBuffer)</li> <li>ExtensionData (FRollbackData)</li> <li>EnableFlags (FStateMachine)</li> <li>EnabledCustomStateTypes (FStateMachine)</li> <li>Exec (UBattleExtension, UState, USubroutine)</li> <li>ExtensionArray (UBattleExtensionData)</li> <li>EndRecordReplay (UNightSkyGameInstance)</li> <li>EntryStance (UState)</li> </ul>"},{"location":"NightSkyEngine/class_members/#f","title":"f","text":"<ul> <li>FaceOpponent (ABattleObject)</li> <li>FadeTransparency (ABattleObject, FBattleObjectLog)</li> <li>FlipObject (ABattleObject)</li> <li>FrameBlendPosition (ABattleObject, FBattleObjectLog)</li> <li>FuncCall (ABattleObject)</li> <li>FreeBuffer (AFighterMultiplayerRunner)</li> <li>fletcher32_checksum (AFighterMultiplayerRunner)</li> <li>FighterMultiplayerRunner (ANetworkPawn)</li> <li>FighterRunner (ANightSkyGameState, UNightSkyGameInstance)</li> <li>Frame (ANightSkyPlayerController)</li> <li>FAirDashNoAttackTime (APlayerObject, FPlayerObjectLog)</li> <li>FAirDashSpeed (APlayerObject, FPlayerObjectLog)</li> <li>FAirDashTime (APlayerObject, FPlayerObjectLog)</li> <li>FDashAccel (APlayerObject, FPlayerObjectLog)</li> <li>FDashFriction (APlayerObject, FPlayerObjectLog)</li> <li>FDashInitSpeed (APlayerObject, FPlayerObjectLog)</li> <li>FDashMaxSpeed (APlayerObject, FPlayerObjectLog)</li> <li>FJumpSpeed (APlayerObject, FPlayerObjectLog)</li> <li>FSuperJumpSpeed (APlayerObject, FPlayerObjectLog)</li> <li>FWalkSpeed (APlayerObject, FPlayerObjectLog)</li> <li>FindAutoComboCancelOption (APlayerObject)</li> <li>FindChainCancelOption (APlayerObject)</li> <li>FindWhiffCancelOption (APlayerObject)</li> <li>FlipInput (APlayerObject)</li> <li>FlipInputs (APlayerObject, FPlayerObjectLog)</li> <li>ForceEnableFarNormal (APlayerObject)</li> <li>ForwardAirDashMeterGain (APlayerObject, FPlayerObjectLog)</li> <li>ForwardDashMeterGain (APlayerObject, FPlayerObjectLog)</li> <li>ForwardJumpMeterGain (APlayerObject, FPlayerObjectLog)</li> <li>ForwardWalkMeterGain (APlayerObject, FPlayerObjectLog)</li> <li>Flipbook (FAnimStruct, FFlipbookStruct)</li> <li>Finished (FAudioChannel)</li> <li>FBattleParticle (FBattleParticle)</li> <li>FadeTimer (FBattleState)</li> <li>FrameNumber (FBattleState)</li> <li>FunctionName (FEventHandler)</li> <li>FloatingCrumpleType (FHitData)</li> <li>ForcedProration (FHitData)</li> <li>FInputBitmask (FInputBitmask)</li> <li>FlipInputsInBuffer (FInputBuffer)</li> <li>FNSESessionInfo (FNSESessionInfo)</li> <li>FNightSkySaveArchive (FNightSkySaveArchive)</li> <li>FObjectRecord (FObjectRecord)</li> <li>FRandomManager (FRandomManager)</li> <li>FinalScreenWidth (FScreenData)</li> <li>FinalScreenX (FScreenData)</li> <li>FinalScreenY (FScreenData)</li> <li>Flags (FScreenData)</li> <li>ForceRollbackState (FStateMachine)</li> <li>ForceSetState (FStateMachine)</li> <li>FlipbookStructs (UFlipbookData)</li> <li>FindSessions (UNSESessionSubsystem)</li> <li>FindSessionsCompleteDelegate (UNSESessionSubsystem)</li> <li>FindSessionsCompleteDelegateHandle (UNSESessionSubsystem)</li> <li>FrameCount (UNightSkyAnimSequenceUserData)</li> <li>FrameRate (UNightSkyAnimSequenceUserData)</li> <li>FindReplays (UNightSkyGameInstance)</li> <li>FinishedLoadingForNetworkBattle (UNightSkyGameInstance)</li> </ul>"},{"location":"NightSkyEngine/class_members/#g","title":"g","text":"<ul> <li>GameState (ABattleObject, AFighterLocalRunner, ANightSkyAIController, AWTCharacter)</li> <li>GenerateRandomNumber (ABattleObject, FRandomManager)</li> <li>GetAnimSequenceForPart (ABattleObject)</li> <li>GetAnimSequenceUserData (ABattleObject)</li> <li>GetAnimSequenceUserDatas (ABattleObject)</li> <li>GetBattleObject (ABattleObject)</li> <li>GetBoxPosition (ABattleObject)</li> <li>GetBoxes (ABattleObject)</li> <li>GetCelName (ABattleObject)</li> <li>GetFlipbookForPart (ABattleObject)</li> <li>GetGauge (ABattleObject, ANightSkyGameState)</li> <li>GetLabelName (ABattleObject)</li> <li>GetPosYCenter (ABattleObject)</li> <li>GotoLabel (ABattleObject)</li> <li>GotoLabelActive (ABattleObject, FBattleObjectLog)</li> <li>Gravity (ABattleObject, FBattleObjectLog, FHitData)</li> <li>GroundHeight (ABattleObject, FBattleObjectLog)</li> <li>GgpoUpdate (AFighterMultiplayerRunner)</li> <li>ggpo (AFighterMultiplayerRunner)</li> <li>GameInstance (AFighterReplayRunner, ANightSkyCharaSelectGameState, ANightSkyGameState, ANightSkyVSInfoGameState)</li> <li>GetLifetimeReplicatedProps (ANetworkPawn)</li> <li>GetEnemyDistanceX (ANightSkyAIController)</li> <li>GetEnemyDistanceY (ANightSkyAIController)</li> <li>GetLocalInputs (ANightSkyGameState)</li> <li>GetMainPlayer (ANightSkyGameState)</li> <li>GetNetworkStats (ANightSkyGameState)</li> <li>GetPaused (ANightSkyGameState)</li> <li>GetScreenFlags (ANightSkyGameState)</li> <li>GetTeam (ANightSkyGameState)</li> <li>GetTeamCount (ANightSkyGameState)</li> <li>GetAttackBlockType (APlayerObject)</li> <li>GetCurrentStateName (APlayerObject)</li> <li>GetEnableFlags (APlayerObject)</li> <li>GetLastStateName (APlayerObject)</li> <li>GetStateEntryName (APlayerObject)</li> <li>GetStateMachine (APlayerObject)</li> <li>GaugeP1 (FBattleState)</li> <li>GaugeP2 (FBattleState)</li> <li>GroundBounceCount (FGroundBounceData)</li> <li>GroundBounceGravity (FGroundBounceData)</li> <li>GroundBounceStop (FGroundBounceData)</li> <li>GroundBounceUntech (FGroundBounceData)</li> <li>GroundBounceXRate (FGroundBounceData)</li> <li>GroundBounceXSpeed (FGroundBounceData)</li> <li>GroundBounceYRate (FGroundBounceData)</li> <li>GroundBounceYSpeed (FGroundBounceData)</li> <li>GravityOverTime (FHitData)</li> <li>GroundBounce (FHitData)</li> <li>GroundHitAction (FHitData)</li> <li>GroundPushbackX (FHitData)</li> <li>GroundGuardPushbackX (FHitDataCommon)</li> <li>GuardGravity (FHitDataCommon)</li> <li>GuardSFX (FHitDataCommon)</li> <li>GuardSFXOverride (FHitDataCommon)</li> <li>GuardVFX (FHitDataCommon)</li> <li>GuardVFXOverride (FHitDataCommon)</li> <li>GetSeed (FRandomManager)</li> <li>GetStateIndex (FStateMachine)</li> <li>GetStateName (FStateMachine)</li> <li>GetByCelName (UCollisionData)</li> <li>GetIndexByCelName (UCollisionData)</li> <li>GameMouseCaptureMode (UExtendedCommonActivatableWidget)</li> <li>GetDesiredInputConfig (UExtendedCommonActivatableWidget)</li> <li>GetCachedBoneLocationAtTime (UNightSkyAnimSequenceUserData)</li> <li>GetCachedBoneTransformAtTime (UNightSkyAnimSequenceUserData)</li> <li>GetFrameCount (UNightSkyAnimSequenceUserData)</li> <li>GetFrameRate (UNightSkyAnimSequenceUserData)</li> <li>GetRootTranslationAtTime (UNightSkyAnimSequenceUserData)</li> <li>GameVersion (UNightSkyGameInstance)</li> <li>GlobalIlluminationMethod (UNightSkySettingsInfo)</li> <li>GetPrimaryAssetId (UPrimaryCharaData, UPrimaryStageData)</li> <li>GetByStateName (UStateData)</li> </ul>"},{"location":"NightSkyEngine/class_members/#h","title":"h","text":"<ul> <li>HaltMomentum (ABattleObject)</li> <li>HandleClashCollision (ABattleObject)</li> <li>HandleCustomCollision_PostHit (ABattleObject)</li> <li>HandleCustomCollision_PreHit (ABattleObject)</li> <li>HandleFlip (ABattleObject)</li> <li>HandleHitCollision (ABattleObject, ANightSkyGameState)</li> <li>HandlePushCollision (ABattleObject, ANightSkyGameState)</li> <li>HitCommon (ABattleObject, FBattleObjectLog)</li> <li>Hitstop (ABattleObject, FBattleObjectLog, FHitData)</li> <li>HomingParams (ABattleObject, FBattleObjectLog)</li> <li>HUDInit (ANightSkyGameState)</li> <li>HandleMatchWin (ANightSkyGameState)</li> <li>HandleRoundWin (ANightSkyGameState)</li> <li>HandleAutoCombo (APlayerObject)</li> <li>HandleBlockAction (APlayerObject)</li> <li>HandleBufferedState (APlayerObject)</li> <li>HandleEndCombo (APlayerObject)</li> <li>HandleFlipInput (APlayerObject)</li> <li>HandleGroundBounce (APlayerObject)</li> <li>HandleHitAction (APlayerObject)</li> <li>HandleLanding (APlayerObject)</li> <li>HandleProximityBlock (APlayerObject)</li> <li>HandleStateCondition (APlayerObject)</li> <li>HandleStateInputs (APlayerObject)</li> <li>HandleStateMachine (APlayerObject)</li> <li>HandleStateTransition (APlayerObject)</li> <li>HandleThrowCollision (APlayerObject)</li> <li>HandleWallBounce (APlayerObject)</li> <li>HardKnockdown (FHitData)</li> <li>Hitstun (FHitData)</li> <li>HitAngle (FHitDataCommon)</li> <li>HitSFX (FHitDataCommon)</li> <li>HitSFXOverride (FHitDataCommon)</li> <li>HitVFX (FHitDataCommon)</li> <li>HitVFXOverride (FHitDataCommon)</li> <li>Handle (FInputActionBindingHandle)</li> <li>Hold (FInputBitmask)</li> <li>HigherObjBottom (FScreenData)</li> </ul>"},{"location":"NightSkyEngine/class_members/#i","title":"i","text":"<ul> <li>IgnoreSuperFreeze (ABattleObject)</li> <li>Inertia (ABattleObject, FBattleObjectLog)</li> <li>InitEventHandler (ABattleObject)</li> <li>InitHitDataByAttackLevel (ABattleObject)</li> <li>InitObject (ABattleObject)</li> <li>IsActive (ABattleObject, FBattleObjectLog)</li> <li>IsPlayer (ABattleObject, FBattleObjectLog)</li> <li>IsStopped (ABattleObject)</li> <li>IsTimerPaused (ABattleObject)</li> <li>Init (ALinkActor, ANightSkyGameState, ANightSkyWTGameState, UNightSkyGameInstance, UState)</li> <li>InputCount (ANightSkyAIController)</li> <li>InputCountLimit (ANightSkyAIController)</li> <li>IsTagBattle (ANightSkyGameState)</li> <li>InputActions (ANightSkyPlayerController)</li> <li>InputMapping (ANightSkyPlayerController)</li> <li>Inputs (ANightSkyPlayerController, APlayerObject, FPlayerObjectLog)</li> <li>InitBP (APlayerObject)</li> <li>InitPlayer (APlayerObject)</li> <li>InstantBlockLockoutTimer (APlayerObject, FPlayerObjectLog)</li> <li>IntroEndFlag (APlayerObject, FPlayerObjectLog)</li> <li>IntroName (APlayerObject, FPlayerObjectLog)</li> <li>InvulnFlags (APlayerObject, FPlayerObjectLog)</li> <li>IsCorrectBlock (APlayerObject)</li> <li>IsEnemyAttackState (APlayerObject)</li> <li>IsEnemyBlocking (APlayerObject)</li> <li>IsEnemyThrow (APlayerObject)</li> <li>IsInvulnerable (APlayerObject)</li> <li>IsInvulnerable_BP (APlayerObject)</li> <li>IsMainPlayer (APlayerObject)</li> <li>IsOnScreen (APlayerObject)</li> <li>IsTouchingWall (APlayerObject)</li> <li>IsPlayingSequence (FBattleState)</li> <li>InitialValue (FExtraGauge)</li> <li>InitialProration (FHitData)</li> <li>InputFlag (FInputBitmask)</li> <li>ImpreciseInputCount (FInputBuffer, FInputCondition)</li> <li>InputBufferInternal (FInputBuffer)</li> <li>InputSequence (FInputBuffer)</li> <li>InputTime (FInputBuffer)</li> <li>InputConditions (FInputConditionList)</li> <li>Index (FLinkedActorContainer)</li> <li>IsCurrentState (FStateMachine)</li> <li>IsLoggedIn (UNSESessionSubsystem)</li> <li>IsCPUBattle (UNightSkyGameInstance)</li> <li>IsReplay (UNightSkyGameInstance)</li> <li>IsTraining (UNightSkyGameInstance)</li> <li>InputsP1 (UReplaySaveInfo)</li> <li>InputsP2 (UReplaySaveInfo)</li> <li>InputConditionLists (UState)</li> <li>IsFollowupState (UState)</li> </ul>"},{"location":"NightSkyEngine/class_members/#j","title":"j","text":"<ul> <li>JumpGravity (APlayerObject, FPlayerObjectLog)</li> <li>JumpHeight (APlayerObject, FPlayerObjectLog)</li> <li>JumpToState (APlayerObject)</li> <li>JumpToStateByClass (APlayerObject)</li> <li>JumpToStateByClassPrimary (APlayerObject)</li> <li>JumpToStatePrimary (APlayerObject)</li> <li>JoinGameSession (UNSESessionSubsystem)</li> <li>JoinGameSession_BP (UNSESessionSubsystem)</li> <li>JoinSessionCompleteDelegate (UNSESessionSubsystem)</li> <li>JoinSessionCompleteDelegateHandle (UNSESessionSubsystem)</li> </ul>"},{"location":"NightSkyEngine/class_members/#k","title":"k","text":"<ul> <li>KnockdownTime (FHitData)</li> </ul>"},{"location":"NightSkyEngine/class_members/#l","title":"l","text":"<ul> <li>L (ABattleObject, FBattleObjectLog)</li> <li>LabelName (ABattleObject, FBattleObjectLog)</li> <li>LinkActor (ABattleObject)</li> <li>LinkCharaParticle (ABattleObject)</li> <li>LinkCommonParticle (ABattleObject)</li> <li>LinkedActor (ABattleObject)</li> <li>LinkedParticle (ABattleObject)</li> <li>LoadForRollback (ABattleObject, ANightSkyGameState, UNightSkyBattleWidget, USerializableObj)</li> <li>LoadGameStateCallback (AFighterMultiplayerRunner)</li> <li>LogGameState (AFighterMultiplayerRunner)</li> <li>LoadGameState (ANightSkyGameState)</li> <li>LocalFrame (ANightSkyGameState)</li> <li>LocalInputs (ANightSkyGameState)</li> <li>LoadedCharaPackageCount (ANightSkyVSInfoGameState)</li> <li>LastStateName (APlayerObject, FPlayerObjectLog)</li> <li>LinkActorData (APlayerObject)</li> <li>LoadForRollbackBP (APlayerObject)</li> <li>LoadForRollbackPlayer (APlayerObject)</li> <li>LogForSyncTestFile (FBattleObjectLog, FPlayerObjectLog)</li> <li>Lenience (FInputBitmask)</li> <li>LinkedActorStructs (ULinkActorData)</li> <li>LastSessionSearch (UNSESessionSubsystem)</li> <li>LastSessionSettings (UNSESessionSubsystem)</li> <li>Login (UNSESessionSubsystem)</li> <li>LoginDelegateHandle (UNSESessionSubsystem)</li> <li>LoadReplay (UNightSkyGameInstance)</li> <li>LoadData (UNightSkySaveInfo)</li> <li>LengthInFrames (UReplaySaveInfo)</li> </ul>"},{"location":"NightSkyEngine/class_members/#m","title":"m","text":"<ul> <li>MusicPlayer (AAudioManager)</li> <li>MaterialLinkObj (ABattleObject, FBattleObjectLog)</li> <li>MaxCelTime (ABattleObject, FBattleObjectLog)</li> <li>MiscFlags (ABattleObject, FBattleObjectLog)</li> <li>Move (ABattleObject)</li> <li>MulColor (ABattleObject, FBattleObjectLog)</li> <li>MulFadeColor (ABattleObject, FBattleObjectLog)</li> <li>MulFadeSpeed (ABattleObject, FBattleObjectLog)</li> <li>MultipliedFramesAhead (AFighterMultiplayerRunner)</li> <li>MultipliedFramesBehind (AFighterMultiplayerRunner)</li> <li>ManageAudio (ANightSkyGameState)</li> <li>MatchInit (ANightSkyGameState)</li> <li>MaxBattleObjects (ANightSkyGameState)</li> <li>MapLoaded (ANightSkyVSInfoGameState)</li> <li>MaxVSInfoTime (ANightSkyVSInfoGameState)</li> <li>MaterialData (APlayerObject)</li> <li>MaxColorIndex (APlayerObject)</li> <li>MaxHealth (APlayerObject, FPlayerObjectLog)</li> <li>MaxMeter (APlayerObject, FBattleState, FPlayerObjectLog)</li> <li>MaxOTGCount (APlayerObject, FPlayerObjectLog)</li> <li>MeterCooldownTimer (APlayerObject, FPlayerObjectLog)</li> <li>MeterPercentOnHit (APlayerObject, FPlayerObjectLog)</li> <li>MeterPercentOnHitGuard (APlayerObject, FPlayerObjectLog)</li> <li>MeterPercentOnReceiveHit (APlayerObject, FPlayerObjectLog)</li> <li>MeterPercentOnReceiveHitGuard (APlayerObject, FPlayerObjectLog)</li> <li>MovesUsedInChain (APlayerObject)</li> <li>MovesUsedInCombo (APlayerObject)</li> <li>MaxDuration (FAudioChannel, FSoundStruct)</li> <li>MusicName (FBattleData)</li> <li>MainPlayer (FBattleState)</li> <li>MaxFadeTimer (FBattleState)</li> <li>MaxGauge (FBattleState)</li> <li>MaxRoundCount (FBattleState)</li> <li>MaxTimeUntilRoundStart (FBattleState)</li> <li>Meter (FBattleState)</li> <li>MusicChannel (FBattleState)</li> <li>MaxValue (FExtraGauge)</li> <li>MinimumDamagePercent (FHitData)</li> <li>Method (FInputCondition)</li> <li>MaxInstances (FLinkActorStruct, UState)</li> <li>Material (FMaterialStruct)</li> <li>MaxZoomOutWidth (FScreenData)</li> <li>MaterialStructs (UMaterialData)</li> <li>Montage_Advance (UNightSkyAnimInstance)</li> <li>MeshSpaceBoneTransforms (UNightSkyAnimSequenceUserData)</li> <li>MusicData (UNightSkyGameInstance)</li> <li>MaxChain (UState)</li> </ul>"},{"location":"NightSkyEngine/class_members/#n","title":"n","text":"<ul> <li>NextOffsetX (ABattleObject, FBattleObjectLog)</li> <li>NextOffsetY (ABattleObject, FBattleObjectLog)</li> <li>NormalHit (ABattleObject, FBattleObjectLog)</li> <li>NormalizeAngle (ABattleObject)</li> <li>NetworkStats (ANightSkyGameState)</li> <li>NextRoundTransition (ANightSkyGameState)</li> <li>NetworkPawn (ANightSkyPlayerController)</li> <li>NiagaraComponent (FBattleParticle)</li> <li>Name (FCameraShakeStruct, FFlipbookStruct, FLinkActorStruct, FLinkedActorContainer, FMaterialStruct, FObjectRecord, FParticleStruct, FSequenceStruct, FSoundStruct, UBattleExtension, UState, USubroutine)</li> <li>NumOpenPrivateConnections (FNSESessionInfo)</li> <li>NumOpenPublicConnections (FNSESessionInfo)</li> <li>NativeDestruct (UExtendedCommonActivatableWidget)</li> </ul>"},{"location":"NightSkyEngine/class_members/#o","title":"o","text":"<ul> <li>ObjNumber (ABattleObject)</li> <li>ObjSync (ABattleObject, FBattleObjectLog)</li> <li>ObjSyncEnd (ABattleObject, FBattleObjectLog)</li> <li>ObjectID (ABattleObject, FBattleObjectLog, UState)</li> <li>ObjectOffset (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg1 (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg2 (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg3 (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg4 (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg5 (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg6 (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg7 (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg8 (ABattleObject, FBattleObjectLog)</li> <li>ObjectRotation (ABattleObject, FBattleObjectLog)</li> <li>ObjectScale (ABattleObject, FBattleObjectLog)</li> <li>ObjectState (ABattleObject)</li> <li>ObjectStateIndex (ABattleObject, FBattleObjectLog)</li> <li>ObjectStateName (ABattleObject, FBattleObjectLog)</li> <li>ObjectsToIgnoreHitsFrom (ABattleObject)</li> <li>OrthoBlendActive (ABattleObject, FBattleState)</li> <li>OnEventCallback (AFighterMultiplayerRunner)</li> <li>Objects (ANightSkyGameState)</li> <li>OtherChecksum (ANightSkyGameState)</li> <li>OtherChecksumFrame (ANightSkyGameState)</li> <li>OpenPauseMenu (ANightSkyPlayerController)</li> <li>OnCharaPackageLoaded (ANightSkyVSInfoGameState)</li> <li>OnMapPackageLoaded (ANightSkyVSInfoGameState)</li> <li>OnBattleEndDelegate (ANightSkyWTGameState)</li> <li>OTGCount (APlayerObject, FPlayerObjectLog)</li> <li>ObjectStateData (APlayerObject)</li> <li>ObjectStateNames (APlayerObject)</li> <li>ObjectStates (APlayerObject)</li> <li>OnStateChange (APlayerObject)</li> <li>OtgProration (APlayerObject, FPlayerObjectLog)</li> <li>operator!= (FCollisionBox)</li> <li>OffsetX (FHomingParams)</li> <li>OffsetY (FHomingParams)</li> <li>OverlayMaterial (FMaterialStruct)</li> <li>OwningUserName (FNSESessionInfo)</li> <li>Outer (FObjectRecord)</li> <li>OuterID (FObjectRecord)</li> <li>ObjActive (FRollbackData)</li> <li>ObjBuffer (FRollbackData)</li> <li>ObjBottom (FScreenData)</li> <li>ObjDistanceY (FScreenData)</li> <li>ObjHeight (FScreenData)</li> <li>ObjLeft (FScreenData)</li> <li>ObjLength (FScreenData)</li> <li>ObjRight (FScreenData)</li> <li>ObjTop (FScreenData)</li> <li>OnCreateSessionComplete (UNSESessionSubsystem)</li> <li>OnCreateSessionCompleteDelegate (UNSESessionSubsystem)</li> <li>OnDestroySessionComplete (UNSESessionSubsystem)</li> <li>OnDestroySessionCompleteEvent (UNSESessionSubsystem)</li> <li>OnFindSessionsComplete (UNSESessionSubsystem)</li> <li>OnFindSessionsCompleteEvent (UNSESessionSubsystem)</li> <li>OnJoinGameSessionCompleteEvent (UNSESessionSubsystem)</li> <li>OnJoinSessionComplete (UNSESessionSubsystem)</li> <li>OnLoginCompleted (UNSESessionSubsystem)</li> <li>OnSessionInviteAccepted (UNSESessionSubsystem)</li> <li>OnStartSessionComplete (UNSESessionSubsystem)</li> <li>OnStartSessionCompleteEvent (UNSESessionSubsystem)</li> <li>OnUpdateSessionComplete (UNSESessionSubsystem)</li> <li>OnUpdateSessionCompleteEvent (UNSESessionSubsystem)</li> <li>ObjectRecords (UNightSkySaveInfo)</li> </ul>"},{"location":"NightSkyEngine/class_members/#p","title":"p","text":"<ul> <li>PauseAllAudio (AAudioManager)</li> <li>PlayCharaSound (ABattleObject)</li> <li>PlayCommonSound (ABattleObject)</li> <li>Player (ABattleObject, ANightSkyAIController, FBattleObjectLog)</li> <li>PosTypeToPosition (ABattleObject)</li> <li>PosX (ABattleObject, FBattleObjectLog, FCollisionBox, FHitPosition)</li> <li>PosY (ABattleObject, FBattleObjectLog, FCollisionBox, FHitPosition)</li> <li>PosZ (ABattleObject, FBattleObjectLog)</li> <li>PositionLinkObj (ABattleObject, FBattleObjectLog)</li> <li>PositionLinkUpdate (ABattleObject)</li> <li>PrevOffsetX (ABattleObject, FBattleObjectLog)</li> <li>PrevOffsetY (ABattleObject, FBattleObjectLog)</li> <li>PrevPosX (ABattleObject, FBattleObjectLog)</li> <li>PrevPosY (ABattleObject, FBattleObjectLog)</li> <li>PrevPosZ (ABattleObject, FBattleObjectLog)</li> <li>PrevRootMotionX (ABattleObject, FBattleObjectLog)</li> <li>PrevRootMotionY (ABattleObject, FBattleObjectLog)</li> <li>PrevRootMotionZ (ABattleObject, FBattleObjectLog)</li> <li>PushHeight (ABattleObject, FBattleObjectLog)</li> <li>PushHeightLow (ABattleObject, FBattleObjectLog)</li> <li>PushWidth (ABattleObject, FBattleObjectLog)</li> <li>PushWidthExtend (ABattleObject, FBattleObjectLog)</li> <li>Pushback (ABattleObject, FBattleObjectLog)</li> <li>PlayerHandles (AFighterMultiplayerRunner)</li> <li>PlayerInputIndex (AFighterMultiplayerRunner)</li> <li>Players (AFighterMultiplayerRunner, ANightSkyGameState)</li> <li>P1Charas (ANightSkyCharaSelectGameState)</li> <li>P1Positions (ANightSkyCharaSelectGameState)</li> <li>P2Charas (ANightSkyCharaSelectGameState)</li> <li>P2Positions (ANightSkyCharaSelectGameState)</li> <li>ParticleManager (ANightSkyGameState)</li> <li>PlayAnnouncerVoice (ANightSkyGameState)</li> <li>PlayCharaAudio (ANightSkyGameState)</li> <li>PlayCommonAudio (ANightSkyGameState)</li> <li>PlayIntros (ANightSkyGameState)</li> <li>PlayLevelSequence (ANightSkyGameState, APlayerObject)</li> <li>PlayMusic (ANightSkyGameState)</li> <li>PlayVoiceLine (ANightSkyGameState, APlayerObject)</li> <li>PrevOtherChecksumFrame (ANightSkyGameState)</li> <li>PauseGame (ANightSkyPlayerController, FBattleInputActions)</li> <li>PostRematch (ANightSkyPlayerController)</li> <li>PressA (ANightSkyPlayerController, FBattleInputActions)</li> <li>PressB (ANightSkyPlayerController, FBattleInputActions)</li> <li>PressC (ANightSkyPlayerController, FBattleInputActions)</li> <li>PressD (ANightSkyPlayerController, FBattleInputActions)</li> <li>PressDown (ANightSkyPlayerController, FBattleInputActions)</li> <li>PressE (ANightSkyPlayerController, FBattleInputActions)</li> <li>PressF (ANightSkyPlayerController, FBattleInputActions)</li> <li>PressG (ANightSkyPlayerController, FBattleInputActions)</li> <li>PressH (ANightSkyPlayerController, FBattleInputActions)</li> <li>PressLeft (ANightSkyPlayerController, FBattleInputActions)</li> <li>PressRight (ANightSkyPlayerController, FBattleInputActions)</li> <li>PressUp (ANightSkyPlayerController, FBattleInputActions)</li> <li>Packages (ANightSkyVSInfoGameState)</li> <li>PauseParticles (AParticleManager, FBattleState)</li> <li>PauseRoundTimer (APlayerObject)</li> <li>PlayCommonLevelSequence (APlayerObject)</li> <li>PlayerFlags (APlayerObject, FPlayerObjectLog)</li> <li>PlayerIndex (APlayerObject, FPlayerObjectLog, UNightSkyGameInstance)</li> <li>PlayerReg1 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerReg2 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerReg3 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerReg4 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerReg5 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerReg6 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerReg7 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerReg8 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerSync (APlayerObject, FPlayerObjectLog)</li> <li>PlayerSyncEnd (APlayerObject, FPlayerObjectLog)</li> <li>PostStateChange (APlayerObject)</li> <li>PrimaryStateMachine (APlayerObject)</li> <li>ProximityThrowInput (APlayerObject, FPlayerObjectLog)</li> <li>Pitch (FAnimRotator)</li> <li>PartName (FAnimStruct)</li> <li>Position (FAnimTransform, FHitData)</li> <li>PlayerListP1 (FBattleData)</li> <li>PlayerListP2 (FBattleData)</li> <li>ParticleOwner (FBattleParticle)</li> <li>P1RoundsWon (FBattleState, UNightSkyBattleWidget)</li> <li>P2RoundsWon (FBattleState, UNightSkyBattleWidget)</li> <li>PauseTimer (FBattleState)</li> <li>ProximityBlockDistanceX (FHitDataCommon)</li> <li>ProximityBlockDistanceY (FHitDataCommon)</li> <li>ParamA (FHomingParams)</li> <li>ParamB (FHomingParams)</li> <li>Pos (FHomingParams)</li> <li>PlayerList (FNetworkMirror)</li> <li>Ping (FNetworkStats, UNightSkyBattleWidget)</li> <li>ParticleSystem (FParticleStruct)</li> <li>PlayerData (FRollbackData)</li> <li>PunishRange (FStateCPUData)</li> <li>Parent (FStateMachine, UBattleExtension, UState, USubroutine)</li> <li>playerIndex (RpcConnectionManager)</li> <li>PostEditChangeOwner (UNightSkyAnimSequenceUserData)</li> <li>P1ComboCounter (UNightSkyBattleWidget)</li> <li>P1Gauge (UNightSkyBattleWidget)</li> <li>P1Health (UNightSkyBattleWidget)</li> <li>P1Meter (UNightSkyBattleWidget)</li> <li>P1RecoverableHealth (UNightSkyBattleWidget)</li> <li>P2ComboCounter (UNightSkyBattleWidget)</li> <li>P2Gauge (UNightSkyBattleWidget)</li> <li>P2Health (UNightSkyBattleWidget)</li> <li>P2Meter (UNightSkyBattleWidget)</li> <li>P2RecoverableHealth (UNightSkyBattleWidget)</li> <li>PlayComboCounterAnim (UNightSkyBattleWidget)</li> <li>PlayFadeAnim (UNightSkyBattleWidget)</li> <li>PlayFadeOutAnim (UNightSkyBattleWidget)</li> <li>PlayGaugeAnim (UNightSkyBattleWidget)</li> <li>PlayHealthAnim (UNightSkyBattleWidget)</li> <li>PlayMatchWinAnim (UNightSkyBattleWidget)</li> <li>PlayMeterAnim (UNightSkyBattleWidget)</li> <li>PlayRecoverableHealthAnim (UNightSkyBattleWidget)</li> <li>PlayRoundInitAnim (UNightSkyBattleWidget)</li> <li>PlayRoundWinAnim (UNightSkyBattleWidget)</li> <li>PlayStandardAnimations (UNightSkyBattleWidget)</li> <li>PlayTimerAnim (UNightSkyBattleWidget)</li> <li>PlayReplayFromBP (UNightSkyGameInstance)</li> <li>PlayReplayToGameState (UNightSkyGameInstance)</li> <li>PersistentOuters (UNightSkySaveInfo)</li> <li>ParticleStructs (UParticleData)</li> <li>PlayerClass (UPrimaryCharaData)</li> </ul>"},{"location":"NightSkyEngine/class_members/#r","title":"r","text":"<ul> <li>R (ABattleObject, FBattleObjectLog)</li> <li>ReceivedHit (ABattleObject, FBattleObjectLog)</li> <li>ReceivedHitCommon (ABattleObject, FBattleObjectLog)</li> <li>RemoveEventHandler (ABattleObject)</li> <li>RemoveLinkActor (ABattleObject)</li> <li>ResetObject (ABattleObject)</li> <li>ResetParams (ANightSkyAIController)</li> <li>RemoteFrame (ANightSkyGameState)</li> <li>ResetTraining (ANightSkyGameState, ANightSkyPlayerController, FBattleInputActions)</li> <li>RollbackStartAudio (ANightSkyGameState)</li> <li>RoundInit (ANightSkyGameState, APlayerObject)</li> <li>ReleaseA (ANightSkyPlayerController, FBattleInputActions)</li> <li>ReleaseB (ANightSkyPlayerController, FBattleInputActions)</li> <li>ReleaseC (ANightSkyPlayerController, FBattleInputActions)</li> <li>ReleaseD (ANightSkyPlayerController, FBattleInputActions)</li> <li>ReleaseDown (ANightSkyPlayerController, FBattleInputActions)</li> <li>ReleaseE (ANightSkyPlayerController, FBattleInputActions)</li> <li>ReleaseF (ANightSkyPlayerController, FBattleInputActions)</li> <li>ReleaseG (ANightSkyPlayerController, FBattleInputActions)</li> <li>ReleaseH (ANightSkyPlayerController, FBattleInputActions)</li> <li>ReleaseLeft (ANightSkyPlayerController, FBattleInputActions)</li> <li>ReleaseRight (ANightSkyPlayerController, FBattleInputActions)</li> <li>ReleaseUp (ANightSkyPlayerController, FBattleInputActions)</li> <li>Rematch (ANightSkyPlayerController)</li> <li>RollbackParticles (AParticleManager)</li> <li>RecoverHealth (APlayerObject)</li> <li>RecoverableHealth (APlayerObject, FPlayerObjectLog)</li> <li>RemoveAutoComboCancel (APlayerObject)</li> <li>RemoveChainCancelOption (APlayerObject)</li> <li>RemoveWhiffCancelOption (APlayerObject)</li> <li>ResetAirDash (APlayerObject)</li> <li>ResetAirJump (APlayerObject)</li> <li>RoundEndFlag (APlayerObject, FPlayerObjectLog)</li> <li>RoundInit_BP (APlayerObject)</li> <li>RoundWinTimer (APlayerObject, FPlayerObjectLog)</li> <li>Roll (FAnimRotator)</li> <li>Rotation (FAnimTransform)</li> <li>Random (FBattleData)</li> <li>RoundCount (FBattleData, FBattleState)</li> <li>ReturnReg (FBattleObjectLog)</li> <li>RandomManager (FBattleState)</li> <li>RoundStartPos (FBattleState)</li> <li>RoundTimer (FBattleState)</li> <li>RecoverableDamagePercent (FHitData)</li> <li>RollbackFrames (FNetworkStats, UNightSkyBattleWidget)</li> <li>Rand (FRandomManager)</li> <li>RandRange (FRandomManager)</li> <li>Reseed (FRandomManager)</li> <li>RecvFrom (RpcConnectionManager)</li> <li>RpcConnectionManager (RpcConnectionManager)</li> <li>receiveSchedule (RpcConnectionManager)</li> <li>RegisterBinding (UExtendedCommonActivatableWidget)</li> <li>RootMontage (UNightSkyAnimInstance)</li> <li>RootTranslation (UNightSkyAnimSequenceUserData)</li> <li>RegisterAnimationsForRollback (UNightSkyBattleWidget)</li> <li>RollbackAnimations (UNightSkyBattleWidget)</li> <li>RecordReplay (UNightSkyGameInstance)</li> <li>ReplayList (UNightSkyGameInstance)</li> <li>RollbackReplay (UNightSkyGameInstance)</li> <li>ReplayIndex (UReplaySaveInfo)</li> <li>ResetToCDO (USerializableObj)</li> </ul>"},{"location":"NightSkyEngine/class_members/#s","title":"s","text":"<ul> <li>SaveForRollback (ABattleObject, ANightSkyGameState, UNightSkyBattleWidget, USerializableObj)</li> <li>ScreenPosToWorldPos (ABattleObject, ANightSkyGameState)</li> <li>ScreenSpaceDepthOffset (ABattleObject)</li> <li>SetAttacking (ABattleObject)</li> <li>SetBlendCelName (ABattleObject)</li> <li>SetCelDuration (ABattleObject)</li> <li>SetCelName (ABattleObject)</li> <li>SetFacing (ABattleObject)</li> <li>SetFloorCollisionActive (ABattleObject)</li> <li>SetGauge (ABattleObject, ANightSkyGameState)</li> <li>SetHitOTG (ABattleObject)</li> <li>SetIgnoreHitstunScaling (ABattleObject)</li> <li>SetIgnoreOTG (ABattleObject)</li> <li>SetIgnorePushbackScaling (ABattleObject)</li> <li>SetObjectID (ABattleObject)</li> <li>SetPitch (ABattleObject)</li> <li>SetPlayerHit (ABattleObject)</li> <li>SetProjectileAttribute (ABattleObject)</li> <li>SetProrateOnce (ABattleObject)</li> <li>SetPushCollisionActive (ABattleObject)</li> <li>SetPushWidthExtend (ABattleObject)</li> <li>SetRoll (ABattleObject)</li> <li>SetSpeedXRaw (ABattleObject)</li> <li>SetTimeUntilNextCel (ABattleObject)</li> <li>SetWallCollisionActive (ABattleObject)</li> <li>SetYaw (ABattleObject)</li> <li>SocketName (ABattleObject, FBattleObjectLog)</li> <li>SocketObj (ABattleObject, FBattleObjectLog)</li> <li>SocketOffset (ABattleObject, FBattleObjectLog)</li> <li>SpeedX (ABattleObject, FBattleObjectLog)</li> <li>SpeedXRate (ABattleObject, FBattleObjectLog)</li> <li>SpeedXRatePerFrame (ABattleObject, FBattleObjectLog)</li> <li>SpeedY (ABattleObject, FBattleObjectLog)</li> <li>SpeedYRate (ABattleObject, FBattleObjectLog)</li> <li>SpeedYRatePerFrame (ABattleObject, FBattleObjectLog)</li> <li>SpeedZ (ABattleObject, FBattleObjectLog)</li> <li>SpeedZRate (ABattleObject, FBattleObjectLog)</li> <li>SpeedZRatePerFrame (ABattleObject, FBattleObjectLog)</li> <li>StartSuperFreeze (ABattleObject, ANightSkyGameState)</li> <li>StopLinkObj (ABattleObject, FBattleObjectLog)</li> <li>StunTime (ABattleObject, FBattleObjectLog)</li> <li>StunTimeMax (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReg1 (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReg2 (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReg3 (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReg4 (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReturnVal1 (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReturnVal2 (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReturnVal3 (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReturnVal4 (ABattleObject, FBattleObjectLog)</li> <li>SuperArmorData (ABattleObject, FBattleObjectLog)</li> <li>SuperArmorSuccess (ABattleObject)</li> <li>SaveGameStateCallback (AFighterMultiplayerRunner)</li> <li>SendGgpoToClient (ANetworkPawn)</li> <li>SendGgpoToServer (ANetworkPawn)</li> <li>SendRematchToServer (ANetworkPawn)</li> <li>ServerChecksumCheck (ANetworkPawn)</li> <li>ServerGetBattleData (ANetworkPawn)</li> <li>ServerGetCharaData (ANetworkPawn)</li> <li>ServerGetFinishedLoading (ANetworkPawn)</li> <li>SetInputs (ANightSkyAIController)</li> <li>SaveGameState (ANightSkyGameState)</li> <li>SequenceActor (ANightSkyGameState)</li> <li>SequenceCameraActor (ANightSkyGameState)</li> <li>SequenceCameraActorClass (ANightSkyGameState)</li> <li>SequenceEnemy (ANightSkyGameState)</li> <li>SequenceTarget (ANightSkyGameState)</li> <li>SetDrawPriorityBack (ANightSkyGameState)</li> <li>SetDrawPriorityFront (ANightSkyGameState)</li> <li>SetOtherChecksum (ANightSkyGameState)</li> <li>SetPaused (ANightSkyGameState)</li> <li>SetScreenBounds (ANightSkyGameState)</li> <li>SetScreenCorners (ANightSkyGameState)</li> <li>SetScreenFlags (ANightSkyGameState)</li> <li>SetTeamCooldown (ANightSkyGameState, APlayerObject)</li> <li>SortObjects (ANightSkyGameState)</li> <li>SortedObjects (ANightSkyGameState)</li> <li>StopLevelSequence (ANightSkyGameState, APlayerObject)</li> <li>SwitchMainPlayer (ANightSkyGameState, APlayerObject)</li> <li>SendBattleData (ANightSkyPlayerController)</li> <li>SendGgpo (ANightSkyPlayerController)</li> <li>SetupInputComponent (ANightSkyPlayerController)</li> <li>SaveForRollbackBP (APlayerObject)</li> <li>SaveForRollbackPlayer (APlayerObject)</li> <li>SequenceData (APlayerObject)</li> <li>SetAirDashNoAttackTimer (APlayerObject)</li> <li>SetAirDashTimer (APlayerObject)</li> <li>SetComponentVisibility (APlayerObject)</li> <li>SetDamageReactionCel (APlayerObject)</li> <li>SetDefaultComponentVisibility (APlayerObject)</li> <li>SetDefaultLandingAction (APlayerObject)</li> <li>SetGuardValues (APlayerObject)</li> <li>SetHeadAttribute (APlayerObject)</li> <li>SetHeadInvulnerable (APlayerObject)</li> <li>SetHealth (APlayerObject)</li> <li>SetHitValues (APlayerObject)</li> <li>SetHitValuesOverTime (APlayerObject)</li> <li>SetHitgrabActive (APlayerObject)</li> <li>SetKnockdownState (APlayerObject)</li> <li>SetMeterCooldownTimer (APlayerObject)</li> <li>SetOnScreen (APlayerObject)</li> <li>SetProjectileInvulnerable (APlayerObject)</li> <li>SetRecoverableHealth (APlayerObject)</li> <li>SetStance (APlayerObject)</li> <li>SetStateForCPU (APlayerObject)</li> <li>SetStrikeInvulnerable (APlayerObject)</li> <li>SetStrikeInvulnerableForTime (APlayerObject)</li> <li>SetStunTime (APlayerObject)</li> <li>SetThrowActive (APlayerObject)</li> <li>SetThrowExeState (APlayerObject)</li> <li>SetThrowInvulnerable (APlayerObject)</li> <li>SetThrowInvulnerableForTime (APlayerObject)</li> <li>SetThrowPosition (APlayerObject)</li> <li>SetThrowRange (APlayerObject)</li> <li>SetThrowResistForTime (APlayerObject)</li> <li>SoundData (APlayerObject)</li> <li>Stance (APlayerObject, FPlayerObjectLog)</li> <li>StandPushHeight (APlayerObject, FPlayerObjectLog)</li> <li>StandPushWidth (APlayerObject, FPlayerObjectLog)</li> <li>StateEntryName (APlayerObject, FPlayerObjectLog)</li> <li>StoredBattleObjects (APlayerObject, FPlayerObjectLog)</li> <li>StoredInputBuffer (APlayerObject, FPlayerObjectLog)</li> <li>StoredLinkActors (APlayerObject)</li> <li>StrikeInvulnerableTimer (APlayerObject, FPlayerObjectLog)</li> <li>SubStateData (APlayerObject)</li> <li>SubStateMachines (APlayerObject)</li> <li>SubroutineNames (APlayerObject)</li> <li>Subroutines (APlayerObject)</li> <li>SuperJumpGravity (APlayerObject, FPlayerObjectLog)</li> <li>SuperJumpHeight (APlayerObject, FPlayerObjectLog)</li> <li>SetupPlayerInputComponent (AWTCharacter)</li> <li>StartBattle (AWTCharacter)</li> <li>Scale (FAnimTransform)</li> <li>SoundWave (FAudioChannel, FSoundStruct)</li> <li>StartingFrame (FAudioChannel)</li> <li>Stage (FBattleData, FNetworkMirror)</li> <li>StartRoundTimer (FBattleData)</li> <li>ScreenData (FBattleState)</li> <li>SuperFreezeCaller (FBattleState)</li> <li>SuperFreezeDuration (FBattleState)</li> <li>SuperFreezeSelfDuration (FBattleState)</li> <li>SizeX (FCollisionBox)</li> <li>SizeY (FCollisionBox)</li> <li>SubroutineName (FEventHandler, USubroutineState)</li> <li>Sections (FExtraGauge)</li> <li>SFXType (FHitDataCommon)</li> <li>Sequence (FInputCondition, FSequenceStruct)</li> <li>StoredActor (FLinkedActorContainer)</li> <li>SessionSearchResult (FNSESessionInfo)</li> <li>Self (FObjectRecord)</li> <li>Seed (FRandomManager)</li> <li>Serialize (FRollbackData, UNightSkyAnimSequenceUserData)</li> <li>StateData (FRollbackData)</li> <li>ScreenBoundsLeft (FScreenData)</li> <li>ScreenBoundsRight (FScreenData)</li> <li>ScreenBoundsTop (FScreenData)</li> <li>ScreenWorldCenterX (FScreenData)</li> <li>ScreenWorldCenterY (FScreenData)</li> <li>ScreenWorldWidth (FScreenData)</li> <li>ScreenYZoom (FScreenData)</li> <li>StageBoundsLeft (FScreenData)</li> <li>StageBoundsRight (FScreenData)</li> <li>StageBoundsTop (FScreenData)</li> <li>SetState (FStateMachine)</li> <li>StateMachineName (FStateMachine)</li> <li>StateNames (FStateMachine)</li> <li>States (FStateMachine)</li> <li>SendTo (RpcConnectionManager)</li> <li>sendSchedule (RpcConnectionManager)</li> <li>SessionUserInviteAcceptedDelegate (UNSESessionSubsystem)</li> <li>SessionUserInviteAcceptedDelegateHandle (UNSESessionSubsystem)</li> <li>StartSession (UNSESessionSubsystem)</li> <li>StartSessionCompleteDelegate (UNSESessionSubsystem)</li> <li>StartSessionCompleteDelegateHandle (UNSESessionSubsystem)</li> <li>SetAnimationRollbackData (UNightSkyBattleWidget)</li> <li>Sin_x1000 (UNightSkyBlueprintFunctionLibrary)</li> <li>SettingsInfo (UNightSkyGameInstance)</li> <li>SaveData (UNightSkySaveInfo)</li> <li>StageDescription (UPrimaryStageData)</li> <li>StageFriendlyName (UPrimaryStageData)</li> <li>StageName (UPrimaryStageData)</li> <li>StageSelectIcon (UPrimaryStageData)</li> <li>StageSplashIcon (UPrimaryStageData)</li> <li>StageURL (UPrimaryStageData)</li> <li>SequenceStructs (USequenceData)</li> <li>SoundDatas (USoundData)</li> <li>ShareChainName (UState)</li> <li>StateConditions (UState)</li> <li>StateType (UState)</li> <li>StateToEnter (UStateAlias)</li> <li>StateArray (UStateData)</li> <li>SubroutineArray (USubroutineData)</li> </ul>"},{"location":"NightSkyEngine/class_members/#t","title":"t","text":"<ul> <li>Tick (AAudioManager, ABattleObject, ALinkActor, ANightSkyCharaSelectGameState, ANightSkyGameState, ANightSkyPlayerController, ANightSkyVSInfoGameState, ANightSkyWTGameState, ANightSkyWTPlayerController, AParticleManager, AWTCharacter)</li> <li>T (ABattleObject, FBattleObjectLog)</li> <li>TimeUntilNextCel (ABattleObject, FBattleObjectLog)</li> <li>Timer0 (ABattleObject, FBattleObjectLog)</li> <li>Timer1 (ABattleObject, FBattleObjectLog)</li> <li>Transparency (ABattleObject, FBattleObjectLog)</li> <li>TransparencySpeed (ABattleObject, FBattleObjectLog)</li> <li>TriggerEvent (ABattleObject)</li> <li>TargetState (ANightSkyAIController)</li> <li>TopWidget (ANightSkyBattleHudActor)</li> <li>TotalCharaPackageCount (ANightSkyVSInfoGameState)</li> <li>TeamIndex (APlayerObject, FPlayerObjectLog)</li> <li>ThrowEnd (APlayerObject)</li> <li>ThrowExe (APlayerObject)</li> <li>ThrowInvulnerableTimer (APlayerObject, FPlayerObjectLog)</li> <li>ThrowRange (APlayerObject, FPlayerObjectLog)</li> <li>ThrowResistAfterWakeUp (APlayerObject, FPlayerObjectLog)</li> <li>ThrowResistTimer (APlayerObject, FPlayerObjectLog)</li> <li>ThrowTechTimer (APlayerObject, FPlayerObjectLog)</li> <li>ThrowTechWindow (APlayerObject, FPlayerObjectLog)</li> <li>ToggleComponentVisibility (APlayerObject)</li> <li>TotalProration (APlayerObject, FPlayerObjectLog)</li> <li>TimeUntilRoundStart (FBattleData, FBattleState)</li> <li>TagCooldown (FBattleState)</li> <li>TeamData (FBattleState)</li> <li>Type (FCollisionBox, FHitPosition, FHomingParams, FSuperArmorData)</li> <li>Target (FHomingParams)</li> <li>Transform (FObjectRecord)</li> <li>Time (FRollbackAnimation)</li> <li>TargetCenterX (FScreenData)</li> <li>TargetCenterY (FScreenData)</li> <li>TargetObjects (FScreenData)</li> <li>TargetOffsetAirYAdd (FScreenData)</li> <li>TargetOffsetAirYDist (FScreenData)</li> <li>TargetOffsetAirYMax (FScreenData)</li> <li>TargetOffsetAirYPos (FScreenData)</li> <li>TargetOffsetLandYAdd (FScreenData)</li> <li>TargetOffsetLandYMax (FScreenData)</li> <li>TargetOffsetY (FScreenData)</li> <li>TargetWidth (FScreenData)</li> <li>TeamCount (FTeamData)</li> <li>TryTravelToCurrentSession (UNSESessionSubsystem)</li> <li>Timer (UNightSkyBattleWidget)</li> <li>TravelToBattleMap (UNightSkyGameInstance)</li> <li>TravelToVSInfo (UNightSkyGameInstance)</li> <li>TempObjects (UNightSkySaveInfo)</li> <li>Timestamp (UReplaySaveInfo)</li> </ul>"},{"location":"NightSkyEngine/class_members/#u","title":"u","text":"<ul> <li>Update (ABattleObject, AFighterLocalRunner, AFighterMultiplayerRunner, AFighterReplayRunner, AFighterSynctestRunner, ALinkActor, ANightSkyAIController, APlayerObject, FInputBuffer, FStateMachine)</li> <li>UpdateTime (ABattleObject, FBattleObjectLog)</li> <li>UpdateVisuals (ABattleObject, ANightSkyGameState)</li> <li>UpdateVisualsNoRollback (ABattleObject, APlayerObject)</li> <li>UpdateVisuals_BP (ABattleObject)</li> <li>UseGauge (ABattleObject, ANightSkyGameState)</li> <li>UpdateCamera (ANightSkyGameState)</li> <li>UpdateGameState (ANightSkyGameState)</li> <li>UpdateHUD (ANightSkyGameState)</li> <li>UpdateHUDAnimations_BP (ANightSkyGameState)</li> <li>UpdateHUD_BP (ANightSkyGameState)</li> <li>UpdateLocalInput (ANightSkyGameState)</li> <li>UpdateScreen (ANightSkyGameState)</li> <li>UpdateParticles (AParticleManager)</li> <li>UpdateNotBattle (APlayerObject)</li> <li>UseMeter (APlayerObject)</li> <li>Untech (FHitData)</li> <li>UExtendedCommonActivatableWidget (UExtendedCommonActivatableWidget)</li> <li>UnregisterAllBindings (UExtendedCommonActivatableWidget)</li> <li>UnregisterBinding (UExtendedCommonActivatableWidget)</li> <li>UNSESessionSubsystem (UNSESessionSubsystem)</li> <li>UpdateSession (UNSESessionSubsystem)</li> <li>UpdateSessionCompleteDelegate (UNSESessionSubsystem)</li> <li>UpdateSessionCompleteDelegateHandle (UNSESessionSubsystem)</li> <li>UNightSkyAnimMetaData (UNightSkyAnimMetaData)</li> <li>UserData (UNightSkyAnimMetaData)</li> <li>UpdateReplay (UNightSkyGameInstance)</li> <li>UObjectArraySaver (UNightSkySaveInfo)</li> <li>UObjectDataLoader (UNightSkySaveInfo)</li> <li>UObjectSaver (UNightSkySaveInfo)</li> <li>UObjectsPreloader (UNightSkySaveInfo)</li> <li>UReplaySaveInfo (UReplaySaveInfo)</li> </ul>"},{"location":"NightSkyEngine/class_members/#v","title":"v","text":"<ul> <li>VSInfoTime (ANightSkyVSInfoGameState)</li> <li>VoiceData (APlayerObject)</li> <li>Value (FExtraGauge, FHitValueOverTime)</li> <li>VFXType (FHitDataCommon)</li> <li>Vec2Angle_x1000 (UNightSkyBlueprintFunctionLibrary)</li> <li>Version (UReplaySaveInfo)</li> </ul>"},{"location":"NightSkyEngine/class_members/#w","title":"w","text":"<ul> <li>WaitCount (ANightSkyAIController)</li> <li>WaitLimit (ANightSkyAIController)</li> <li>WallTouchTimer (APlayerObject, FPlayerObjectLog)</li> <li>WhiffCancelOptions (APlayerObject)</li> <li>WallBounce (FHitData)</li> <li>WriteInputCondition (FInputBuffer)</li> <li>WidgetAnimationData (FRollbackData)</li> <li>WidthVelocity (FScreenData)</li> <li>WallBounceCount (FWallBounceData)</li> <li>WallBounceGravity (FWallBounceData)</li> <li>WallBounceInCornerOnly (FWallBounceData)</li> <li>WallBounceStop (FWallBounceData)</li> <li>WallBounceUntech (FWallBounceData)</li> <li>WallBounceXRate (FWallBounceData)</li> <li>WallBounceXSpeed (FWallBounceData)</li> <li>WallBounceYRate (FWallBounceData)</li> <li>WallBounceYSpeed (FWallBounceData)</li> <li>WidgetAnimationRollback (UNightSkyBattleWidget)</li> </ul>"},{"location":"NightSkyEngine/class_members/#x","title":"x","text":"<ul> <li>X (FAnimVector)</li> </ul>"},{"location":"NightSkyEngine/class_members/#y","title":"y","text":"<ul> <li>Yaw (FAnimRotator)</li> <li>Y (FAnimVector)</li> </ul>"},{"location":"NightSkyEngine/class_members/#z","title":"z","text":"<ul> <li>Z (FAnimVector)</li> <li>ZoomOutBeginH (FScreenData)</li> <li>ZoomOutBeginX (FScreenData)</li> <li>ZoomOutBeginY (FScreenData)</li> </ul>"},{"location":"NightSkyEngine/class_members/#_1","title":"~","text":"<ul> <li>~FBattleObjectLog (FBattleObjectLog)</li> <li>~RpcConnectionManager (RpcConnectionManager)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/","title":"Class Member Functions","text":""},{"location":"NightSkyEngine/class_member_functions/#a","title":"a","text":"<ul> <li>AAudioManager (AAudioManager)</li> <li>ABattleObject (ABattleObject)</li> <li>AddBattleObject (ABattleObject, ANightSkyGameState)</li> <li>AddCommonBattleObject (ABattleObject)</li> <li>AddPosXWithDir (ABattleObject)</li> <li>AddSpeedXRaw (ABattleObject)</li> <li>AttachToSocketOfObject (ABattleObject)</li> <li>AFighterLocalRunner (AFighterLocalRunner)</li> <li>AFighterMultiplayerRunner (AFighterMultiplayerRunner)</li> <li>AdvanceFrameCallback (AFighterMultiplayerRunner)</li> <li>AFighterReplayRunner (AFighterReplayRunner)</li> <li>AFighterSynctestRunner (AFighterSynctestRunner)</li> <li>ALinkActor (ALinkActor)</li> <li>ANetworkPawn (ANetworkPawn)</li> <li>ANightSkyAIController (ANightSkyAIController)</li> <li>ANightSkyBattleHudActor (ANightSkyBattleHudActor)</li> <li>ANightSkyCharaSelectGameState (ANightSkyCharaSelectGameState)</li> <li>AddColorIndex (ANightSkyCharaSelectGameState)</li> <li>AddPlayerObject (ANightSkyCharaSelectGameState)</li> <li>ANightSkyGameState (ANightSkyGameState)</li> <li>AssignEnemy (ANightSkyGameState)</li> <li>ANightSkyPlayerController (ANightSkyPlayerController)</li> <li>ANightSkyVSInfoGameState (ANightSkyVSInfoGameState)</li> <li>ANightSkyWTGameState (ANightSkyWTGameState)</li> <li>ANightSkyWTPlayerController (ANightSkyWTPlayerController)</li> <li>AParticleManager (AParticleManager)</li> <li>APlayerObject (APlayerObject)</li> <li>AddAirDash (APlayerObject)</li> <li>AddAirJump (APlayerObject)</li> <li>AddAutoComboCancel (APlayerObject)</li> <li>AddBattleObjectToStorage (APlayerObject)</li> <li>AddChainCancelOption (APlayerObject)</li> <li>AddHealth (APlayerObject)</li> <li>AddMeter (APlayerObject)</li> <li>AddObjectState (APlayerObject)</li> <li>AddRecoverableHealth (APlayerObject)</li> <li>AddState (APlayerObject, FStateMachine)</li> <li>AddSubroutine (APlayerObject)</li> <li>AddWhiffCancelOption (APlayerObject)</li> <li>AWTCharacter (AWTCharacter)</li> <li>ActorArraySaver (UNightSkySaveInfo)</li> <li>ActorPreloader (UNightSkySaveInfo)</li> <li>ActorSaver (UNightSkySaveInfo)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#b","title":"b","text":"<ul> <li>BeginPlay (AAudioManager, ABattleObject, AFighterLocalRunner, AFighterMultiplayerRunner, AFighterReplayRunner, AFighterSynctestRunner, ALinkActor, ANetworkPawn, ANightSkyAIController, ANightSkyCharaSelectGameState, ANightSkyGameState, ANightSkyPlayerController, ANightSkyVSInfoGameState, ANightSkyWTGameState, ANightSkyWTPlayerController, AParticleManager, APlayerObject, AWTCharacter)</li> <li>BeginGameCallback (AFighterMultiplayerRunner)</li> <li>BattleHudVisibility (ANightSkyGameState, APlayerObject)</li> <li>BP_OnFindReplaysComplete (UNightSkyGameInstance)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#c","title":"c","text":"<ul> <li>CalculateAngleBetweenPoints (ABattleObject)</li> <li>CalculateDistanceBetweenPoints (ABattleObject)</li> <li>CalculateHoming (ABattleObject)</li> <li>CalculatePushbox (ABattleObject)</li> <li>CalculateSpeedAngle (ABattleObject)</li> <li>CallSubroutine (ABattleObject)</li> <li>CallSubroutineWithArgs (ABattleObject)</li> <li>CameraShake (ABattleObject, ANightSkyGameState)</li> <li>CheckBoxOverlap (ABattleObject)</li> <li>CheckIsGrounded (ABattleObject)</li> <li>CollisionView (ABattleObject, ANightSkyGameState)</li> <li>CreateCharaParticle (ABattleObject)</li> <li>CreateCommonParticle (ABattleObject)</li> <li>CreateCallbacks (AFighterMultiplayerRunner)</li> <li>ClientChecksumCheck (ANetworkPawn)</li> <li>ClientGetBattleData (ANetworkPawn)</li> <li>ClientGetCharaData (ANetworkPawn)</li> <li>CheckAttackWeight (ANightSkyAIController)</li> <li>CheckBasicWeight (ANightSkyAIController)</li> <li>CheckDefenseWeight (ANightSkyAIController)</li> <li>CallAssist (ANightSkyGameState, APlayerObject)</li> <li>CallBattleExtension (ANightSkyGameState)</li> <li>CanTag (ANightSkyGameState)</li> <li>CreateChecksum (ANightSkyGameState)</li> <li>ClosePauseMenu (ANightSkyPlayerController)</li> <li>CanEnterState (APlayerObject, UState)</li> <li>CheckEnemyInRange (APlayerObject)</li> <li>CheckHasHit (APlayerObject)</li> <li>CheckInput (APlayerObject)</li> <li>CheckIsAttacking (APlayerObject)</li> <li>CheckIsStunned (APlayerObject)</li> <li>CheckKaraCancel (APlayerObject)</li> <li>CheckMovesUsedInChain (APlayerObject)</li> <li>CheckObjectPreventingState (APlayerObject)</li> <li>CheckReverseBeat (APlayerObject)</li> <li>CheckStateEnabled (APlayerObject)</li> <li>CheckInputCondition (FInputBuffer)</li> <li>CheckInputSequence (FInputBuffer)</li> <li>CheckInputSequenceNegative (FInputBuffer)</li> <li>CheckInputSequenceNegativeStrict (FInputBuffer)</li> <li>CheckInputSequenceOnce (FInputBuffer)</li> <li>CheckInputSequenceOnceStrict (FInputBuffer)</li> <li>CheckInputSequencePressAndRelease (FInputBuffer)</li> <li>CheckInputSequencePressAndReleaseStrict (FInputBuffer)</li> <li>CheckInputSequenceStrict (FInputBuffer)</li> <li>CheckStateStanceCondition (FStateMachine)</li> <li>CreateSession (UNSESessionSubsystem)</li> <li>CreateRootMontage (UNightSkyAnimInstance)</li> <li>Cos_x1000 (UNightSkyBlueprintFunctionLibrary)</li> <li>CallExec (UState, UStateAlias, USubroutineState)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#d","title":"d","text":"<ul> <li>DeactivateObject (ABattleObject)</li> <li>DetachFromSocket (ABattleObject)</li> <li>DisableInertia (ABattleObject)</li> <li>DisableAll (APlayerObject)</li> <li>DisableCustomState (APlayerObject)</li> <li>DisableState (APlayerObject)</li> <li>DestroySession (UNSESessionSubsystem)</li> <li>DeleteReplay (UNightSkyGameInstance)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#e","title":"e","text":"<ul> <li>EnableDeactivateIfBeyondBounds (ABattleObject)</li> <li>EnableDeactivateOnReceiveHit (ABattleObject)</li> <li>EnableDeactivateOnStateChange (ABattleObject)</li> <li>EnableFlip (ABattleObject)</li> <li>EnableHit (ABattleObject)</li> <li>EnableInertia (ABattleObject)</li> <li>EndPlay (AFighterMultiplayerRunner, ANightSkyGameState)</li> <li>Exit (ALinkActor)</li> <li>EndMatch (ANightSkyGameState, APlayerObject)</li> <li>EndMatch_BP (ANightSkyGameState)</li> <li>EditorUpdate (APlayerObject)</li> <li>EmptyStateMachine (APlayerObject)</li> <li>EnableAll (APlayerObject)</li> <li>EnableAttacks (APlayerObject)</li> <li>EnableCancelIntoSelf (APlayerObject)</li> <li>EnableChainCancel (APlayerObject)</li> <li>EnableCustomState (APlayerObject)</li> <li>EnableForwardAirdashCancel (APlayerObject)</li> <li>EnableJumpCancel (APlayerObject)</li> <li>EnableReverseBeat (APlayerObject)</li> <li>EnableSpecialCancel (APlayerObject)</li> <li>EnableState (APlayerObject)</li> <li>EnableSuperCancel (APlayerObject)</li> <li>EnableWhiffCancel (APlayerObject)</li> <li>EndRound (APlayerObject)</li> <li>EndBattle (AWTCharacter)</li> <li>EndBattle_BP (AWTCharacter)</li> <li>Emplace (FInputBuffer)</li> <li>Exec (UBattleExtension, UState, USubroutine)</li> <li>EndRecordReplay (UNightSkyGameInstance)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#f","title":"f","text":"<ul> <li>FaceOpponent (ABattleObject)</li> <li>FlipObject (ABattleObject)</li> <li>FuncCall (ABattleObject)</li> <li>FreeBuffer (AFighterMultiplayerRunner)</li> <li>fletcher32_checksum (AFighterMultiplayerRunner)</li> <li>FindAutoComboCancelOption (APlayerObject)</li> <li>FindChainCancelOption (APlayerObject)</li> <li>FindWhiffCancelOption (APlayerObject)</li> <li>FlipInput (APlayerObject)</li> <li>ForceEnableFarNormal (APlayerObject)</li> <li>FBattleParticle (FBattleParticle)</li> <li>FInputBitmask (FInputBitmask)</li> <li>FlipInputsInBuffer (FInputBuffer)</li> <li>FNSESessionInfo (FNSESessionInfo)</li> <li>FNightSkySaveArchive (FNightSkySaveArchive)</li> <li>FObjectRecord (FObjectRecord)</li> <li>FRandomManager (FRandomManager)</li> <li>ForceRollbackState (FStateMachine)</li> <li>ForceSetState (FStateMachine)</li> <li>FindSessions (UNSESessionSubsystem)</li> <li>FindReplays (UNightSkyGameInstance)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#g","title":"g","text":"<ul> <li>GenerateRandomNumber (ABattleObject, FRandomManager)</li> <li>GetAnimSequenceForPart (ABattleObject)</li> <li>GetAnimSequenceUserData (ABattleObject)</li> <li>GetAnimSequenceUserDatas (ABattleObject)</li> <li>GetBattleObject (ABattleObject)</li> <li>GetBoxPosition (ABattleObject)</li> <li>GetBoxes (ABattleObject)</li> <li>GetCelName (ABattleObject)</li> <li>GetFlipbookForPart (ABattleObject)</li> <li>GetGauge (ABattleObject, ANightSkyGameState)</li> <li>GetLabelName (ABattleObject)</li> <li>GetPosYCenter (ABattleObject)</li> <li>GotoLabel (ABattleObject)</li> <li>GgpoUpdate (AFighterMultiplayerRunner)</li> <li>GetLifetimeReplicatedProps (ANetworkPawn)</li> <li>GetEnemyDistanceX (ANightSkyAIController)</li> <li>GetEnemyDistanceY (ANightSkyAIController)</li> <li>GetLocalInputs (ANightSkyGameState)</li> <li>GetMainPlayer (ANightSkyGameState)</li> <li>GetNetworkStats (ANightSkyGameState)</li> <li>GetPaused (ANightSkyGameState)</li> <li>GetScreenFlags (ANightSkyGameState)</li> <li>GetTeam (ANightSkyGameState)</li> <li>GetTeamCount (ANightSkyGameState)</li> <li>GetAttackBlockType (APlayerObject)</li> <li>GetCurrentStateName (APlayerObject)</li> <li>GetEnableFlags (APlayerObject)</li> <li>GetLastStateName (APlayerObject)</li> <li>GetStateEntryName (APlayerObject)</li> <li>GetStateMachine (APlayerObject)</li> <li>GetSeed (FRandomManager)</li> <li>GetStateIndex (FStateMachine)</li> <li>GetStateName (FStateMachine)</li> <li>GetByCelName (UCollisionData)</li> <li>GetIndexByCelName (UCollisionData)</li> <li>GetDesiredInputConfig (UExtendedCommonActivatableWidget)</li> <li>GetCachedBoneLocationAtTime (UNightSkyAnimSequenceUserData)</li> <li>GetCachedBoneTransformAtTime (UNightSkyAnimSequenceUserData)</li> <li>GetFrameCount (UNightSkyAnimSequenceUserData)</li> <li>GetFrameRate (UNightSkyAnimSequenceUserData)</li> <li>GetRootTranslationAtTime (UNightSkyAnimSequenceUserData)</li> <li>GetPrimaryAssetId (UPrimaryCharaData, UPrimaryStageData)</li> <li>GetByStateName (UStateData)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#h","title":"h","text":"<ul> <li>HaltMomentum (ABattleObject)</li> <li>HandleClashCollision (ABattleObject)</li> <li>HandleCustomCollision_PostHit (ABattleObject)</li> <li>HandleCustomCollision_PreHit (ABattleObject)</li> <li>HandleFlip (ABattleObject)</li> <li>HandleHitCollision (ABattleObject, ANightSkyGameState)</li> <li>HandlePushCollision (ABattleObject, ANightSkyGameState)</li> <li>HUDInit (ANightSkyGameState)</li> <li>HandleMatchWin (ANightSkyGameState)</li> <li>HandleRoundWin (ANightSkyGameState)</li> <li>HandleAutoCombo (APlayerObject)</li> <li>HandleBlockAction (APlayerObject)</li> <li>HandleBufferedState (APlayerObject)</li> <li>HandleEndCombo (APlayerObject)</li> <li>HandleFlipInput (APlayerObject)</li> <li>HandleGroundBounce (APlayerObject)</li> <li>HandleHitAction (APlayerObject)</li> <li>HandleLanding (APlayerObject)</li> <li>HandleProximityBlock (APlayerObject)</li> <li>HandleStateCondition (APlayerObject)</li> <li>HandleStateInputs (APlayerObject)</li> <li>HandleStateMachine (APlayerObject)</li> <li>HandleStateTransition (APlayerObject)</li> <li>HandleThrowCollision (APlayerObject)</li> <li>HandleWallBounce (APlayerObject)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#i","title":"i","text":"<ul> <li>IgnoreSuperFreeze (ABattleObject)</li> <li>InitEventHandler (ABattleObject)</li> <li>InitHitDataByAttackLevel (ABattleObject)</li> <li>InitObject (ABattleObject)</li> <li>IsStopped (ABattleObject)</li> <li>IsTimerPaused (ABattleObject)</li> <li>Init (ALinkActor, ANightSkyGameState, ANightSkyWTGameState, UNightSkyGameInstance, UState)</li> <li>IsTagBattle (ANightSkyGameState)</li> <li>InitBP (APlayerObject)</li> <li>InitPlayer (APlayerObject)</li> <li>IsCorrectBlock (APlayerObject)</li> <li>IsEnemyAttackState (APlayerObject)</li> <li>IsEnemyBlocking (APlayerObject)</li> <li>IsEnemyThrow (APlayerObject)</li> <li>IsInvulnerable (APlayerObject)</li> <li>IsInvulnerable_BP (APlayerObject)</li> <li>IsMainPlayer (APlayerObject)</li> <li>IsOnScreen (APlayerObject)</li> <li>IsTouchingWall (APlayerObject)</li> <li>IsCurrentState (FStateMachine)</li> <li>IsLoggedIn (UNSESessionSubsystem)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#j","title":"j","text":"<ul> <li>JumpToState (APlayerObject)</li> <li>JumpToStateByClass (APlayerObject)</li> <li>JumpToStateByClassPrimary (APlayerObject)</li> <li>JumpToStatePrimary (APlayerObject)</li> <li>JoinGameSession (UNSESessionSubsystem)</li> <li>JoinGameSession_BP (UNSESessionSubsystem)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#l","title":"l","text":"<ul> <li>LinkActor (ABattleObject)</li> <li>LinkCharaParticle (ABattleObject)</li> <li>LinkCommonParticle (ABattleObject)</li> <li>LoadForRollback (ABattleObject, ANightSkyGameState, UNightSkyBattleWidget, USerializableObj)</li> <li>LoadGameStateCallback (AFighterMultiplayerRunner)</li> <li>LogGameState (AFighterMultiplayerRunner)</li> <li>LoadGameState (ANightSkyGameState)</li> <li>LoadForRollbackBP (APlayerObject)</li> <li>LoadForRollbackPlayer (APlayerObject)</li> <li>LogForSyncTestFile (FBattleObjectLog, FPlayerObjectLog)</li> <li>Login (UNSESessionSubsystem)</li> <li>LoadReplay (UNightSkyGameInstance)</li> <li>LoadData (UNightSkySaveInfo)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#m","title":"m","text":"<ul> <li>Move (ABattleObject)</li> <li>ManageAudio (ANightSkyGameState)</li> <li>MatchInit (ANightSkyGameState)</li> <li>Montage_Advance (UNightSkyAnimInstance)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#n","title":"n","text":"<ul> <li>NormalizeAngle (ABattleObject)</li> <li>NextRoundTransition (ANightSkyGameState)</li> <li>NativeDestruct (UExtendedCommonActivatableWidget)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#o","title":"o","text":"<ul> <li>OnEventCallback (AFighterMultiplayerRunner)</li> <li>OpenPauseMenu (ANightSkyPlayerController)</li> <li>OnCharaPackageLoaded (ANightSkyVSInfoGameState)</li> <li>OnMapPackageLoaded (ANightSkyVSInfoGameState)</li> <li>OnStateChange (APlayerObject)</li> <li>operator!= (FCollisionBox)</li> <li>OnCreateSessionComplete (UNSESessionSubsystem)</li> <li>OnDestroySessionComplete (UNSESessionSubsystem)</li> <li>OnFindSessionsComplete (UNSESessionSubsystem)</li> <li>OnJoinSessionComplete (UNSESessionSubsystem)</li> <li>OnLoginCompleted (UNSESessionSubsystem)</li> <li>OnSessionInviteAccepted (UNSESessionSubsystem)</li> <li>OnStartSessionComplete (UNSESessionSubsystem)</li> <li>OnUpdateSessionComplete (UNSESessionSubsystem)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#p","title":"p","text":"<ul> <li>PauseAllAudio (AAudioManager)</li> <li>PlayCharaSound (ABattleObject)</li> <li>PlayCommonSound (ABattleObject)</li> <li>PosTypeToPosition (ABattleObject)</li> <li>PositionLinkUpdate (ABattleObject)</li> <li>PlayAnnouncerVoice (ANightSkyGameState)</li> <li>PlayCharaAudio (ANightSkyGameState)</li> <li>PlayCommonAudio (ANightSkyGameState)</li> <li>PlayIntros (ANightSkyGameState)</li> <li>PlayLevelSequence (ANightSkyGameState, APlayerObject)</li> <li>PlayMusic (ANightSkyGameState)</li> <li>PlayVoiceLine (ANightSkyGameState, APlayerObject)</li> <li>PauseGame (ANightSkyPlayerController)</li> <li>PostRematch (ANightSkyPlayerController)</li> <li>PressA (ANightSkyPlayerController)</li> <li>PressB (ANightSkyPlayerController)</li> <li>PressC (ANightSkyPlayerController)</li> <li>PressD (ANightSkyPlayerController)</li> <li>PressDown (ANightSkyPlayerController)</li> <li>PressE (ANightSkyPlayerController)</li> <li>PressF (ANightSkyPlayerController)</li> <li>PressG (ANightSkyPlayerController)</li> <li>PressH (ANightSkyPlayerController)</li> <li>PressLeft (ANightSkyPlayerController)</li> <li>PressRight (ANightSkyPlayerController)</li> <li>PressUp (ANightSkyPlayerController)</li> <li>PauseParticles (AParticleManager)</li> <li>PauseRoundTimer (APlayerObject)</li> <li>PlayCommonLevelSequence (APlayerObject)</li> <li>PostStateChange (APlayerObject)</li> <li>PostEditChangeOwner (UNightSkyAnimSequenceUserData)</li> <li>PlayComboCounterAnim (UNightSkyBattleWidget)</li> <li>PlayFadeAnim (UNightSkyBattleWidget)</li> <li>PlayFadeOutAnim (UNightSkyBattleWidget)</li> <li>PlayGaugeAnim (UNightSkyBattleWidget)</li> <li>PlayHealthAnim (UNightSkyBattleWidget)</li> <li>PlayMatchWinAnim (UNightSkyBattleWidget)</li> <li>PlayMeterAnim (UNightSkyBattleWidget)</li> <li>PlayRecoverableHealthAnim (UNightSkyBattleWidget)</li> <li>PlayRoundInitAnim (UNightSkyBattleWidget)</li> <li>PlayRoundWinAnim (UNightSkyBattleWidget)</li> <li>PlayStandardAnimations (UNightSkyBattleWidget)</li> <li>PlayTimerAnim (UNightSkyBattleWidget)</li> <li>PlayReplayFromBP (UNightSkyGameInstance)</li> <li>PlayReplayToGameState (UNightSkyGameInstance)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#r","title":"r","text":"<ul> <li>RemoveEventHandler (ABattleObject)</li> <li>RemoveLinkActor (ABattleObject)</li> <li>ResetObject (ABattleObject)</li> <li>ResetParams (ANightSkyAIController)</li> <li>ResetTraining (ANightSkyGameState, ANightSkyPlayerController)</li> <li>RollbackStartAudio (ANightSkyGameState)</li> <li>RoundInit (ANightSkyGameState, APlayerObject)</li> <li>ReleaseA (ANightSkyPlayerController)</li> <li>ReleaseB (ANightSkyPlayerController)</li> <li>ReleaseC (ANightSkyPlayerController)</li> <li>ReleaseD (ANightSkyPlayerController)</li> <li>ReleaseDown (ANightSkyPlayerController)</li> <li>ReleaseE (ANightSkyPlayerController)</li> <li>ReleaseF (ANightSkyPlayerController)</li> <li>ReleaseG (ANightSkyPlayerController)</li> <li>ReleaseH (ANightSkyPlayerController)</li> <li>ReleaseLeft (ANightSkyPlayerController)</li> <li>ReleaseRight (ANightSkyPlayerController)</li> <li>ReleaseUp (ANightSkyPlayerController)</li> <li>Rematch (ANightSkyPlayerController)</li> <li>RollbackParticles (AParticleManager)</li> <li>RecoverHealth (APlayerObject)</li> <li>RemoveAutoComboCancel (APlayerObject)</li> <li>RemoveChainCancelOption (APlayerObject)</li> <li>RemoveWhiffCancelOption (APlayerObject)</li> <li>ResetAirDash (APlayerObject)</li> <li>ResetAirJump (APlayerObject)</li> <li>RoundInit_BP (APlayerObject)</li> <li>Rand (FRandomManager)</li> <li>RandRange (FRandomManager)</li> <li>Reseed (FRandomManager)</li> <li>RecvFrom (RpcConnectionManager)</li> <li>RpcConnectionManager (RpcConnectionManager)</li> <li>RegisterBinding (UExtendedCommonActivatableWidget)</li> <li>RegisterAnimationsForRollback (UNightSkyBattleWidget)</li> <li>RollbackAnimations (UNightSkyBattleWidget)</li> <li>RecordReplay (UNightSkyGameInstance)</li> <li>RollbackReplay (UNightSkyGameInstance)</li> <li>ResetToCDO (USerializableObj)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#s","title":"s","text":"<ul> <li>SaveForRollback (ABattleObject, ANightSkyGameState, UNightSkyBattleWidget, USerializableObj)</li> <li>ScreenPosToWorldPos (ABattleObject, ANightSkyGameState)</li> <li>SetAttacking (ABattleObject)</li> <li>SetBlendCelName (ABattleObject)</li> <li>SetCelDuration (ABattleObject)</li> <li>SetCelName (ABattleObject)</li> <li>SetFacing (ABattleObject)</li> <li>SetFloorCollisionActive (ABattleObject)</li> <li>SetGauge (ABattleObject, ANightSkyGameState)</li> <li>SetHitOTG (ABattleObject)</li> <li>SetIgnoreHitstunScaling (ABattleObject)</li> <li>SetIgnoreOTG (ABattleObject)</li> <li>SetIgnorePushbackScaling (ABattleObject)</li> <li>SetObjectID (ABattleObject)</li> <li>SetPitch (ABattleObject)</li> <li>SetPlayerHit (ABattleObject)</li> <li>SetProjectileAttribute (ABattleObject)</li> <li>SetProrateOnce (ABattleObject)</li> <li>SetPushCollisionActive (ABattleObject)</li> <li>SetPushWidthExtend (ABattleObject)</li> <li>SetRoll (ABattleObject)</li> <li>SetSpeedXRaw (ABattleObject)</li> <li>SetTimeUntilNextCel (ABattleObject)</li> <li>SetWallCollisionActive (ABattleObject)</li> <li>SetYaw (ABattleObject)</li> <li>StartSuperFreeze (ABattleObject, ANightSkyGameState)</li> <li>SuperArmorSuccess (ABattleObject)</li> <li>SaveGameStateCallback (AFighterMultiplayerRunner)</li> <li>SendGgpoToClient (ANetworkPawn)</li> <li>SendGgpoToServer (ANetworkPawn)</li> <li>SendRematchToServer (ANetworkPawn)</li> <li>ServerChecksumCheck (ANetworkPawn)</li> <li>ServerGetBattleData (ANetworkPawn)</li> <li>ServerGetCharaData (ANetworkPawn)</li> <li>ServerGetFinishedLoading (ANetworkPawn)</li> <li>SetInputs (ANightSkyAIController)</li> <li>SaveGameState (ANightSkyGameState)</li> <li>SetDrawPriorityBack (ANightSkyGameState)</li> <li>SetDrawPriorityFront (ANightSkyGameState)</li> <li>SetOtherChecksum (ANightSkyGameState)</li> <li>SetPaused (ANightSkyGameState)</li> <li>SetScreenBounds (ANightSkyGameState)</li> <li>SetScreenCorners (ANightSkyGameState)</li> <li>SetScreenFlags (ANightSkyGameState)</li> <li>SetTeamCooldown (ANightSkyGameState, APlayerObject)</li> <li>SortObjects (ANightSkyGameState)</li> <li>StopLevelSequence (ANightSkyGameState, APlayerObject)</li> <li>SwitchMainPlayer (ANightSkyGameState, APlayerObject)</li> <li>SendBattleData (ANightSkyPlayerController)</li> <li>SendGgpo (ANightSkyPlayerController)</li> <li>SetupInputComponent (ANightSkyPlayerController)</li> <li>SaveForRollbackBP (APlayerObject)</li> <li>SaveForRollbackPlayer (APlayerObject)</li> <li>SetAirDashNoAttackTimer (APlayerObject)</li> <li>SetAirDashTimer (APlayerObject)</li> <li>SetComponentVisibility (APlayerObject)</li> <li>SetDamageReactionCel (APlayerObject)</li> <li>SetDefaultComponentVisibility (APlayerObject)</li> <li>SetDefaultLandingAction (APlayerObject)</li> <li>SetGuardValues (APlayerObject)</li> <li>SetHeadAttribute (APlayerObject)</li> <li>SetHeadInvulnerable (APlayerObject)</li> <li>SetHealth (APlayerObject)</li> <li>SetHitValues (APlayerObject)</li> <li>SetHitValuesOverTime (APlayerObject)</li> <li>SetHitgrabActive (APlayerObject)</li> <li>SetKnockdownState (APlayerObject)</li> <li>SetMeterCooldownTimer (APlayerObject)</li> <li>SetOnScreen (APlayerObject)</li> <li>SetProjectileInvulnerable (APlayerObject)</li> <li>SetRecoverableHealth (APlayerObject)</li> <li>SetStance (APlayerObject)</li> <li>SetStateForCPU (APlayerObject)</li> <li>SetStrikeInvulnerable (APlayerObject)</li> <li>SetStrikeInvulnerableForTime (APlayerObject)</li> <li>SetStunTime (APlayerObject)</li> <li>SetThrowActive (APlayerObject)</li> <li>SetThrowExeState (APlayerObject)</li> <li>SetThrowInvulnerable (APlayerObject)</li> <li>SetThrowInvulnerableForTime (APlayerObject)</li> <li>SetThrowPosition (APlayerObject)</li> <li>SetThrowRange (APlayerObject)</li> <li>SetThrowResistForTime (APlayerObject)</li> <li>SetupPlayerInputComponent (AWTCharacter)</li> <li>StartBattle (AWTCharacter)</li> <li>Serialize (FRollbackData, UNightSkyAnimSequenceUserData)</li> <li>SetState (FStateMachine)</li> <li>SendTo (RpcConnectionManager)</li> <li>StartSession (UNSESessionSubsystem)</li> <li>SetAnimationRollbackData (UNightSkyBattleWidget)</li> <li>Sin_x1000 (UNightSkyBlueprintFunctionLibrary)</li> <li>SaveData (UNightSkySaveInfo)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#t","title":"t","text":"<ul> <li>Tick (AAudioManager, ABattleObject, ALinkActor, ANightSkyCharaSelectGameState, ANightSkyGameState, ANightSkyPlayerController, ANightSkyVSInfoGameState, ANightSkyWTGameState, ANightSkyWTPlayerController, AParticleManager, AWTCharacter)</li> <li>TriggerEvent (ABattleObject)</li> <li>ThrowEnd (APlayerObject)</li> <li>ThrowExe (APlayerObject)</li> <li>ToggleComponentVisibility (APlayerObject)</li> <li>TryTravelToCurrentSession (UNSESessionSubsystem)</li> <li>TravelToBattleMap (UNightSkyGameInstance)</li> <li>TravelToVSInfo (UNightSkyGameInstance)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#u","title":"u","text":"<ul> <li>Update (ABattleObject, AFighterLocalRunner, AFighterMultiplayerRunner, AFighterReplayRunner, AFighterSynctestRunner, ALinkActor, ANightSkyAIController, APlayerObject, FInputBuffer, FStateMachine)</li> <li>UpdateVisuals (ABattleObject, ANightSkyGameState)</li> <li>UpdateVisualsNoRollback (ABattleObject, APlayerObject)</li> <li>UpdateVisuals_BP (ABattleObject)</li> <li>UseGauge (ABattleObject, ANightSkyGameState)</li> <li>UpdateCamera (ANightSkyGameState)</li> <li>UpdateGameState (ANightSkyGameState)</li> <li>UpdateHUD (ANightSkyGameState)</li> <li>UpdateHUDAnimations_BP (ANightSkyGameState)</li> <li>UpdateHUD_BP (ANightSkyGameState)</li> <li>UpdateLocalInput (ANightSkyGameState)</li> <li>UpdateScreen (ANightSkyGameState)</li> <li>UpdateParticles (AParticleManager)</li> <li>UpdateNotBattle (APlayerObject)</li> <li>UseMeter (APlayerObject)</li> <li>UExtendedCommonActivatableWidget (UExtendedCommonActivatableWidget)</li> <li>UnregisterAllBindings (UExtendedCommonActivatableWidget)</li> <li>UnregisterBinding (UExtendedCommonActivatableWidget)</li> <li>UNSESessionSubsystem (UNSESessionSubsystem)</li> <li>UpdateSession (UNSESessionSubsystem)</li> <li>UNightSkyAnimMetaData (UNightSkyAnimMetaData)</li> <li>UpdateReplay (UNightSkyGameInstance)</li> <li>UObjectArraySaver (UNightSkySaveInfo)</li> <li>UObjectDataLoader (UNightSkySaveInfo)</li> <li>UObjectSaver (UNightSkySaveInfo)</li> <li>UObjectsPreloader (UNightSkySaveInfo)</li> <li>UReplaySaveInfo (UReplaySaveInfo)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#v","title":"v","text":"<ul> <li>Vec2Angle_x1000 (UNightSkyBlueprintFunctionLibrary)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#w","title":"w","text":"<ul> <li>WriteInputCondition (FInputBuffer)</li> </ul>"},{"location":"NightSkyEngine/class_member_functions/#_1","title":"~","text":"<ul> <li>~FBattleObjectLog (FBattleObjectLog)</li> <li>~RpcConnectionManager (RpcConnectionManager)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/","title":"Class Member Variables","text":""},{"location":"NightSkyEngine/class_member_variables/#a","title":"a","text":"<ul> <li>AnnouncerVoicePlayer (AAudioManager)</li> <li>ActionReg1 (ABattleObject, FBattleObjectLog)</li> <li>ActionReg2 (ABattleObject, FBattleObjectLog)</li> <li>ActionReg3 (ABattleObject, FBattleObjectLog)</li> <li>ActionReg4 (ABattleObject, FBattleObjectLog)</li> <li>ActionReg5 (ABattleObject, FBattleObjectLog)</li> <li>ActionReg6 (ABattleObject, FBattleObjectLog)</li> <li>ActionReg7 (ABattleObject, FBattleObjectLog)</li> <li>ActionReg8 (ABattleObject, FBattleObjectLog)</li> <li>ActionTime (ABattleObject, FBattleObjectLog)</li> <li>AddColor (ABattleObject, FBattleObjectLog)</li> <li>AddFadeColor (ABattleObject, FBattleObjectLog)</li> <li>AddFadeSpeed (ABattleObject, FBattleObjectLog)</li> <li>AnglePitch_x1000 (ABattleObject)</li> <li>AngleRoll_x1000 (ABattleObject)</li> <li>AngleYaw_x1000 (ABattleObject)</li> <li>AnimBlendIn (ABattleObject, FBattleObjectLog, FCollisionStruct)</li> <li>AnimBlendOut (ABattleObject, FBattleObjectLog, FCollisionStruct)</li> <li>AnimFrame (ABattleObject, FBattleObjectLog, FCollisionStruct)</li> <li>AnimStructs (ABattleObject)</li> <li>AttackFlags (ABattleObject, FBattleObjectLog)</li> <li>AttackOwner (ABattleObject, FBattleObjectLog)</li> <li>AttackTarget (ABattleObject, FBattleObjectLog)</li> <li>AudioManager (ANightSkyGameState)</li> <li>AirDashCount (APlayerObject, FPlayerObjectLog)</li> <li>AirDashMinimumHeight (APlayerObject, FPlayerObjectLog)</li> <li>AirDashNoAttackTime (APlayerObject, FPlayerObjectLog)</li> <li>AirDashTimer (APlayerObject, FPlayerObjectLog)</li> <li>AirDashTimerMax (APlayerObject, FPlayerObjectLog)</li> <li>AirJumpCount (APlayerObject, FPlayerObjectLog)</li> <li>AirPushHeight (APlayerObject, FPlayerObjectLog)</li> <li>AirPushHeightLow (APlayerObject, FPlayerObjectLog)</li> <li>AirPushWidth (APlayerObject, FPlayerObjectLog)</li> <li>AutoComboCancels (APlayerObject, FPlayerObjectLog)</li> <li>AnimSequence (FAnimStruct)</li> <li>AnglePitch_x10 (FBattleObjectLog)</li> <li>AngleRoll_x10 (FBattleObjectLog)</li> <li>AngleYaw_x10 (FBattleObjectLog)</li> <li>ActiveObjectCount (FBattleState)</li> <li>AnnouncerVoiceChannel (FBattleState)</li> <li>AssistCooldown (FBattleState)</li> <li>Anim (FCollisionStruct, FRollbackAnimation)</li> <li>AirHitAction (FHitData)</li> <li>AirPushbackX (FHitData)</li> <li>AirPushbackXOverTime (FHitData)</li> <li>AirPushbackY (FHitData)</li> <li>AirPushbackYOverTime (FHitData)</li> <li>AirGuardPushbackX (FHitDataCommon)</li> <li>AirGuardPushbackY (FHitDataCommon)</li> <li>AttackLevel (FHitDataCommon)</li> <li>ActorClass (FLinkActorStruct)</li> <li>AttackSpeed (FStateCPUData)</li> <li>AttackXBeginRange (FStateCPUData)</li> <li>AttackXEndRange (FStateCPUData)</li> <li>AttackYBeginRange (FStateCPUData)</li> <li>AttackYEndRange (FStateCPUData)</li> <li>ArmorDamagePercent (FSuperArmorData)</li> <li>ArmorHits (FSuperArmorData)</li> <li>AnnouncerData (UNightSkyGameInstance)</li> <li>AntiAliasingMethod (UNightSkySettingsInfo)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#b","title":"b","text":"<ul> <li>B (ABattleObject, FBattleObjectLog)</li> <li>BlendAnimFrame (ABattleObject, FBattleObjectLog)</li> <li>BlendCelName (ABattleObject, FBattleObjectLog)</li> <li>BlendOffset (ABattleObject, FBattleObjectLog)</li> <li>Boxes (ABattleObject, FCollisionStruct)</li> <li>bIsCommonState (ABattleObject, FBattleObjectLog)</li> <li>bRender (ABattleObject, FBattleObjectLog)</li> <li>bRematchAccepted (ANetworkPawn, ANightSkyPlayerController)</li> <li>bBlock (ANightSkyAIController)</li> <li>BottomWidget (ANightSkyBattleHudActor)</li> <li>BattleExtensionData (ANightSkyGameState)</li> <li>BattleExtensionNames (ANightSkyGameState)</li> <li>BattleExtensions (ANightSkyGameState)</li> <li>BattleHudActor (ANightSkyGameState)</li> <li>BattleObjectClass (ANightSkyGameState)</li> <li>BattleSceneTransform (ANightSkyGameState)</li> <li>BattleState (ANightSkyGameState)</li> <li>bIsPlayingSequence (ANightSkyGameState)</li> <li>bIsResimulating (ANightSkyGameState)</li> <li>bPauseGame (ANightSkyGameState)</li> <li>bViewCollision (ANightSkyGameState)</li> <li>bRematch (ANightSkyPlayerController)</li> <li>bSentCharaData (ANightSkyPlayerController)</li> <li>bIsBattling (ANightSkyWTGameState)</li> <li>bIsMatchEnd (ANightSkyWTGameState)</li> <li>BattleParticles (AParticleManager)</li> <li>BAirDashNoAttackTime (APlayerObject, FPlayerObjectLog)</li> <li>BAirDashSpeed (APlayerObject, FPlayerObjectLog)</li> <li>BAirDashTime (APlayerObject, FPlayerObjectLog)</li> <li>BDashGravity (APlayerObject, FPlayerObjectLog)</li> <li>BDashHeight (APlayerObject, FPlayerObjectLog)</li> <li>BDashSpeed (APlayerObject, FPlayerObjectLog)</li> <li>BJumpSpeed (APlayerObject, FPlayerObjectLog)</li> <li>BSuperJumpSpeed (APlayerObject, FPlayerObjectLog)</li> <li>BWalkSpeed (APlayerObject, FPlayerObjectLog)</li> <li>BufferedStateName (APlayerObject, FPlayerObjectLog)</li> <li>bCrumpled (APlayerObject, FPlayerObjectLog)</li> <li>bIsAutoCombo (APlayerObject, FPlayerObjectLog)</li> <li>bIsCpu (APlayerObject)</li> <li>bLimitCrumple (APlayerObject, FPlayerObjectLog)</li> <li>bMirrorWhenFlip (APlayerObject)</li> <li>BattlePlayer (AWTCharacter)</li> <li>BattlePlayerClass (AWTCharacter)</li> <li>BattleFormat (FBattleData, FBattleState)</li> <li>BattlePhase (FBattleState)</li> <li>BattleStateSync (FBattleState)</li> <li>BattleStateSyncEnd (FBattleState)</li> <li>bHUDVisible (FBattleState)</li> <li>BlowbackLevel (FHitData)</li> <li>BlockType (FHitDataCommon, FStateCPUData)</li> <li>BlockstopModifier (FHitDataCommon)</li> <li>Blockstun (FHitDataCommon)</li> <li>BeginFrame (FHitValueOverTime)</li> <li>bIsActive (FLinkedActorContainer)</li> <li>bActor (FObjectRecord)</li> <li>bPlaying (FRollbackAnimation)</li> <li>BattleStateBuffer (FRollbackData)</li> <li>BattleStateData (FRollbackData)</li> <li>bTouchingWorldSide (FScreenData)</li> <li>bAntiAir (FStateCPUData)</li> <li>bAttack (FStateCPUData)</li> <li>bBigDamage (FStateCPUData)</li> <li>bBlockstring (FStateCPUData)</li> <li>bCombo (FStateCPUData)</li> <li>bInvuln (FStateCPUData)</li> <li>bNoCombo (FStateCPUData)</li> <li>bProjectile (FStateCPUData)</li> <li>bPunish (FStateCPUData)</li> <li>bThrow (FStateCPUData)</li> <li>bUsesResource (FStateCPUData)</li> <li>bPrimary (FStateMachine)</li> <li>bArmorHead (FSuperArmorData)</li> <li>bArmorLow (FSuperArmorData)</li> <li>bArmorMid (FSuperArmorData)</li> <li>bArmorOverhead (FSuperArmorData)</li> <li>bArmorProjectile (FSuperArmorData)</li> <li>bArmorStrike (FSuperArmorData)</li> <li>bArmorTakeChipDamage (FSuperArmorData)</li> <li>bArmorThrow (FSuperArmorData)</li> <li>BindingHandles (UExtendedCommonActivatableWidget)</li> <li>BattleData (UNightSkyGameInstance, UReplaySaveInfo)</li> <li>BattleVersion (UNightSkyGameInstance)</li> <li>bIsTraining (UReplaySaveInfo)</li> <li>bCPUUsable (UState)</li> <li>bEnableReverseBeat (UState)</li> <li>bHumanUsable (UState)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#c","title":"c","text":"<ul> <li>CharaAudioPlayers (AAudioManager)</li> <li>CharaVoicePlayers (AAudioManager)</li> <li>CommonAudioPlayers (AAudioManager)</li> <li>CelIndex (ABattleObject, FBattleObjectLog, UState)</li> <li>CelName (ABattleObject, FBattleObjectLog, FCollisionStruct)</li> <li>CharaSelectGameState (ABattleObject)</li> <li>ColPosX (ABattleObject, FBattleObjectLog)</li> <li>ColPosY (ABattleObject, FBattleObjectLog)</li> <li>CounterHit (ABattleObject, FBattleObjectLog)</li> <li>connectionManager (AFighterMultiplayerRunner)</li> <li>CharaDataReceived (ANetworkPawn)</li> <li>CameraActor (ANightSkyGameState)</li> <li>Checksum (ANightSkyGameState)</li> <li>CameraShakeData (APlayerObject)</li> <li>CanProximityThrow (APlayerObject, FPlayerObjectLog)</li> <li>CanReverseBeat (APlayerObject, FPlayerObjectLog)</li> <li>CancelFlags (APlayerObject, FPlayerObjectLog)</li> <li>ChainCancelOptions (APlayerObject)</li> <li>CharaParticleData (APlayerObject)</li> <li>CharaStateData (APlayerObject)</li> <li>CharaSubroutineData (APlayerObject)</li> <li>CloseNormalRange (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg1 (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg2 (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg3 (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg4 (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg5 (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg6 (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg7 (APlayerObject, FPlayerObjectLog)</li> <li>CmnPlayerReg8 (APlayerObject, FPlayerObjectLog)</li> <li>CollisionData (APlayerObject)</li> <li>ColorIndex (APlayerObject)</li> <li>ComboCounter (APlayerObject, FPlayerObjectLog)</li> <li>ComboRate (APlayerObject, FPlayerObjectLog)</li> <li>ComboTimer (APlayerObject, FPlayerObjectLog)</li> <li>CommonCollisionData (APlayerObject)</li> <li>CommonLinkActorData (APlayerObject)</li> <li>CommonObjectStateData (APlayerObject)</li> <li>CommonObjectStateNames (APlayerObject)</li> <li>CommonObjectStates (APlayerObject)</li> <li>CommonParticleData (APlayerObject)</li> <li>CommonSequenceData (APlayerObject)</li> <li>CommonSoundData (APlayerObject)</li> <li>CommonSubroutineData (APlayerObject)</li> <li>CommonSubroutineNames (APlayerObject)</li> <li>CommonSubroutines (APlayerObject)</li> <li>ComponentVisible (APlayerObject, FPlayerObjectLog)</li> <li>CrouchPushHeight (APlayerObject, FPlayerObjectLog)</li> <li>CrouchPushWidth (APlayerObject, FPlayerObjectLog)</li> <li>CurrentAirDashCount (APlayerObject, FPlayerObjectLog)</li> <li>CurrentAirJumpCount (APlayerObject, FPlayerObjectLog)</li> <li>CurrentHealth (APlayerObject, FPlayerObjectLog)</li> <li>ColorIndicesP1 (FBattleData)</li> <li>ColorIndicesP2 (FBattleData)</li> <li>CameraPosition (FBattleState)</li> <li>CharaAudioChannels (FBattleState)</li> <li>CharaVoiceChannels (FBattleState)</li> <li>CommonAudioChannels (FBattleState)</li> <li>CurrentIntroSide (FBattleState)</li> <li>CurrentSequenceTime (FBattleState)</li> <li>CurrentWinSide (FBattleState)</li> <li>CameraShake (FCameraShakeStruct)</li> <li>CustomType (FCollisionBox)</li> <li>CustomHitAction (FHitData)</li> <li>ChipDamagePercent (FHitDataCommon)</li> <li>Class (FObjectRecord)</li> <li>CharBuffer (FRollbackData)</li> <li>CenterXVelocity (FScreenData)</li> <li>CenterYVelocity (FScreenData)</li> <li>CurrentState (FStateMachine)</li> <li>CooldownTimer (FTeamData)</li> <li>CameraShakeStructs (UCameraShakeData)</li> <li>CollisionFrames (UCollisionData)</li> <li>CreateSessionCompleteDelegate (UNSESessionSubsystem)</li> <li>CreateSessionCompleteDelegateHandle (UNSESessionSubsystem)</li> <li>CurrentAnimTime (UNightSkyAnimInstance)</li> <li>CachedBoneNames (UNightSkyAnimMetaData)</li> <li>CurrentReplay (UNightSkyGameInstance)</li> <li>CharaDescription (UPrimaryCharaData)</li> <li>CharaFriendlyName (UPrimaryCharaData)</li> <li>CharaHUDIcon (UPrimaryCharaData)</li> <li>CharaName (UPrimaryCharaData)</li> <li>CharaSelectIcon (UPrimaryCharaData)</li> <li>CharaSplashIcon (UPrimaryCharaData)</li> <li>CPUData (UState)</li> <li>CustomStateType (UState)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#d","title":"d","text":"<ul> <li>DamageColor (ABattleObject, FBattleObjectLog, FHitDataCommon)</li> <li>DamageColor2 (ABattleObject, FBattleObjectLog, FHitDataCommon)</li> <li>Direction (ABattleObject, FBattleObjectLog)</li> <li>DrawPriority (ABattleObject, FBattleObjectLog)</li> <li>DrawPriorityLinkObj (ABattleObject, FBattleObjectLog)</li> <li>DamageReactionCels (APlayerObject)</li> <li>Damage (FHitData)</li> <li>DeathCamOverride (FHitDataCommon)</li> <li>DisallowedInputs (FInputBitmask, FInputBuffer, FInputCondition)</li> <li>Data (FObjectRecord, UNightSkySaveInfo)</li> <li>DefaultMaxWidth (FScreenData)</li> <li>DefaultWidth (FScreenData)</li> <li>DefaultInputConfig (UExtendedCommonActivatableWidget)</li> <li>DestroySessionCompleteDelegate (UNSESessionSubsystem)</li> <li>DestroySessionCompleteDelegateHandle (UNSESessionSubsystem)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#e","title":"e","text":"<ul> <li>EventHandlers (ABattleObject, FBattleObjectLog)</li> <li>ElapsedTime (AFighterLocalRunner)</li> <li>Enemy (APlayerObject, FPlayerObjectLog)</li> <li>ExeStateName (APlayerObject, FPlayerObjectLog)</li> <li>ExtraGauges (APlayerObject)</li> <li>EnemyHitstopModifier (FHitData)</li> <li>EnemyBlockstopModifier (FHitDataCommon)</li> <li>EndFrame (FHitValueOverTime)</li> <li>ExtensionData (FRollbackData)</li> <li>EnableFlags (FStateMachine)</li> <li>EnabledCustomStateTypes (FStateMachine)</li> <li>ExtensionArray (UBattleExtensionData)</li> <li>EntryStance (UState)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#f","title":"f","text":"<ul> <li>FadeTransparency (ABattleObject, FBattleObjectLog)</li> <li>FrameBlendPosition (ABattleObject, FBattleObjectLog)</li> <li>FighterMultiplayerRunner (ANetworkPawn)</li> <li>FighterRunner (ANightSkyGameState, UNightSkyGameInstance)</li> <li>Frame (ANightSkyPlayerController)</li> <li>FAirDashNoAttackTime (APlayerObject, FPlayerObjectLog)</li> <li>FAirDashSpeed (APlayerObject, FPlayerObjectLog)</li> <li>FAirDashTime (APlayerObject, FPlayerObjectLog)</li> <li>FDashAccel (APlayerObject, FPlayerObjectLog)</li> <li>FDashFriction (APlayerObject, FPlayerObjectLog)</li> <li>FDashInitSpeed (APlayerObject, FPlayerObjectLog)</li> <li>FDashMaxSpeed (APlayerObject, FPlayerObjectLog)</li> <li>FJumpSpeed (APlayerObject, FPlayerObjectLog)</li> <li>FSuperJumpSpeed (APlayerObject, FPlayerObjectLog)</li> <li>FWalkSpeed (APlayerObject, FPlayerObjectLog)</li> <li>FlipInputs (APlayerObject, FPlayerObjectLog)</li> <li>ForwardAirDashMeterGain (APlayerObject, FPlayerObjectLog)</li> <li>ForwardDashMeterGain (APlayerObject, FPlayerObjectLog)</li> <li>ForwardJumpMeterGain (APlayerObject, FPlayerObjectLog)</li> <li>ForwardWalkMeterGain (APlayerObject, FPlayerObjectLog)</li> <li>Flipbook (FAnimStruct, FFlipbookStruct)</li> <li>Finished (FAudioChannel)</li> <li>FadeTimer (FBattleState)</li> <li>FrameNumber (FBattleState)</li> <li>FunctionName (FEventHandler)</li> <li>FloatingCrumpleType (FHitData)</li> <li>ForcedProration (FHitData)</li> <li>FinalScreenWidth (FScreenData)</li> <li>FinalScreenX (FScreenData)</li> <li>FinalScreenY (FScreenData)</li> <li>Flags (FScreenData)</li> <li>FlipbookStructs (UFlipbookData)</li> <li>FindSessionsCompleteDelegate (UNSESessionSubsystem)</li> <li>FindSessionsCompleteDelegateHandle (UNSESessionSubsystem)</li> <li>FrameCount (UNightSkyAnimSequenceUserData)</li> <li>FrameRate (UNightSkyAnimSequenceUserData)</li> <li>FinishedLoadingForNetworkBattle (UNightSkyGameInstance)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#g","title":"g","text":"<ul> <li>GameState (ABattleObject, AFighterLocalRunner, ANightSkyAIController, AWTCharacter)</li> <li>GotoLabelActive (ABattleObject, FBattleObjectLog)</li> <li>Gravity (ABattleObject, FBattleObjectLog, FHitData)</li> <li>GroundHeight (ABattleObject, FBattleObjectLog)</li> <li>ggpo (AFighterMultiplayerRunner)</li> <li>GameInstance (AFighterReplayRunner, ANightSkyCharaSelectGameState, ANightSkyGameState, ANightSkyVSInfoGameState)</li> <li>GaugeP1 (FBattleState)</li> <li>GaugeP2 (FBattleState)</li> <li>GroundBounceCount (FGroundBounceData)</li> <li>GroundBounceGravity (FGroundBounceData)</li> <li>GroundBounceStop (FGroundBounceData)</li> <li>GroundBounceUntech (FGroundBounceData)</li> <li>GroundBounceXRate (FGroundBounceData)</li> <li>GroundBounceXSpeed (FGroundBounceData)</li> <li>GroundBounceYRate (FGroundBounceData)</li> <li>GroundBounceYSpeed (FGroundBounceData)</li> <li>GravityOverTime (FHitData)</li> <li>GroundBounce (FHitData)</li> <li>GroundHitAction (FHitData)</li> <li>GroundPushbackX (FHitData)</li> <li>GroundGuardPushbackX (FHitDataCommon)</li> <li>GuardGravity (FHitDataCommon)</li> <li>GuardSFX (FHitDataCommon)</li> <li>GuardSFXOverride (FHitDataCommon)</li> <li>GuardVFX (FHitDataCommon)</li> <li>GuardVFXOverride (FHitDataCommon)</li> <li>GameMouseCaptureMode (UExtendedCommonActivatableWidget)</li> <li>GameVersion (UNightSkyGameInstance)</li> <li>GlobalIlluminationMethod (UNightSkySettingsInfo)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#h","title":"h","text":"<ul> <li>HitCommon (ABattleObject, FBattleObjectLog)</li> <li>Hitstop (ABattleObject, FBattleObjectLog, FHitData)</li> <li>HomingParams (ABattleObject, FBattleObjectLog)</li> <li>HardKnockdown (FHitData)</li> <li>Hitstun (FHitData)</li> <li>HitAngle (FHitDataCommon)</li> <li>HitSFX (FHitDataCommon)</li> <li>HitSFXOverride (FHitDataCommon)</li> <li>HitVFX (FHitDataCommon)</li> <li>HitVFXOverride (FHitDataCommon)</li> <li>Handle (FInputActionBindingHandle)</li> <li>Hold (FInputBitmask)</li> <li>HigherObjBottom (FScreenData)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#i","title":"i","text":"<ul> <li>Inertia (ABattleObject, FBattleObjectLog)</li> <li>IsActive (ABattleObject, FBattleObjectLog)</li> <li>IsPlayer (ABattleObject, FBattleObjectLog)</li> <li>InputCount (ANightSkyAIController)</li> <li>InputCountLimit (ANightSkyAIController)</li> <li>InputActions (ANightSkyPlayerController)</li> <li>InputMapping (ANightSkyPlayerController)</li> <li>Inputs (ANightSkyPlayerController, APlayerObject, FPlayerObjectLog)</li> <li>InstantBlockLockoutTimer (APlayerObject, FPlayerObjectLog)</li> <li>IntroEndFlag (APlayerObject, FPlayerObjectLog)</li> <li>IntroName (APlayerObject, FPlayerObjectLog)</li> <li>InvulnFlags (APlayerObject, FPlayerObjectLog)</li> <li>IsPlayingSequence (FBattleState)</li> <li>InitialValue (FExtraGauge)</li> <li>InitialProration (FHitData)</li> <li>InputFlag (FInputBitmask)</li> <li>ImpreciseInputCount (FInputBuffer, FInputCondition)</li> <li>InputBufferInternal (FInputBuffer)</li> <li>InputSequence (FInputBuffer)</li> <li>InputTime (FInputBuffer)</li> <li>InputConditions (FInputConditionList)</li> <li>Index (FLinkedActorContainer)</li> <li>IsCPUBattle (UNightSkyGameInstance)</li> <li>IsReplay (UNightSkyGameInstance)</li> <li>IsTraining (UNightSkyGameInstance)</li> <li>InputsP1 (UReplaySaveInfo)</li> <li>InputsP2 (UReplaySaveInfo)</li> <li>InputConditionLists (UState)</li> <li>IsFollowupState (UState)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#j","title":"j","text":"<ul> <li>JumpGravity (APlayerObject, FPlayerObjectLog)</li> <li>JumpHeight (APlayerObject, FPlayerObjectLog)</li> <li>JoinSessionCompleteDelegate (UNSESessionSubsystem)</li> <li>JoinSessionCompleteDelegateHandle (UNSESessionSubsystem)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#k","title":"k","text":"<ul> <li>KnockdownTime (FHitData)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#l","title":"l","text":"<ul> <li>L (ABattleObject, FBattleObjectLog)</li> <li>LabelName (ABattleObject, FBattleObjectLog)</li> <li>LinkedActor (ABattleObject)</li> <li>LinkedParticle (ABattleObject)</li> <li>LocalFrame (ANightSkyGameState)</li> <li>LocalInputs (ANightSkyGameState)</li> <li>LoadedCharaPackageCount (ANightSkyVSInfoGameState)</li> <li>LastStateName (APlayerObject, FPlayerObjectLog)</li> <li>LinkActorData (APlayerObject)</li> <li>Lenience (FInputBitmask)</li> <li>LinkedActorStructs (ULinkActorData)</li> <li>LastSessionSearch (UNSESessionSubsystem)</li> <li>LastSessionSettings (UNSESessionSubsystem)</li> <li>LoginDelegateHandle (UNSESessionSubsystem)</li> <li>LengthInFrames (UReplaySaveInfo)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#m","title":"m","text":"<ul> <li>MusicPlayer (AAudioManager)</li> <li>MaterialLinkObj (ABattleObject, FBattleObjectLog)</li> <li>MaxCelTime (ABattleObject, FBattleObjectLog)</li> <li>MiscFlags (ABattleObject, FBattleObjectLog)</li> <li>MulColor (ABattleObject, FBattleObjectLog)</li> <li>MulFadeColor (ABattleObject, FBattleObjectLog)</li> <li>MulFadeSpeed (ABattleObject, FBattleObjectLog)</li> <li>MultipliedFramesAhead (AFighterMultiplayerRunner)</li> <li>MultipliedFramesBehind (AFighterMultiplayerRunner)</li> <li>MaxBattleObjects (ANightSkyGameState)</li> <li>MapLoaded (ANightSkyVSInfoGameState)</li> <li>MaxVSInfoTime (ANightSkyVSInfoGameState)</li> <li>MaterialData (APlayerObject)</li> <li>MaxColorIndex (APlayerObject)</li> <li>MaxHealth (APlayerObject, FPlayerObjectLog)</li> <li>MaxMeter (APlayerObject, FBattleState, FPlayerObjectLog)</li> <li>MaxOTGCount (APlayerObject, FPlayerObjectLog)</li> <li>MeterCooldownTimer (APlayerObject, FPlayerObjectLog)</li> <li>MeterPercentOnHit (APlayerObject, FPlayerObjectLog)</li> <li>MeterPercentOnHitGuard (APlayerObject, FPlayerObjectLog)</li> <li>MeterPercentOnReceiveHit (APlayerObject, FPlayerObjectLog)</li> <li>MeterPercentOnReceiveHitGuard (APlayerObject, FPlayerObjectLog)</li> <li>MovesUsedInChain (APlayerObject)</li> <li>MovesUsedInCombo (APlayerObject)</li> <li>MaxDuration (FAudioChannel, FSoundStruct)</li> <li>MusicName (FBattleData)</li> <li>MainPlayer (FBattleState)</li> <li>MaxFadeTimer (FBattleState)</li> <li>MaxGauge (FBattleState)</li> <li>MaxRoundCount (FBattleState)</li> <li>MaxTimeUntilRoundStart (FBattleState)</li> <li>Meter (FBattleState)</li> <li>MusicChannel (FBattleState)</li> <li>MaxValue (FExtraGauge)</li> <li>MinimumDamagePercent (FHitData)</li> <li>Method (FInputCondition)</li> <li>MaxInstances (FLinkActorStruct, UState)</li> <li>Material (FMaterialStruct)</li> <li>MaxZoomOutWidth (FScreenData)</li> <li>MaterialStructs (UMaterialData)</li> <li>MeshSpaceBoneTransforms (UNightSkyAnimSequenceUserData)</li> <li>MusicData (UNightSkyGameInstance)</li> <li>MaxChain (UState)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#n","title":"n","text":"<ul> <li>NextOffsetX (ABattleObject, FBattleObjectLog)</li> <li>NextOffsetY (ABattleObject, FBattleObjectLog)</li> <li>NormalHit (ABattleObject, FBattleObjectLog)</li> <li>NetworkStats (ANightSkyGameState)</li> <li>NetworkPawn (ANightSkyPlayerController)</li> <li>NiagaraComponent (FBattleParticle)</li> <li>Name (FCameraShakeStruct, FFlipbookStruct, FLinkActorStruct, FLinkedActorContainer, FMaterialStruct, FObjectRecord, FParticleStruct, FSequenceStruct, FSoundStruct, UBattleExtension, UState, USubroutine)</li> <li>NumOpenPrivateConnections (FNSESessionInfo)</li> <li>NumOpenPublicConnections (FNSESessionInfo)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#o","title":"o","text":"<ul> <li>ObjNumber (ABattleObject)</li> <li>ObjSync (ABattleObject, FBattleObjectLog)</li> <li>ObjSyncEnd (ABattleObject, FBattleObjectLog)</li> <li>ObjectID (ABattleObject, FBattleObjectLog, UState)</li> <li>ObjectOffset (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg1 (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg2 (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg3 (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg4 (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg5 (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg6 (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg7 (ABattleObject, FBattleObjectLog)</li> <li>ObjectReg8 (ABattleObject, FBattleObjectLog)</li> <li>ObjectRotation (ABattleObject, FBattleObjectLog)</li> <li>ObjectScale (ABattleObject, FBattleObjectLog)</li> <li>ObjectState (ABattleObject)</li> <li>ObjectStateIndex (ABattleObject, FBattleObjectLog)</li> <li>ObjectStateName (ABattleObject, FBattleObjectLog)</li> <li>ObjectsToIgnoreHitsFrom (ABattleObject)</li> <li>OrthoBlendActive (ABattleObject, FBattleState)</li> <li>Objects (ANightSkyGameState)</li> <li>OtherChecksum (ANightSkyGameState)</li> <li>OtherChecksumFrame (ANightSkyGameState)</li> <li>OnBattleEndDelegate (ANightSkyWTGameState)</li> <li>OTGCount (APlayerObject, FPlayerObjectLog)</li> <li>ObjectStateData (APlayerObject)</li> <li>ObjectStateNames (APlayerObject)</li> <li>ObjectStates (APlayerObject)</li> <li>OtgProration (APlayerObject, FPlayerObjectLog)</li> <li>OffsetX (FHomingParams)</li> <li>OffsetY (FHomingParams)</li> <li>OverlayMaterial (FMaterialStruct)</li> <li>OwningUserName (FNSESessionInfo)</li> <li>Outer (FObjectRecord)</li> <li>OuterID (FObjectRecord)</li> <li>ObjActive (FRollbackData)</li> <li>ObjBuffer (FRollbackData)</li> <li>ObjBottom (FScreenData)</li> <li>ObjDistanceY (FScreenData)</li> <li>ObjHeight (FScreenData)</li> <li>ObjLeft (FScreenData)</li> <li>ObjLength (FScreenData)</li> <li>ObjRight (FScreenData)</li> <li>ObjTop (FScreenData)</li> <li>OnCreateSessionCompleteDelegate (UNSESessionSubsystem)</li> <li>OnDestroySessionCompleteEvent (UNSESessionSubsystem)</li> <li>OnFindSessionsCompleteEvent (UNSESessionSubsystem)</li> <li>OnJoinGameSessionCompleteEvent (UNSESessionSubsystem)</li> <li>OnStartSessionCompleteEvent (UNSESessionSubsystem)</li> <li>OnUpdateSessionCompleteEvent (UNSESessionSubsystem)</li> <li>ObjectRecords (UNightSkySaveInfo)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#p","title":"p","text":"<ul> <li>Player (ABattleObject, ANightSkyAIController, FBattleObjectLog)</li> <li>PosX (ABattleObject, FBattleObjectLog, FCollisionBox, FHitPosition)</li> <li>PosY (ABattleObject, FBattleObjectLog, FCollisionBox, FHitPosition)</li> <li>PosZ (ABattleObject, FBattleObjectLog)</li> <li>PositionLinkObj (ABattleObject, FBattleObjectLog)</li> <li>PrevOffsetX (ABattleObject, FBattleObjectLog)</li> <li>PrevOffsetY (ABattleObject, FBattleObjectLog)</li> <li>PrevPosX (ABattleObject, FBattleObjectLog)</li> <li>PrevPosY (ABattleObject, FBattleObjectLog)</li> <li>PrevPosZ (ABattleObject, FBattleObjectLog)</li> <li>PrevRootMotionX (ABattleObject, FBattleObjectLog)</li> <li>PrevRootMotionY (ABattleObject, FBattleObjectLog)</li> <li>PrevRootMotionZ (ABattleObject, FBattleObjectLog)</li> <li>PushHeight (ABattleObject, FBattleObjectLog)</li> <li>PushHeightLow (ABattleObject, FBattleObjectLog)</li> <li>PushWidth (ABattleObject, FBattleObjectLog)</li> <li>PushWidthExtend (ABattleObject, FBattleObjectLog)</li> <li>Pushback (ABattleObject, FBattleObjectLog)</li> <li>PlayerHandles (AFighterMultiplayerRunner)</li> <li>PlayerInputIndex (AFighterMultiplayerRunner)</li> <li>Players (AFighterMultiplayerRunner, ANightSkyGameState)</li> <li>P1Charas (ANightSkyCharaSelectGameState)</li> <li>P1Positions (ANightSkyCharaSelectGameState)</li> <li>P2Charas (ANightSkyCharaSelectGameState)</li> <li>P2Positions (ANightSkyCharaSelectGameState)</li> <li>ParticleManager (ANightSkyGameState)</li> <li>PrevOtherChecksumFrame (ANightSkyGameState)</li> <li>Packages (ANightSkyVSInfoGameState)</li> <li>PlayerFlags (APlayerObject, FPlayerObjectLog)</li> <li>PlayerIndex (APlayerObject, FPlayerObjectLog, UNightSkyGameInstance)</li> <li>PlayerReg1 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerReg2 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerReg3 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerReg4 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerReg5 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerReg6 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerReg7 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerReg8 (APlayerObject, FPlayerObjectLog)</li> <li>PlayerSync (APlayerObject, FPlayerObjectLog)</li> <li>PlayerSyncEnd (APlayerObject, FPlayerObjectLog)</li> <li>PrimaryStateMachine (APlayerObject)</li> <li>ProximityThrowInput (APlayerObject, FPlayerObjectLog)</li> <li>Pitch (FAnimRotator)</li> <li>PartName (FAnimStruct)</li> <li>Position (FAnimTransform, FHitData)</li> <li>PlayerListP1 (FBattleData)</li> <li>PlayerListP2 (FBattleData)</li> <li>PauseGame (FBattleInputActions)</li> <li>PressA (FBattleInputActions)</li> <li>PressB (FBattleInputActions)</li> <li>PressC (FBattleInputActions)</li> <li>PressD (FBattleInputActions)</li> <li>PressDown (FBattleInputActions)</li> <li>PressE (FBattleInputActions)</li> <li>PressF (FBattleInputActions)</li> <li>PressG (FBattleInputActions)</li> <li>PressH (FBattleInputActions)</li> <li>PressLeft (FBattleInputActions)</li> <li>PressRight (FBattleInputActions)</li> <li>PressUp (FBattleInputActions)</li> <li>ParticleOwner (FBattleParticle)</li> <li>P1RoundsWon (FBattleState, UNightSkyBattleWidget)</li> <li>P2RoundsWon (FBattleState, UNightSkyBattleWidget)</li> <li>PauseParticles (FBattleState)</li> <li>PauseTimer (FBattleState)</li> <li>ProximityBlockDistanceX (FHitDataCommon)</li> <li>ProximityBlockDistanceY (FHitDataCommon)</li> <li>ParamA (FHomingParams)</li> <li>ParamB (FHomingParams)</li> <li>Pos (FHomingParams)</li> <li>PlayerList (FNetworkMirror)</li> <li>Ping (FNetworkStats, UNightSkyBattleWidget)</li> <li>ParticleSystem (FParticleStruct)</li> <li>PlayerData (FRollbackData)</li> <li>PunishRange (FStateCPUData)</li> <li>Parent (FStateMachine, UBattleExtension, UState, USubroutine)</li> <li>playerIndex (RpcConnectionManager)</li> <li>P1ComboCounter (UNightSkyBattleWidget)</li> <li>P1Gauge (UNightSkyBattleWidget)</li> <li>P1Health (UNightSkyBattleWidget)</li> <li>P1Meter (UNightSkyBattleWidget)</li> <li>P1RecoverableHealth (UNightSkyBattleWidget)</li> <li>P2ComboCounter (UNightSkyBattleWidget)</li> <li>P2Gauge (UNightSkyBattleWidget)</li> <li>P2Health (UNightSkyBattleWidget)</li> <li>P2Meter (UNightSkyBattleWidget)</li> <li>P2RecoverableHealth (UNightSkyBattleWidget)</li> <li>PersistentOuters (UNightSkySaveInfo)</li> <li>ParticleStructs (UParticleData)</li> <li>PlayerClass (UPrimaryCharaData)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#r","title":"r","text":"<ul> <li>R (ABattleObject, FBattleObjectLog)</li> <li>ReceivedHit (ABattleObject, FBattleObjectLog)</li> <li>ReceivedHitCommon (ABattleObject, FBattleObjectLog)</li> <li>RemoteFrame (ANightSkyGameState)</li> <li>RecoverableHealth (APlayerObject, FPlayerObjectLog)</li> <li>RoundEndFlag (APlayerObject, FPlayerObjectLog)</li> <li>RoundWinTimer (APlayerObject, FPlayerObjectLog)</li> <li>Roll (FAnimRotator)</li> <li>Rotation (FAnimTransform)</li> <li>Random (FBattleData)</li> <li>RoundCount (FBattleData, FBattleState)</li> <li>ReleaseA (FBattleInputActions)</li> <li>ReleaseB (FBattleInputActions)</li> <li>ReleaseC (FBattleInputActions)</li> <li>ReleaseD (FBattleInputActions)</li> <li>ReleaseDown (FBattleInputActions)</li> <li>ReleaseE (FBattleInputActions)</li> <li>ReleaseF (FBattleInputActions)</li> <li>ReleaseG (FBattleInputActions)</li> <li>ReleaseH (FBattleInputActions)</li> <li>ReleaseLeft (FBattleInputActions)</li> <li>ReleaseRight (FBattleInputActions)</li> <li>ReleaseUp (FBattleInputActions)</li> <li>ResetTraining (FBattleInputActions)</li> <li>ReturnReg (FBattleObjectLog)</li> <li>RandomManager (FBattleState)</li> <li>RoundStartPos (FBattleState)</li> <li>RoundTimer (FBattleState)</li> <li>RecoverableDamagePercent (FHitData)</li> <li>RollbackFrames (FNetworkStats, UNightSkyBattleWidget)</li> <li>receiveSchedule (RpcConnectionManager)</li> <li>RootMontage (UNightSkyAnimInstance)</li> <li>RootTranslation (UNightSkyAnimSequenceUserData)</li> <li>ReplayList (UNightSkyGameInstance)</li> <li>ReplayIndex (UReplaySaveInfo)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#s","title":"s","text":"<ul> <li>ScreenSpaceDepthOffset (ABattleObject)</li> <li>SocketName (ABattleObject, FBattleObjectLog)</li> <li>SocketObj (ABattleObject, FBattleObjectLog)</li> <li>SocketOffset (ABattleObject, FBattleObjectLog)</li> <li>SpeedX (ABattleObject, FBattleObjectLog)</li> <li>SpeedXRate (ABattleObject, FBattleObjectLog)</li> <li>SpeedXRatePerFrame (ABattleObject, FBattleObjectLog)</li> <li>SpeedY (ABattleObject, FBattleObjectLog)</li> <li>SpeedYRate (ABattleObject, FBattleObjectLog)</li> <li>SpeedYRatePerFrame (ABattleObject, FBattleObjectLog)</li> <li>SpeedZ (ABattleObject, FBattleObjectLog)</li> <li>SpeedZRate (ABattleObject, FBattleObjectLog)</li> <li>SpeedZRatePerFrame (ABattleObject, FBattleObjectLog)</li> <li>StopLinkObj (ABattleObject, FBattleObjectLog)</li> <li>StunTime (ABattleObject, FBattleObjectLog)</li> <li>StunTimeMax (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReg1 (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReg2 (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReg3 (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReg4 (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReturnVal1 (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReturnVal2 (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReturnVal3 (ABattleObject, FBattleObjectLog)</li> <li>SubroutineReturnVal4 (ABattleObject, FBattleObjectLog)</li> <li>SuperArmorData (ABattleObject, FBattleObjectLog)</li> <li>SequenceActor (ANightSkyGameState)</li> <li>SequenceCameraActor (ANightSkyGameState)</li> <li>SequenceCameraActorClass (ANightSkyGameState)</li> <li>SequenceEnemy (ANightSkyGameState)</li> <li>SequenceTarget (ANightSkyGameState)</li> <li>SortedObjects (ANightSkyGameState)</li> <li>SequenceData (APlayerObject)</li> <li>SoundData (APlayerObject)</li> <li>Stance (APlayerObject, FPlayerObjectLog)</li> <li>StandPushHeight (APlayerObject, FPlayerObjectLog)</li> <li>StandPushWidth (APlayerObject, FPlayerObjectLog)</li> <li>StateEntryName (APlayerObject, FPlayerObjectLog)</li> <li>StoredBattleObjects (APlayerObject, FPlayerObjectLog)</li> <li>StoredInputBuffer (APlayerObject, FPlayerObjectLog)</li> <li>StoredLinkActors (APlayerObject)</li> <li>StrikeInvulnerableTimer (APlayerObject, FPlayerObjectLog)</li> <li>SubStateData (APlayerObject)</li> <li>SubStateMachines (APlayerObject)</li> <li>SubroutineNames (APlayerObject)</li> <li>Subroutines (APlayerObject)</li> <li>SuperJumpGravity (APlayerObject, FPlayerObjectLog)</li> <li>SuperJumpHeight (APlayerObject, FPlayerObjectLog)</li> <li>Scale (FAnimTransform)</li> <li>SoundWave (FAudioChannel, FSoundStruct)</li> <li>StartingFrame (FAudioChannel)</li> <li>Stage (FBattleData, FNetworkMirror)</li> <li>StartRoundTimer (FBattleData)</li> <li>ScreenData (FBattleState)</li> <li>SuperFreezeCaller (FBattleState)</li> <li>SuperFreezeDuration (FBattleState)</li> <li>SuperFreezeSelfDuration (FBattleState)</li> <li>SizeX (FCollisionBox)</li> <li>SizeY (FCollisionBox)</li> <li>SubroutineName (FEventHandler, USubroutineState)</li> <li>Sections (FExtraGauge)</li> <li>SFXType (FHitDataCommon)</li> <li>Sequence (FInputCondition, FSequenceStruct)</li> <li>StoredActor (FLinkedActorContainer)</li> <li>SessionSearchResult (FNSESessionInfo)</li> <li>Self (FObjectRecord)</li> <li>Seed (FRandomManager)</li> <li>StateData (FRollbackData)</li> <li>ScreenBoundsLeft (FScreenData)</li> <li>ScreenBoundsRight (FScreenData)</li> <li>ScreenBoundsTop (FScreenData)</li> <li>ScreenWorldCenterX (FScreenData)</li> <li>ScreenWorldCenterY (FScreenData)</li> <li>ScreenWorldWidth (FScreenData)</li> <li>ScreenYZoom (FScreenData)</li> <li>StageBoundsLeft (FScreenData)</li> <li>StageBoundsRight (FScreenData)</li> <li>StageBoundsTop (FScreenData)</li> <li>StateMachineName (FStateMachine)</li> <li>StateNames (FStateMachine)</li> <li>States (FStateMachine)</li> <li>sendSchedule (RpcConnectionManager)</li> <li>SessionUserInviteAcceptedDelegate (UNSESessionSubsystem)</li> <li>SessionUserInviteAcceptedDelegateHandle (UNSESessionSubsystem)</li> <li>StartSessionCompleteDelegate (UNSESessionSubsystem)</li> <li>StartSessionCompleteDelegateHandle (UNSESessionSubsystem)</li> <li>SettingsInfo (UNightSkyGameInstance)</li> <li>StageDescription (UPrimaryStageData)</li> <li>StageFriendlyName (UPrimaryStageData)</li> <li>StageName (UPrimaryStageData)</li> <li>StageSelectIcon (UPrimaryStageData)</li> <li>StageSplashIcon (UPrimaryStageData)</li> <li>StageURL (UPrimaryStageData)</li> <li>SequenceStructs (USequenceData)</li> <li>SoundDatas (USoundData)</li> <li>ShareChainName (UState)</li> <li>StateConditions (UState)</li> <li>StateType (UState)</li> <li>StateToEnter (UStateAlias)</li> <li>StateArray (UStateData)</li> <li>SubroutineArray (USubroutineData)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#t","title":"t","text":"<ul> <li>T (ABattleObject, FBattleObjectLog)</li> <li>TimeUntilNextCel (ABattleObject, FBattleObjectLog)</li> <li>Timer0 (ABattleObject, FBattleObjectLog)</li> <li>Timer1 (ABattleObject, FBattleObjectLog)</li> <li>Transparency (ABattleObject, FBattleObjectLog)</li> <li>TransparencySpeed (ABattleObject, FBattleObjectLog)</li> <li>TargetState (ANightSkyAIController)</li> <li>TopWidget (ANightSkyBattleHudActor)</li> <li>TotalCharaPackageCount (ANightSkyVSInfoGameState)</li> <li>TeamIndex (APlayerObject, FPlayerObjectLog)</li> <li>ThrowInvulnerableTimer (APlayerObject, FPlayerObjectLog)</li> <li>ThrowRange (APlayerObject, FPlayerObjectLog)</li> <li>ThrowResistAfterWakeUp (APlayerObject, FPlayerObjectLog)</li> <li>ThrowResistTimer (APlayerObject, FPlayerObjectLog)</li> <li>ThrowTechTimer (APlayerObject, FPlayerObjectLog)</li> <li>ThrowTechWindow (APlayerObject, FPlayerObjectLog)</li> <li>TotalProration (APlayerObject, FPlayerObjectLog)</li> <li>TimeUntilRoundStart (FBattleData, FBattleState)</li> <li>TagCooldown (FBattleState)</li> <li>TeamData (FBattleState)</li> <li>Type (FCollisionBox, FHitPosition, FHomingParams, FSuperArmorData)</li> <li>Target (FHomingParams)</li> <li>Transform (FObjectRecord)</li> <li>Time (FRollbackAnimation)</li> <li>TargetCenterX (FScreenData)</li> <li>TargetCenterY (FScreenData)</li> <li>TargetObjects (FScreenData)</li> <li>TargetOffsetAirYAdd (FScreenData)</li> <li>TargetOffsetAirYDist (FScreenData)</li> <li>TargetOffsetAirYMax (FScreenData)</li> <li>TargetOffsetAirYPos (FScreenData)</li> <li>TargetOffsetLandYAdd (FScreenData)</li> <li>TargetOffsetLandYMax (FScreenData)</li> <li>TargetOffsetY (FScreenData)</li> <li>TargetWidth (FScreenData)</li> <li>TeamCount (FTeamData)</li> <li>Timer (UNightSkyBattleWidget)</li> <li>TempObjects (UNightSkySaveInfo)</li> <li>Timestamp (UReplaySaveInfo)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#u","title":"u","text":"<ul> <li>UpdateTime (ABattleObject, FBattleObjectLog)</li> <li>Untech (FHitData)</li> <li>UpdateSessionCompleteDelegate (UNSESessionSubsystem)</li> <li>UpdateSessionCompleteDelegateHandle (UNSESessionSubsystem)</li> <li>UserData (UNightSkyAnimMetaData)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#v","title":"v","text":"<ul> <li>VSInfoTime (ANightSkyVSInfoGameState)</li> <li>VoiceData (APlayerObject)</li> <li>Value (FExtraGauge, FHitValueOverTime)</li> <li>VFXType (FHitDataCommon)</li> <li>Version (UReplaySaveInfo)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#w","title":"w","text":"<ul> <li>WaitCount (ANightSkyAIController)</li> <li>WaitLimit (ANightSkyAIController)</li> <li>WallTouchTimer (APlayerObject, FPlayerObjectLog)</li> <li>WhiffCancelOptions (APlayerObject)</li> <li>WallBounce (FHitData)</li> <li>WidgetAnimationData (FRollbackData)</li> <li>WidthVelocity (FScreenData)</li> <li>WallBounceCount (FWallBounceData)</li> <li>WallBounceGravity (FWallBounceData)</li> <li>WallBounceInCornerOnly (FWallBounceData)</li> <li>WallBounceStop (FWallBounceData)</li> <li>WallBounceUntech (FWallBounceData)</li> <li>WallBounceXRate (FWallBounceData)</li> <li>WallBounceXSpeed (FWallBounceData)</li> <li>WallBounceYRate (FWallBounceData)</li> <li>WallBounceYSpeed (FWallBounceData)</li> <li>WidgetAnimationRollback (UNightSkyBattleWidget)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#x","title":"x","text":"<ul> <li>X (FAnimVector)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#y","title":"y","text":"<ul> <li>Yaw (FAnimRotator)</li> <li>Y (FAnimVector)</li> </ul>"},{"location":"NightSkyEngine/class_member_variables/#z","title":"z","text":"<ul> <li>Z (FAnimVector)</li> <li>ZoomOutBeginH (FScreenData)</li> <li>ZoomOutBeginX (FScreenData)</li> <li>ZoomOutBeginY (FScreenData)</li> </ul>"},{"location":"NightSkyEngine/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"NightSkyEngine/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"NightSkyEngine/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"NightSkyEngine/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"NightSkyEngine/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"NightSkyEngine/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"NightSkyEngine/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"NightSkyEngine/functions/","title":"Functions","text":""},{"location":"NightSkyEngine/functions/#c","title":"c","text":"<ul> <li>clip_line_y (BattleObject.cpp)</li> </ul>"},{"location":"NightSkyEngine/functions/#d","title":"d","text":"<ul> <li>DECLARE_MULTICAST_DELEGATE (CollisionData.h)</li> <li>DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam (NSESessionSubsystem.h)</li> <li>DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams (NSESessionSubsystem.h)</li> <li>DECLARE_MULTICAST_DELEGATE_OneParam (NSESessionSubsystem.h)</li> <li>DECLARE_DYNAMIC_DELEGATE_OneParam (ExtendedCommonActivatableWidget.h)</li> <li>DECLARE_DYNAMIC_MULTICAST_DELEGATE (NightSkyWTGameState.h)</li> </ul>"},{"location":"NightSkyEngine/functions/#e","title":"e","text":"<ul> <li>ENUM_CLASS_FLAGS (Bitflags.h, NightSkyGameState.h)</li> </ul>"},{"location":"NightSkyEngine/functions/#i","title":"i","text":"<ul> <li>isqrt (Globals.cpp, Globals.h)</li> <li>isqrt_impl (Globals.cpp, Globals.h)</li> <li>IMPLEMENT_MODULE (NightSkyEngine.cpp)</li> </ul>"},{"location":"NightSkyEngine/functions/#l","title":"l","text":"<ul> <li>line_box_intersection (BattleObject.cpp)</li> </ul>"},{"location":"NightSkyEngine/functions/#m","title":"m","text":"<ul> <li>max (BattleObject.cpp)</li> <li>min (BattleObject.cpp)</li> </ul>"},{"location":"NightSkyEngine/functions/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (NightSkyAnimSequenceUserData.h)</li> </ul>"},{"location":"NightSkyEngine/functions/#u","title":"u","text":"<ul> <li>UE_DEFINE_GAMEPLAY_TAG_COMMENT (PlayerObject.cpp, StateMachine.cpp, BattleExtensionData.cpp, ParticleData.cpp, SoundData.cpp, StateData.cpp, SubroutineData.cpp)</li> <li>UE_DECLARE_GAMEPLAY_TAG_EXTERN (PlayerObject.h, StateMachine.h, BattleExtensionData.h, ParticleData.h, SoundData.h, StateData.h, SubroutineData.h)</li> </ul>"},{"location":"NightSkyEngine/macros/","title":"Macros","text":""},{"location":"NightSkyEngine/macros/#c","title":"c","text":"<ul> <li>COORD_SCALE (Globals.h)</li> </ul>"},{"location":"NightSkyEngine/macros/#l","title":"l","text":"<ul> <li>LOCTEXT_NAMESPACE (CollisionData.cpp, ExtendedCommonActivatableWidget.cpp)</li> </ul>"},{"location":"NightSkyEngine/variables/","title":"Variables","text":""},{"location":"NightSkyEngine/variables/#c","title":"c","text":"<ul> <li>CharaAudioChannelCount (AudioManager.h)</li> <li>CharaVoiceChannelCount (AudioManager.h)</li> <li>CommonAudioChannelCount (AudioManager.h)</li> </ul>"},{"location":"NightSkyEngine/variables/#e","title":"e","text":"<ul> <li>EAttackFlags (Bitflags.h)</li> <li>ECancelFlags (Bitflags.h)</li> <li>EEnableFlags (Bitflags.h)</li> <li>EInputFlags (Bitflags.h)</li> <li>EInvulnFlags (Bitflags.h)</li> <li>EMiscFlags (Bitflags.h)</li> <li>EPlayerFlags (Bitflags.h)</li> <li>EBoxType (CollisionBox.h)</li> <li>EBlockType (BattleObject.h)</li> <li>EDistanceType (BattleObject.h)</li> <li>EEventType (BattleObject.h)</li> <li>EFloatingCrumpleType (BattleObject.h)</li> <li>EHitAction (BattleObject.h)</li> <li>EHitPositionType (BattleObject.h)</li> <li>EHitSFXType (BattleObject.h)</li> <li>EHitVFXType (BattleObject.h)</li> <li>EHomingType (BattleObject.h)</li> <li>EObjDir (BattleObject.h)</li> <li>EObjType (BattleObject.h)</li> <li>EPosType (BattleObject.h)</li> <li>ESuperArmorType (BattleObject.h)</li> <li>EActionStance (PlayerObject.h)</li> <li>EAttackSpeed (State.h)</li> <li>EEntryStance (State.h)</li> <li>EInputMethod (State.h)</li> <li>ERangeType (State.h)</li> <li>EStateCondition (State.h)</li> <li>EStateType (State.h)</li> <li>EBattleFormat (NightSkyGameState.h)</li> <li>EBattlePhase (NightSkyGameState.h)</li> <li>EIntroSide (NightSkyGameState.h)</li> <li>EScreenFlag (NightSkyGameState.h)</li> <li>EWinSide (NightSkyGameState.h)</li> <li>EFighterRunners (FighterRunners.h)</li> <li>ENightSkyWidgetInputMode (ExtendedCommonActivatableWidget.h)</li> </ul>"},{"location":"NightSkyEngine/variables/#g","title":"g","text":"<ul> <li>gSinTable (Globals.h)</li> </ul>"},{"location":"NightSkyEngine/variables/#i","title":"i","text":"<ul> <li>InputBufferSize (InputBuffer.h)</li> <li>InputSequenceSize (InputBuffer.h)</li> </ul>"},{"location":"NightSkyEngine/variables/#m","title":"m","text":"<ul> <li>MaxDrawPriority (BattleObject.h)</li> <li>MaxComponentCount (PlayerObject.h)</li> <li>MaxRollbackFrames (NightSkyGameState.h)</li> <li>MaxReplays (NightSkyGameInstance.h)</li> </ul>"},{"location":"NightSkyEngine/variables/#o","title":"o","text":"<ul> <li>OneFrame (NightSkyGameState.h)</li> </ul>"},{"location":"NightSkyEngine/variables/#s","title":"s","text":"<ul> <li>SizeOfBattleObject (BattleObject.h)</li> <li>SizeOfPlayerObject (PlayerObject.h)</li> <li>SizeOfBattleState (NightSkyGameState.h)</li> </ul>"},{"location":"NightSkyEngine/variables/#t","title":"t","text":"<ul> <li>TimesyncMultiplier (FighterMultiplayerRunner.h)</li> </ul>"},{"location":"NightSkyEngine/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"NightSkyEngineEditor/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class FNightSkyEngineEditorModule </li> <li>class UNightSkyEditorBlueprintLibrary </li> </ul>"},{"location":"NightSkyEngineEditor/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir Plugins <ul> <li>dir NightSkyEngine <ul> <li>dir Source <ul> <li>dir NightSkyEngineEditor <ul> <li>dir Private <ul> <li>file NightSkyEditorBlueprintLibrary.cpp </li> <li>file NightSkyEngineEditor.cpp </li> </ul> </li> <li>dir Public <ul> <li>file NightSkyEditorBlueprintLibrary.h </li> <li>file NightSkyEngineEditor.h </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"NightSkyEngineEditor/class_f_night_sky_engine_editor_module/","title":"Class FNightSkyEngineEditorModule","text":"<p>ClassList &gt; FNightSkyEngineEditorModule</p> <p>Inherits the following classes: IModuleInterface</p>"},{"location":"NightSkyEngineEditor/class_f_night_sky_engine_editor_module/#public-functions","title":"Public Functions","text":"Type Name virtual void ShutdownModule () override virtual void StartupModule () override"},{"location":"NightSkyEngineEditor/class_f_night_sky_engine_editor_module/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"NightSkyEngineEditor/class_f_night_sky_engine_editor_module/#function-shutdownmodule","title":"function ShutdownModule","text":"<pre><code>virtual void FNightSkyEngineEditorModule::ShutdownModule () override\n</code></pre>"},{"location":"NightSkyEngineEditor/class_f_night_sky_engine_editor_module/#function-startupmodule","title":"function StartupModule","text":"<pre><code>virtual void FNightSkyEngineEditorModule::StartupModule () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngineEditor/Public/NightSkyEngineEditor.h</code></p>"},{"location":"NightSkyEngineEditor/class_u_night_sky_editor_blueprint_library/","title":"Class UNightSkyEditorBlueprintLibrary","text":"<p>ClassList &gt; UNightSkyEditorBlueprintLibrary</p> <p>Inherits the following classes: UBlueprintFunctionLibrary</p>"},{"location":"NightSkyEngineEditor/class_u_night_sky_editor_blueprint_library/#public-static-functions","title":"Public Static Functions","text":"Type Name FGameplayTag GetGameplayTagFromName (FName Name)"},{"location":"NightSkyEngineEditor/class_u_night_sky_editor_blueprint_library/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"NightSkyEngineEditor/class_u_night_sky_editor_blueprint_library/#function-getgameplaytagfromname","title":"function GetGameplayTagFromName","text":"<pre><code>static FGameplayTag UNightSkyEditorBlueprintLibrary::GetGameplayTagFromName (\n    FName Name\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngineEditor/Public/NightSkyEditorBlueprintLibrary.h</code></p>"},{"location":"NightSkyEngineEditor/dir_0b4eaef40a1fe20bedafe9e8e719ce66/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins","text":"<p>FileList &gt; Plugins</p>"},{"location":"NightSkyEngineEditor/dir_0b4eaef40a1fe20bedafe9e8e719ce66/#directories","title":"Directories","text":"Type Name dir NightSkyEngine <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/</code></p>"},{"location":"NightSkyEngineEditor/dir_01309b4faf1ec48651014f612e2b32bb/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine","text":"<p>FileList &gt; NightSkyEngine</p>"},{"location":"NightSkyEngineEditor/dir_01309b4faf1ec48651014f612e2b32bb/#directories","title":"Directories","text":"Type Name dir Source <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/</code></p>"},{"location":"NightSkyEngineEditor/dir_d32ee28216ed342fa25c01ae9dcd9cc4/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source","text":"<p>FileList &gt; NightSkyEngine &gt; Source</p>"},{"location":"NightSkyEngineEditor/dir_d32ee28216ed342fa25c01ae9dcd9cc4/#directories","title":"Directories","text":"Type Name dir NightSkyEngineEditor <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/</code></p>"},{"location":"NightSkyEngineEditor/dir_e38b96015bf9e01b06e1db3a9ecb109f/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngineEditor","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngineEditor</p>"},{"location":"NightSkyEngineEditor/dir_e38b96015bf9e01b06e1db3a9ecb109f/#directories","title":"Directories","text":"Type Name dir Private dir Public <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngineEditor/</code></p>"},{"location":"NightSkyEngineEditor/dir_bb140671b05e9cd1d3ff0c1fb32f057e/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngineEditor/Private","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngineEditor &gt; Private</p>"},{"location":"NightSkyEngineEditor/dir_bb140671b05e9cd1d3ff0c1fb32f057e/#files","title":"Files","text":"Type Name file NightSkyEditorBlueprintLibrary.cpp file NightSkyEngineEditor.cpp <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngineEditor/Private/</code></p>"},{"location":"NightSkyEngineEditor/_night_sky_editor_blueprint_library_8cpp/","title":"File NightSkyEditorBlueprintLibrary.cpp","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngineEditor &gt; Private &gt; NightSkyEditorBlueprintLibrary.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyEditorBlueprintLibrary.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngineEditor/Private/NightSkyEditorBlueprintLibrary.cpp</code></p>"},{"location":"NightSkyEngineEditor/_night_sky_editor_blueprint_library_8cpp_source/","title":"File NightSkyEditorBlueprintLibrary.cpp","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngineEditor &gt; Private &gt; NightSkyEditorBlueprintLibrary.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"NightSkyEditorBlueprintLibrary.h\"\n\n#include UE_INLINE_GENERATED_CPP_BY_NAME(NightSkyEditorBlueprintLibrary)\n\nFGameplayTag UNightSkyEditorBlueprintLibrary::GetGameplayTagFromName(FName Name)\n{\n    return FGameplayTag::RequestGameplayTag(Name);\n}\n</code></pre>"},{"location":"NightSkyEngineEditor/_night_sky_engine_editor_8cpp/","title":"File NightSkyEngineEditor.cpp","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngineEditor &gt; Private &gt; NightSkyEngineEditor.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"NightSkyEngineEditor.h\"</code></li> </ul>"},{"location":"NightSkyEngineEditor/_night_sky_engine_editor_8cpp/#macros","title":"Macros","text":"Type Name define LOCTEXT_NAMESPACE <code>\"FNightSkyEngineEditorModule\"</code>"},{"location":"NightSkyEngineEditor/_night_sky_engine_editor_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"NightSkyEngineEditor/_night_sky_engine_editor_8cpp/#define-loctext_namespace","title":"define LOCTEXT_NAMESPACE","text":"<pre><code>#define LOCTEXT_NAMESPACE `\"FNightSkyEngineEditorModule\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngineEditor/Private/NightSkyEngineEditor.cpp</code></p>"},{"location":"NightSkyEngineEditor/_night_sky_engine_editor_8cpp_source/","title":"File NightSkyEngineEditor.cpp","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngineEditor &gt; Private &gt; NightSkyEngineEditor.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"NightSkyEngineEditor.h\"\n\n#define LOCTEXT_NAMESPACE \"FNightSkyEngineEditorModule\"\n\nvoid FNightSkyEngineEditorModule::StartupModule()\n{\n\n}\n\nvoid FNightSkyEngineEditorModule::ShutdownModule()\n{\n\n}\n\n#undef LOCTEXT_NAMESPACE\n\nIMPLEMENT_MODULE(FNightSkyEngineEditorModule, NightSkyEngineEditor)\n</code></pre>"},{"location":"NightSkyEngineEditor/dir_b1f934c454122ee63eeb5ca8173b113f/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngineEditor/Public","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngineEditor &gt; Public</p>"},{"location":"NightSkyEngineEditor/dir_b1f934c454122ee63eeb5ca8173b113f/#files","title":"Files","text":"Type Name file NightSkyEditorBlueprintLibrary.h file NightSkyEngineEditor.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngineEditor/Public/</code></p>"},{"location":"NightSkyEngineEditor/_night_sky_editor_blueprint_library_8h/","title":"File NightSkyEditorBlueprintLibrary.h","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngineEditor &gt; Public &gt; NightSkyEditorBlueprintLibrary.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"GameplayTagContainer.h\"</code></li> <li><code>#include \"Kismet/BlueprintFunctionLibrary.h\"</code></li> <li><code>#include \"NightSkyEditorBlueprintLibrary.generated.h\"</code></li> </ul>"},{"location":"NightSkyEngineEditor/_night_sky_editor_blueprint_library_8h/#classes","title":"Classes","text":"Type Name class UNightSkyEditorBlueprintLibrary <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngineEditor/Public/NightSkyEditorBlueprintLibrary.h</code></p>"},{"location":"NightSkyEngineEditor/_night_sky_editor_blueprint_library_8h_source/","title":"File NightSkyEditorBlueprintLibrary.h","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngineEditor &gt; Public &gt; NightSkyEditorBlueprintLibrary.h</p> <p>Go to the documentation of this file</p> <pre><code>// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameplayTagContainer.h\"\n#include \"Kismet/BlueprintFunctionLibrary.h\"\n#include \"NightSkyEditorBlueprintLibrary.generated.h\"\n\nUCLASS()\nclass NIGHTSKYENGINEEDITOR_API UNightSkyEditorBlueprintLibrary : public UBlueprintFunctionLibrary\n{\n    GENERATED_BODY()\n\npublic:\n    UFUNCTION(BlueprintCallable, Category = \"Gameplay Tags\")\n    static FGameplayTag GetGameplayTagFromName(FName Name);\n};\n</code></pre>"},{"location":"NightSkyEngineEditor/_night_sky_engine_editor_8h/","title":"File NightSkyEngineEditor.h","text":"<p>FileList &gt; NightSkyEngine &gt; Source &gt; NightSkyEngineEditor &gt; Public &gt; NightSkyEngineEditor.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Modules/ModuleManager.h\"</code></li> </ul>"},{"location":"NightSkyEngineEditor/_night_sky_engine_editor_8h/#classes","title":"Classes","text":"Type Name class FNightSkyEngineEditorModule <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/NightSkyEngineEditor/Public/NightSkyEngineEditor.h</code></p>"},{"location":"NightSkyEngineEditor/_night_sky_engine_editor_8h_source/","title":"File NightSkyEngineEditor.h","text":"<p>File List &gt; NightSkyEngine &gt; Source &gt; NightSkyEngineEditor &gt; Public &gt; NightSkyEngineEditor.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleManager.h\"\n\nclass FNightSkyEngineEditorModule : public IModuleInterface\n{\npublic:\n    virtual void StartupModule() override;\n    virtual void ShutdownModule() override;\n};\n</code></pre>"},{"location":"NightSkyEngineEditor/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"NightSkyEngineEditor/classes/","title":"Class Index","text":""},{"location":"NightSkyEngineEditor/classes/#f","title":"f","text":"<ul> <li>FNightSkyEngineEditorModule</li> </ul>"},{"location":"NightSkyEngineEditor/classes/#u","title":"u","text":"<ul> <li>UNightSkyEditorBlueprintLibrary</li> </ul>"},{"location":"NightSkyEngineEditor/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class IModuleInterface <ul> <li>class FNightSkyEngineEditorModule </li> </ul> </li> <li>class UBlueprintFunctionLibrary <ul> <li>class UNightSkyEditorBlueprintLibrary </li> </ul> </li> </ul>"},{"location":"NightSkyEngineEditor/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"NightSkyEngineEditor/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"NightSkyEngineEditor/class_members/","title":"Class Members","text":""},{"location":"NightSkyEngineEditor/class_members/#g","title":"g","text":"<ul> <li>GetGameplayTagFromName (UNightSkyEditorBlueprintLibrary)</li> </ul>"},{"location":"NightSkyEngineEditor/class_members/#s","title":"s","text":"<ul> <li>ShutdownModule (FNightSkyEngineEditorModule)</li> <li>StartupModule (FNightSkyEngineEditorModule)</li> </ul>"},{"location":"NightSkyEngineEditor/class_member_functions/","title":"Class Member Functions","text":""},{"location":"NightSkyEngineEditor/class_member_functions/#g","title":"g","text":"<ul> <li>GetGameplayTagFromName (UNightSkyEditorBlueprintLibrary)</li> </ul>"},{"location":"NightSkyEngineEditor/class_member_functions/#s","title":"s","text":"<ul> <li>ShutdownModule (FNightSkyEngineEditorModule)</li> <li>StartupModule (FNightSkyEngineEditorModule)</li> </ul>"},{"location":"NightSkyEngineEditor/class_member_variables/","title":"Class Member Variables","text":"<p>Nothing related to Class Member Variables found.</p>"},{"location":"NightSkyEngineEditor/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"NightSkyEngineEditor/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"NightSkyEngineEditor/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"NightSkyEngineEditor/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"NightSkyEngineEditor/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"NightSkyEngineEditor/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"NightSkyEngineEditor/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"NightSkyEngineEditor/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"NightSkyEngineEditor/macros/","title":"Macros","text":""},{"location":"NightSkyEngineEditor/macros/#l","title":"l","text":"<ul> <li>LOCTEXT_NAMESPACE (NightSkyEngineEditor.cpp)</li> </ul>"},{"location":"NightSkyEngineEditor/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"NightSkyEngineEditor/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"CollisionEditor/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class FAssetTypeActions_CollisionData </li> <li>class FCelAssetTreeNode </li> <li>class FCollisionAnimationPreviewScene </li> <li>class FCollisionAnimationViewportClient </li> <li>class FCollisionDataDetails </li> <li>class FCollisionDataEditorToolkit </li> <li>class FCollisionEditor </li> <li>class SCelAssetTree </li> <li>class SCollisionAnimationViewport </li> </ul>"},{"location":"CollisionEditor/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir Plugins <ul> <li>dir NightSkyEngine <ul> <li>dir Source <ul> <li>dir CollisionEditor <ul> <li>dir Private <ul> <li>file AssetTypeActions_CollisionData.cpp </li> <li>dir Viewport <ul> <li>file CollisionAnimationPreviewScene.cpp </li> <li>file CollisionAnimationViewport.cpp </li> <li>file CollisionAnimationViewportClient.cpp </li> </ul> </li> <li>file CelAssetTree.cpp </li> <li>file CollisionDataDetails.cpp </li> <li>file CollisionDataEditorToolkit.cpp </li> <li>file CollisionEditor.cpp </li> <li>file Logging.cpp </li> <li>file Logging.h </li> </ul> </li> <li>dir Public <ul> <li>file AssetTypeActions_CollisionData.h </li> <li>dir Viewport <ul> <li>file CollisionAnimationPreviewScene.h </li> <li>file CollisionAnimationViewport.h </li> <li>file CollisionAnimationViewportClient.h </li> </ul> </li> <li>file CelAssetTree.h </li> <li>file CelAssetTreeNode.h </li> <li>file CollisionDataDetails.h </li> <li>file CollisionDataEditorToolkit.h </li> <li>file CollisionEditor.h </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"CollisionEditor/class_f_asset_type_actions___collision_data/","title":"Class FAssetTypeActions_CollisionData","text":"<p>ClassList &gt; FAssetTypeActions_CollisionData</p> <p>Inherits the following classes: FAssetTypeActions_Base</p>"},{"location":"CollisionEditor/class_f_asset_type_actions___collision_data/#public-functions","title":"Public Functions","text":"Type Name virtual bool CanFilter () override FAssetTypeActions_CollisionData (EAssetTypeCategories::Type InAssetCategory)  virtual uint32 GetCategories () override virtual FText GetName () override const virtual UClass * GetSupportedClass () override const virtual FColor GetTypeColor () override const virtual void OpenAssetEditor (const TArray&lt; UObject * &gt; &amp; InObjects, TSharedPtr&lt; IToolkitHost &gt; EditWithinLevelEditor) override"},{"location":"CollisionEditor/class_f_asset_type_actions___collision_data/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CollisionEditor/class_f_asset_type_actions___collision_data/#function-canfilter","title":"function CanFilter","text":"<pre><code>inline virtual bool FAssetTypeActions_CollisionData::CanFilter () override\n</code></pre>"},{"location":"CollisionEditor/class_f_asset_type_actions___collision_data/#function-fassettypeactions_collisiondata","title":"function FAssetTypeActions_CollisionData","text":"<pre><code>inline FAssetTypeActions_CollisionData::FAssetTypeActions_CollisionData (\n    EAssetTypeCategories::Type InAssetCategory\n) \n</code></pre>"},{"location":"CollisionEditor/class_f_asset_type_actions___collision_data/#function-getcategories","title":"function GetCategories","text":"<pre><code>virtual uint32 FAssetTypeActions_CollisionData::GetCategories () override\n</code></pre>"},{"location":"CollisionEditor/class_f_asset_type_actions___collision_data/#function-getname","title":"function GetName","text":"<pre><code>virtual FText FAssetTypeActions_CollisionData::GetName () override const\n</code></pre>"},{"location":"CollisionEditor/class_f_asset_type_actions___collision_data/#function-getsupportedclass","title":"function GetSupportedClass","text":"<pre><code>virtual UClass * FAssetTypeActions_CollisionData::GetSupportedClass () override const\n</code></pre>"},{"location":"CollisionEditor/class_f_asset_type_actions___collision_data/#function-gettypecolor","title":"function GetTypeColor","text":"<pre><code>virtual FColor FAssetTypeActions_CollisionData::GetTypeColor () override const\n</code></pre>"},{"location":"CollisionEditor/class_f_asset_type_actions___collision_data/#function-openasseteditor","title":"function OpenAssetEditor","text":"<pre><code>virtual void FAssetTypeActions_CollisionData::OpenAssetEditor (\n    const TArray&lt; UObject * &gt; &amp; InObjects,\n    TSharedPtr&lt; IToolkitHost &gt; EditWithinLevelEditor\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/AssetTypeActions_CollisionData.h</code></p>"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/","title":"Class FCelAssetTreeNode","text":"<p>ClassList &gt; FCelAssetTreeNode</p> <p>More...</p> <ul> <li><code>#include &lt;CelAssetTreeNode.h&gt;</code></li> </ul> <p>Inherits the following classes: TSharedFromThis&lt; FCelAssetTreeNode &gt;</p>"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#public-attributes","title":"Public Attributes","text":"Type Name TArray&lt; TSharedPtr&lt; FCelAssetTreeNode &gt; &gt; Children TWeakPtr&lt; FCelAssetTreeNode &gt; Parent"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#public-functions","title":"Public Functions","text":"Type Name FCelAssetTreeNode (const FString &amp; InDisplayName, int32 InCelIndex=INDEX_NONE)  FCelAssetTreeNode (int32 InCelIndex, const FString &amp; InDisplayName, bool bInHasProblem=false)  TSharedPtr&lt; FCelAssetTreeNode &gt; FindOrCreateChild (const FString &amp; ChildName, int32 ChildCelIndex=INDEX_NONE)  int32 GetCelIndex () const FString GetDisplayName () const bool IsCategory () const bool IsCel () const bool IsValid () const void SetCelIndex (int32 InCelIndex)"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#detailed-description","title":"Detailed Description","text":"<p>Node for the cel asset tree view. Can represent either a category (intermediate node) or a cel (leaf node). </p>"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#variable-children","title":"variable Children","text":"<pre><code>TArray&lt;TSharedPtr&lt;FCelAssetTreeNode&gt; &gt; FCelAssetTreeNode::Children;\n</code></pre>"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#variable-parent","title":"variable Parent","text":"<pre><code>TWeakPtr&lt;FCelAssetTreeNode&gt; FCelAssetTreeNode::Parent;\n</code></pre>"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#function-fcelassettreenode-12","title":"function FCelAssetTreeNode [1/2]","text":"<pre><code>inline FCelAssetTreeNode::FCelAssetTreeNode (\n    const FString &amp; InDisplayName,\n    int32 InCelIndex=INDEX_NONE\n) \n</code></pre> <p>Category constructor </p>"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#function-fcelassettreenode-22","title":"function FCelAssetTreeNode [2/2]","text":"<pre><code>inline FCelAssetTreeNode::FCelAssetTreeNode (\n    int32 InCelIndex,\n    const FString &amp; InDisplayName,\n    bool bInHasProblem=false\n) \n</code></pre> <p>Cel node constructor, requires an index </p>"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#function-findorcreatechild","title":"function FindOrCreateChild","text":"<pre><code>TSharedPtr&lt; FCelAssetTreeNode &gt; FCelAssetTreeNode::FindOrCreateChild (\n    const FString &amp; ChildName,\n    int32 ChildCelIndex=INDEX_NONE\n) \n</code></pre>"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#function-getcelindex","title":"function GetCelIndex","text":"<pre><code>inline int32 FCelAssetTreeNode::GetCelIndex () const\n</code></pre>"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#function-getdisplayname","title":"function GetDisplayName","text":"<pre><code>inline FString FCelAssetTreeNode::GetDisplayName () const\n</code></pre>"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#function-iscategory","title":"function IsCategory","text":"<pre><code>inline bool FCelAssetTreeNode::IsCategory () const\n</code></pre>"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#function-iscel","title":"function IsCel","text":"<pre><code>inline bool FCelAssetTreeNode::IsCel () const\n</code></pre>"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#function-isvalid","title":"function IsValid","text":"<pre><code>inline bool FCelAssetTreeNode::IsValid () const\n</code></pre>"},{"location":"CollisionEditor/class_f_cel_asset_tree_node/#function-setcelindex","title":"function SetCelIndex","text":"<pre><code>inline void FCelAssetTreeNode::SetCelIndex (\n    int32 InCelIndex\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/CelAssetTreeNode.h</code></p>"},{"location":"CollisionEditor/class_f_collision_animation_preview_scene/","title":"Class FCollisionAnimationPreviewScene","text":"<p>ClassList &gt; FCollisionAnimationPreviewScene</p> <p>Inherits the following classes: FAdvancedPreviewScene</p>"},{"location":"CollisionEditor/class_f_collision_animation_preview_scene/#public-functions","title":"Public Functions","text":"Type Name FCollisionAnimationPreviewScene (ConstructionValues CVS, const TSharedRef&lt; FCollisionDataEditorToolkit &gt; &amp; EditorToolkit)  APlayerObject * SetPlayerObject (const UClass * Class)  void SetupScene (UCollisionData * CollisionData)  virtual void Tick (float InDeltaTime) override void UpdateCollisionView ()  virtual ~FCollisionAnimationPreviewScene () override"},{"location":"CollisionEditor/class_f_collision_animation_preview_scene/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CollisionEditor/class_f_collision_animation_preview_scene/#function-fcollisionanimationpreviewscene","title":"function FCollisionAnimationPreviewScene","text":"<pre><code>FCollisionAnimationPreviewScene::FCollisionAnimationPreviewScene (\n    ConstructionValues CVS,\n    const TSharedRef&lt; FCollisionDataEditorToolkit &gt; &amp; EditorToolkit\n) \n</code></pre>"},{"location":"CollisionEditor/class_f_collision_animation_preview_scene/#function-setplayerobject","title":"function SetPlayerObject","text":"<pre><code>APlayerObject * FCollisionAnimationPreviewScene::SetPlayerObject (\n    const UClass * Class\n) \n</code></pre>"},{"location":"CollisionEditor/class_f_collision_animation_preview_scene/#function-setupscene","title":"function SetupScene","text":"<pre><code>void FCollisionAnimationPreviewScene::SetupScene (\n    UCollisionData * CollisionData\n) \n</code></pre>"},{"location":"CollisionEditor/class_f_collision_animation_preview_scene/#function-tick","title":"function Tick","text":"<pre><code>virtual void FCollisionAnimationPreviewScene::Tick (\n    float InDeltaTime\n) override\n</code></pre>"},{"location":"CollisionEditor/class_f_collision_animation_preview_scene/#function-updatecollisionview","title":"function UpdateCollisionView","text":"<pre><code>void FCollisionAnimationPreviewScene::UpdateCollisionView () \n</code></pre>"},{"location":"CollisionEditor/class_f_collision_animation_preview_scene/#function-fcollisionanimationpreviewscene_1","title":"function ~FCollisionAnimationPreviewScene","text":"<pre><code>virtual FCollisionAnimationPreviewScene::~FCollisionAnimationPreviewScene () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/Viewport/CollisionAnimationPreviewScene.h</code></p>"},{"location":"CollisionEditor/class_f_collision_animation_viewport_client/","title":"Class FCollisionAnimationViewportClient","text":"<p>ClassList &gt; FCollisionAnimationViewportClient</p> <p>Inherits the following classes: FEditorViewportClient</p>"},{"location":"CollisionEditor/class_f_collision_animation_viewport_client/#public-functions","title":"Public Functions","text":"Type Name FCollisionAnimationViewportClient (const TSharedRef&lt; SEditorViewport &gt; &amp; InEditorViewport, const TSharedRef&lt; FAdvancedPreviewScene &gt; &amp; InPreviewScene)  virtual void Tick (float DeltaSeconds) override virtual ~FCollisionAnimationViewportClient ()"},{"location":"CollisionEditor/class_f_collision_animation_viewport_client/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CollisionEditor/class_f_collision_animation_viewport_client/#function-fcollisionanimationviewportclient","title":"function FCollisionAnimationViewportClient","text":"<pre><code>FCollisionAnimationViewportClient::FCollisionAnimationViewportClient (\n    const TSharedRef&lt; SEditorViewport &gt; &amp; InEditorViewport,\n    const TSharedRef&lt; FAdvancedPreviewScene &gt; &amp; InPreviewScene\n) \n</code></pre>"},{"location":"CollisionEditor/class_f_collision_animation_viewport_client/#function-tick","title":"function Tick","text":"<pre><code>virtual void FCollisionAnimationViewportClient::Tick (\n    float DeltaSeconds\n) override\n</code></pre>"},{"location":"CollisionEditor/class_f_collision_animation_viewport_client/#function-fcollisionanimationviewportclient_1","title":"function ~FCollisionAnimationViewportClient","text":"<pre><code>virtual FCollisionAnimationViewportClient::~FCollisionAnimationViewportClient () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/Viewport/CollisionAnimationViewportClient.h</code></p>"},{"location":"CollisionEditor/class_f_collision_data_details/","title":"Class FCollisionDataDetails","text":"<p>ClassList &gt; FCollisionDataDetails</p> <p>More...</p> <ul> <li><code>#include &lt;CollisionDataDetails.h&gt;</code></li> </ul> <p>Inherits the following classes: IDetailCustomization</p>"},{"location":"CollisionEditor/class_f_collision_data_details/#public-functions","title":"Public Functions","text":"Type Name virtual void CustomizeDetails (IDetailLayoutBuilder &amp; DetailBuilder) override"},{"location":"CollisionEditor/class_f_collision_data_details/#public-static-functions","title":"Public Static Functions","text":"Type Name TSharedRef&lt; IDetailCustomization &gt; MakeInstance ()"},{"location":"CollisionEditor/class_f_collision_data_details/#detailed-description","title":"Detailed Description","text":"<p>Detail customization for UCollisionData that displays CollisionFrames in a hierarchical tree organized by GameplayTag. </p>"},{"location":"CollisionEditor/class_f_collision_data_details/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CollisionEditor/class_f_collision_data_details/#function-customizedetails","title":"function CustomizeDetails","text":"<pre><code>virtual void FCollisionDataDetails::CustomizeDetails (\n    IDetailLayoutBuilder &amp; DetailBuilder\n) override\n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_details/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"CollisionEditor/class_f_collision_data_details/#function-makeinstance","title":"function MakeInstance","text":"<pre><code>static TSharedRef&lt; IDetailCustomization &gt; FCollisionDataDetails::MakeInstance () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/CollisionDataDetails.h</code></p>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/","title":"Class FCollisionDataEditorToolkit","text":"<p>ClassList &gt; FCollisionDataEditorToolkit</p> <p>More...</p> <ul> <li><code>#include &lt;CollisionDataEditorToolkit.h&gt;</code></li> </ul> <p>Inherits the following classes: FAssetEditorToolkit</p>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#public-functions","title":"Public Functions","text":"Type Name FCollisionDataEditorToolkit ()  virtual FText GetBaseToolkitName () override const FText GetSelectedState () const virtual FName GetToolkitFName () override const virtual FText GetToolkitName () override const virtual FLinearColor GetWorldCentricTabColorScale () override const virtual FString GetWorldCentricTabPrefix () override const void Initialize (UCollisionData * InCollisionData, const EToolkitMode::Type Mode, const TSharedPtr&lt; IToolkitHost &gt; &amp; InitToolkitHost)  void InitializePreviewScene ()  virtual void RegisterTabSpawners (const TSharedRef&lt; FTabManager &gt; &amp; InTabManager) override TSharedRef&lt; SDockTab &gt; SpawnTab_CollisionDataDetails (const FSpawnTabArgs &amp; Args)  TSharedRef&lt; SDockTab &gt; SpawnTab_PlayerObjectSelector (const FSpawnTabArgs &amp; Args)  TSharedRef&lt; SDockTab &gt; SpawnTab_ViewportTab (const FSpawnTabArgs &amp; Args)  virtual void UnregisterTabSpawners (const TSharedRef&lt; FTabManager &gt; &amp; InTabManager) override virtual ~FCollisionDataEditorToolkit () override"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#protected-functions","title":"Protected Functions","text":"Type Name virtual void OnClose () override"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#detailed-description","title":"Detailed Description","text":"<p>Toolkit for editing collision data assets for Night Sky. </p>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-fcollisiondataeditortoolkit","title":"function FCollisionDataEditorToolkit","text":"<pre><code>FCollisionDataEditorToolkit::FCollisionDataEditorToolkit () \n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-getbasetoolkitname","title":"function GetBaseToolkitName","text":"<pre><code>virtual FText FCollisionDataEditorToolkit::GetBaseToolkitName () override const\n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-getselectedstate","title":"function GetSelectedState","text":"<pre><code>FText FCollisionDataEditorToolkit::GetSelectedState () const\n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-gettoolkitfname","title":"function GetToolkitFName","text":"<pre><code>virtual FName FCollisionDataEditorToolkit::GetToolkitFName () override const\n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-gettoolkitname","title":"function GetToolkitName","text":"<pre><code>virtual FText FCollisionDataEditorToolkit::GetToolkitName () override const\n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-getworldcentrictabcolorscale","title":"function GetWorldCentricTabColorScale","text":"<pre><code>virtual FLinearColor FCollisionDataEditorToolkit::GetWorldCentricTabColorScale () override const\n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-getworldcentrictabprefix","title":"function GetWorldCentricTabPrefix","text":"<pre><code>virtual FString FCollisionDataEditorToolkit::GetWorldCentricTabPrefix () override const\n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-initialize","title":"function Initialize","text":"<pre><code>void FCollisionDataEditorToolkit::Initialize (\n    UCollisionData * InCollisionData,\n    const EToolkitMode::Type Mode,\n    const TSharedPtr&lt; IToolkitHost &gt; &amp; InitToolkitHost\n) \n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-initializepreviewscene","title":"function InitializePreviewScene","text":"<pre><code>void FCollisionDataEditorToolkit::InitializePreviewScene () \n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-registertabspawners","title":"function RegisterTabSpawners","text":"<pre><code>virtual void FCollisionDataEditorToolkit::RegisterTabSpawners (\n    const TSharedRef&lt; FTabManager &gt; &amp; InTabManager\n) override\n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-spawntab_collisiondatadetails","title":"function SpawnTab_CollisionDataDetails","text":"<pre><code>TSharedRef&lt; SDockTab &gt; FCollisionDataEditorToolkit::SpawnTab_CollisionDataDetails (\n    const FSpawnTabArgs &amp; Args\n) \n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-spawntab_playerobjectselector","title":"function SpawnTab_PlayerObjectSelector","text":"<pre><code>TSharedRef&lt; SDockTab &gt; FCollisionDataEditorToolkit::SpawnTab_PlayerObjectSelector (\n    const FSpawnTabArgs &amp; Args\n) \n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-spawntab_viewporttab","title":"function SpawnTab_ViewportTab","text":"<pre><code>TSharedRef&lt; SDockTab &gt; FCollisionDataEditorToolkit::SpawnTab_ViewportTab (\n    const FSpawnTabArgs &amp; Args\n) \n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-unregistertabspawners","title":"function UnregisterTabSpawners","text":"<pre><code>virtual void FCollisionDataEditorToolkit::UnregisterTabSpawners (\n    const TSharedRef&lt; FTabManager &gt; &amp; InTabManager\n) override\n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-fcollisiondataeditortoolkit_1","title":"function ~FCollisionDataEditorToolkit","text":"<pre><code>virtual FCollisionDataEditorToolkit::~FCollisionDataEditorToolkit () override\n</code></pre>"},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"CollisionEditor/class_f_collision_data_editor_toolkit/#function-onclose","title":"function OnClose","text":"<pre><code>virtual void FCollisionDataEditorToolkit::OnClose () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/CollisionDataEditorToolkit.h</code></p>"},{"location":"CollisionEditor/class_f_collision_editor/","title":"Class FCollisionEditor","text":"<p>ClassList &gt; FCollisionEditor</p> <p>Inherits the following classes: IModuleInterface</p>"},{"location":"CollisionEditor/class_f_collision_editor/#public-functions","title":"Public Functions","text":"Type Name void ShutdownModule () override void StartupModule () override"},{"location":"CollisionEditor/class_f_collision_editor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CollisionEditor/class_f_collision_editor/#function-shutdownmodule","title":"function ShutdownModule","text":"<pre><code>void FCollisionEditor::ShutdownModule () override\n</code></pre>"},{"location":"CollisionEditor/class_f_collision_editor/#function-startupmodule","title":"function StartupModule","text":"<pre><code>void FCollisionEditor::StartupModule () override\n</code></pre> <p>IModuleInterface implementation </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/CollisionEditor.h</code></p>"},{"location":"CollisionEditor/class_s_cel_asset_tree/","title":"Class SCelAssetTree","text":"<p>ClassList &gt; SCelAssetTree</p> <p>More...</p> <ul> <li><code>#include &lt;CelAssetTree.h&gt;</code></li> </ul> <p>Inherits the following classes: SCompoundWidget</p>"},{"location":"CollisionEditor/class_s_cel_asset_tree/#public-functions","title":"Public Functions","text":"Type Name void Construct (const FArguments &amp; InArgs, UCollisionData * InCollisionData)  void RefreshTree ()  SLATE_BEGIN_ARGS (SCelAssetTree)  void SetSelectedCel (const FGameplayTag &amp; CelName)"},{"location":"CollisionEditor/class_s_cel_asset_tree/#detailed-description","title":"Detailed Description","text":"<p>Tree view widget for browsing cels grouped by GameplayTag hierarchy. </p>"},{"location":"CollisionEditor/class_s_cel_asset_tree/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CollisionEditor/class_s_cel_asset_tree/#function-construct","title":"function Construct","text":"<pre><code>void SCelAssetTree::Construct (\n    const FArguments &amp; InArgs,\n    UCollisionData * InCollisionData\n) \n</code></pre>"},{"location":"CollisionEditor/class_s_cel_asset_tree/#function-refreshtree","title":"function RefreshTree","text":"<pre><code>void SCelAssetTree::RefreshTree () \n</code></pre>"},{"location":"CollisionEditor/class_s_cel_asset_tree/#function-slate_begin_args","title":"function SLATE_BEGIN_ARGS","text":"<pre><code>inline SCelAssetTree::SLATE_BEGIN_ARGS (\n    SCelAssetTree\n) \n</code></pre>"},{"location":"CollisionEditor/class_s_cel_asset_tree/#function-setselectedcel","title":"function SetSelectedCel","text":"<pre><code>void SCelAssetTree::SetSelectedCel (\n    const FGameplayTag &amp; CelName\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/CelAssetTree.h</code></p>"},{"location":"CollisionEditor/class_s_collision_animation_viewport/","title":"Class SCollisionAnimationViewport","text":"<p>ClassList &gt; SCollisionAnimationViewport</p> <p>Inherits the following classes: SEditorViewport,  FGCObject,  ICommonEditorViewportToolbarInfoProvider</p>"},{"location":"CollisionEditor/class_s_collision_animation_viewport/#public-attributes","title":"Public Attributes","text":"Type Name TSharedPtr&lt; FCollisionAnimationPreviewScene &gt; PreviewScene"},{"location":"CollisionEditor/class_s_collision_animation_viewport/#public-functions","title":"Public Functions","text":"Type Name virtual void AddReferencedObjects (FReferenceCollector &amp; Collector) override void Construct (const FArguments &amp; InArgs, TSharedPtr&lt; FCollisionDataEditorToolkit &gt; InEditorToolkit, TSharedPtr&lt; FCollisionAnimationPreviewScene &gt; InPreviewScene)  virtual TSharedPtr&lt; FExtender &gt; GetExtenders () override const virtual FString GetReferencerName () override const virtual TSharedRef&lt; SEditorViewport &gt; GetViewportWidget () override virtual TSharedRef&lt; FEditorViewportClient &gt; MakeEditorViewportClient () override virtual void OnFloatingButtonClicked () override virtual void OnFocusViewportToSelection () override SLATE_BEGIN_ARGS (SCollisionAnimationViewport)  virtual ~SCollisionAnimationViewport () override"},{"location":"CollisionEditor/class_s_collision_animation_viewport/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"CollisionEditor/class_s_collision_animation_viewport/#variable-previewscene","title":"variable PreviewScene","text":"<pre><code>TSharedPtr&lt;FCollisionAnimationPreviewScene&gt; SCollisionAnimationViewport::PreviewScene;\n</code></pre>"},{"location":"CollisionEditor/class_s_collision_animation_viewport/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CollisionEditor/class_s_collision_animation_viewport/#function-addreferencedobjects","title":"function AddReferencedObjects","text":"<pre><code>inline virtual void SCollisionAnimationViewport::AddReferencedObjects (\n    FReferenceCollector &amp; Collector\n) override\n</code></pre>"},{"location":"CollisionEditor/class_s_collision_animation_viewport/#function-construct","title":"function Construct","text":"<pre><code>void SCollisionAnimationViewport::Construct (\n    const FArguments &amp; InArgs,\n    TSharedPtr&lt; FCollisionDataEditorToolkit &gt; InEditorToolkit,\n    TSharedPtr&lt; FCollisionAnimationPreviewScene &gt; InPreviewScene\n) \n</code></pre>"},{"location":"CollisionEditor/class_s_collision_animation_viewport/#function-getextenders","title":"function GetExtenders","text":"<pre><code>virtual TSharedPtr&lt; FExtender &gt; SCollisionAnimationViewport::GetExtenders () override const\n</code></pre>"},{"location":"CollisionEditor/class_s_collision_animation_viewport/#function-getreferencername","title":"function GetReferencerName","text":"<pre><code>virtual FString SCollisionAnimationViewport::GetReferencerName () override const\n</code></pre>"},{"location":"CollisionEditor/class_s_collision_animation_viewport/#function-getviewportwidget","title":"function GetViewportWidget","text":"<pre><code>virtual TSharedRef&lt; SEditorViewport &gt; SCollisionAnimationViewport::GetViewportWidget () override\n</code></pre>"},{"location":"CollisionEditor/class_s_collision_animation_viewport/#function-makeeditorviewportclient","title":"function MakeEditorViewportClient","text":"<pre><code>virtual TSharedRef&lt; FEditorViewportClient &gt; SCollisionAnimationViewport::MakeEditorViewportClient () override\n</code></pre>"},{"location":"CollisionEditor/class_s_collision_animation_viewport/#function-onfloatingbuttonclicked","title":"function OnFloatingButtonClicked","text":"<pre><code>virtual void SCollisionAnimationViewport::OnFloatingButtonClicked () override\n</code></pre>"},{"location":"CollisionEditor/class_s_collision_animation_viewport/#function-onfocusviewporttoselection","title":"function OnFocusViewportToSelection","text":"<pre><code>virtual void SCollisionAnimationViewport::OnFocusViewportToSelection () override\n</code></pre>"},{"location":"CollisionEditor/class_s_collision_animation_viewport/#function-slate_begin_args","title":"function SLATE_BEGIN_ARGS","text":"<pre><code>inline SCollisionAnimationViewport::SLATE_BEGIN_ARGS (\n    SCollisionAnimationViewport\n) \n</code></pre>"},{"location":"CollisionEditor/class_s_collision_animation_viewport/#function-scollisionanimationviewport","title":"function ~SCollisionAnimationViewport","text":"<pre><code>virtual SCollisionAnimationViewport::~SCollisionAnimationViewport () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/Viewport/CollisionAnimationViewport.h</code></p>"},{"location":"CollisionEditor/dir_0b4eaef40a1fe20bedafe9e8e719ce66/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins","text":"<p>FileList &gt; Plugins</p>"},{"location":"CollisionEditor/dir_0b4eaef40a1fe20bedafe9e8e719ce66/#directories","title":"Directories","text":"Type Name dir NightSkyEngine <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/</code></p>"},{"location":"CollisionEditor/dir_01309b4faf1ec48651014f612e2b32bb/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine","text":"<p>FileList &gt; NightSkyEngine</p>"},{"location":"CollisionEditor/dir_01309b4faf1ec48651014f612e2b32bb/#directories","title":"Directories","text":"Type Name dir Source <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/</code></p>"},{"location":"CollisionEditor/dir_d32ee28216ed342fa25c01ae9dcd9cc4/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source","text":"<p>FileList &gt; NightSkyEngine &gt; Source</p>"},{"location":"CollisionEditor/dir_d32ee28216ed342fa25c01ae9dcd9cc4/#directories","title":"Directories","text":"Type Name dir CollisionEditor <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/</code></p>"},{"location":"CollisionEditor/dir_940e8f38acfe3acbe44a727b0224043a/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor","text":"<p>FileList &gt; CollisionEditor</p>"},{"location":"CollisionEditor/dir_940e8f38acfe3acbe44a727b0224043a/#directories","title":"Directories","text":"Type Name dir Private dir Public <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/</code></p>"},{"location":"CollisionEditor/dir_b4aad7ce9c05cbacc2935f83ad755e41/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Private","text":"<p>FileList &gt; CollisionEditor &gt; Private</p>"},{"location":"CollisionEditor/dir_b4aad7ce9c05cbacc2935f83ad755e41/#files","title":"Files","text":"Type Name file AssetTypeActions_CollisionData.cpp file CelAssetTree.cpp file CollisionDataDetails.cpp file CollisionDataEditorToolkit.cpp file CollisionEditor.cpp file Logging.cpp file Logging.h"},{"location":"CollisionEditor/dir_b4aad7ce9c05cbacc2935f83ad755e41/#directories","title":"Directories","text":"Type Name dir Viewport <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Private/</code></p>"},{"location":"CollisionEditor/_asset_type_actions___collision_data_8cpp/","title":"File AssetTypeActions_CollisionData.cpp","text":"<p>FileList &gt; CollisionEditor &gt; Private &gt; AssetTypeActions_CollisionData.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"AssetTypeActions_CollisionData.h\"</code></li> <li><code>#include \"CollisionDataEditorToolkit.h\"</code></li> <li><code>#include \"Toolkits/IToolkit.h\"</code></li> <li><code>#include \"Math/Color.h\"</code></li> <li><code>#include \"Internationalization/Internationalization.h\"</code></li> </ul>"},{"location":"CollisionEditor/_asset_type_actions___collision_data_8cpp/#macros","title":"Macros","text":"Type Name define LOCTEXT_NAMESPACE <code>\"NightSkyCollisionEditor\"</code>"},{"location":"CollisionEditor/_asset_type_actions___collision_data_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CollisionEditor/_asset_type_actions___collision_data_8cpp/#define-loctext_namespace","title":"define LOCTEXT_NAMESPACE","text":"<pre><code>#define LOCTEXT_NAMESPACE `\"NightSkyCollisionEditor\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Private/AssetTypeActions_CollisionData.cpp</code></p>"},{"location":"CollisionEditor/_asset_type_actions___collision_data_8cpp_source/","title":"File AssetTypeActions_CollisionData.cpp","text":"<p>File List &gt; CollisionEditor &gt; Private &gt; AssetTypeActions_CollisionData.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"AssetTypeActions_CollisionData.h\"\n#include \"CollisionDataEditorToolkit.h\"\n#include \"Toolkits/IToolkit.h\"\n#include \"Math/Color.h\"\n#include \"Internationalization/Internationalization.h\" // included to use LOCTEXT\n\n#define LOCTEXT_NAMESPACE \"NightSkyCollisionEditor\"\n\nFColor FAssetTypeActions_CollisionData::GetTypeColor() const\n{\n    return FColor(0, 255, 0);\n}\n\nUClass* FAssetTypeActions_CollisionData::GetSupportedClass() const\n{\n    return UCollisionData::StaticClass();\n}\n\nvoid FAssetTypeActions_CollisionData::OpenAssetEditor(const TArray&lt;UObject*&gt;&amp; InObjects, TSharedPtr&lt;IToolkitHost&gt; EditWithinLevelEditor)\n{\n    for (auto ObjIt = InObjects.CreateConstIterator(); ObjIt; ++ObjIt)\n    {\n        auto CollisionData = Cast&lt;UCollisionData&gt;(*ObjIt);\n        if (CollisionData != nullptr)\n        {\n            // Create an instance of the editor. Let Unreal manage the editor's lifecycle.\n            TSharedRef&lt;FCollisionDataEditorToolkit&gt; Editor = MakeShareable(new FCollisionDataEditorToolkit());\n            Editor-&gt;Initialize(CollisionData, EToolkitMode::Standalone, EditWithinLevelEditor);\n        }\n    }\n}\n\n\nFText FAssetTypeActions_CollisionData::GetName() const\n{\n    return NSLOCTEXT(\"AssetTypeActions\", \"FAssetTypeActionsCollisionDataName\", \"Collision Data\");\n}\n\nuint32 FAssetTypeActions_CollisionData::GetCategories()\n{\n    return AssetCategory;\n}\n\n#undef LOCTEXT_NAMESPACE\n</code></pre>"},{"location":"CollisionEditor/dir_29897cda01bed08dbaaebcd119403720/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Private/Viewport","text":"<p>FileList &gt; CollisionEditor &gt; Private &gt; Viewport</p>"},{"location":"CollisionEditor/dir_29897cda01bed08dbaaebcd119403720/#files","title":"Files","text":"Type Name file CollisionAnimationPreviewScene.cpp file CollisionAnimationViewport.cpp file CollisionAnimationViewportClient.cpp <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Private/Viewport/</code></p>"},{"location":"CollisionEditor/_collision_animation_preview_scene_8cpp/","title":"File CollisionAnimationPreviewScene.cpp","text":"<p>FileList &gt; CollisionEditor &gt; Private &gt; Viewport &gt; CollisionAnimationPreviewScene.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Viewport/CollisionAnimationPreviewScene.h\"</code></li> <li><code>#include \"Components/SkeletalMeshComponent.h\"</code></li> <li><code>#include \"Data/CollisionData.h\"</code></li> <li><code>#include \"CollisionDataEditorToolkit.h\"</code></li> <li><code>#include \"DrawDebugHelpers.h\"</code></li> <li><code>#include \"Battle/Objects/PlayerObject.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Private/Viewport/CollisionAnimationPreviewScene.cpp</code></p>"},{"location":"CollisionEditor/_collision_animation_preview_scene_8cpp_source/","title":"File CollisionAnimationPreviewScene.cpp","text":"<p>File List &gt; CollisionEditor &gt; Private &gt; Viewport &gt; CollisionAnimationPreviewScene.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Viewport/CollisionAnimationPreviewScene.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"Data/CollisionData.h\"\n#include \"CollisionDataEditorToolkit.h\"\n#include \"DrawDebugHelpers.h\"\n#include \"Battle/Objects/PlayerObject.h\"\n\nFCollisionAnimationPreviewScene::FCollisionAnimationPreviewScene(ConstructionValues CVS, const TSharedRef&lt;FCollisionDataEditorToolkit&gt;&amp; EditorToolkit)\n    : FAdvancedPreviewScene(CVS), EditorPtr(EditorToolkit)\n{\n    // Disable the default floor to customize the scene\n    SetFloorVisibility(true, true);\n\n    // Setup events or additional components if necessary\n}\n\nFCollisionAnimationPreviewScene::~FCollisionAnimationPreviewScene()\n{\n    // Cleanup or unregister anything necessary\n}\n\nvoid FCollisionAnimationPreviewScene::Tick(float InDeltaTime)\n{\n    FAdvancedPreviewScene::Tick(InDeltaTime);\n\n    // Update animations and Collisiones as needed\n    UpdateMeshAndAnimation(InDeltaTime);\n    UpdateCollisionView();\n}\n\nAPlayerObject* FCollisionAnimationPreviewScene::SetPlayerObject(const UClass* Class)\n{\n    if (PreviewPlayerObject) PreviewPlayerObject-&gt;Destroy();\n\n    const auto PlayerObject = GetWorld()-&gt;SpawnActor&lt;APlayerObject&gt;(const_cast&lt;UClass*&gt;(Class));\n    PreviewPlayerObject = PlayerObject;\n    PreviewPlayerObject-&gt;InitPlayer();\n    PreviewPlayerObject-&gt;SetDefaultComponentVisibility();\n\n    TArray&lt;USkeletalMeshComponent*&gt; SkeletalMeshComponents;\n    PreviewPlayerObject-&gt;GetComponents(USkeletalMeshComponent::StaticClass(), SkeletalMeshComponents);\n    for (auto* Component : SkeletalMeshComponents)\n    {\n        // TODO: Uncomment if it crashes again\n        // if (Component-&gt;GetSkeletalMeshAsset() &amp;&amp; Component-&gt;GetNumBones() &gt; 0)\n        // {\n        //     Component-&gt;InitAnim(true);\n        //     Component-&gt;SetUpdateAnimationInEditor(true);\n        // }\n        Component-&gt;InitAnim(true);\n        Component-&gt;SetUpdateAnimationInEditor(true);\n    }\n\n    return PreviewPlayerObject;\n}\n\nvoid FCollisionAnimationPreviewScene::SetupScene(UCollisionData* CollisionData)\n{\n    CurrentCollisionData = CollisionData;\n}\n\nvoid FCollisionAnimationPreviewScene::UpdateMeshAndAnimation(float DeltaTime)\n{\n    if (!PreviewPlayerObject) return;\n    PreviewPlayerObject-&gt;EditorUpdate();\n\n    TArray&lt;USkeletalMeshComponent*&gt; SkeletalMeshComponents;\n    PreviewPlayerObject-&gt;GetComponents(USkeletalMeshComponent::StaticClass(), SkeletalMeshComponents);\n    for (auto* Component : SkeletalMeshComponents)\n    {\n        if (Component-&gt;GetSkeletalMeshAsset() &amp;&amp; Component-&gt;GetNumBones() &gt; 0)\n        {\n            Component-&gt;TickComponent(DeltaTime, ELevelTick::LEVELTICK_ViewportsOnly, nullptr);\n        }\n    }\n}\n\nvoid FCollisionAnimationPreviewScene::DrawCollisionData()\n{\n    PreviewPlayerObject-&gt;CollisionView();\n}\n\nvoid FCollisionAnimationPreviewScene::UpdateCollisionView()\n{\n    if (!CurrentCollisionData || !PreviewPlayerObject) // || !PreviewComponent)\n      return;\n\n  //Clear Debug Draw Debug Lines\n  FlushPersistentDebugLines(GetWorld());\n\n  // Get Cel name and call DrawCollisionData\n  DrawCollisionData();\n}\n</code></pre>"},{"location":"CollisionEditor/_collision_animation_viewport_8cpp/","title":"File CollisionAnimationViewport.cpp","text":"<p>FileList &gt; CollisionEditor &gt; Private &gt; Viewport &gt; CollisionAnimationViewport.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Viewport/CollisionAnimationViewport.h\"</code></li> <li><code>#include \"Viewport/CollisionAnimationPreviewScene.h\"</code></li> <li><code>#include \"CollisionDataEditorToolkit.h\"</code></li> <li><code>#include \"Viewport/CollisionAnimationViewportClient.h\"</code></li> <li><code>#include \"Modules/ModuleManager.h\"</code></li> <li><code>#include \"PropertyEditorModule.h\"</code></li> </ul>"},{"location":"CollisionEditor/_collision_animation_viewport_8cpp/#macros","title":"Macros","text":"Type Name define LOCTEXT_NAMESPACE <code>\"NightSkyCollisionEditor\"</code>"},{"location":"CollisionEditor/_collision_animation_viewport_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CollisionEditor/_collision_animation_viewport_8cpp/#define-loctext_namespace","title":"define LOCTEXT_NAMESPACE","text":"<pre><code>#define LOCTEXT_NAMESPACE `\"NightSkyCollisionEditor\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Private/Viewport/CollisionAnimationViewport.cpp</code></p>"},{"location":"CollisionEditor/_collision_animation_viewport_8cpp_source/","title":"File CollisionAnimationViewport.cpp","text":"<p>File List &gt; CollisionEditor &gt; Private &gt; Viewport &gt; CollisionAnimationViewport.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Viewport/CollisionAnimationViewport.h\"\n#include \"Viewport/CollisionAnimationPreviewScene.h\"\n#include \"CollisionDataEditorToolkit.h\"\n#include \"Viewport/CollisionAnimationViewportClient.h\"\n#include \"Modules/ModuleManager.h\"\n#include \"PropertyEditorModule.h\"\n\n#define LOCTEXT_NAMESPACE \"NightSkyCollisionEditor\"\n\nSCollisionAnimationViewport::~SCollisionAnimationViewport()\n{\n    if (ViewportClient.IsValid())\n    {\n        ViewportClient-&gt;Viewport = nullptr;\n    }\n}\n\nvoid SCollisionAnimationViewport::Construct(const FArguments&amp; InArgs, TSharedPtr&lt;FCollisionDataEditorToolkit&gt; InEditorToolkit, TSharedPtr&lt;FCollisionAnimationPreviewScene&gt; InPreviewScene)\n{\n    EditorToolkit = InEditorToolkit;\n    PreviewScene = InPreviewScene;\n\n    SEditorViewport::Construct(SEditorViewport::FArguments());\n\n    // What to put here?\n}\n\nFString SCollisionAnimationViewport::GetReferencerName() const\n{\n    return TEXT(\"SCollisionAnimationViewport\");\n}\n\nTSharedRef&lt;SEditorViewport&gt; SCollisionAnimationViewport::GetViewportWidget()\n{\n    return SharedThis(this);\n}\n\nTSharedPtr&lt;FExtender&gt; SCollisionAnimationViewport::GetExtenders() const\n{\n    TSharedPtr&lt;FExtender&gt; Extender = MakeShareable(new FExtender);\n    return Extender;\n}\n\nvoid SCollisionAnimationViewport::OnFloatingButtonClicked()\n{\n    // Handle special button actions here\n}\n\nvoid SCollisionAnimationViewport::OnFocusViewportToSelection()\n{\n    if (PreviewScene.IsValid())\n    {\n        // Implement FocusOnSelection\n        //PreviewScene-&gt;FocusOnSelection();\n    }\n}\n\nTSharedRef&lt;FEditorViewportClient&gt; SCollisionAnimationViewport::MakeEditorViewportClient()\n{\n    if (!ViewportClient.IsValid())\n    {\n        ViewportClient = MakeShareable(new FCollisionAnimationViewportClient(SharedThis(this), PreviewScene.ToSharedRef()));\n    }\n\n    return ViewportClient.ToSharedRef();\n}\n\n#undef LOCTEXT_NAMESPACE\n</code></pre>"},{"location":"CollisionEditor/_collision_animation_viewport_client_8cpp/","title":"File CollisionAnimationViewportClient.cpp","text":"<p>FileList &gt; CollisionEditor &gt; Private &gt; Viewport &gt; CollisionAnimationViewportClient.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Viewport/CollisionAnimationViewportClient.h\"</code></li> <li><code>#include \"AdvancedPreviewScene.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Private/Viewport/CollisionAnimationViewportClient.cpp</code></p>"},{"location":"CollisionEditor/_collision_animation_viewport_client_8cpp_source/","title":"File CollisionAnimationViewportClient.cpp","text":"<p>File List &gt; CollisionEditor &gt; Private &gt; Viewport &gt; CollisionAnimationViewportClient.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"Viewport/CollisionAnimationViewportClient.h\"\n#include \"AdvancedPreviewScene.h\"\n\nFCollisionAnimationViewportClient::FCollisionAnimationViewportClient(const TSharedRef&lt;SEditorViewport&gt;&amp; InEditorViewport, const TSharedRef&lt;FAdvancedPreviewScene&gt;&amp; InPreviewScene)\n    : FEditorViewportClient(nullptr, &amp;InPreviewScene.Get(), StaticCastSharedRef&lt;SEditorViewport&gt;(InEditorViewport))\n{\n    AdvancedPreviewScene = static_cast&lt;FAdvancedPreviewScene*&gt;(PreviewScene);\n\n    // Set initial viewport properties\n    SetRealtime(true);\n    DrawHelper.bDrawGrid = false;\n    DrawHelper.bDrawPivot = false;\n    DrawHelper.AxesLineThickness = 5;\n    DrawHelper.PivotSize = 5;\n\n    // Enable screen percentage rendering\n    EngineShowFlags.SetScreenPercentage(true);\n\n    // Set perspective as default view mode\n    SetViewportType(LVT_Perspective);\n    SetViewModes(VMI_Lit, VMI_Lit);\n}\n\nvoid FCollisionAnimationViewportClient::Tick(float DeltaSeconds)\n{\n    FEditorViewportClient::Tick(DeltaSeconds);\n\n    // Set initial camera position and orientation\n    SetViewLocation(FVector(0, 720, 175));\n    SetViewRotation(FRotator(0, -90, 0));\n    ViewFOV = 54;\n}\n\nFCollisionAnimationViewportClient::~FCollisionAnimationViewportClient()\n{\n    // Clean up code if necessary\n}\n</code></pre>"},{"location":"CollisionEditor/_cel_asset_tree_8cpp/","title":"File CelAssetTree.cpp","text":"<p>FileList &gt; CollisionEditor &gt; Private &gt; CelAssetTree.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CelAssetTree.h\"</code></li> <li><code>#include \"Logging.h\"</code></li> <li><code>#include \"Data/CollisionData.h\"</code></li> <li><code>#include \"Styling/AppStyle.h\"</code></li> <li><code>#include \"Widgets/Layout/SBorder.h\"</code></li> <li><code>#include \"Widgets/Text/STextBlock.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Private/CelAssetTree.cpp</code></p>"},{"location":"CollisionEditor/_cel_asset_tree_8cpp_source/","title":"File CelAssetTree.cpp","text":"<p>File List &gt; CollisionEditor &gt; Private &gt; CelAssetTree.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"CelAssetTree.h\"\n\n#include \"Logging.h\"\n#include \"Data/CollisionData.h\"\n#include \"Styling/AppStyle.h\"\n#include \"Widgets/Layout/SBorder.h\"\n#include \"Widgets/Text/STextBlock.h\"\n\nTSharedPtr&lt;FCelAssetTreeNode&gt; FCelAssetTreeNode::FindOrCreateChild(const FString&amp; ChildName, int32 ChildCelIndex)\n{\n    // Look for existing child with this name\n    for (const TSharedPtr&lt;FCelAssetTreeNode&gt;&amp; Child : Children)\n    {\n        if (Child-&gt;GetDisplayName() == ChildName)\n        {\n            // If we're trying to set a cel index on an existing category node, update it\n            // This happens when e.g. \"Attack\" exists as both a parent for \"Attack.00\" and as a cel itself\n            if (ChildCelIndex != INDEX_NONE &amp;&amp; Child-&gt;IsCategory())\n            {\n                Child-&gt;SetCelIndex(ChildCelIndex);\n            }\n            return Child;\n        }\n    }\n\n    // Create new child\n    TSharedPtr&lt;FCelAssetTreeNode&gt; NewChild = MakeShared&lt;FCelAssetTreeNode&gt;(ChildName, ChildCelIndex);\n    NewChild-&gt;Parent = AsShared();\n    Children.Add(NewChild);\n    return NewChild;\n}\n\nvoid SCelAssetTree::Construct(const FArguments&amp; InArgs, UCollisionData* InCollisionData)\n{\n    CollisionData = InCollisionData;\n    OnCelSelectedDelegate = InArgs._OnCelSelected;\n\n    ChildSlot\n    [\n        // TODO: When we implement filtering, add a new SVerticalBox at the top\n        SNew(SVerticalBox)\n        + SVerticalBox::Slot()\n        .FillHeight(1.f)\n        [\n            SNew(SBorder)\n            .BorderImage(FAppStyle::GetBrush(\"ToolPanel.GroupBorder\"))\n            .Padding(2.f)\n            [\n                SAssignNew(TreeView, STreeView&lt;TSharedPtr&lt;FCelAssetTreeNode&gt;&gt;)\n                .TreeItemsSource(&amp;RootNodes)\n                .SelectionMode(ESelectionMode::Single)\n                .OnGenerateRow(this, &amp;SCelAssetTree::GenerateTreeRow)\n                .OnGetChildren(this, &amp;SCelAssetTree::GetChildrenForNode)\n                .OnSelectionChanged(this, &amp;SCelAssetTree::OnSelectionChanged)\n            ]\n        ]\n    ];\n\n    RefreshTree();\n}\n\nvoid SCelAssetTree::RefreshTree()\n{\n    RootNodes.Empty();\n    AllNodes.Empty();\n    CelIndexToNodeMap.Empty();\n\n    BuildTreeFromCollisionData();\n\n    if (TreeView.IsValid())\n    {\n        TreeView-&gt;RequestTreeRefresh();\n\n        // Expand all root nodes by default\n        for (const TSharedPtr&lt;FCelAssetTreeNode&gt;&amp; RootNode : RootNodes)\n        {\n            TreeView-&gt;SetItemExpansion(RootNode, true);\n        }\n    }\n}\n\nvoid SCelAssetTree::BuildTreeFromCollisionData()\n{\n    UCollisionData* Data = CollisionData.Get();\n    if (!Data)\n    {\n        return;\n    }\n\n    // Build a map of category paths to nodes\n    TMap&lt;FString, TSharedPtr&lt;FCelAssetTreeNode&gt;&gt; CategoryMap;\n\n    TMap&lt;FGameplayTag, int32&gt; SeenTags;  // For duplicate detection\n    TSharedPtr&lt;FCelAssetTreeNode&gt; ProblemsCategory;\n\n    for (int32 CelIdx = 0; CelIdx &lt; Data-&gt;CollisionFrames.Num(); ++CelIdx)\n    {\n        const FCollisionStruct&amp; Cel = Data-&gt;CollisionFrames[CelIdx];\n\n        // Check for problems\n        bool bIsUnnamed = !Cel.CelName.IsValid();\n        bool bIsDuplicate = false;\n        if (!bIsUnnamed)\n        {\n            if (SeenTags.Find(Cel.CelName))\n            {\n                bIsDuplicate = true;\n            }\n            else\n            {\n                SeenTags.Add(Cel.CelName, CelIdx);\n            }\n        }\n\n        if (bIsUnnamed || bIsDuplicate)\n        {\n            // Create Problems category on first problematic cel\n            if (!ProblemsCategory.IsValid())\n            {\n                ProblemsCategory = MakeShared&lt;FCelAssetTreeNode&gt;(TEXT(\"Problems\"));\n                RootNodes.Insert(ProblemsCategory, 0);  // Always at the top\n            }\n\n            FString ProblemName = bIsUnnamed \n                ? FString::Printf(TEXT(\"Unnamed Cel at Index [%d]\"), CelIdx)\n                : FString::Printf(TEXT(\"[%s] Duplicate at [%d])\"), *Cel.CelName.ToString(), CelIdx);\n\n            const TCHAR* ProblemChars = *ProblemName;\n            UE_LOG(LogCollisionEditor, Error, TEXT(\"%s\"), ProblemChars);\n\n            auto ProblemNode = MakeShared&lt;FCelAssetTreeNode&gt;(CelIdx, ProblemName, true);\n            ProblemNode-&gt;Parent = ProblemsCategory;\n            ProblemsCategory-&gt;Children.Add(ProblemNode);\n            CelIndexToNodeMap.Add(CelIdx, ProblemNode);\n            continue;\n        }\n\n        // Parse the GameplayTag path\n        // We currently use the form Character.StateCategory[.Subcategory].State.[Substate].[Index]\n        FString TagString = Cel.CelName.ToString();\n        TArray&lt;FString&gt; PathParts;\n        TagString.ParseIntoArray(PathParts, TEXT(\".\"));\n\n        if (PathParts.Num() == 0)\n        {\n            continue;\n        }\n\n        // Build tree structure from path\n        // Skip the first part if it's a common prefix like \"Cel\"\n        int32 StartIndex = 0;\n        if (PathParts.Num() &gt; 1 &amp;&amp; PathParts[0].Equals(TEXT(\"Cel\"), ESearchCase::IgnoreCase))\n        {\n            StartIndex = 1;\n        }\n\n        TSharedPtr&lt;FCelAssetTreeNode&gt; CurrentParent;\n        FString CurrentPath;\n\n        for (int32 i = StartIndex; i &lt; PathParts.Num(); ++i)\n        {\n            const FString&amp; Part = PathParts[i];\n            CurrentPath = CurrentPath.IsEmpty() ? Part : (CurrentPath + TEXT(\".\") + Part);\n\n            bool bIsLeaf = (i == PathParts.Num() - 1);\n\n            if (!CurrentParent.IsValid())\n            {\n                // Looking for/creating a root node\n                TSharedPtr&lt;FCelAssetTreeNode&gt;* ExistingRoot = CategoryMap.Find(CurrentPath);\n                if (ExistingRoot &amp;&amp; ExistingRoot-&gt;IsValid())\n                {\n                    // If this is a leaf and the existing node is a category, update its CelIndex\n                    if (bIsLeaf &amp;&amp; (*ExistingRoot)-&gt;IsCategory())\n                    {\n                        (*ExistingRoot)-&gt;SetCelIndex(CelIdx);\n                        CelIndexToNodeMap.Add(CelIdx, *ExistingRoot);\n                    }\n                    CurrentParent = *ExistingRoot;\n                }\n                else\n                {\n                    TSharedPtr&lt;FCelAssetTreeNode&gt; NewNode = MakeShared&lt;FCelAssetTreeNode&gt;(\n                        Part,\n                        bIsLeaf ? CelIdx : INDEX_NONE\n                    );\n                    RootNodes.Add(NewNode);\n                    AllNodes.Add(NewNode);\n                    CategoryMap.Add(CurrentPath, NewNode);\n                    CurrentParent = NewNode;\n\n                    if (bIsLeaf)\n                    {\n                        CelIndexToNodeMap.Add(CelIdx, NewNode);\n                    }\n                }\n            }\n            else\n            {\n                // Creating/finding a child node\n                TSharedPtr&lt;FCelAssetTreeNode&gt;* ExistingNode = CategoryMap.Find(CurrentPath);\n                if (ExistingNode &amp;&amp; ExistingNode-&gt;IsValid())\n                {\n                    // If this is a leaf and the existing node is a category, update its CelIndex\n                    if (bIsLeaf &amp;&amp; (*ExistingNode)-&gt;IsCategory())\n                    {\n                        (*ExistingNode)-&gt;SetCelIndex(CelIdx);\n                        CelIndexToNodeMap.Add(CelIdx, *ExistingNode);\n                    }\n                    CurrentParent = *ExistingNode;\n                }\n                else\n                {\n                    TSharedPtr&lt;FCelAssetTreeNode&gt; NewNode = CurrentParent-&gt;FindOrCreateChild(\n                        Part,\n                        bIsLeaf ? CelIdx : INDEX_NONE\n                    );\n                    AllNodes.Add(NewNode);\n                    CategoryMap.Add(CurrentPath, NewNode);\n                    CurrentParent = NewNode;\n\n                    if (bIsLeaf)\n                    {\n                        CelIndexToNodeMap.Add(CelIdx, NewNode);\n                    }\n                }\n            }\n        }\n    }\n\n    // Sort root nodes and their children alphabetically\n    auto SortNodes = [](TArray&lt;TSharedPtr&lt;FCelAssetTreeNode&gt;&gt;&amp; Nodes)\n    {\n        Nodes.Sort([](const TSharedPtr&lt;FCelAssetTreeNode&gt;&amp; A, const TSharedPtr&lt;FCelAssetTreeNode&gt;&amp; B)\n        {\n            // Categories before cels, then alphabetical\n            if (A-&gt;IsCategory() != B-&gt;IsCategory())\n            {\n                return A-&gt;IsCategory();\n            }\n            return A-&gt;GetDisplayName() &lt; B-&gt;GetDisplayName();\n        });\n    };\n\n    TFunction&lt;void(TSharedPtr&lt;FCelAssetTreeNode&gt;&amp;)&gt; SortRecursive = [&amp;](TSharedPtr&lt;FCelAssetTreeNode&gt;&amp; Node)\n    {\n        SortNodes(Node-&gt;Children);\n        for (TSharedPtr&lt;FCelAssetTreeNode&gt;&amp; Child : Node-&gt;Children)\n        {\n            SortRecursive(Child);\n        }\n    };\n\n    SortNodes(RootNodes);\n    for (TSharedPtr&lt;FCelAssetTreeNode&gt;&amp; RootNode : RootNodes)\n    {\n        SortRecursive(RootNode);\n    }\n}\n\nvoid SCelAssetTree::SetSelectedCel(const FGameplayTag&amp; CelName)\n{\n    if (!TreeView.IsValid() || !CollisionData.IsValid())\n    {\n        return;\n    }\n\n    // Find cel index\n    UCollisionData* Data = CollisionData.Get();\n    for (int32 i = 0; i &lt; Data-&gt;CollisionFrames.Num(); ++i)\n    {\n        if (Data-&gt;CollisionFrames[i].CelName == CelName)\n        {\n            TSharedPtr&lt;FCelAssetTreeNode&gt;* NodePtr = CelIndexToNodeMap.Find(i);\n            if (NodePtr &amp;&amp; NodePtr-&gt;IsValid())\n            {\n                // Expand parents\n                TSharedPtr&lt;FCelAssetTreeNode&gt; Parent = (*NodePtr)-&gt;Parent.Pin();\n                while (Parent.IsValid())\n                {\n                    TreeView-&gt;SetItemExpansion(Parent, true);\n                    Parent = Parent-&gt;Parent.Pin();\n                }\n\n                TreeView-&gt;SetSelection(*NodePtr);\n                TreeView-&gt;RequestScrollIntoView(*NodePtr);\n            }\n            break;\n        }\n    }\n}\n\nTSharedRef&lt;ITableRow&gt; SCelAssetTree::GenerateTreeRow(\n    TSharedPtr&lt;FCelAssetTreeNode&gt; InNode,\n    const TSharedRef&lt;STableViewBase&gt;&amp; OwnerTable)\n{\n    FText DisplayText = FText::FromString(InNode-&gt;GetDisplayName());\n\n    // Use different styling for categories vs cels\n    FSlateFontInfo Font = InNode-&gt;IsCategory()\n        ? FAppStyle::GetFontStyle(\"NormalFontBold\")\n        : FAppStyle::GetFontStyle(\"NormalFont\");\n\n    return SNew(STableRow&lt;TSharedPtr&lt;FCelAssetTreeNode&gt;&gt;, OwnerTable)\n        [\n            SNew(SHorizontalBox)\n            + SHorizontalBox::Slot()\n            .AutoWidth()\n            .Padding(2.f, 1.f)\n            .VAlign(VAlign_Center)\n            [\n                SNew(STextBlock)\n                .Text(DisplayText)\n                .Font(Font)\n            ]\n        ];\n}\n\nvoid SCelAssetTree::GetChildrenForNode(\n    TSharedPtr&lt;FCelAssetTreeNode&gt; InNode,\n    TArray&lt;TSharedPtr&lt;FCelAssetTreeNode&gt;&gt;&amp; OutChildren)\n{\n    if (InNode.IsValid())\n    {\n        OutChildren = InNode-&gt;Children;\n    }\n}\n\nvoid SCelAssetTree::OnSelectionChanged(\n    TSharedPtr&lt;FCelAssetTreeNode&gt; SelectedNode,\n    ESelectInfo::Type SelectInfo)\n{\n    if (!SelectedNode.IsValid() || !SelectedNode-&gt;IsCel())\n    {\n        return;\n    }\n\n    UCollisionData* Data = CollisionData.Get();\n    if (!Data)\n    {\n        return;\n    }\n\n    int32 CelIdx = SelectedNode-&gt;GetCelIndex();\n    if (Data-&gt;CollisionFrames.IsValidIndex(CelIdx))\n    {\n        OnCelSelectedDelegate.ExecuteIfBound(CelIdx);\n    }\n}\n\nvoid SCelAssetTree::OnFilterTextChanged(const FText&amp; InText)\n{\n    CurrentFilterString = InText.ToString();\n    RefreshTree();\n}\n</code></pre>"},{"location":"CollisionEditor/_collision_data_details_8cpp/","title":"File CollisionDataDetails.cpp","text":"<p>FileList &gt; CollisionEditor &gt; Private &gt; CollisionDataDetails.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CollisionDataDetails.h\"</code></li> <li><code>#include \"DetailCategoryBuilder.h\"</code></li> <li><code>#include \"DetailLayoutBuilder.h\"</code></li> <li><code>#include \"DetailWidgetRow.h\"</code></li> <li><code>#include \"GameplayTagsEditorModule.h\"</code></li> <li><code>#include \"PropertyHandle.h\"</code></li> <li><code>#include \"ScopedTransaction.h\"</code></li> <li><code>#include \"Data/CollisionData.h\"</code></li> <li><code>#include \"Styling/AppStyle.h\"</code></li> <li><code>#include \"Widgets/Input/SButton.h\"</code></li> <li><code>#include \"Widgets/Layout/SBox.h\"</code></li> <li><code>#include \"Widgets/Layout/SUniformGridPanel.h\"</code></li> <li><code>#include \"Widgets/Text/STextBlock.h\"</code></li> </ul>"},{"location":"CollisionEditor/_collision_data_details_8cpp/#macros","title":"Macros","text":"Type Name define LOCTEXT_NAMESPACE <code>\"NightSkyCollisionEditor\"</code>"},{"location":"CollisionEditor/_collision_data_details_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CollisionEditor/_collision_data_details_8cpp/#define-loctext_namespace","title":"define LOCTEXT_NAMESPACE","text":"<pre><code>#define LOCTEXT_NAMESPACE `\"NightSkyCollisionEditor\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Private/CollisionDataDetails.cpp</code></p>"},{"location":"CollisionEditor/_collision_data_details_8cpp_source/","title":"File CollisionDataDetails.cpp","text":"<p>File List &gt; CollisionEditor &gt; Private &gt; CollisionDataDetails.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"CollisionDataDetails.h\"\n#include \"DetailCategoryBuilder.h\"\n#include \"DetailLayoutBuilder.h\"\n#include \"DetailWidgetRow.h\"\n#include \"GameplayTagsEditorModule.h\"\n#include \"PropertyHandle.h\"\n#include \"ScopedTransaction.h\"\n#include \"Data/CollisionData.h\"\n#include \"Styling/AppStyle.h\"\n#include \"Widgets/Input/SButton.h\"\n#include \"Widgets/Layout/SBox.h\"\n#include \"Widgets/Layout/SUniformGridPanel.h\"\n#include \"Widgets/Text/STextBlock.h\"\n\n#define LOCTEXT_NAMESPACE \"NightSkyCollisionEditor\"\n\nTSharedRef&lt;IDetailCustomization&gt; FCollisionDataDetails::MakeInstance()\n{\n    return MakeShareable(new FCollisionDataDetails);\n}\n\nvoid FCollisionDataDetails::CustomizeDetails(IDetailLayoutBuilder&amp; DetailBuilder)\n{\n    CachedDetailBuilder = &amp;DetailBuilder;\n\n    TArray&lt;TWeakObjectPtr&lt;UObject&gt;&gt; ObjectsBeingCustomized;\n    DetailBuilder.GetObjectsBeingCustomized(ObjectsBeingCustomized);\n\n    if (ObjectsBeingCustomized.Num() != 1)\n    {\n        return;\n    }\n\n    CollisionDataPtr = Cast&lt;UCollisionData&gt;(ObjectsBeingCustomized[0].Get());\n    if (!CollisionDataPtr.IsValid())\n    {\n        return;\n    }\n\n    CollisionFramesHandle = DetailBuilder.GetProperty(\n        GET_MEMBER_NAME_CHECKED(UCollisionData, CollisionFrames));\n\n    // Hide the default array display\n    DetailBuilder.HideProperty(CollisionFramesHandle);\n\n    // Also hide the transient editor property\n    DetailBuilder.HideProperty(GET_MEMBER_NAME_CHECKED(UCollisionData, EditorSelectedIndex));\n\n    IDetailCategoryBuilder&amp; Category = DetailBuilder.EditCategory(\n        \"Selected Cel\",\n        LOCTEXT(\"SelectedCelCategory\", \"Selected Cel\"),\n        ECategoryPriority::Important);\n\n    BuildSelectedCelView(DetailBuilder, Category);\n}\n\nvoid FCollisionDataDetails::BuildSelectedCelView(IDetailLayoutBuilder&amp; DetailBuilder, IDetailCategoryBuilder&amp; Category)\n{\n    UCollisionData* CollisionData = CollisionDataPtr.Get();\n    if (!CollisionData)\n    {\n        return;\n    }\n\n    // Add \"Add New Cel\" button at the top\n    Category.AddCustomRow(LOCTEXT(\"AddCelRow\", \"Add Cel\"))\n        .WholeRowContent()\n        .HAlign(HAlign_Center)\n        .VAlign(VAlign_Center)\n        [\n            SNew(SHorizontalBox)\n            + SHorizontalBox::Slot()\n            .AutoWidth()\n            [\n                SNew(SButton)\n                .Text(LOCTEXT(\"AddNewCel\", \"Add New Cel\"))\n                .HAlign(HAlign_Center)\n                .VAlign(VAlign_Center)\n                .OnClicked(this, &amp;FCollisionDataDetails::OnAddNewCel)\n            ]\n            + SHorizontalBox::Slot()\n            .AutoWidth()\n            .Padding(2.f)\n            [\n                SNew(SButton)\n                .Text(LOCTEXT(\"DeleteSelectedCel\", \"Delete Selected\"))\n                .HAlign(HAlign_Center)\n                .VAlign(VAlign_Center)\n                .IsEnabled(this, &amp;FCollisionDataDetails::CanDeleteSelectedCel)\n                .OnClicked(this, &amp;FCollisionDataDetails::OnDeleteSelectedCel)\n            ]\n        ];\n\n    Category.AddCustomRow(LOCTEXT(\"TemplateSelectedCelRow\", \"New Cel From Selected\"))\n        .WholeRowContent()\n        [\n            SNew(SButton)\n            .Text(LOCTEXT(\"NewCelFromSelected\", \"New Cel From Selected\"))\n            .VAlign(VAlign_Center)\n            .HAlign(HAlign_Center)\n            .IsEnabled(this, &amp;FCollisionDataDetails::CanTemplateSelectedCel)\n            .OnClicked(this, &amp;FCollisionDataDetails::OnTemplateSelectedCel)\n        ];\n\n    Category.AddCustomRow(LOCTEXT(\"RefreshTreeRow\", \"Refresh Tree\"))\n        .WholeRowContent()\n        [\n            SNew(SButton)\n            .HAlign(HAlign_Center)\n            .VAlign(VAlign_Center)\n            .Text(LOCTEXT(\"RefreshTree\", \"Refresh Tree\"))\n            .VAlign(VAlign_Center)\n            .HAlign(HAlign_Center)\n            .OnClicked(this, &amp;FCollisionDataDetails::OnRefreshTree)\n        ];\n\n#if WITH_EDITORONLY_DATA\n    const int32 SelectedIndex = CollisionData-&gt;EditorSelectedIndex;\n\n    if (SelectedIndex == INDEX_NONE || !CollisionData-&gt;CollisionFrames.IsValidIndex(SelectedIndex))\n    {\n        Category.AddCustomRow(LOCTEXT(\"NoSelectionRow\", \"No Selection\"))\n            .WholeRowContent()\n            [\n                SNew(SBox)\n                .Padding(FMargin(8.f, 16.f))\n                [\n                    SNew(STextBlock)\n                    .Text(LOCTEXT(\"SelectCelPrompt\", \"Select a cel from the tree to edit its properties\"))\n                    .Font(FAppStyle::GetFontStyle(\"NormalFont\"))\n                    .ColorAndOpacity(FSlateColor::UseSubduedForeground())\n                ]\n            ];\n        return;\n    }\n\n    const FCollisionStruct&amp; SelectedCel = CollisionData-&gt;CollisionFrames[SelectedIndex];\n\n    // Show header with cel name\n    Category.AddCustomRow(LOCTEXT(\"CelNameRow\", \"Tree View Name\"))\n        .NameContent()\n        [\n            SNew(STextBlock)\n            .Text(LOCTEXT(\"CelNameLabel\", \"Registered Cel Name\"))\n            .Font(FAppStyle::GetFontStyle(\"NormalFontBold\"))\n        ]\n        .ValueContent()\n        [\n            SNew(STextBlock)\n            .Text(FText::FromString(SelectedCel.CelName.ToString()))\n            .Font(FAppStyle::GetFontStyle(\"NormalFont\"))\n        ];\n\n    // Get the property handle for this specific array element\n    TSharedPtr&lt;IPropertyHandle&gt; ElementHandle = CollisionFramesHandle-&gt;GetChildHandle(SelectedIndex);\n    if (!ElementHandle.IsValid())\n    {\n        return;\n    }\n\n    // Add all child properties\n    uint32 NumChildren = 0;\n    ElementHandle-&gt;GetNumChildren(NumChildren);\n\n    for (uint32 ChildIdx = 0; ChildIdx &lt; NumChildren; ++ChildIdx)\n    {\n        TSharedPtr&lt;IPropertyHandle&gt; ChildHandle = ElementHandle-&gt;GetChildHandle(ChildIdx);\n        if (ChildHandle.IsValid())\n        {\n            // Show all properties including CelName (it's editable here)\n            Category.AddProperty(ChildHandle);\n        }\n    }\n#endif\n}\n\nFReply FCollisionDataDetails::OnAddNewCel()\n{\n    UCollisionData* CollisionData = CollisionDataPtr.Get();\n    if (!CollisionData)\n    {\n        return FReply::Handled();\n    }\n\n    FScopedTransaction Transaction(LOCTEXT(\"AddNewCelTransaction\", \"Add New Cel\"));\n    CollisionData-&gt;Modify();\n\n    FCollisionStruct NewCel;\n    CollisionData-&gt;CollisionFrames.Add(NewCel);\n\n#if WITH_EDITORONLY_DATA\n    // Select the new cel\n    CollisionData-&gt;EditorSelectedIndex = CollisionData-&gt;CollisionFrames.Num() - 1;\n    CollisionData-&gt;NotifyCollisionFramesChanged();\n#endif\n\n    if (CachedDetailBuilder)\n    {\n        CachedDetailBuilder-&gt;ForceRefreshDetails();\n    }\n\n    return FReply::Handled();\n}\n\nFReply FCollisionDataDetails::OnDeleteSelectedCel()\n{\n    UCollisionData* CollisionData = CollisionDataPtr.Get();\n    if (!CollisionData)\n    {\n        return FReply::Handled();\n    }\n\n#if WITH_EDITORONLY_DATA\n    const int32 SelectedIndex = CollisionData-&gt;EditorSelectedIndex;\n    if (SelectedIndex == INDEX_NONE || !CollisionData-&gt;CollisionFrames.IsValidIndex(SelectedIndex))\n    {\n        return FReply::Handled();\n    }\n\n    FScopedTransaction Transaction(LOCTEXT(\"DeleteCelTransaction\", \"Delete Cel\"));\n    CollisionData-&gt;Modify();\n\n    CollisionData-&gt;CollisionFrames.RemoveAt(SelectedIndex);\n\n    // Adjust selection\n    if (CollisionData-&gt;CollisionFrames.Num() == 0)\n    {\n        CollisionData-&gt;EditorSelectedIndex = INDEX_NONE;\n    }\n    else if (SelectedIndex &gt;= CollisionData-&gt;CollisionFrames.Num())\n    {\n        CollisionData-&gt;EditorSelectedIndex = CollisionData-&gt;CollisionFrames.Num() - 1;\n    }\n\n    CollisionData-&gt;NotifyCollisionFramesChanged();\n\n    if (CachedDetailBuilder)\n    {\n        CachedDetailBuilder-&gt;ForceRefreshDetails();\n    }\n#endif\n\n    return FReply::Handled();\n}\n\nFReply FCollisionDataDetails::OnTemplateSelectedCel()\n{\n    UCollisionData* CollisionData = CollisionDataPtr.Get();\n    if (!CollisionData)\n    {\n        return FReply::Handled();\n    }\n\n#if WITH_EDITORONLY_DATA\n    const int32 SelectedIndex = CollisionData-&gt;EditorSelectedIndex;\n    if (SelectedIndex == INDEX_NONE || !CollisionData-&gt;CollisionFrames.IsValidIndex(SelectedIndex))\n    {\n        return FReply::Handled();\n    }\n\n    const FCollisionStruct&amp; SourceCel = CollisionData-&gt;CollisionFrames[SelectedIndex];\n\n    // Default name: same as original but without the ending index (numbers) portion of the tag\n    FGameplayTag NewCelDefaultName;\n    if (SourceCel.CelName.IsValid())\n    {\n        FString TagString = SourceCel.CelName.ToString();\n        int32 LastPeriodIndex;\n        TagString.FindLastChar('.', LastPeriodIndex);\n        if (LastPeriodIndex != INDEX_NONE)\n        {\n            // If the last portion of the tag is numeric, we use its parent as the default name\n            auto LastTagString = TagString.RightChop(TagString.Len() - LastPeriodIndex);\n            if (LastTagString.IsNumeric())\n            {\n                NewCelDefaultName = SourceCel.CelName.RequestDirectParent();\n            }\n            else\n            {\n                NewCelDefaultName = SourceCel.CelName;\n            }\n        }\n        else\n        {\n            NewCelDefaultName = SourceCel.CelName;\n        }\n    }\n\n    // ---- Dialog window for selecting the new tag name ----\n\n    // Store result\n    bool bUserConfirmed = false;\n\n    const FVector2D InitialSize(450.0f, 500.0f);\n\n    FWindowSizeLimits WindowSizeLimits;\n    WindowSizeLimits.SetMinWidth(InitialSize.X).SetMinHeight(InitialSize.Y);\n\n    // Need a shared ptr for the window so we can close it from button handlers\n    TSharedRef&lt;SWindow&gt; PickerWindow = SNew(SWindow)\n        .Title(LOCTEXT(\"PickCelTagTitle\", \"Pick Cel Tag\"))\n        .ClientSize(InitialSize)\n        .SupportsMinimize(false)\n        .SupportsMaximize(false)\n        .SizingRule(ESizingRule::Autosized);\n\n    PickerWindow-&gt;SetSizeLimits(WindowSizeLimits);\n\n    // Build tag widget\n    // IGameplayTagsEditorModule::Get invokes LoadModuleChecked\n    IGameplayTagsEditorModule&amp; TagsEditorModule = IGameplayTagsEditorModule::Get();\n\n    // Editable single-tag field\n    TSharedPtr&lt;FGameplayTag&gt; EditableNewName = MakeShared&lt;FGameplayTag&gt;(NewCelDefaultName);\n\n    // Build widget\n    TSharedRef&lt;SWidget&gt; TagWidget =\n        TagsEditorModule.MakeGameplayTagWidget(\n            FOnSetGameplayTag::CreateLambda(\n                [&amp;EditableNewName](FGameplayTag InTag)\n                {\n                    *EditableNewName = InTag;\n                }),\n            EditableNewName,\n            FString(\"\") // TODO: second button with filtering\n        );\n\n    // Compose window content with tag widget + OK/Cancel\n    PickerWindow-&gt;SetContent(\n        SNew(SBorder)\n        .BorderImage(FAppStyle::GetBrush(\"ToolPanel.GroupBorder\"))\n        [\n            SNew(SVerticalBox)\n\n            + SVerticalBox::Slot()\n            .AutoHeight()\n            .Padding(8.0f)\n            [\n                SNew(STextBlock)\n                .Text(LOCTEXT(\"PickCelTagLabel\", \"Select a new cel tag\"))\n            ]\n\n            + SVerticalBox::Slot()\n            .FillHeight(1.0f)\n            .Padding(8.0f)\n            [\n                TagWidget\n            ]\n\n            + SVerticalBox::Slot()\n            .AutoHeight()\n            .HAlign(HAlign_Right)\n            .Padding(8.0f)\n            [\n                SNew(SUniformGridPanel)\n                .SlotPadding(FMargin(2.0f))\n\n                + SUniformGridPanel::Slot(0, 0)\n                [\n                    SNew(SButton)\n                    .Text(LOCTEXT(\"OK\", \"OK\"))\n                    .HAlign(HAlign_Center)\n                    .VAlign(VAlign_Center)\n                    .OnClicked_Lambda(\n                        [&amp;PickerWindow, &amp;bUserConfirmed]()\n                        {\n                            bUserConfirmed = true;\n                            FSlateApplication::Get().RequestDestroyWindow(PickerWindow);\n                            return FReply::Handled();\n                        })\n                ]\n\n                + SUniformGridPanel::Slot(1, 0)\n                [\n                    SNew(SButton)\n                    .Text(LOCTEXT(\"Cancel\", \"Cancel\"))\n                    .HAlign(HAlign_Center)\n                    .VAlign(VAlign_Center)\n                    .OnClicked_Lambda(\n                        [&amp;PickerWindow]()\n                        {\n                            FSlateApplication::Get().RequestDestroyWindow(PickerWindow);\n                            return FReply::Handled();\n                        })\n                ]\n            ]\n        ]);\n\n    // This call BLOCKS until the modal window is closed\n    FSlateApplication::Get().AddModalWindow(PickerWindow, nullptr);\n\n    if (bUserConfirmed &amp;&amp; EditableNewName.IsValid() &amp;&amp; EditableNewName-&gt;IsValid())\n    {\n        // Re-validate after the modal dialog closes in case the array changed\n        if (!CollisionData-&gt;CollisionFrames.IsValidIndex(SelectedIndex))\n        {\n            return FReply::Handled();\n        }\n\n        FScopedTransaction Transaction(LOCTEXT(\"TemplateSelectedCelTransaction\", \"New Cel From Selected\"));\n        CollisionData-&gt;Modify();\n\n        FCollisionStruct NewCel = CollisionData-&gt;CollisionFrames[SelectedIndex];\n        NewCel.CelName = *EditableNewName;\n\n        const int32 NewIndex = CollisionData-&gt;CollisionFrames.Add(NewCel);\n        CollisionData-&gt;EditorSelectedIndex = NewIndex;\n\n        // Notify tree view and refresh the details panel to prevent stale property handles\n        CollisionData-&gt;NotifyCollisionFramesChanged();\n\n        if (CachedDetailBuilder)\n        {\n            CachedDetailBuilder-&gt;ForceRefreshDetails();\n        }\n    }\n#endif\n\n    return FReply::Handled();\n}\n\nbool FCollisionDataDetails::CanTemplateSelectedCel() const\n{\n#if WITH_EDITORONLY_DATA\n    UCollisionData* CollisionData = CollisionDataPtr.Get();\n    if (CollisionData)\n    {\n        const int32 SelectedIndex = CollisionData-&gt;EditorSelectedIndex;\n        return SelectedIndex != INDEX_NONE &amp;&amp; CollisionData-&gt;CollisionFrames.IsValidIndex(SelectedIndex);\n    }\n#endif\n    return false;\n}\n\nbool FCollisionDataDetails::CanDeleteSelectedCel() const\n{\n#if WITH_EDITORONLY_DATA\n    UCollisionData* CollisionData = CollisionDataPtr.Get();\n    if (CollisionData)\n    {\n        const int32 SelectedIndex = CollisionData-&gt;EditorSelectedIndex;\n        return SelectedIndex != INDEX_NONE &amp;&amp; CollisionData-&gt;CollisionFrames.IsValidIndex(SelectedIndex);\n    }\n#endif\n    return false;\n}\n\nFReply FCollisionDataDetails::OnRefreshTree()\n{\n    UCollisionData* CollisionData = CollisionDataPtr.Get();\n    if (!CollisionData)\n    {\n        return FReply::Handled();\n    }\n\n#if WITH_EDITORONLY_DATA\n    CollisionData-&gt;NotifyCollisionFramesChanged();\n#endif\n\n    if (CachedDetailBuilder)\n    {\n        CachedDetailBuilder-&gt;ForceRefreshDetails();\n    }\n\n    return FReply::Handled();\n}\n\nvoid FCollisionDataDetails::OnCelSelected(const FGameplayTag&amp; CelName)\n{\n    SelectedCelName = CelName;\n    if (CachedDetailBuilder)\n    {\n        CachedDetailBuilder-&gt;ForceRefreshDetails();\n    }\n}\n\n#undef LOCTEXT_NAMESPACE\n</code></pre>"},{"location":"CollisionEditor/_collision_data_editor_toolkit_8cpp/","title":"File CollisionDataEditorToolkit.cpp","text":"<p>FileList &gt; CollisionEditor &gt; Private &gt; CollisionDataEditorToolkit.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CollisionDataEditorToolkit.h\"</code></li> <li><code>#include \"Logging.h\"</code></li> <li><code>#include \"CelAssetTree.h\"</code></li> <li><code>#include \"Battle/Objects/PlayerObject.h\"</code></li> <li><code>#include \"Data/CollisionData.h\"</code></li> <li><code>#include \"Editor/PropertyEditor/Public/PropertyEditorModule.h\"</code></li> <li><code>#include \"Viewport/CollisionAnimationPreviewScene.h\"</code></li> <li><code>#include \"Viewport/CollisionAnimationViewport.h\"</code></li> <li><code>#include \"Widgets/Docking/SDockTab.h\"</code></li> <li><code>#include \"Widgets/Layout/SBorder.h\"</code></li> <li><code>#include \"Widgets/Text/STextBlock.h\"</code></li> </ul>"},{"location":"CollisionEditor/_collision_data_editor_toolkit_8cpp/#macros","title":"Macros","text":"Type Name define LOCTEXT_NAMESPACE <code>\"NightSkyCollisionEditor\"</code>"},{"location":"CollisionEditor/_collision_data_editor_toolkit_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CollisionEditor/_collision_data_editor_toolkit_8cpp/#define-loctext_namespace","title":"define LOCTEXT_NAMESPACE","text":"<pre><code>#define LOCTEXT_NAMESPACE `\"NightSkyCollisionEditor\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Private/CollisionDataEditorToolkit.cpp</code></p>"},{"location":"CollisionEditor/_collision_data_editor_toolkit_8cpp_source/","title":"File CollisionDataEditorToolkit.cpp","text":"<p>File List &gt; CollisionEditor &gt; Private &gt; CollisionDataEditorToolkit.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"CollisionDataEditorToolkit.h\"\n#include \"Logging.h\"\n#include \"CelAssetTree.h\"\n#include \"Battle/Objects/PlayerObject.h\"\n#include \"Data/CollisionData.h\"\n#include \"Editor/PropertyEditor/Public/PropertyEditorModule.h\"\n#include \"Viewport/CollisionAnimationPreviewScene.h\"\n#include \"Viewport/CollisionAnimationViewport.h\"\n#include \"Widgets/Docking/SDockTab.h\"\n#include \"Widgets/Layout/SBorder.h\"\n#include \"Widgets/Text/STextBlock.h\"\n\n\n#define LOCTEXT_NAMESPACE \"NightSkyCollisionEditor\"\n\nFCollisionDataEditorToolkit::FCollisionDataEditorToolkit()\n{\n}\n\nFCollisionDataEditorToolkit::~FCollisionDataEditorToolkit()\n{\n}\n\nvoid FCollisionDataEditorToolkit::Initialize(UCollisionData* InCollisionData, const EToolkitMode::Type Mode,\n                                             const TSharedPtr&lt;IToolkitHost&gt;&amp; InitToolkitHost)\n{\n    CollisionData = InCollisionData;\n\n    for (auto&amp; Collision : CollisionData-&gt;CollisionFrames)\n    {\n        for (auto&amp; Box : Collision.Boxes)\n        {\n            Box.EditorInit();\n        }\n    }\n\n    // Setup details view\n    FPropertyEditorModule&amp; PropertyModule = FModuleManager::LoadModuleChecked&lt;FPropertyEditorModule&gt;(\"PropertyEditor\");\n    FDetailsViewArgs DetailsViewArgs;\n    DetailsViewArgs.bUpdatesFromSelection = true;\n    DetailsViewArgs.bLockable = false;\n    DetailsViewArgs.bAllowSearch = true;\n    DetailsViewArgs.bHideSelectionTip = true;\n\n    DetailsView = PropertyModule.CreateDetailView(DetailsViewArgs);\n    DetailsView-&gt;SetObject(CollisionData);\n\n    // Setup PlayerObject BP picker\n    InitializePlayerObjectBPPicker();\n    // Setup cel asset tree\n    InitializeCelAssetTree();\n\n#if WITH_EDITORONLY_DATA\n    // Subscribe to collision frames changes to refresh tree\n    CollisionData-&gt;OnCollisionFramesChanged.AddSP(this, &amp;FCollisionDataEditorToolkit::OnCollisionFramesChanged);\n#endif\n\n    // Set up viewport\n    InitializePreviewScene();\n\n    // Define the layout\n    const TSharedRef&lt;FTabManager::FLayout&gt; StandaloneLayout = FTabManager::NewLayout(\n        \"Standalone_CollisionDataEditor_Layout\")\n        -&gt;AddArea\n        (\n            FTabManager::NewPrimaryArea()\n            -&gt;SetOrientation(Orient_Horizontal)\n            -&gt;Split\n            (\n                // Left side\n                FTabManager::NewStack()\n                -&gt;AddTab(\"PlayerObjectSelectorTab\", ETabState::OpenedTab)\n                -&gt;SetSizeCoefficient(0.15f)\n            )\n            -&gt;Split\n            (\n                // Middle\n                FTabManager::NewStack()\n                -&gt;AddTab(\"ViewportTab\", ETabState::OpenedTab)\n                -&gt;SetHideTabWell(true)\n                -&gt;SetSizeCoefficient(0.55f)\n            )\n            -&gt;Split\n            (\n                // Right side\n                FTabManager::NewStack()\n                -&gt;AddTab(\"CollisionDataDetailsTab\", ETabState::OpenedTab)\n                -&gt;SetSizeCoefficient(0.3f)\n            )\n        );\n\n    // Register tab spawners\n    // Ensure the ToolkitHost is valid and has a valid TabManager\n    if (InitToolkitHost.IsValid() &amp;&amp; InitToolkitHost-&gt;GetTabManager().IsValid())\n    {\n        TabManager = InitToolkitHost-&gt;GetTabManager(); // Do I need to set this or is it already set?\n        RegisterTabSpawners(TabManager.ToSharedRef());\n    }\n    else\n    {\n        // Handle the error condition here, e.g., log an error or assert\n        UE_LOG(LogCollisionEditor, Warning, TEXT(\"Toolkit host or tab manager is not valid.\"));\n    }\n\n    InitAssetEditor(Mode, InitToolkitHost, FName(\"CollisionDataEditorApp\"), StandaloneLayout, true, true,\n                    TArray&lt;UObject*&gt;({CollisionData}));\n    PreviewScene-&gt;SetupScene(CollisionData);\n}\n\nvoid FCollisionDataEditorToolkit::InitializePlayerObjectBPPicker()\n{\n    PlayerObjectBPPicker = SNew(SClassPropertyEntryBox)\n        .MetaClass(APlayerObject::StaticClass())\n        .SelectedClass(PlayerObjectClass)\n        .OnSetClass(this, &amp;FCollisionDataEditorToolkit::OnPlayerObjectBPSelected)\n        .AllowNone(false);\n}\n\nFGameplayTag FCollisionDataEditorToolkit::GetCurrentCelName() const\n{\n    if (PlayerObject &amp;&amp; PlayerObject-&gt;CelName.IsValid())\n        return PlayerObject-&gt;CelName;\n\n    return FGameplayTag::EmptyTag;\n}\n\nvoid FCollisionDataEditorToolkit::OnClose()\n{\n#if WITH_EDITORONLY_DATA\n    if (CollisionData)\n    {\n        CollisionData-&gt;OnCollisionFramesChanged.RemoveAll(this);\n    }\n#endif\n    FAssetEditorToolkit::OnClose();\n}\n\nvoid FCollisionDataEditorToolkit::InitializeCelAssetTree()\n{\n    SAssignNew(CelAssetTree, SCelAssetTree, CollisionData)\n        .OnCelSelected(this, &amp;FCollisionDataEditorToolkit::OnCelSelected);\n}\n\nvoid FCollisionDataEditorToolkit::OnCelSelected(int32 CelIndex)\n{\n    if (!CollisionData || !CollisionData-&gt;CollisionFrames.IsValidIndex(CelIndex))\n    {\n        return;\n    }\n\n    const FGameplayTag&amp; CelName = CollisionData-&gt;CollisionFrames[CelIndex].CelName;\n    SelectedCel = CelName;\n\n    if (PlayerObject &amp;&amp; CelName.IsValid())\n    {\n        PlayerObject-&gt;SetCelName(CelName);\n    }\n\n#if WITH_EDITORONLY_DATA\n    CollisionData-&gt;EditorSelectedIndex = CelIndex;\n    if (DetailsView.IsValid())\n    {\n        DetailsView-&gt;ForceRefresh();\n    }\n#endif\n}\n\nvoid FCollisionDataEditorToolkit::OnCollisionFramesChanged()\n{\n    if (CelAssetTree.IsValid())\n    {\n        CelAssetTree-&gt;RefreshTree();\n    }\n}\n\nvoid FCollisionDataEditorToolkit::OnPlayerObjectBPSelected(const UClass* Class)\n{\n    if (!Class) return;\n    PlayerObjectClass = const_cast&lt;UClass*&gt;(Class);\n    PlayerObject = PreviewScene-&gt;SetPlayerObject(Class);\n    // CollisionData-&gt;SelectedPlayerObjectClass = Class;\n    PlayerObject-&gt;SetCelName(SelectedCel);\n    UE_LOG(LogCollisionEditor, Log, TEXT(\"Selected PlayerObject: %s\"), *PlayerObject-&gt;GetName());\n}\n\nTSharedRef&lt;SDockTab&gt; FCollisionDataEditorToolkit::SpawnTab_CollisionDataDetails(const FSpawnTabArgs&amp; Args)\n{\n    return SNew(SDockTab)\n        .Label(LOCTEXT(\"CollisionDataDetailsTabLabel\", \"Collision Data Details\"))\n        .TabRole(ETabRole::NomadTab)\n        [\n            SNew(SBorder)\n            .Padding(4)\n            [\n                DetailsView-&gt;AsShared()\n            ]\n        ];\n}\n\nTSharedRef&lt;SDockTab&gt; FCollisionDataEditorToolkit::SpawnTab_PlayerObjectSelector(const FSpawnTabArgs&amp; Args)\n{\n    return SNew(SDockTab)\n        .Label(LOCTEXT(\"PlayerObjectSelectorTabLabel\", \"Cel Browser\"))\n        .TabRole(ETabRole::NomadTab)\n        [\n            SNew(SVerticalBox)\n            + SVerticalBox::Slot()\n            .AutoHeight()\n            [\n                SNew(SBorder)\n                .Padding(4)\n                [\n                    PlayerObjectBPPicker.ToSharedRef()\n                ]\n            ]\n            + SVerticalBox::Slot()\n            .FillHeight(1.f)\n            [\n                SNew(SBorder)\n                .Padding(4)\n                [\n                    CelAssetTree.ToSharedRef()\n                ]\n            ]\n        ];\n}\n\nTSharedRef&lt;SDockTab&gt; FCollisionDataEditorToolkit::SpawnTab_ViewportTab(const FSpawnTabArgs&amp; Args)\n{\n    return SNew(SDockTab)\n        .Label(LOCTEXT(\"ViewportTabLabel\", \"Viewport\"))\n        .TabRole(ETabRole::MajorTab)\n        [\n            SNew(SBorder)\n            .Padding(4)\n            [\n                PreviewViewportWidget.ToSharedRef() // Make sure to use the viewport widget\n            ]\n        ];\n}\n\nFText FCollisionDataEditorToolkit::GetSelectedState() const\n{\n    return FText::FromString(SelectedCel.ToString());\n}\n\n// Code to set the animation to a specific frames\nvoid FCollisionDataEditorToolkit::UpdateAnimationPlayback(int32 Frame)\n{\n    if (PlayerObject)\n    {\n        PlayerObject-&gt;CelIndex = Frame;\n    }\n}\n\nvoid FCollisionDataEditorToolkit::InitializePreviewScene()\n{\n    if (!PreviewScene.IsValid())\n    {\n        PreviewScene = MakeShareable(new FCollisionAnimationPreviewScene(\n            FPreviewScene::ConstructionValues()\n            .AllowAudioPlayback(false)\n            .ShouldSimulatePhysics(false)\n            , SharedThis(this)\n        ));\n    }\n\n    PreviewViewportWidget = SNew(SCollisionAnimationViewport, SharedThis(this), PreviewScene);\n}\n\nFName FCollisionDataEditorToolkit::GetToolkitFName() const\n{\n    return FName(\"CollisionDataEditor\");\n}\n\nFText FCollisionDataEditorToolkit::GetBaseToolkitName() const\n{\n    return LOCTEXT(\"AppLabel\", \"Collision Data Editor\");\n}\n\nFText FCollisionDataEditorToolkit::GetToolkitName() const\n{\n    return FText::FromString(CollisionData-&gt;GetName());\n}\n\nFString FCollisionDataEditorToolkit::GetWorldCentricTabPrefix() const\n{\n    return FString(\"CollisionDataEditor\");\n}\n\nFLinearColor FCollisionDataEditorToolkit::GetWorldCentricTabColorScale() const\n{\n    return FLinearColor::White;\n}\n\nvoid FCollisionDataEditorToolkit::RegisterTabSpawners(const TSharedRef&lt;FTabManager&gt;&amp; InTabManager)\n{\n    UE_LOG(LogCollisionEditor, Warning, TEXT(\"Registering Tab Spawners\"));\n    WorkspaceMenuCategory = InTabManager-&gt;AddLocalWorkspaceMenuCategory(\n        LOCTEXT(\"WorkspaceMenu_CollisionDataEditor\", \"Collision Data Editor\"));\n\n    FAssetEditorToolkit::RegisterTabSpawners(InTabManager);\n\n    InTabManager-&gt;RegisterTabSpawner(\"CollisionDataDetailsTab\",\n                                     FOnSpawnTab::CreateSP(\n                                         this, &amp;FCollisionDataEditorToolkit::SpawnTab_CollisionDataDetails))\n                .SetDisplayName(LOCTEXT(\"CollisionDataDetailsTab\", \"Collision Data Details\"))\n                .SetGroup(WorkspaceMenuCategory.ToSharedRef());\n\n    InTabManager-&gt;RegisterTabSpawner(\"PlayerObjectSelectorTab\",\n                                     FOnSpawnTab::CreateSP(\n                                         this, &amp;FCollisionDataEditorToolkit::SpawnTab_PlayerObjectSelector))\n                .SetDisplayName(LOCTEXT(\"PlayerObjectSelectorTab\", \"Cel Browser\"))\n                .SetGroup(WorkspaceMenuCategory.ToSharedRef());\n\n    InTabManager-&gt;RegisterTabSpawner(\"ViewportTab\",\n                                     FOnSpawnTab::CreateSP(this, &amp;FCollisionDataEditorToolkit::SpawnTab_ViewportTab))\n                .SetDisplayName(LOCTEXT(\"ViewportTab\", \"Viewport\"))\n                .SetGroup(WorkspaceMenuCategory.ToSharedRef());\n}\n\nvoid FCollisionDataEditorToolkit::UnregisterTabSpawners(const TSharedRef&lt;FTabManager&gt;&amp; InTabManager)\n{\n    FAssetEditorToolkit::UnregisterTabSpawners(InTabManager);\n\n    InTabManager-&gt;UnregisterTabSpawner(\"CollisionDataDetailsTab\");\n    InTabManager-&gt;UnregisterTabSpawner(\"PlayerObjectSelectorTab\");\n    InTabManager-&gt;UnregisterTabSpawner(\"ViewportTab\");\n}\n\n#undef LOCTEXT_NAMESPACE\n</code></pre>"},{"location":"CollisionEditor/_collision_editor_8cpp/","title":"File CollisionEditor.cpp","text":"<p>FileList &gt; CollisionEditor &gt; Private &gt; CollisionEditor.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CollisionEditor.h\"</code></li> <li><code>#include \"AssetToolsModule.h\"</code></li> <li><code>#include \"AssetTypeActions_CollisionData.h\"</code></li> <li><code>#include \"CollisionDataDetails.h\"</code></li> <li><code>#include \"IAssetTools.h\"</code></li> <li><code>#include \"Logging.h\"</code></li> <li><code>#include \"PropertyEditorModule.h\"</code></li> <li><code>#include \"Data/CollisionData.h\"</code></li> <li><code>#include \"Modules/ModuleManager.h\"</code></li> </ul>"},{"location":"CollisionEditor/_collision_editor_8cpp/#public-functions","title":"Public Functions","text":"Type Name IMPLEMENT_MODULE (FCollisionEditor, CollisionEditor)"},{"location":"CollisionEditor/_collision_editor_8cpp/#macros","title":"Macros","text":"Type Name define LOCTEXT_NAMESPACE <code>\"NightSkyCollisionEditor\"</code>"},{"location":"CollisionEditor/_collision_editor_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CollisionEditor/_collision_editor_8cpp/#function-implement_module","title":"function IMPLEMENT_MODULE","text":"<pre><code>IMPLEMENT_MODULE (\n    FCollisionEditor,\n    CollisionEditor\n) \n</code></pre>"},{"location":"CollisionEditor/_collision_editor_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"CollisionEditor/_collision_editor_8cpp/#define-loctext_namespace","title":"define LOCTEXT_NAMESPACE","text":"<pre><code>#define LOCTEXT_NAMESPACE `\"NightSkyCollisionEditor\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Private/CollisionEditor.cpp</code></p>"},{"location":"CollisionEditor/_collision_editor_8cpp_source/","title":"File CollisionEditor.cpp","text":"<p>File List &gt; CollisionEditor &gt; Private &gt; CollisionEditor.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"CollisionEditor.h\"\n#include \"AssetToolsModule.h\"\n#include \"AssetTypeActions_CollisionData.h\"\n#include \"CollisionDataDetails.h\"\n#include \"IAssetTools.h\"\n#include \"Logging.h\"\n#include \"PropertyEditorModule.h\"\n#include \"Data/CollisionData.h\"\n#include \"Modules/ModuleManager.h\"\n\n#define LOCTEXT_NAMESPACE \"NightSkyCollisionEditor\"\n\nvoid FCollisionEditor::StartupModule()\n{\n    UE_LOG(LogCollisionEditor, Log, TEXT(\"CollisionEditor Starting\"));\n    RegisterAssetTools();\n    RegisterPropertyCustomizations();\n}\n\nvoid FCollisionEditor::ShutdownModule()\n{\n    UnregisterPropertyCustomizations();\n\n    if (FModuleManager::Get().IsModuleLoaded(\"AssetTools\"))\n    {\n        IAssetTools&amp; AssetTools = FModuleManager::GetModuleChecked&lt;FAssetToolsModule&gt;(\"AssetTools\").Get();\n        AssetTools.UnregisterAssetTypeActions(MakeShareable(new FAssetTypeActions_CollisionData(CollisionAssetCategoryBit)));\n    }\n}\n\nvoid FCollisionEditor::RegisterAssetTools()\n{\n    // Register the asset tools\n    IAssetTools&amp; AssetTools = FModuleManager::LoadModuleChecked&lt;FAssetToolsModule&gt;(\"AssetTools\").Get();\n    CollisionAssetCategoryBit = AssetTools.RegisterAdvancedAssetCategory(FName(TEXT(\"CollisionData\")), LOCTEXT(\"CollisionDataAssetCategory\", \"Collision Data\"));\n    TSharedRef&lt;IAssetTypeActions&gt; CollisionDataTypeActions = MakeShareable(new FAssetTypeActions_CollisionData(CollisionAssetCategoryBit));\n    AssetTools.RegisterAssetTypeActions(CollisionDataTypeActions);\n}\n\nvoid FCollisionEditor::RegisterPropertyCustomizations()\n{\n    FPropertyEditorModule&amp; PropertyModule = FModuleManager::LoadModuleChecked&lt;FPropertyEditorModule&gt;(\"PropertyEditor\");\n\n    PropertyModule.RegisterCustomClassLayout(\n        UCollisionData::StaticClass()-&gt;GetFName(),\n        FOnGetDetailCustomizationInstance::CreateStatic(&amp;FCollisionDataDetails::MakeInstance)\n    );\n\n    PropertyModule.NotifyCustomizationModuleChanged();\n}\n\nvoid FCollisionEditor::UnregisterPropertyCustomizations()\n{\n    if (FModuleManager::Get().IsModuleLoaded(\"PropertyEditor\"))\n    {\n        FPropertyEditorModule&amp; PropertyModule = FModuleManager::GetModuleChecked&lt;FPropertyEditorModule&gt;(\"PropertyEditor\");\n        PropertyModule.UnregisterCustomClassLayout(UCollisionData::StaticClass()-&gt;GetFName());\n    }\n}\n\n#undef LOCTEXT_NAMESPACE\n\nIMPLEMENT_MODULE(FCollisionEditor, CollisionEditor);\n</code></pre>"},{"location":"CollisionEditor/_logging_8cpp/","title":"File Logging.cpp","text":"<p>FileList &gt; CollisionEditor &gt; Private &gt; Logging.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"Logging.h\"</code></li> </ul>"},{"location":"CollisionEditor/_logging_8cpp/#public-functions","title":"Public Functions","text":"Type Name DEFINE_LOG_CATEGORY (LogCollisionEditor)"},{"location":"CollisionEditor/_logging_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CollisionEditor/_logging_8cpp/#function-define_log_category","title":"function DEFINE_LOG_CATEGORY","text":"<pre><code>DEFINE_LOG_CATEGORY (\n    LogCollisionEditor\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Private/Logging.cpp</code></p>"},{"location":"CollisionEditor/_logging_8cpp_source/","title":"File Logging.cpp","text":"<p>File List &gt; CollisionEditor &gt; Private &gt; Logging.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright Screaming Goose Games. All Rights Reserved.\n\n#include \"Logging.h\"\n\nDEFINE_LOG_CATEGORY(LogCollisionEditor);\n</code></pre>"},{"location":"CollisionEditor/_logging_8h/","title":"File Logging.h","text":"<p>FileList &gt; CollisionEditor &gt; Private &gt; Logging.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> </ul>"},{"location":"CollisionEditor/_logging_8h/#public-functions","title":"Public Functions","text":"Type Name DECLARE_LOG_CATEGORY_EXTERN (LogCollisionEditor, Log, All)"},{"location":"CollisionEditor/_logging_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CollisionEditor/_logging_8h/#function-declare_log_category_extern","title":"function DECLARE_LOG_CATEGORY_EXTERN","text":"<pre><code>DECLARE_LOG_CATEGORY_EXTERN (\n    LogCollisionEditor,\n    Log,\n    All\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Private/Logging.h</code></p>"},{"location":"CollisionEditor/_logging_8h_source/","title":"File Logging.h","text":"<p>File List &gt; CollisionEditor &gt; Private &gt; Logging.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright Screaming Goose Games. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n\nDECLARE_LOG_CATEGORY_EXTERN(LogCollisionEditor, Log, All);\n</code></pre>"},{"location":"CollisionEditor/dir_56ac83e1ee3de8bf475f92dfdd96fd55/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public","text":"<p>FileList &gt; CollisionEditor &gt; Public</p>"},{"location":"CollisionEditor/dir_56ac83e1ee3de8bf475f92dfdd96fd55/#files","title":"Files","text":"Type Name file AssetTypeActions_CollisionData.h file CelAssetTree.h file CelAssetTreeNode.h file CollisionDataDetails.h file CollisionDataEditorToolkit.h file CollisionEditor.h"},{"location":"CollisionEditor/dir_56ac83e1ee3de8bf475f92dfdd96fd55/#directories","title":"Directories","text":"Type Name dir Viewport <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/</code></p>"},{"location":"CollisionEditor/_asset_type_actions___collision_data_8h/","title":"File AssetTypeActions_CollisionData.h","text":"<p>FileList &gt; CollisionEditor &gt; Public &gt; AssetTypeActions_CollisionData.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"AssetTypeActions_Base.h\"</code></li> <li><code>#include \"Math/Color.h\"</code></li> </ul>"},{"location":"CollisionEditor/_asset_type_actions___collision_data_8h/#classes","title":"Classes","text":"Type Name class FAssetTypeActions_CollisionData <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/AssetTypeActions_CollisionData.h</code></p>"},{"location":"CollisionEditor/_asset_type_actions___collision_data_8h_source/","title":"File AssetTypeActions_CollisionData.h","text":"<p>File List &gt; CollisionEditor &gt; Public &gt; AssetTypeActions_CollisionData.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n// Note: My intellisense is not working so I'm just including everything I may need\n#include \"CoreMinimal.h\"\n#include \"AssetTypeActions_Base.h\"\n#include \"Math/Color.h\"\n\nclass COLLISIONEDITOR_API FAssetTypeActions_CollisionData : public FAssetTypeActions_Base\n{\npublic:\n\n    FAssetTypeActions_CollisionData(EAssetTypeCategories::Type InAssetCategory)\n        : AssetCategory(InAssetCategory){}\n\n    virtual FColor GetTypeColor() const override;\n    virtual UClass* GetSupportedClass() const override;\n\n    virtual void OpenAssetEditor(const TArray&lt;UObject*&gt;&amp; InObjects, TSharedPtr&lt;IToolkitHost&gt; EditWithinLevelEditor) override;\n\n    virtual FText GetName() const override;\n\n    virtual bool CanFilter() override { return true; }\n\n    virtual uint32 GetCategories() override;\n\nprivate:\n    EAssetTypeCategories::Type AssetCategory;\n};\n</code></pre>"},{"location":"CollisionEditor/dir_d692cfa9987693da5da8910b9a0fc6c1/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/Viewport","text":"<p>FileList &gt; CollisionEditor &gt; Public &gt; Viewport</p>"},{"location":"CollisionEditor/dir_d692cfa9987693da5da8910b9a0fc6c1/#files","title":"Files","text":"Type Name file CollisionAnimationPreviewScene.h file CollisionAnimationViewport.h file CollisionAnimationViewportClient.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/Viewport/</code></p>"},{"location":"CollisionEditor/_collision_animation_preview_scene_8h/","title":"File CollisionAnimationPreviewScene.h","text":"<p>FileList &gt; CollisionEditor &gt; Public &gt; Viewport &gt; CollisionAnimationPreviewScene.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"AdvancedPreviewScene.h\"</code></li> <li><code>#include \"Components/SkeletalMeshComponent.h\"</code></li> <li><code>#include \"Data/CollisionData.h\"</code></li> </ul>"},{"location":"CollisionEditor/_collision_animation_preview_scene_8h/#classes","title":"Classes","text":"Type Name class FCollisionAnimationPreviewScene <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/Viewport/CollisionAnimationPreviewScene.h</code></p>"},{"location":"CollisionEditor/_collision_animation_preview_scene_8h_source/","title":"File CollisionAnimationPreviewScene.h","text":"<p>File List &gt; CollisionEditor &gt; Public &gt; Viewport &gt; CollisionAnimationPreviewScene.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AdvancedPreviewScene.h\"\n#include \"Components/SkeletalMeshComponent.h\"\n#include \"Data/CollisionData.h\"\n\nclass APlayerObject;\nclass FCollisionDataEditorToolkit;\n\nclass FCollisionAnimationPreviewScene : public FAdvancedPreviewScene\n{\npublic:\n    FCollisionAnimationPreviewScene(ConstructionValues CVS, const TSharedRef&lt;FCollisionDataEditorToolkit&gt;&amp; EditorToolkit);\n    virtual ~FCollisionAnimationPreviewScene() override;\n\n    virtual void Tick(float InDeltaTime) override;\n\n    // Switch skeletal mesh on component\n    APlayerObject* SetPlayerObject(const UClass* Class);\n\n    // Setup the scene with animation data\n    void SetupScene(UCollisionData* CollisionData);\n\n    // Update the animation hitboxes\n    void UpdateCollisionView();\n\nprivate:\n    APlayerObject* PreviewPlayerObject = nullptr;\n    TWeakPtr&lt;FCollisionDataEditorToolkit&gt; EditorPtr;\n    UCollisionData* CurrentCollisionData = nullptr;\n\n    // Functions to update mesh and animations\n    void UpdateMeshAndAnimation(float DeltaTime);\n\n    // Draw hitboxes based on loaded collision data\n    void DrawCollisionData();\n};\n</code></pre>"},{"location":"CollisionEditor/_collision_animation_viewport_8h/","title":"File CollisionAnimationViewport.h","text":"<p>FileList &gt; CollisionEditor &gt; Public &gt; Viewport &gt; CollisionAnimationViewport.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"SCommonEditorViewportToolbarBase.h\"</code></li> <li><code>#include \"SEditorViewport.h\"</code></li> <li><code>#include \"CollisionAnimationPreviewScene.h\"</code></li> <li><code>#include \"CollisionDataEditorToolkit.h\"</code></li> <li><code>#include \"CollisionAnimationViewportClient.h\"</code></li> </ul>"},{"location":"CollisionEditor/_collision_animation_viewport_8h/#classes","title":"Classes","text":"Type Name class SCollisionAnimationViewport <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/Viewport/CollisionAnimationViewport.h</code></p>"},{"location":"CollisionEditor/_collision_animation_viewport_8h_source/","title":"File CollisionAnimationViewport.h","text":"<p>File List &gt; CollisionEditor &gt; Public &gt; Viewport &gt; CollisionAnimationViewport.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"SCommonEditorViewportToolbarBase.h\"\n#include \"SEditorViewport.h\"\n#include \"CollisionAnimationPreviewScene.h\"\n#include \"CollisionDataEditorToolkit.h\"\n#include \"CollisionAnimationViewportClient.h\"\n\nclass SCollisionAnimationViewport : public SEditorViewport, public FGCObject, public ICommonEditorViewportToolbarInfoProvider\n{\npublic:\n    SLATE_BEGIN_ARGS(SCollisionAnimationViewport) {}\n    SLATE_END_ARGS()\n\n    // The scene\n    TSharedPtr&lt;FCollisionAnimationPreviewScene&gt; PreviewScene;\n\n    // Construct the viewport\n    void Construct(const FArguments&amp; InArgs, TSharedPtr&lt;FCollisionDataEditorToolkit&gt; InEditorToolkit, TSharedPtr&lt;FCollisionAnimationPreviewScene&gt; InPreviewScene);\n    virtual ~SCollisionAnimationViewport() override;\n\n    // FGCObject interface\n    virtual void AddReferencedObjects(FReferenceCollector&amp; Collector) override {};\n    virtual FString GetReferencerName() const override;\n    // Toolbar interface\n    virtual TSharedRef&lt;SEditorViewport&gt; GetViewportWidget() override;\n    virtual TSharedPtr&lt;FExtender&gt; GetExtenders() const override;\n    virtual void OnFloatingButtonClicked() override;\n    virtual void OnFocusViewportToSelection() override; // Not sure this is needed yet\n\n    // Construct the viewport\n    virtual TSharedRef&lt;FEditorViewportClient&gt; MakeEditorViewportClient() override;\n\nprivate:\n    TSharedPtr&lt;FCollisionAnimationViewportClient&gt; ViewportClient;\n    TWeakPtr&lt;FCollisionDataEditorToolkit&gt; EditorToolkit;\n};\n</code></pre>"},{"location":"CollisionEditor/_collision_animation_viewport_client_8h/","title":"File CollisionAnimationViewportClient.h","text":"<p>FileList &gt; CollisionEditor &gt; Public &gt; Viewport &gt; CollisionAnimationViewportClient.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"SEditorViewport.h\"</code></li> <li><code>#include \"AdvancedPreviewScene.h\"</code></li> <li><code>#include \"SCommonEditorViewportToolbarBase.h\"</code></li> </ul>"},{"location":"CollisionEditor/_collision_animation_viewport_client_8h/#classes","title":"Classes","text":"Type Name class FCollisionAnimationViewportClient <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/Viewport/CollisionAnimationViewportClient.h</code></p>"},{"location":"CollisionEditor/_collision_animation_viewport_client_8h_source/","title":"File CollisionAnimationViewportClient.h","text":"<p>File List &gt; CollisionEditor &gt; Public &gt; Viewport &gt; CollisionAnimationViewportClient.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"SEditorViewport.h\"\n#include \"AdvancedPreviewScene.h\"\n#include \"SCommonEditorViewportToolbarBase.h\"\n\nclass UAnimationAsset;\nclass FCollisionAnimationPreviewScene;\nclass FCollisionDataEditorToolkit;\n\n// Define the viewport client\nclass FCollisionAnimationViewportClient : public FEditorViewportClient\n{\npublic:\n    FCollisionAnimationViewportClient(const TSharedRef&lt;SEditorViewport&gt;&amp; InEditorViewport, const TSharedRef&lt;FAdvancedPreviewScene&gt;&amp; InPreviewScene);\n    virtual void Tick(float DeltaSeconds) override;\n\n    virtual ~FCollisionAnimationViewportClient();\n\n    /*FRenderTarget* GetRenderTarget() { return Viewport-&gt;GetRenderTargetTexture(); }\n    FSceneInterface* GetScene() const { return (FSceneInterface*)(GetWorld()-&gt;Scene); }*/\n\nprivate:\n\n    FAdvancedPreviewScene* AdvancedPreviewScene;\n};\n</code></pre>"},{"location":"CollisionEditor/_cel_asset_tree_8h/","title":"File CelAssetTree.h","text":"<p>FileList &gt; CollisionEditor &gt; Public &gt; CelAssetTree.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"CelAssetTreeNode.h\"</code></li> <li><code>#include \"GameplayTagContainer.h\"</code></li> <li><code>#include \"Widgets/SCompoundWidget.h\"</code></li> <li><code>#include \"Widgets/Views/STreeView.h\"</code></li> </ul>"},{"location":"CollisionEditor/_cel_asset_tree_8h/#classes","title":"Classes","text":"Type Name class SCelAssetTree"},{"location":"CollisionEditor/_cel_asset_tree_8h/#public-functions","title":"Public Functions","text":"Type Name DECLARE_DELEGATE_OneParam (FOnCelSelected, int32)"},{"location":"CollisionEditor/_cel_asset_tree_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"CollisionEditor/_cel_asset_tree_8h/#function-declare_delegate_oneparam","title":"function DECLARE_DELEGATE_OneParam","text":"<pre><code>DECLARE_DELEGATE_OneParam (\n    FOnCelSelected,\n    int32\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/CelAssetTree.h</code></p>"},{"location":"CollisionEditor/_cel_asset_tree_8h_source/","title":"File CelAssetTree.h","text":"<p>File List &gt; CollisionEditor &gt; Public &gt; CelAssetTree.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"CelAssetTreeNode.h\"\n#include \"GameplayTagContainer.h\"\n#include \"Widgets/SCompoundWidget.h\"\n#include \"Widgets/Views/STreeView.h\"\n\nclass UCollisionData;\n\nDECLARE_DELEGATE_OneParam(FOnCelSelected, int32 /*SelectedCelIndex*/);\n\nclass SCelAssetTree : public SCompoundWidget\n{\npublic:\n    SLATE_BEGIN_ARGS(SCelAssetTree) {}\n        SLATE_EVENT(FOnCelSelected, OnCelSelected)\n    SLATE_END_ARGS()\n\n    void Construct(const FArguments&amp; InArgs, UCollisionData* InCollisionData);\n\n    void RefreshTree();\n    void SetSelectedCel(const FGameplayTag&amp; CelName);\n\nprivate:\n    TSharedRef&lt;ITableRow&gt; GenerateTreeRow(\n        TSharedPtr&lt;FCelAssetTreeNode&gt; InNode,\n        const TSharedRef&lt;STableViewBase&gt;&amp; OwnerTable);\n\n    void GetChildrenForNode(\n        TSharedPtr&lt;FCelAssetTreeNode&gt; InNode,\n        TArray&lt;TSharedPtr&lt;FCelAssetTreeNode&gt;&gt;&amp; OutChildren);\n\n    void OnSelectionChanged(\n        TSharedPtr&lt;FCelAssetTreeNode&gt; SelectedNode,\n        ESelectInfo::Type SelectInfo);\n\n    void OnFilterTextChanged(const FText&amp; InText);\n\n    void BuildTreeFromCollisionData();\n\n    // TODO: Search box filtering\n    // void ApplyFilter(const FString&amp; FilterString);\n\n    TWeakObjectPtr&lt;UCollisionData&gt; CollisionData;\n    TSharedPtr&lt;STreeView&lt;TSharedPtr&lt;FCelAssetTreeNode&gt;&gt;&gt; TreeView;\n    TArray&lt;TSharedPtr&lt;FCelAssetTreeNode&gt;&gt; RootNodes;\n    TArray&lt;TSharedPtr&lt;FCelAssetTreeNode&gt;&gt; AllNodes;\n\n    FString CurrentFilterString;\n    FOnCelSelected OnCelSelectedDelegate;\n\n    // Maps cel index to its tree node for quick lookup\n    TMap&lt;int32, TSharedPtr&lt;FCelAssetTreeNode&gt;&gt; CelIndexToNodeMap;\n};\n</code></pre>"},{"location":"CollisionEditor/_cel_asset_tree_node_8h/","title":"File CelAssetTreeNode.h","text":"<p>FileList &gt; CollisionEditor &gt; Public &gt; CelAssetTreeNode.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> </ul>"},{"location":"CollisionEditor/_cel_asset_tree_node_8h/#classes","title":"Classes","text":"Type Name class FCelAssetTreeNode <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/CelAssetTreeNode.h</code></p>"},{"location":"CollisionEditor/_cel_asset_tree_node_8h_source/","title":"File CelAssetTreeNode.h","text":"<p>File List &gt; CollisionEditor &gt; Public &gt; CelAssetTreeNode.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n\nclass FCelAssetTreeNode : public TSharedFromThis&lt;FCelAssetTreeNode&gt;\n{\npublic:\n    FCelAssetTreeNode(const FString&amp; InDisplayName, int32 InCelIndex = INDEX_NONE)\n        : DisplayName(InDisplayName)\n        , CelIndex(InCelIndex)\n        , bHasProblem(false)\n    {\n    }\n\n    FCelAssetTreeNode(int32 InCelIndex, const FString&amp; InDisplayName, bool bInHasProblem = false)\n        : DisplayName(InDisplayName)\n        , CelIndex(InCelIndex)\n        , bHasProblem(bInHasProblem) {}\n\n    bool IsCategory() const { return CelIndex == INDEX_NONE; }\n    bool IsCel() const { return CelIndex != INDEX_NONE; }\n    bool IsValid() const { return bHasProblem; }\n\n    FString GetDisplayName() const { return DisplayName; }\n    int32 GetCelIndex() const { return CelIndex; }\n    void SetCelIndex(int32 InCelIndex) { CelIndex = InCelIndex; }\n\n    TSharedPtr&lt;FCelAssetTreeNode&gt; FindOrCreateChild(const FString&amp; ChildName, int32 ChildCelIndex = INDEX_NONE);\n\n    TWeakPtr&lt;FCelAssetTreeNode&gt; Parent;\n    TArray&lt;TSharedPtr&lt;FCelAssetTreeNode&gt;&gt; Children;\n\nprivate:\n    FString DisplayName;\n    int32 CelIndex;\n    bool bHasProblem;\n};\n</code></pre>"},{"location":"CollisionEditor/_collision_data_details_8h/","title":"File CollisionDataDetails.h","text":"<p>FileList &gt; CollisionEditor &gt; Public &gt; CollisionDataDetails.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"IDetailCustomization.h\"</code></li> <li><code>#include \"GameplayTagContainer.h\"</code></li> <li><code>#include \"Input/Reply.h\"</code></li> </ul>"},{"location":"CollisionEditor/_collision_data_details_8h/#classes","title":"Classes","text":"Type Name class FCollisionDataDetails <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/CollisionDataDetails.h</code></p>"},{"location":"CollisionEditor/_collision_data_details_8h_source/","title":"File CollisionDataDetails.h","text":"<p>File List &gt; CollisionEditor &gt; Public &gt; CollisionDataDetails.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"IDetailCustomization.h\"\n#include \"GameplayTagContainer.h\"\n#include \"Input/Reply.h\"\n\nclass UCollisionData;\nclass IDetailCategoryBuilder;\n\n\nclass FCollisionDataDetails : public IDetailCustomization\n{\npublic:\n    static TSharedRef&lt;IDetailCustomization&gt; MakeInstance();\n\n    virtual void CustomizeDetails(IDetailLayoutBuilder&amp; DetailBuilder) override;\n\nprivate:\n    void BuildSelectedCelView(IDetailLayoutBuilder&amp; DetailBuilder, IDetailCategoryBuilder&amp; Category);\n    void OnCelSelected(const FGameplayTag&amp; CelName);\n\n    FReply OnAddNewCel();\n    FReply OnDeleteSelectedCel();\n    FReply OnTemplateSelectedCel();\n    FReply OnRefreshTree();\n\n    bool CanDeleteSelectedCel() const;\n    bool CanTemplateSelectedCel() const;\n\n    TWeakObjectPtr&lt;UCollisionData&gt; CollisionDataPtr;\n    TSharedPtr&lt;IPropertyHandle&gt; CollisionFramesHandle;\n    IDetailLayoutBuilder* CachedDetailBuilder = nullptr;\n    FGameplayTag SelectedCelName;\n};\n</code></pre>"},{"location":"CollisionEditor/_collision_data_editor_toolkit_8h/","title":"File CollisionDataEditorToolkit.h","text":"<p>FileList &gt; CollisionEditor &gt; Public &gt; CollisionDataEditorToolkit.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Toolkits/AssetEditorToolkit.h\"</code></li> <li><code>#include \"Toolkits/IToolkitHost.h\"</code></li> <li><code>#include \"Widgets/Docking/SDockTab.h\"</code></li> <li><code>#include \"Widgets/Layout/SBorder.h\"</code></li> <li><code>#include \"Widgets/Text/STextBlock.h\"</code></li> <li><code>#include \"PropertyCustomizationHelpers.h\"</code></li> <li><code>#include \"Data/CollisionData.h\"</code></li> </ul>"},{"location":"CollisionEditor/_collision_data_editor_toolkit_8h/#classes","title":"Classes","text":"Type Name class FCollisionDataEditorToolkit"},{"location":"CollisionEditor/_collision_data_editor_toolkit_8h/#public-types","title":"Public Types","text":"Type Name enum EBoxEditMode enum ESceneInteractionMode"},{"location":"CollisionEditor/_collision_data_editor_toolkit_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"CollisionEditor/_collision_data_editor_toolkit_8h/#enum-eboxeditmode","title":"enum EBoxEditMode","text":"<pre><code>enum EBoxEditMode {\n    EditMode_None,\n    EditMode_Add,\n    EditMode_Move,\n    EditMode_Delete\n};\n</code></pre> <p>The different modes of editing collision boxes. </p>"},{"location":"CollisionEditor/_collision_data_editor_toolkit_8h/#enum-esceneinteractionmode","title":"enum ESceneInteractionMode","text":"<pre><code>enum ESceneInteractionMode {\n    Interaction_CameraMove,\n    Interaction_EditCollisionBoxes\n};\n</code></pre> <p>The different modes of interaction in the Scene. </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/CollisionDataEditorToolkit.h</code></p>"},{"location":"CollisionEditor/_collision_data_editor_toolkit_8h_source/","title":"File CollisionDataEditorToolkit.h","text":"<p>File List &gt; CollisionEditor &gt; Public &gt; CollisionDataEditorToolkit.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Toolkits/AssetEditorToolkit.h\"\n#include \"Toolkits/IToolkitHost.h\"\n#include \"Widgets/Docking/SDockTab.h\"\n#include \"Widgets/Layout/SBorder.h\"\n#include \"Widgets/Text/STextBlock.h\"\n#include \"PropertyCustomizationHelpers.h\"\n#include \"Data/CollisionData.h\"\n\nclass APlayerObject;\nclass FCollisionAnimationPreviewScene;\nclass SCollisionAnimationViewport;\nclass SCelAssetTree;\n\n\n//These aren't used yet\nenum ESceneInteractionMode\n{\n    Interaction_CameraMove,\n    Interaction_EditCollisionBoxes\n};\n\nenum EBoxEditMode\n{\n    EditMode_None,\n    EditMode_Add,\n    EditMode_Move,\n    EditMode_Delete\n};\n\nclass FCollisionDataEditorToolkit : public FAssetEditorToolkit\n{\npublic:\n    FCollisionDataEditorToolkit();\n    virtual ~FCollisionDataEditorToolkit() override;\n\n    // Move some of these to private\n\n    // Initializes the editor with the asset to be edited\n    void Initialize(UCollisionData* InCollisionData, const EToolkitMode::Type Mode,\n                    const TSharedPtr&lt;IToolkitHost&gt;&amp; InitToolkitHost);\n\n    // FAssetEditorToolkit interface\n    virtual FName GetToolkitFName() const override; // Unique name for this toolkit type\n    virtual FText GetBaseToolkitName() const override; // Display name for the toolkit\n    virtual FText GetToolkitName() const override;\n    virtual FString GetWorldCentricTabPrefix() const override; // Prefix for tabs in world-centric mode\n    virtual FLinearColor GetWorldCentricTabColorScale() const override;\n\n    // Tab management\n    virtual void RegisterTabSpawners(const TSharedRef&lt;FTabManager&gt;&amp; InTabManager) override;\n    virtual void UnregisterTabSpawners(const TSharedRef&lt;FTabManager&gt;&amp; InTabManager) override;\n\n    TSharedRef&lt;SDockTab&gt; SpawnTab_CollisionDataDetails(const FSpawnTabArgs&amp; Args);\n    TSharedRef&lt;SDockTab&gt; SpawnTab_PlayerObjectSelector(const FSpawnTabArgs&amp; Args);\n    TSharedRef&lt;SDockTab&gt; SpawnTab_ViewportTab(const FSpawnTabArgs&amp; Args);\n\n    // Do I need to initialize a scene?\n    void InitializePreviewScene();\n\n    // Accessors\n    // Get current animation name\n    FText GetSelectedState() const;\n\nprivate:\n    TSharedPtr&lt;IDetailsView&gt; DetailsView;\n    TSharedPtr&lt;SClassPropertyEntryBox&gt; PlayerObjectBPPicker;\n\n    TSharedPtr&lt;FCollisionAnimationPreviewScene&gt; PreviewScene;\n    TSharedPtr&lt;SCollisionAnimationViewport&gt; PreviewViewportWidget;\n\n    UCollisionData* CollisionData{};\n    TSharedPtr&lt;SCelAssetTree&gt; CelAssetTree;\n    FGameplayTag SelectedCel;\n    UClass* PlayerObjectClass = nullptr;\n    APlayerObject* PlayerObject{};\n\n    void InitializeCelAssetTree();\n    void OnCelSelected(int32 CelIndex);\n    void OnCollisionFramesChanged();\n\n    void OnPlayerObjectBPSelected(const UClass* Class);\n    void InitializePlayerObjectBPPicker();\n\n    FGameplayTag GetCurrentCelName() const;\n\n    void UpdateAnimationPlayback(int32 frame);\n\nprotected:\n    virtual void OnClose() override;\n};\n</code></pre>"},{"location":"CollisionEditor/_collision_editor_8h/","title":"File CollisionEditor.h","text":"<p>FileList &gt; CollisionEditor &gt; Public &gt; CollisionEditor.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"AssetTypeCategories.h\"</code></li> <li><code>#include \"Modules/ModuleManager.h\"</code></li> </ul>"},{"location":"CollisionEditor/_collision_editor_8h/#classes","title":"Classes","text":"Type Name class FCollisionEditor <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/CollisionEditor/Public/CollisionEditor.h</code></p>"},{"location":"CollisionEditor/_collision_editor_8h_source/","title":"File CollisionEditor.h","text":"<p>File List &gt; CollisionEditor &gt; Public &gt; CollisionEditor.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"AssetTypeCategories.h\"\n#include \"Modules/ModuleManager.h\"\n\n\nclass COLLISIONEDITOR_API FCollisionEditor : public IModuleInterface\n{\npublic:\n\n    void StartupModule() override;\n    void ShutdownModule() override;\n\nprivate:\n    EAssetTypeCategories::Type CollisionAssetCategoryBit;\n\n    void RegisterAssetTools();\n    void RegisterPropertyCustomizations();\n    void UnregisterPropertyCustomizations();\n};\n</code></pre>"},{"location":"CollisionEditor/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p>"},{"location":"CollisionEditor/classes/","title":"Class Index","text":""},{"location":"CollisionEditor/classes/#f","title":"f","text":"<ul> <li>FAssetTypeActions_CollisionData</li> <li>FCelAssetTreeNode</li> <li>FCollisionAnimationPreviewScene</li> <li>FCollisionAnimationViewportClient</li> <li>FCollisionDataDetails</li> <li>FCollisionDataEditorToolkit</li> <li>FCollisionEditor</li> </ul>"},{"location":"CollisionEditor/classes/#s","title":"s","text":"<ul> <li>SCelAssetTree</li> <li>SCollisionAnimationViewport</li> </ul>"},{"location":"CollisionEditor/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class FAssetTypeActions_Base <ul> <li>class FAssetTypeActions_CollisionData </li> </ul> </li> <li>class TSharedFromThis&lt; FCelAssetTreeNode &gt; <ul> <li>class FCelAssetTreeNode </li> </ul> </li> <li>class FAdvancedPreviewScene <ul> <li>class FCollisionAnimationPreviewScene </li> </ul> </li> <li>class FEditorViewportClient <ul> <li>class FCollisionAnimationViewportClient </li> </ul> </li> <li>class IDetailCustomization <ul> <li>class FCollisionDataDetails </li> </ul> </li> <li>class FAssetEditorToolkit <ul> <li>class FCollisionDataEditorToolkit </li> </ul> </li> <li>class IModuleInterface <ul> <li>class FCollisionEditor </li> </ul> </li> <li>class SCompoundWidget <ul> <li>class SCelAssetTree </li> </ul> </li> <li>class SEditorViewport <ul> <li>class SCollisionAnimationViewport </li> </ul> </li> <li>class FGCObject <ul> <li>class SCollisionAnimationViewport </li> </ul> </li> <li>class ICommonEditorViewportToolbarInfoProvider <ul> <li>class SCollisionAnimationViewport </li> </ul> </li> </ul>"},{"location":"CollisionEditor/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"CollisionEditor/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"CollisionEditor/class_members/","title":"Class Members","text":""},{"location":"CollisionEditor/class_members/#a","title":"a","text":"<ul> <li>AssetCategory (FAssetTypeActions_CollisionData)</li> <li>AdvancedPreviewScene (FCollisionAnimationViewportClient)</li> <li>AllNodes (SCelAssetTree)</li> <li>AddReferencedObjects (SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_members/#b","title":"b","text":"<ul> <li>bHasProblem (FCelAssetTreeNode)</li> <li>BuildSelectedCelView (FCollisionDataDetails)</li> <li>BuildTreeFromCollisionData (SCelAssetTree)</li> </ul>"},{"location":"CollisionEditor/class_members/#c","title":"c","text":"<ul> <li>CanFilter (FAssetTypeActions_CollisionData)</li> <li>CelIndex (FCelAssetTreeNode)</li> <li>Children (FCelAssetTreeNode)</li> <li>CurrentCollisionData (FCollisionAnimationPreviewScene)</li> <li>CachedDetailBuilder (FCollisionDataDetails)</li> <li>CanDeleteSelectedCel (FCollisionDataDetails)</li> <li>CanTemplateSelectedCel (FCollisionDataDetails)</li> <li>CollisionDataPtr (FCollisionDataDetails)</li> <li>CollisionFramesHandle (FCollisionDataDetails)</li> <li>CustomizeDetails (FCollisionDataDetails)</li> <li>CelAssetTree (FCollisionDataEditorToolkit)</li> <li>CollisionData (FCollisionDataEditorToolkit, SCelAssetTree)</li> <li>CollisionAssetCategoryBit (FCollisionEditor)</li> <li>CelIndexToNodeMap (SCelAssetTree)</li> <li>Construct (SCelAssetTree, SCollisionAnimationViewport)</li> <li>CurrentFilterString (SCelAssetTree)</li> </ul>"},{"location":"CollisionEditor/class_members/#d","title":"d","text":"<ul> <li>DisplayName (FCelAssetTreeNode)</li> <li>DrawCollisionData (FCollisionAnimationPreviewScene)</li> <li>DetailsView (FCollisionDataEditorToolkit)</li> </ul>"},{"location":"CollisionEditor/class_members/#e","title":"e","text":"<ul> <li>EditorPtr (FCollisionAnimationPreviewScene)</li> <li>EditorToolkit (SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_members/#f","title":"f","text":"<ul> <li>FAssetTypeActions_CollisionData (FAssetTypeActions_CollisionData)</li> <li>FCelAssetTreeNode (FCelAssetTreeNode)</li> <li>FindOrCreateChild (FCelAssetTreeNode)</li> <li>FCollisionAnimationPreviewScene (FCollisionAnimationPreviewScene)</li> <li>FCollisionAnimationViewportClient (FCollisionAnimationViewportClient)</li> <li>FCollisionDataEditorToolkit (FCollisionDataEditorToolkit)</li> </ul>"},{"location":"CollisionEditor/class_members/#g","title":"g","text":"<ul> <li>GetCategories (FAssetTypeActions_CollisionData)</li> <li>GetName (FAssetTypeActions_CollisionData)</li> <li>GetSupportedClass (FAssetTypeActions_CollisionData)</li> <li>GetTypeColor (FAssetTypeActions_CollisionData)</li> <li>GetCelIndex (FCelAssetTreeNode)</li> <li>GetDisplayName (FCelAssetTreeNode)</li> <li>GetBaseToolkitName (FCollisionDataEditorToolkit)</li> <li>GetCurrentCelName (FCollisionDataEditorToolkit)</li> <li>GetSelectedState (FCollisionDataEditorToolkit)</li> <li>GetToolkitFName (FCollisionDataEditorToolkit)</li> <li>GetToolkitName (FCollisionDataEditorToolkit)</li> <li>GetWorldCentricTabColorScale (FCollisionDataEditorToolkit)</li> <li>GetWorldCentricTabPrefix (FCollisionDataEditorToolkit)</li> <li>GenerateTreeRow (SCelAssetTree)</li> <li>GetChildrenForNode (SCelAssetTree)</li> <li>GetExtenders (SCollisionAnimationViewport)</li> <li>GetReferencerName (SCollisionAnimationViewport)</li> <li>GetViewportWidget (SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_members/#i","title":"i","text":"<ul> <li>IsCategory (FCelAssetTreeNode)</li> <li>IsCel (FCelAssetTreeNode)</li> <li>IsValid (FCelAssetTreeNode)</li> <li>Initialize (FCollisionDataEditorToolkit)</li> <li>InitializeCelAssetTree (FCollisionDataEditorToolkit)</li> <li>InitializePlayerObjectBPPicker (FCollisionDataEditorToolkit)</li> <li>InitializePreviewScene (FCollisionDataEditorToolkit)</li> </ul>"},{"location":"CollisionEditor/class_members/#m","title":"m","text":"<ul> <li>MakeInstance (FCollisionDataDetails)</li> <li>MakeEditorViewportClient (SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_members/#o","title":"o","text":"<ul> <li>OpenAssetEditor (FAssetTypeActions_CollisionData)</li> <li>OnAddNewCel (FCollisionDataDetails)</li> <li>OnCelSelected (FCollisionDataDetails, FCollisionDataEditorToolkit)</li> <li>OnDeleteSelectedCel (FCollisionDataDetails)</li> <li>OnRefreshTree (FCollisionDataDetails)</li> <li>OnTemplateSelectedCel (FCollisionDataDetails)</li> <li>OnClose (FCollisionDataEditorToolkit)</li> <li>OnCollisionFramesChanged (FCollisionDataEditorToolkit)</li> <li>OnPlayerObjectBPSelected (FCollisionDataEditorToolkit)</li> <li>OnCelSelectedDelegate (SCelAssetTree)</li> <li>OnFilterTextChanged (SCelAssetTree)</li> <li>OnSelectionChanged (SCelAssetTree)</li> <li>OnFloatingButtonClicked (SCollisionAnimationViewport)</li> <li>OnFocusViewportToSelection (SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_members/#p","title":"p","text":"<ul> <li>Parent (FCelAssetTreeNode)</li> <li>PreviewPlayerObject (FCollisionAnimationPreviewScene)</li> <li>PlayerObject (FCollisionDataEditorToolkit)</li> <li>PlayerObjectBPPicker (FCollisionDataEditorToolkit)</li> <li>PlayerObjectClass (FCollisionDataEditorToolkit)</li> <li>PreviewScene (FCollisionDataEditorToolkit, SCollisionAnimationViewport)</li> <li>PreviewViewportWidget (FCollisionDataEditorToolkit)</li> </ul>"},{"location":"CollisionEditor/class_members/#r","title":"r","text":"<ul> <li>RegisterTabSpawners (FCollisionDataEditorToolkit)</li> <li>RegisterAssetTools (FCollisionEditor)</li> <li>RegisterPropertyCustomizations (FCollisionEditor)</li> <li>RefreshTree (SCelAssetTree)</li> <li>RootNodes (SCelAssetTree)</li> </ul>"},{"location":"CollisionEditor/class_members/#s","title":"s","text":"<ul> <li>SetCelIndex (FCelAssetTreeNode)</li> <li>SetPlayerObject (FCollisionAnimationPreviewScene)</li> <li>SetupScene (FCollisionAnimationPreviewScene)</li> <li>SelectedCelName (FCollisionDataDetails)</li> <li>SelectedCel (FCollisionDataEditorToolkit)</li> <li>SpawnTab_CollisionDataDetails (FCollisionDataEditorToolkit)</li> <li>SpawnTab_PlayerObjectSelector (FCollisionDataEditorToolkit)</li> <li>SpawnTab_ViewportTab (FCollisionDataEditorToolkit)</li> <li>ShutdownModule (FCollisionEditor)</li> <li>StartupModule (FCollisionEditor)</li> <li>SLATE_BEGIN_ARGS (SCelAssetTree, SCollisionAnimationViewport)</li> <li>SetSelectedCel (SCelAssetTree)</li> </ul>"},{"location":"CollisionEditor/class_members/#t","title":"t","text":"<ul> <li>Tick (FCollisionAnimationPreviewScene, FCollisionAnimationViewportClient)</li> <li>TreeView (SCelAssetTree)</li> </ul>"},{"location":"CollisionEditor/class_members/#u","title":"u","text":"<ul> <li>UpdateCollisionView (FCollisionAnimationPreviewScene)</li> <li>UpdateMeshAndAnimation (FCollisionAnimationPreviewScene)</li> <li>UnregisterTabSpawners (FCollisionDataEditorToolkit)</li> <li>UpdateAnimationPlayback (FCollisionDataEditorToolkit)</li> <li>UnregisterPropertyCustomizations (FCollisionEditor)</li> </ul>"},{"location":"CollisionEditor/class_members/#v","title":"v","text":"<ul> <li>ViewportClient (SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_members/#_1","title":"~","text":"<ul> <li>~FCollisionAnimationPreviewScene (FCollisionAnimationPreviewScene)</li> <li>~FCollisionAnimationViewportClient (FCollisionAnimationViewportClient)</li> <li>~FCollisionDataEditorToolkit (FCollisionDataEditorToolkit)</li> <li>~SCollisionAnimationViewport (SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_member_functions/","title":"Class Member Functions","text":""},{"location":"CollisionEditor/class_member_functions/#a","title":"a","text":"<ul> <li>AddReferencedObjects (SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_member_functions/#b","title":"b","text":"<ul> <li>BuildSelectedCelView (FCollisionDataDetails)</li> <li>BuildTreeFromCollisionData (SCelAssetTree)</li> </ul>"},{"location":"CollisionEditor/class_member_functions/#c","title":"c","text":"<ul> <li>CanFilter (FAssetTypeActions_CollisionData)</li> <li>CanDeleteSelectedCel (FCollisionDataDetails)</li> <li>CanTemplateSelectedCel (FCollisionDataDetails)</li> <li>CustomizeDetails (FCollisionDataDetails)</li> <li>Construct (SCelAssetTree, SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_member_functions/#d","title":"d","text":"<ul> <li>DrawCollisionData (FCollisionAnimationPreviewScene)</li> </ul>"},{"location":"CollisionEditor/class_member_functions/#f","title":"f","text":"<ul> <li>FAssetTypeActions_CollisionData (FAssetTypeActions_CollisionData)</li> <li>FCelAssetTreeNode (FCelAssetTreeNode)</li> <li>FindOrCreateChild (FCelAssetTreeNode)</li> <li>FCollisionAnimationPreviewScene (FCollisionAnimationPreviewScene)</li> <li>FCollisionAnimationViewportClient (FCollisionAnimationViewportClient)</li> <li>FCollisionDataEditorToolkit (FCollisionDataEditorToolkit)</li> </ul>"},{"location":"CollisionEditor/class_member_functions/#g","title":"g","text":"<ul> <li>GetCategories (FAssetTypeActions_CollisionData)</li> <li>GetName (FAssetTypeActions_CollisionData)</li> <li>GetSupportedClass (FAssetTypeActions_CollisionData)</li> <li>GetTypeColor (FAssetTypeActions_CollisionData)</li> <li>GetCelIndex (FCelAssetTreeNode)</li> <li>GetDisplayName (FCelAssetTreeNode)</li> <li>GetBaseToolkitName (FCollisionDataEditorToolkit)</li> <li>GetCurrentCelName (FCollisionDataEditorToolkit)</li> <li>GetSelectedState (FCollisionDataEditorToolkit)</li> <li>GetToolkitFName (FCollisionDataEditorToolkit)</li> <li>GetToolkitName (FCollisionDataEditorToolkit)</li> <li>GetWorldCentricTabColorScale (FCollisionDataEditorToolkit)</li> <li>GetWorldCentricTabPrefix (FCollisionDataEditorToolkit)</li> <li>GenerateTreeRow (SCelAssetTree)</li> <li>GetChildrenForNode (SCelAssetTree)</li> <li>GetExtenders (SCollisionAnimationViewport)</li> <li>GetReferencerName (SCollisionAnimationViewport)</li> <li>GetViewportWidget (SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_member_functions/#i","title":"i","text":"<ul> <li>IsCategory (FCelAssetTreeNode)</li> <li>IsCel (FCelAssetTreeNode)</li> <li>IsValid (FCelAssetTreeNode)</li> <li>Initialize (FCollisionDataEditorToolkit)</li> <li>InitializeCelAssetTree (FCollisionDataEditorToolkit)</li> <li>InitializePlayerObjectBPPicker (FCollisionDataEditorToolkit)</li> <li>InitializePreviewScene (FCollisionDataEditorToolkit)</li> </ul>"},{"location":"CollisionEditor/class_member_functions/#m","title":"m","text":"<ul> <li>MakeInstance (FCollisionDataDetails)</li> <li>MakeEditorViewportClient (SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_member_functions/#o","title":"o","text":"<ul> <li>OpenAssetEditor (FAssetTypeActions_CollisionData)</li> <li>OnAddNewCel (FCollisionDataDetails)</li> <li>OnCelSelected (FCollisionDataDetails, FCollisionDataEditorToolkit)</li> <li>OnDeleteSelectedCel (FCollisionDataDetails)</li> <li>OnRefreshTree (FCollisionDataDetails)</li> <li>OnTemplateSelectedCel (FCollisionDataDetails)</li> <li>OnClose (FCollisionDataEditorToolkit)</li> <li>OnCollisionFramesChanged (FCollisionDataEditorToolkit)</li> <li>OnPlayerObjectBPSelected (FCollisionDataEditorToolkit)</li> <li>OnFilterTextChanged (SCelAssetTree)</li> <li>OnSelectionChanged (SCelAssetTree)</li> <li>OnFloatingButtonClicked (SCollisionAnimationViewport)</li> <li>OnFocusViewportToSelection (SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_member_functions/#r","title":"r","text":"<ul> <li>RegisterTabSpawners (FCollisionDataEditorToolkit)</li> <li>RegisterAssetTools (FCollisionEditor)</li> <li>RegisterPropertyCustomizations (FCollisionEditor)</li> <li>RefreshTree (SCelAssetTree)</li> </ul>"},{"location":"CollisionEditor/class_member_functions/#s","title":"s","text":"<ul> <li>SetCelIndex (FCelAssetTreeNode)</li> <li>SetPlayerObject (FCollisionAnimationPreviewScene)</li> <li>SetupScene (FCollisionAnimationPreviewScene)</li> <li>SpawnTab_CollisionDataDetails (FCollisionDataEditorToolkit)</li> <li>SpawnTab_PlayerObjectSelector (FCollisionDataEditorToolkit)</li> <li>SpawnTab_ViewportTab (FCollisionDataEditorToolkit)</li> <li>ShutdownModule (FCollisionEditor)</li> <li>StartupModule (FCollisionEditor)</li> <li>SLATE_BEGIN_ARGS (SCelAssetTree, SCollisionAnimationViewport)</li> <li>SetSelectedCel (SCelAssetTree)</li> </ul>"},{"location":"CollisionEditor/class_member_functions/#t","title":"t","text":"<ul> <li>Tick (FCollisionAnimationPreviewScene, FCollisionAnimationViewportClient)</li> </ul>"},{"location":"CollisionEditor/class_member_functions/#u","title":"u","text":"<ul> <li>UpdateCollisionView (FCollisionAnimationPreviewScene)</li> <li>UpdateMeshAndAnimation (FCollisionAnimationPreviewScene)</li> <li>UnregisterTabSpawners (FCollisionDataEditorToolkit)</li> <li>UpdateAnimationPlayback (FCollisionDataEditorToolkit)</li> <li>UnregisterPropertyCustomizations (FCollisionEditor)</li> </ul>"},{"location":"CollisionEditor/class_member_functions/#_1","title":"~","text":"<ul> <li>~FCollisionAnimationPreviewScene (FCollisionAnimationPreviewScene)</li> <li>~FCollisionAnimationViewportClient (FCollisionAnimationViewportClient)</li> <li>~FCollisionDataEditorToolkit (FCollisionDataEditorToolkit)</li> <li>~SCollisionAnimationViewport (SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_member_variables/","title":"Class Member Variables","text":""},{"location":"CollisionEditor/class_member_variables/#a","title":"a","text":"<ul> <li>AssetCategory (FAssetTypeActions_CollisionData)</li> <li>AdvancedPreviewScene (FCollisionAnimationViewportClient)</li> <li>AllNodes (SCelAssetTree)</li> </ul>"},{"location":"CollisionEditor/class_member_variables/#b","title":"b","text":"<ul> <li>bHasProblem (FCelAssetTreeNode)</li> </ul>"},{"location":"CollisionEditor/class_member_variables/#c","title":"c","text":"<ul> <li>CelIndex (FCelAssetTreeNode)</li> <li>Children (FCelAssetTreeNode)</li> <li>CurrentCollisionData (FCollisionAnimationPreviewScene)</li> <li>CachedDetailBuilder (FCollisionDataDetails)</li> <li>CollisionDataPtr (FCollisionDataDetails)</li> <li>CollisionFramesHandle (FCollisionDataDetails)</li> <li>CelAssetTree (FCollisionDataEditorToolkit)</li> <li>CollisionData (FCollisionDataEditorToolkit, SCelAssetTree)</li> <li>CollisionAssetCategoryBit (FCollisionEditor)</li> <li>CelIndexToNodeMap (SCelAssetTree)</li> <li>CurrentFilterString (SCelAssetTree)</li> </ul>"},{"location":"CollisionEditor/class_member_variables/#d","title":"d","text":"<ul> <li>DisplayName (FCelAssetTreeNode)</li> <li>DetailsView (FCollisionDataEditorToolkit)</li> </ul>"},{"location":"CollisionEditor/class_member_variables/#e","title":"e","text":"<ul> <li>EditorPtr (FCollisionAnimationPreviewScene)</li> <li>EditorToolkit (SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_member_variables/#o","title":"o","text":"<ul> <li>OnCelSelectedDelegate (SCelAssetTree)</li> </ul>"},{"location":"CollisionEditor/class_member_variables/#p","title":"p","text":"<ul> <li>Parent (FCelAssetTreeNode)</li> <li>PreviewPlayerObject (FCollisionAnimationPreviewScene)</li> <li>PlayerObject (FCollisionDataEditorToolkit)</li> <li>PlayerObjectBPPicker (FCollisionDataEditorToolkit)</li> <li>PlayerObjectClass (FCollisionDataEditorToolkit)</li> <li>PreviewScene (FCollisionDataEditorToolkit, SCollisionAnimationViewport)</li> <li>PreviewViewportWidget (FCollisionDataEditorToolkit)</li> </ul>"},{"location":"CollisionEditor/class_member_variables/#r","title":"r","text":"<ul> <li>RootNodes (SCelAssetTree)</li> </ul>"},{"location":"CollisionEditor/class_member_variables/#s","title":"s","text":"<ul> <li>SelectedCelName (FCollisionDataDetails)</li> <li>SelectedCel (FCollisionDataEditorToolkit)</li> </ul>"},{"location":"CollisionEditor/class_member_variables/#t","title":"t","text":"<ul> <li>TreeView (SCelAssetTree)</li> </ul>"},{"location":"CollisionEditor/class_member_variables/#v","title":"v","text":"<ul> <li>ViewportClient (SCollisionAnimationViewport)</li> </ul>"},{"location":"CollisionEditor/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"CollisionEditor/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"CollisionEditor/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"CollisionEditor/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"CollisionEditor/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"CollisionEditor/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"CollisionEditor/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"CollisionEditor/functions/","title":"Functions","text":""},{"location":"CollisionEditor/functions/#d","title":"d","text":"<ul> <li>DEFINE_LOG_CATEGORY (Logging.cpp)</li> <li>DECLARE_LOG_CATEGORY_EXTERN (Logging.h)</li> <li>DECLARE_DELEGATE_OneParam (CelAssetTree.h)</li> </ul>"},{"location":"CollisionEditor/functions/#i","title":"i","text":"<ul> <li>IMPLEMENT_MODULE (CollisionEditor.cpp)</li> </ul>"},{"location":"CollisionEditor/macros/","title":"Macros","text":""},{"location":"CollisionEditor/macros/#l","title":"l","text":"<ul> <li>LOCTEXT_NAMESPACE (AssetTypeActions_CollisionData.cpp, CollisionAnimationViewport.cpp, CollisionDataDetails.cpp, CollisionDataEditorToolkit.cpp, CollisionEditor.cpp)</li> </ul>"},{"location":"CollisionEditor/variables/","title":"Variables","text":""},{"location":"CollisionEditor/variables/#e","title":"e","text":"<ul> <li>EBoxEditMode (CollisionDataEditorToolkit.h)</li> <li>ESceneInteractionMode (CollisionDataEditorToolkit.h)</li> </ul>"},{"location":"CollisionEditor/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"GGPOUE4/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class ConnectionInfo </li> <li>class ConnectionManager </li> <li>struct FGGPONetworkInfo </li> <li>struct FGGPONetworkStats </li> <li>struct FGGPOSyncInfo </li> <li>class FGGPOUE4Module </li> <li>struct GGPOEvent </li> <li>struct GGPOLocalEndpoint </li> <li>class GGPONet </li> <li>struct GGPOPlayer </li> <li>struct GGPOSession </li> <li>struct GGPOSessionCallbacks </li> <li>struct GameInput </li> <li>class IPollSink </li> <li>class InputQueue </li> <li>class Peer2PeerBackend </li> <li>class Poll <ul> <li>struct PollPeriodicSinkCb </li> <li>struct PollSinkCb </li> </ul> </li> <li>class RingBuffer </li> <li>class SpectatorBackend </li> <li>class StaticBuffer </li> <li>class Sync <ul> <li>struct Config </li> <li>struct Event </li> <li>struct SavedFrame </li> <li>struct SavedState </li> </ul> </li> <li>class SyncTestBackend <ul> <li>struct SavedInfo </li> </ul> </li> <li>class TimeSync </li> <li>class UGGPOGameInstance </li> <li>class UGGPONetwork </li> <li>class UGGPONetworkAddress </li> <li>class Udp <ul> <li>struct Callbacks </li> <li>struct Stats </li> </ul> </li> <li>struct UdpMsg <ul> <li>struct connect_status </li> </ul> </li> <li>class UdpProtocol <ul> <li>struct Event </li> <li>struct QueueEntry </li> <li>struct Stats </li> </ul> </li> <li>struct internal_state </li> <li>namespace neosmart <ul> <li>struct neosmart_event_t_ </li> <li>struct neosmart_wfmo_info_t_ </li> <li>struct neosmart_wfmo_t_ </li> </ul> </li> <li>struct z_stream_s </li> </ul>"},{"location":"GGPOUE4/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir Plugins <ul> <li>dir NightSkyEngine <ul> <li>dir Source <ul> <li>dir GGPOUE4 <ul> <li>dir Private <ul> <li>dir backends <ul> <li>file backend.h </li> <li>file p2p.cpp </li> <li>file p2p.h </li> <li>file spectator.cpp </li> <li>file spectator.h </li> <li>file synctest.cpp </li> <li>file synctest.h </li> </ul> </li> <li>dir include <ul> <li>file connection_manager.cpp </li> </ul> </li> <li>dir network <ul> <li>file udp.cpp </li> <li>file udp.h </li> <li>file udp_msg.h </li> <li>file udp_proto.cpp </li> <li>file udp_proto.h </li> </ul> </li> <li>file GGPOGameInstance.cpp </li> <li>file GGPOUE4.cpp </li> <li>file bitvector.cpp </li> <li>file bitvector.h </li> <li>file game_input.cpp </li> <li>file game_input.h </li> <li>file input_queue.cpp </li> <li>file input_queue.h </li> <li>file log.cpp </li> <li>file log.h </li> <li>file main.cpp </li> <li>file pevents.cpp </li> <li>file pevents.h </li> <li>file platform_unix.cpp </li> <li>file platform_unix.h </li> <li>file platform_windows.cpp </li> <li>file platform_windows.h </li> <li>file poll.cpp </li> <li>file poll.h </li> <li>file ring_buffer.h </li> <li>file static_buffer.h </li> <li>file sync.cpp </li> <li>file sync.h </li> <li>file timesync.cpp </li> <li>file timesync.h </li> <li>file types.h </li> <li>file zconf.h </li> <li>file zlib.h </li> </ul> </li> <li>dir Public <ul> <li>dir include <ul> <li>file connection_manager.h </li> <li>file ggponet.cpp </li> <li>file ggponet.h </li> </ul> </li> <li>file GGPOGameInstance.h </li> <li>file GGPOUE4.h </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"GGPOUE4/class_connection_info/","title":"Class ConnectionInfo","text":"<p>ClassList &gt; ConnectionInfo</p> <p>More...</p> <ul> <li><code>#include &lt;connection_manager.h&gt;</code></li> </ul>"},{"location":"GGPOUE4/class_connection_info/#public-functions","title":"Public Functions","text":"Type Name ConnectionInfo ()  virtual std::string ToString () = 0 virtual ~ConnectionInfo ()"},{"location":"GGPOUE4/class_connection_info/#detailed-description","title":"Detailed Description","text":"<p>ConnectionInfo is an abstract base class for defining connections.</p> <p>Derived classes from this class must provide a ToString function that provides a useful string for logging purposes about the details of the given connection. </p>"},{"location":"GGPOUE4/class_connection_info/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_connection_info/#function-connectioninfo","title":"function ConnectionInfo","text":"<pre><code>inline ConnectionInfo::ConnectionInfo () \n</code></pre>"},{"location":"GGPOUE4/class_connection_info/#function-tostring","title":"function ToString","text":"<pre><code>virtual std::string ConnectionInfo::ToString () = 0\n</code></pre>"},{"location":"GGPOUE4/class_connection_info/#function-connectioninfo_1","title":"function ~ConnectionInfo","text":"<pre><code>inline virtual ConnectionInfo::~ConnectionInfo () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/connection_manager.h</code></p>"},{"location":"GGPOUE4/class_connection_manager/","title":"Class ConnectionManager","text":"<p>ClassList &gt; ConnectionManager</p> <p>More...</p> <ul> <li><code>#include &lt;connection_manager.h&gt;</code></li> </ul>"},{"location":"GGPOUE4/class_connection_manager/#public-functions","title":"Public Functions","text":"Type Name ConnectionManager ()  void Log (const char * fmt, ...)  virtual int RecvFrom (char * buffer, int len, int flags, int * connection_id) = 0 virtual int ResetManager ()  virtual int SendTo (const char * buffer, int len, int flags, int connection_id) = 0 virtual std::string ToString (int connection_id)  virtual ~ConnectionManager ()"},{"location":"GGPOUE4/class_connection_manager/#protected-attributes","title":"Protected Attributes","text":"Type Name std::map&lt; int, std::shared_ptr&lt; ConnectionInfo &gt; &gt; _connection_map A map of connection IDs and smart pointers to their respective info objects. int _id_to_issue The current ID value to be issued to the next connection added."},{"location":"GGPOUE4/class_connection_manager/#protected-functions","title":"Protected Functions","text":"Type Name int AddConnection (std::shared_ptr&lt; ConnectionInfo &gt; info)"},{"location":"GGPOUE4/class_connection_manager/#detailed-description","title":"Detailed Description","text":"<p>Abstract class to define a connection manager interface</p> <p>This is a class whos purpose is to provide an abstraction from underlying network system calls. It must provide a non-blocking upd style send recv interface. When adding a connection it should return a unique int ID for the connection to be referred to by in future interactions with the manager. </p>"},{"location":"GGPOUE4/class_connection_manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_connection_manager/#function-connectionmanager","title":"function ConnectionManager","text":"<pre><code>inline ConnectionManager::ConnectionManager () \n</code></pre>"},{"location":"GGPOUE4/class_connection_manager/#function-log","title":"function Log","text":"<pre><code>void ConnectionManager::Log (\n    const char * fmt,\n    ...\n) \n</code></pre>"},{"location":"GGPOUE4/class_connection_manager/#function-recvfrom","title":"function RecvFrom","text":"<pre><code>virtual int ConnectionManager::RecvFrom (\n    char * buffer,\n    int len,\n    int flags,\n    int * connection_id\n) = 0\n</code></pre> <p>RecvFrom is a recvfrom upd style interface</p> <p>This function is expected to function similar to a standard upd socket style recvfrom. Return values are as follows: greater than 0 values indicate data length. 0 indicates a disconnect. -1 indicates no data or some other error. </p>"},{"location":"GGPOUE4/class_connection_manager/#function-resetmanager","title":"function ResetManager","text":"<pre><code>inline virtual int ConnectionManager::ResetManager () \n</code></pre> <p>ResetManager is a reset function to clear the connection_map</p> <p>This should be called if there is a need to clear all existing connections without creating a new connection manager. </p>"},{"location":"GGPOUE4/class_connection_manager/#function-sendto","title":"function SendTo","text":"<pre><code>virtual int ConnectionManager::SendTo (\n    const char * buffer,\n    int len,\n    int flags,\n    int connection_id\n) = 0\n</code></pre> <p>SendTo is a sendto upd style interface</p> <p>This function is expected to function similar to a standard upd socket style send. </p>"},{"location":"GGPOUE4/class_connection_manager/#function-tostring","title":"function ToString","text":"<pre><code>virtual std::string ConnectionManager::ToString (\n    int connection_id\n) \n</code></pre> <p>ToString converts relevant information to a string</p> <p>This function should convert relevant information from the connection info object identified by connection_id to a string. The default implementation should be valid for most use cases. Overload the ToString function in the derived ConnectionInfo definition. </p>"},{"location":"GGPOUE4/class_connection_manager/#function-connectionmanager_1","title":"function ~ConnectionManager","text":"<pre><code>virtual ConnectionManager::~ConnectionManager () \n</code></pre>"},{"location":"GGPOUE4/class_connection_manager/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"GGPOUE4/class_connection_manager/#variable-_connection_map","title":"variable _connection_map","text":"<p>A map of connection IDs and smart pointers to their respective info objects. <pre><code>std::map&lt;int, std::shared_ptr&lt;ConnectionInfo&gt; &gt; ConnectionManager::_connection_map;\n</code></pre></p>"},{"location":"GGPOUE4/class_connection_manager/#variable-_id_to_issue","title":"variable _id_to_issue","text":"<p>The current ID value to be issued to the next connection added. <pre><code>int ConnectionManager::_id_to_issue;\n</code></pre></p>"},{"location":"GGPOUE4/class_connection_manager/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"GGPOUE4/class_connection_manager/#function-addconnection","title":"function AddConnection","text":"<pre><code>inline int ConnectionManager::AddConnection (\n    std::shared_ptr&lt; ConnectionInfo &gt; info\n) \n</code></pre> <p>AddConnection adds a connection to the manager and returns the ID.</p> <p>This function takes in a ConnectionInfo smartpointer to an object that implicitly must be a defined type that inheriteds from ConnectionInfo. Derived ConnectionManagers should define their own AddConnection functions with args that provide the relevant information for the specific connection desired. This function should then be called to add a derived ConnectionInfo object to the _connection_map and it will return the connection id. Having monotonically increasing IDs is fine for this use case. It is up to the user to correctly manage IDs to ensure they are only used with the ConnectionManager that issued them as the same IDs will likely be valid in multiple ConnectionManagers on the same process. </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/connection_manager.h</code></p>"},{"location":"GGPOUE4/struct_f_g_g_p_o_network_info/","title":"Struct FGGPONetworkInfo","text":"<p>ClassList &gt; FGGPONetworkInfo</p>"},{"location":"GGPOUE4/struct_f_g_g_p_o_network_info/#public-attributes","title":"Public Attributes","text":"Type Name int32 kbps_sent int32 ping int32 recv_queue_len int32 send_queue_len"},{"location":"GGPOUE4/struct_f_g_g_p_o_network_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_f_g_g_p_o_network_info/#variable-kbps_sent","title":"variable kbps_sent","text":"<pre><code>int32 FGGPONetworkInfo::kbps_sent;\n</code></pre>"},{"location":"GGPOUE4/struct_f_g_g_p_o_network_info/#variable-ping","title":"variable ping","text":"<pre><code>int32 FGGPONetworkInfo::ping;\n</code></pre>"},{"location":"GGPOUE4/struct_f_g_g_p_o_network_info/#variable-recv_queue_len","title":"variable recv_queue_len","text":"<pre><code>int32 FGGPONetworkInfo::recv_queue_len;\n</code></pre>"},{"location":"GGPOUE4/struct_f_g_g_p_o_network_info/#variable-send_queue_len","title":"variable send_queue_len","text":"<pre><code>int32 FGGPONetworkInfo::send_queue_len;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/ggponet.h</code></p>"},{"location":"GGPOUE4/struct_f_g_g_p_o_network_stats/","title":"Struct FGGPONetworkStats","text":"<p>ClassList &gt; FGGPONetworkStats</p>"},{"location":"GGPOUE4/struct_f_g_g_p_o_network_stats/#public-attributes","title":"Public Attributes","text":"Type Name FGGPONetworkInfo network FGGPOSyncInfo timesync"},{"location":"GGPOUE4/struct_f_g_g_p_o_network_stats/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_f_g_g_p_o_network_stats/#variable-network","title":"variable network","text":"<pre><code>FGGPONetworkInfo FGGPONetworkStats::network;\n</code></pre>"},{"location":"GGPOUE4/struct_f_g_g_p_o_network_stats/#variable-timesync","title":"variable timesync","text":"<pre><code>FGGPOSyncInfo FGGPONetworkStats::timesync;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/ggponet.h</code></p>"},{"location":"GGPOUE4/struct_f_g_g_p_o_sync_info/","title":"Struct FGGPOSyncInfo","text":"<p>ClassList &gt; FGGPOSyncInfo</p>"},{"location":"GGPOUE4/struct_f_g_g_p_o_sync_info/#public-attributes","title":"Public Attributes","text":"Type Name int32 local_frames_behind int32 remote_frames_behind"},{"location":"GGPOUE4/struct_f_g_g_p_o_sync_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_f_g_g_p_o_sync_info/#variable-local_frames_behind","title":"variable local_frames_behind","text":"<pre><code>int32 FGGPOSyncInfo::local_frames_behind;\n</code></pre>"},{"location":"GGPOUE4/struct_f_g_g_p_o_sync_info/#variable-remote_frames_behind","title":"variable remote_frames_behind","text":"<pre><code>int32 FGGPOSyncInfo::remote_frames_behind;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/ggponet.h</code></p>"},{"location":"GGPOUE4/class_f_g_g_p_o_u_e4_module/","title":"Class FGGPOUE4Module","text":"<p>ClassList &gt; FGGPOUE4Module</p> <p>Inherits the following classes: IModuleInterface</p>"},{"location":"GGPOUE4/class_f_g_g_p_o_u_e4_module/#public-functions","title":"Public Functions","text":"Type Name virtual void ShutdownModule () override virtual void StartupModule () override"},{"location":"GGPOUE4/class_f_g_g_p_o_u_e4_module/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_f_g_g_p_o_u_e4_module/#function-shutdownmodule","title":"function ShutdownModule","text":"<pre><code>virtual void FGGPOUE4Module::ShutdownModule () override\n</code></pre>"},{"location":"GGPOUE4/class_f_g_g_p_o_u_e4_module/#function-startupmodule","title":"function StartupModule","text":"<pre><code>virtual void FGGPOUE4Module::StartupModule () override\n</code></pre> <p>IModuleInterface implementation </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/GGPOUE4.h</code></p>"},{"location":"GGPOUE4/struct_g_g_p_o_event/","title":"Struct GGPOEvent","text":"<p>ClassList &gt; GGPOEvent</p>"},{"location":"GGPOUE4/struct_g_g_p_o_event/#public-attributes","title":"Public Attributes","text":"Type Name GGPOEventCode code struct GGPOEvent connected struct GGPOEvent connection_interrupted struct GGPOEvent connection_resumed int count int disconnect_timeout struct GGPOEvent disconnected int frames_ahead GGPOPlayerHandle player struct GGPOEvent synchronized struct GGPOEvent synchronizing struct GGPOEvent timesync int total union GGPOEvent u"},{"location":"GGPOUE4/struct_g_g_p_o_event/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_g_g_p_o_event/#variable-code","title":"variable code","text":"<pre><code>GGPOEventCode GGPOEvent::code;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_event/#variable-connected","title":"variable connected","text":"<pre><code>struct GGPOEvent GGPOEvent::connected;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_event/#variable-connection_interrupted","title":"variable connection_interrupted","text":"<pre><code>struct GGPOEvent GGPOEvent::connection_interrupted;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_event/#variable-connection_resumed","title":"variable connection_resumed","text":"<pre><code>struct GGPOEvent GGPOEvent::connection_resumed;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_event/#variable-count","title":"variable count","text":"<pre><code>int GGPOEvent::count;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_event/#variable-disconnect_timeout","title":"variable disconnect_timeout","text":"<pre><code>int GGPOEvent::disconnect_timeout;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_event/#variable-disconnected","title":"variable disconnected","text":"<pre><code>struct GGPOEvent GGPOEvent::disconnected;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_event/#variable-frames_ahead","title":"variable frames_ahead","text":"<pre><code>int GGPOEvent::frames_ahead;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_event/#variable-player","title":"variable player","text":"<pre><code>GGPOPlayerHandle GGPOEvent::player;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_event/#variable-synchronized","title":"variable synchronized","text":"<pre><code>struct GGPOEvent GGPOEvent::synchronized;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_event/#variable-synchronizing","title":"variable synchronizing","text":"<pre><code>struct GGPOEvent GGPOEvent::synchronizing;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_event/#variable-timesync","title":"variable timesync","text":"<pre><code>struct GGPOEvent GGPOEvent::timesync;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_event/#variable-total","title":"variable total","text":"<pre><code>int GGPOEvent::total;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_event/#variable-u","title":"variable u","text":"<pre><code>union GGPOEvent GGPOEvent::u;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/ggponet.h</code></p>"},{"location":"GGPOUE4/struct_g_g_p_o_local_endpoint/","title":"Struct GGPOLocalEndpoint","text":"<p>ClassList &gt; GGPOLocalEndpoint</p>"},{"location":"GGPOUE4/struct_g_g_p_o_local_endpoint/#public-attributes","title":"Public Attributes","text":"Type Name int player_num"},{"location":"GGPOUE4/struct_g_g_p_o_local_endpoint/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_g_g_p_o_local_endpoint/#variable-player_num","title":"variable player_num","text":"<pre><code>int GGPOLocalEndpoint::player_num;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/ggponet.h</code></p>"},{"location":"GGPOUE4/class_g_g_p_o_net/","title":"Class GGPONet","text":"<p>ClassList &gt; GGPONet</p>"},{"location":"GGPOUE4/class_g_g_p_o_net/#public-static-functions","title":"Public Static Functions","text":"Type Name GGPO_API GGPOErrorCode __cdecl ggpo_add_local_input (GGPOSession * ggpo, GGPOPlayerHandle player, void * values, int size)  GGPO_API GGPOErrorCode __cdecl ggpo_add_player (GGPOSession * session, GGPOPlayer * player, GGPOPlayerHandle * handle)  GGPO_API GGPOErrorCode __cdecl ggpo_advance_frame (GGPOSession * ggpo)  GGPO_API GGPOErrorCode __cdecl ggpo_close_session (GGPOSession * ggpo)  GGPO_API GGPOErrorCode __cdecl ggpo_disconnect_player (GGPOSession * ggpo, GGPOPlayerHandle player)  GGPO_API GGPOErrorCode __cdecl ggpo_get_network_stats (GGPOSession * ggpo, GGPOPlayerHandle player, FGGPONetworkStats * stats)  GGPO_API GGPOErrorCode __cdecl ggpo_idle (GGPOSession * ggpo, int timeout)  GGPO_API GGPOErrorCode __cdecl ggpo_set_disconnect_notify_start (GGPOSession * ggpo, int timeout)  GGPO_API GGPOErrorCode __cdecl ggpo_set_disconnect_timeout (GGPOSession * ggpo, int timeout)  GGPO_API GGPOErrorCode __cdecl ggpo_set_frame_delay (GGPOSession * ggpo, GGPOPlayerHandle player, int frame_delay)  GGPO_API GGPOErrorCode __cdecl ggpo_start_session (GGPOSession ** session, GGPOSessionCallbacks * cb, ConnectionManager * connection_manager, const char * game, int num_players, int input_size)  GGPO_API GGPOErrorCode __cdecl ggpo_start_spectating (GGPOSession ** session, GGPOSessionCallbacks * cb, ConnectionManager * connection_manager, const char * game, int num_players, int input_size, int connection_id)  GGPO_API GGPOErrorCode __cdecl ggpo_start_synctest (GGPOSession ** session, GGPOSessionCallbacks * cb, const char * game, int num_players, int input_size, int frames)  GGPO_API GGPOErrorCode __cdecl ggpo_synchronize_input (GGPOSession * ggpo, void * values, int size, int * disconnect_flags)  GGPO_API GGPOErrorCode __cdecl ggpo_try_synchronize_local (GGPOSession * ggpo)"},{"location":"GGPOUE4/class_g_g_p_o_net/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_add_local_input","title":"function ggpo_add_local_input","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_add_local_input (\n    GGPOSession * ggpo,\n    GGPOPlayerHandle player,\n    void * values,\n    int size\n) \n</code></pre>"},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_add_player","title":"function ggpo_add_player","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_add_player (\n    GGPOSession * session,\n    GGPOPlayer * player,\n    GGPOPlayerHandle * handle\n) \n</code></pre>"},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_advance_frame","title":"function ggpo_advance_frame","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_advance_frame (\n    GGPOSession * ggpo\n) \n</code></pre>"},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_close_session","title":"function ggpo_close_session","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_close_session (\n    GGPOSession * ggpo\n) \n</code></pre>"},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_disconnect_player","title":"function ggpo_disconnect_player","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_disconnect_player (\n    GGPOSession * ggpo,\n    GGPOPlayerHandle player\n) \n</code></pre>"},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_get_network_stats","title":"function ggpo_get_network_stats","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_get_network_stats (\n    GGPOSession * ggpo,\n    GGPOPlayerHandle player,\n    FGGPONetworkStats * stats\n) \n</code></pre>"},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_idle","title":"function ggpo_idle","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_idle (\n    GGPOSession * ggpo,\n    int timeout\n) \n</code></pre>"},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_set_disconnect_notify_start","title":"function ggpo_set_disconnect_notify_start","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_set_disconnect_notify_start (\n    GGPOSession * ggpo,\n    int timeout\n) \n</code></pre>"},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_set_disconnect_timeout","title":"function ggpo_set_disconnect_timeout","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_set_disconnect_timeout (\n    GGPOSession * ggpo,\n    int timeout\n) \n</code></pre>"},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_set_frame_delay","title":"function ggpo_set_frame_delay","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_set_frame_delay (\n    GGPOSession * ggpo,\n    GGPOPlayerHandle player,\n    int frame_delay\n) \n</code></pre>"},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_start_session","title":"function ggpo_start_session","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_start_session (\n    GGPOSession ** session,\n    GGPOSessionCallbacks * cb,\n    ConnectionManager * connection_manager,\n    const char * game,\n    int num_players,\n    int input_size\n) \n</code></pre>"},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_start_spectating","title":"function ggpo_start_spectating","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_start_spectating (\n    GGPOSession ** session,\n    GGPOSessionCallbacks * cb,\n    ConnectionManager * connection_manager,\n    const char * game,\n    int num_players,\n    int input_size,\n    int connection_id\n) \n</code></pre>"},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_start_synctest","title":"function ggpo_start_synctest","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_start_synctest (\n    GGPOSession ** session,\n    GGPOSessionCallbacks * cb,\n    const char * game,\n    int num_players,\n    int input_size,\n    int frames\n) \n</code></pre>"},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_synchronize_input","title":"function ggpo_synchronize_input","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_synchronize_input (\n    GGPOSession * ggpo,\n    void * values,\n    int size,\n    int * disconnect_flags\n) \n</code></pre>"},{"location":"GGPOUE4/class_g_g_p_o_net/#function-ggpo_try_synchronize_local","title":"function ggpo_try_synchronize_local","text":"<pre><code>static GGPO_API GGPOErrorCode __cdecl GGPONet::ggpo_try_synchronize_local (\n    GGPOSession * ggpo\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/ggponet.h</code></p>"},{"location":"GGPOUE4/struct_g_g_p_o_player/","title":"Struct GGPOPlayer","text":"<p>ClassList &gt; GGPOPlayer</p>"},{"location":"GGPOUE4/struct_g_g_p_o_player/#public-attributes","title":"Public Attributes","text":"Type Name int connection_id int player_num int size GGPOPlayerType type"},{"location":"GGPOUE4/struct_g_g_p_o_player/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_g_g_p_o_player/#variable-connection_id","title":"variable connection_id","text":"<pre><code>int GGPOPlayer::connection_id;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_player/#variable-player_num","title":"variable player_num","text":"<pre><code>int GGPOPlayer::player_num;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_player/#variable-size","title":"variable size","text":"<pre><code>int GGPOPlayer::size;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_player/#variable-type","title":"variable type","text":"<pre><code>GGPOPlayerType GGPOPlayer::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/ggponet.h</code></p>"},{"location":"GGPOUE4/struct_g_g_p_o_session/","title":"Struct GGPOSession","text":"<p>ClassList &gt; GGPOSession</p> <p>Inherited by the following classes: Peer2PeerBackend,  SpectatorBackend,  SyncTestBackend</p>"},{"location":"GGPOUE4/struct_g_g_p_o_session/#public-functions","title":"Public Functions","text":"Type Name virtual GGPOErrorCode AddLocalInput (GGPOPlayerHandle player, void * values, int size) = 0 virtual GGPOErrorCode AddPlayer (GGPOPlayer * player, GGPOPlayerHandle * handle) = 0 virtual GGPOErrorCode Chat (char * text)  virtual GGPOErrorCode DisconnectPlayer (GGPOPlayerHandle handle)  virtual GGPOErrorCode DoPoll (int timeout)  virtual GGPOErrorCode GetNetworkStats (FGGPONetworkStats * stats, GGPOPlayerHandle handle)  virtual GGPOErrorCode IncrementFrame (void)  virtual GGPOErrorCode Logv (const char * fmt, va_list list)  virtual GGPOErrorCode SetDisconnectNotifyStart (int timeout)  virtual GGPOErrorCode SetDisconnectTimeout (int timeout)  virtual GGPOErrorCode SetFrameDelay (GGPOPlayerHandle player, int delay)  virtual GGPOErrorCode SyncInput (void * values, int size, int * disconnect_flags) = 0 virtual GGPOErrorCode TrySynchronizeLocal ()  virtual ~GGPOSession ()"},{"location":"GGPOUE4/struct_g_g_p_o_session/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/struct_g_g_p_o_session/#function-addlocalinput","title":"function AddLocalInput","text":"<pre><code>virtual GGPOErrorCode GGPOSession::AddLocalInput (\n    GGPOPlayerHandle player,\n    void * values,\n    int size\n) = 0\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session/#function-addplayer","title":"function AddPlayer","text":"<pre><code>virtual GGPOErrorCode GGPOSession::AddPlayer (\n    GGPOPlayer * player,\n    GGPOPlayerHandle * handle\n) = 0\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session/#function-chat","title":"function Chat","text":"<pre><code>inline virtual GGPOErrorCode GGPOSession::Chat (\n    char * text\n) \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session/#function-disconnectplayer","title":"function DisconnectPlayer","text":"<pre><code>inline virtual GGPOErrorCode GGPOSession::DisconnectPlayer (\n    GGPOPlayerHandle handle\n) \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session/#function-dopoll","title":"function DoPoll","text":"<pre><code>inline virtual GGPOErrorCode GGPOSession::DoPoll (\n    int timeout\n) \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session/#function-getnetworkstats","title":"function GetNetworkStats","text":"<pre><code>inline virtual GGPOErrorCode GGPOSession::GetNetworkStats (\n    FGGPONetworkStats * stats,\n    GGPOPlayerHandle handle\n) \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session/#function-incrementframe","title":"function IncrementFrame","text":"<pre><code>inline virtual GGPOErrorCode GGPOSession::IncrementFrame (\n    void\n) \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session/#function-logv","title":"function Logv","text":"<pre><code>inline virtual GGPOErrorCode GGPOSession::Logv (\n    const char * fmt,\n    va_list list\n) \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session/#function-setdisconnectnotifystart","title":"function SetDisconnectNotifyStart","text":"<pre><code>inline virtual GGPOErrorCode GGPOSession::SetDisconnectNotifyStart (\n    int timeout\n) \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session/#function-setdisconnecttimeout","title":"function SetDisconnectTimeout","text":"<pre><code>inline virtual GGPOErrorCode GGPOSession::SetDisconnectTimeout (\n    int timeout\n) \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session/#function-setframedelay","title":"function SetFrameDelay","text":"<pre><code>inline virtual GGPOErrorCode GGPOSession::SetFrameDelay (\n    GGPOPlayerHandle player,\n    int delay\n) \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session/#function-syncinput","title":"function SyncInput","text":"<pre><code>virtual GGPOErrorCode GGPOSession::SyncInput (\n    void * values,\n    int size,\n    int * disconnect_flags\n) = 0\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session/#function-trysynchronizelocal","title":"function TrySynchronizeLocal","text":"<pre><code>inline virtual GGPOErrorCode GGPOSession::TrySynchronizeLocal () \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session/#function-ggposession","title":"function ~GGPOSession","text":"<pre><code>inline virtual GGPOSession::~GGPOSession () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/backend.h</code></p>"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/","title":"Struct GGPOSessionCallbacks","text":"<p>ClassList &gt; GGPOSessionCallbacks</p>"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#public-attributes","title":"Public Attributes","text":"Type Name unsigned char * buffer int int * checksum int int int frame int * len int len unsigned char int len"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#public-functions","title":"Public Functions","text":"Type Name bool (__cdecl * begin_game) const bool (__cdecl * save_game_state)  bool (__cdecl * load_game_state)  bool (__cdecl * log_game_state)  bool (__cdecl * advance_frame)  bool (__cdecl * on_event)  void (__cdecl * free_buffer)"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#variable-buffer","title":"variable buffer","text":"<pre><code>unsigned char* GGPOSessionCallbacks::buffer;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#variable-checksum","title":"variable checksum","text":"<pre><code>int int* GGPOSessionCallbacks::checksum;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#variable-frame","title":"variable frame","text":"<pre><code>int int int GGPOSessionCallbacks::frame;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#variable-len-13","title":"variable len [1/3]","text":"<pre><code>int* GGPOSessionCallbacks::len;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#variable-len-23","title":"variable len [2/3]","text":"<pre><code>int GGPOSessionCallbacks::len;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#variable-len-33","title":"variable len [3/3]","text":"<pre><code>unsigned char int GGPOSessionCallbacks::len;\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#function-bool-16","title":"function bool [1/6]","text":"<pre><code>GGPOSessionCallbacks::bool (\n    __cdecl * begin_game\n) const\n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#function-bool-26","title":"function bool [2/6]","text":"<pre><code>GGPOSessionCallbacks::bool (\n    __cdecl * save_game_state\n) \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#function-bool-36","title":"function bool [3/6]","text":"<pre><code>GGPOSessionCallbacks::bool (\n    __cdecl * load_game_state\n) \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#function-bool-46","title":"function bool [4/6]","text":"<pre><code>GGPOSessionCallbacks::bool (\n    __cdecl * log_game_state\n) \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#function-bool-56","title":"function bool [5/6]","text":"<pre><code>GGPOSessionCallbacks::bool (\n    __cdecl * advance_frame\n) \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#function-bool-66","title":"function bool [6/6]","text":"<pre><code>GGPOSessionCallbacks::bool (\n    __cdecl * on_event\n) \n</code></pre>"},{"location":"GGPOUE4/struct_g_g_p_o_session_callbacks/#function-void","title":"function void","text":"<pre><code>GGPOSessionCallbacks::void (\n    __cdecl * free_buffer\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/ggponet.h</code></p>"},{"location":"GGPOUE4/struct_game_input/","title":"Struct GameInput","text":"<p>ClassList &gt; GameInput</p>"},{"location":"GGPOUE4/struct_game_input/#public-types","title":"Public Types","text":"Type Name enum Constants"},{"location":"GGPOUE4/struct_game_input/#public-attributes","title":"Public Attributes","text":"Type Name char bits int frame int size"},{"location":"GGPOUE4/struct_game_input/#public-functions","title":"Public Functions","text":"Type Name void clear (int i)  void desc (char * buf, size_t buf_size, bool show_frame=true) const bool equal (GameInput &amp; input, bool bitsonly=false)  void erase ()  void init (int frame, char * bits, int size, int offset)  void init (int frame, char * bits, int size)  bool is_null ()  void log (char * prefix, bool show_frame=true) const void set (int i)  bool value (int i) const"},{"location":"GGPOUE4/struct_game_input/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"GGPOUE4/struct_game_input/#enum-constants","title":"enum Constants","text":"<pre><code>enum GameInput::Constants {\n    NullFrame = -1\n};\n</code></pre>"},{"location":"GGPOUE4/struct_game_input/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_game_input/#variable-bits","title":"variable bits","text":"<pre><code>char GameInput::bits[GAMEINPUT_MAX_BYTES *GAMEINPUT_MAX_PLAYERS];\n</code></pre>"},{"location":"GGPOUE4/struct_game_input/#variable-frame","title":"variable frame","text":"<pre><code>int GameInput::frame;\n</code></pre>"},{"location":"GGPOUE4/struct_game_input/#variable-size","title":"variable size","text":"<pre><code>int GameInput::size;\n</code></pre>"},{"location":"GGPOUE4/struct_game_input/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/struct_game_input/#function-clear","title":"function clear","text":"<pre><code>inline void GameInput::clear (\n    int i\n) \n</code></pre>"},{"location":"GGPOUE4/struct_game_input/#function-desc","title":"function desc","text":"<pre><code>void GameInput::desc (\n    char * buf,\n    size_t buf_size,\n    bool show_frame=true\n) const\n</code></pre>"},{"location":"GGPOUE4/struct_game_input/#function-equal","title":"function equal","text":"<pre><code>bool GameInput::equal (\n    GameInput &amp; input,\n    bool bitsonly=false\n) \n</code></pre>"},{"location":"GGPOUE4/struct_game_input/#function-erase","title":"function erase","text":"<pre><code>inline void GameInput::erase () \n</code></pre>"},{"location":"GGPOUE4/struct_game_input/#function-init-12","title":"function init [1/2]","text":"<pre><code>void GameInput::init (\n    int frame,\n    char * bits,\n    int size,\n    int offset\n) \n</code></pre>"},{"location":"GGPOUE4/struct_game_input/#function-init-22","title":"function init [2/2]","text":"<pre><code>void GameInput::init (\n    int frame,\n    char * bits,\n    int size\n) \n</code></pre>"},{"location":"GGPOUE4/struct_game_input/#function-is_null","title":"function is_null","text":"<pre><code>inline bool GameInput::is_null () \n</code></pre>"},{"location":"GGPOUE4/struct_game_input/#function-log","title":"function log","text":"<pre><code>void GameInput::log (\n    char * prefix,\n    bool show_frame=true\n) const\n</code></pre>"},{"location":"GGPOUE4/struct_game_input/#function-set","title":"function set","text":"<pre><code>inline void GameInput::set (\n    int i\n) \n</code></pre>"},{"location":"GGPOUE4/struct_game_input/#function-value","title":"function value","text":"<pre><code>inline bool GameInput::value (\n    int i\n) const\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/game_input.h</code></p>"},{"location":"GGPOUE4/class_i_poll_sink/","title":"Class IPollSink","text":"<p>ClassList &gt; IPollSink</p> <p>Inherited by the following classes: Peer2PeerBackend,  SpectatorBackend,  Udp,  UdpProtocol</p>"},{"location":"GGPOUE4/class_i_poll_sink/#public-functions","title":"Public Functions","text":"Type Name virtual bool OnHandlePoll (void *)  virtual bool OnLoopPoll (void *)  virtual bool OnMsgPoll (void *)  virtual bool OnPeriodicPoll (void *, int)  virtual ~IPollSink ()"},{"location":"GGPOUE4/class_i_poll_sink/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_i_poll_sink/#function-onhandlepoll","title":"function OnHandlePoll","text":"<pre><code>inline virtual bool IPollSink::OnHandlePoll (\n    void *\n) \n</code></pre>"},{"location":"GGPOUE4/class_i_poll_sink/#function-onlooppoll","title":"function OnLoopPoll","text":"<pre><code>inline virtual bool IPollSink::OnLoopPoll (\n    void *\n) \n</code></pre>"},{"location":"GGPOUE4/class_i_poll_sink/#function-onmsgpoll","title":"function OnMsgPoll","text":"<pre><code>inline virtual bool IPollSink::OnMsgPoll (\n    void *\n) \n</code></pre>"},{"location":"GGPOUE4/class_i_poll_sink/#function-onperiodicpoll","title":"function OnPeriodicPoll","text":"<pre><code>inline virtual bool IPollSink::OnPeriodicPoll (\n    void *,\n    int\n) \n</code></pre>"},{"location":"GGPOUE4/class_i_poll_sink/#function-ipollsink","title":"function ~IPollSink","text":"<pre><code>inline virtual IPollSink::~IPollSink () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/poll.h</code></p>"},{"location":"GGPOUE4/class_input_queue/","title":"Class InputQueue","text":"<p>ClassList &gt; InputQueue</p>"},{"location":"GGPOUE4/class_input_queue/#public-functions","title":"Public Functions","text":"Type Name void AddInput (GameInput &amp; input)  void DiscardConfirmedFrames (int frame)  bool GetConfirmedInput (int frame, GameInput * input)  int GetFirstIncorrectFrame ()  bool GetInput (int frame, GameInput * input)  int GetLastConfirmedFrame ()  int GetLength ()  void Init (int id, int input_size)  InputQueue (int input_size=DEFAULT_INPUT_SIZE)  void ResetPrediction (int frame)  void SetFrameDelay (int delay)  ~InputQueue ()"},{"location":"GGPOUE4/class_input_queue/#protected-attributes","title":"Protected Attributes","text":"Type Name bool _first_frame int _first_incorrect_frame int _frame_delay int _head int _id GameInput _inputs int _last_added_frame int _last_frame_requested int _last_user_added_frame int _length GameInput _prediction int _tail"},{"location":"GGPOUE4/class_input_queue/#protected-functions","title":"Protected Functions","text":"Type Name void AddDelayedInputToQueue (GameInput &amp; input, int i)  int AdvanceQueueHead (int frame)  void Log (const char * fmt, ...)"},{"location":"GGPOUE4/class_input_queue/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_input_queue/#function-addinput","title":"function AddInput","text":"<pre><code>void InputQueue::AddInput (\n    GameInput &amp; input\n) \n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#function-discardconfirmedframes","title":"function DiscardConfirmedFrames","text":"<pre><code>void InputQueue::DiscardConfirmedFrames (\n    int frame\n) \n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#function-getconfirmedinput","title":"function GetConfirmedInput","text":"<pre><code>bool InputQueue::GetConfirmedInput (\n    int frame,\n    GameInput * input\n) \n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#function-getfirstincorrectframe","title":"function GetFirstIncorrectFrame","text":"<pre><code>int InputQueue::GetFirstIncorrectFrame () \n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#function-getinput","title":"function GetInput","text":"<pre><code>bool InputQueue::GetInput (\n    int frame,\n    GameInput * input\n) \n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#function-getlastconfirmedframe","title":"function GetLastConfirmedFrame","text":"<pre><code>int InputQueue::GetLastConfirmedFrame () \n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#function-getlength","title":"function GetLength","text":"<pre><code>inline int InputQueue::GetLength () \n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#function-init","title":"function Init","text":"<pre><code>void InputQueue::Init (\n    int id,\n    int input_size\n) \n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#function-inputqueue","title":"function InputQueue","text":"<pre><code>InputQueue::InputQueue (\n    int input_size=DEFAULT_INPUT_SIZE\n) \n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#function-resetprediction","title":"function ResetPrediction","text":"<pre><code>void InputQueue::ResetPrediction (\n    int frame\n) \n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#function-setframedelay","title":"function SetFrameDelay","text":"<pre><code>inline void InputQueue::SetFrameDelay (\n    int delay\n) \n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#function-inputqueue_1","title":"function ~InputQueue","text":"<pre><code>InputQueue::~InputQueue () \n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"GGPOUE4/class_input_queue/#variable-_first_frame","title":"variable _first_frame","text":"<pre><code>bool InputQueue::_first_frame;\n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#variable-_first_incorrect_frame","title":"variable _first_incorrect_frame","text":"<pre><code>int InputQueue::_first_incorrect_frame;\n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#variable-_frame_delay","title":"variable _frame_delay","text":"<pre><code>int InputQueue::_frame_delay;\n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#variable-_head","title":"variable _head","text":"<pre><code>int InputQueue::_head;\n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#variable-_id","title":"variable _id","text":"<pre><code>int InputQueue::_id;\n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#variable-_inputs","title":"variable _inputs","text":"<pre><code>GameInput InputQueue::_inputs[INPUT_QUEUE_LENGTH];\n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#variable-_last_added_frame","title":"variable _last_added_frame","text":"<pre><code>int InputQueue::_last_added_frame;\n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#variable-_last_frame_requested","title":"variable _last_frame_requested","text":"<pre><code>int InputQueue::_last_frame_requested;\n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#variable-_last_user_added_frame","title":"variable _last_user_added_frame","text":"<pre><code>int InputQueue::_last_user_added_frame;\n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#variable-_length","title":"variable _length","text":"<pre><code>int InputQueue::_length;\n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#variable-_prediction","title":"variable _prediction","text":"<pre><code>GameInput InputQueue::_prediction;\n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#variable-_tail","title":"variable _tail","text":"<pre><code>int InputQueue::_tail;\n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"GGPOUE4/class_input_queue/#function-adddelayedinputtoqueue","title":"function AddDelayedInputToQueue","text":"<pre><code>void InputQueue::AddDelayedInputToQueue (\n    GameInput &amp; input,\n    int i\n) \n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#function-advancequeuehead","title":"function AdvanceQueueHead","text":"<pre><code>int InputQueue::AdvanceQueueHead (\n    int frame\n) \n</code></pre>"},{"location":"GGPOUE4/class_input_queue/#function-log","title":"function Log","text":"<pre><code>void InputQueue::Log (\n    const char * fmt,\n    ...\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/input_queue.h</code></p>"},{"location":"GGPOUE4/class_peer2_peer_backend/","title":"Class Peer2PeerBackend","text":"<p>ClassList &gt; Peer2PeerBackend</p> <p>Inherits the following classes: GGPOSession,  IPollSink,  Udp::Callbacks</p>"},{"location":"GGPOUE4/class_peer2_peer_backend/#public-attributes","title":"Public Attributes","text":"Type Name int remoteplayerId int remoteplayerQueueu"},{"location":"GGPOUE4/class_peer2_peer_backend/#public-functions","title":"Public Functions","text":"Type Name virtual GGPOErrorCode AddLocalInput (GGPOPlayerHandle player, void * values, int size)  virtual GGPOErrorCode AddPlayer (GGPOPlayer * player, GGPOPlayerHandle * handle)  virtual GGPOErrorCode DisconnectPlayer (GGPOPlayerHandle handle)  virtual GGPOErrorCode DoPoll (int timeout)  virtual GGPOErrorCode GetNetworkStats (FGGPONetworkStats * stats, GGPOPlayerHandle handle) override virtual GGPOErrorCode IncrementFrame (void)  virtual void OnMsg (int connection_id, UdpMsg * msg, int len) override Peer2PeerBackend (GGPOSessionCallbacks * cb, const char * gamename, ConnectionManager * connection_manager, int num_players, int input_size)  virtual GGPOErrorCode SetDisconnectNotifyStart (int timeout)  virtual GGPOErrorCode SetDisconnectTimeout (int timeout)  virtual GGPOErrorCode SetFrameDelay (GGPOPlayerHandle player, int delay)  virtual GGPOErrorCode SyncInput (void * values, int size, int * disconnect_flags)  virtual GGPOErrorCode TrySynchronizeLocal () override virtual ~Peer2PeerBackend ()"},{"location":"GGPOUE4/class_peer2_peer_backend/#public-functions-inherited-from-ggposession","title":"Public Functions inherited from GGPOSession","text":"<p>See GGPOSession</p> Type Name virtual GGPOErrorCode AddLocalInput (GGPOPlayerHandle player, void * values, int size) = 0 virtual GGPOErrorCode AddPlayer (GGPOPlayer * player, GGPOPlayerHandle * handle) = 0 virtual GGPOErrorCode Chat (char * text)  virtual GGPOErrorCode DisconnectPlayer (GGPOPlayerHandle handle)  virtual GGPOErrorCode DoPoll (int timeout)  virtual GGPOErrorCode GetNetworkStats (FGGPONetworkStats * stats, GGPOPlayerHandle handle)  virtual GGPOErrorCode IncrementFrame (void)  virtual GGPOErrorCode Logv (const char * fmt, va_list list)  virtual GGPOErrorCode SetDisconnectNotifyStart (int timeout)  virtual GGPOErrorCode SetDisconnectTimeout (int timeout)  virtual GGPOErrorCode SetFrameDelay (GGPOPlayerHandle player, int delay)  virtual GGPOErrorCode SyncInput (void * values, int size, int * disconnect_flags) = 0 virtual GGPOErrorCode TrySynchronizeLocal ()  virtual ~GGPOSession ()"},{"location":"GGPOUE4/class_peer2_peer_backend/#public-functions-inherited-from-ipollsink","title":"Public Functions inherited from IPollSink","text":"<p>See IPollSink</p> Type Name virtual bool OnHandlePoll (void *)  virtual bool OnLoopPoll (void *)  virtual bool OnMsgPoll (void *)  virtual bool OnPeriodicPoll (void *, int)  virtual ~IPollSink ()"},{"location":"GGPOUE4/class_peer2_peer_backend/#public-functions-inherited-from-udpcallbacks","title":"Public Functions inherited from Udp::Callbacks","text":"<p>See Udp::Callbacks</p> Type Name virtual void OnMsg (int connection_id, UdpMsg * msg, int len) = 0 virtual ~Callbacks ()"},{"location":"GGPOUE4/class_peer2_peer_backend/#protected-attributes","title":"Protected Attributes","text":"Type Name GGPOSessionCallbacks _callbacks int _disconnect_notify_start int _disconnect_timeout UdpProtocol * _endpoints int _input_size UdpMsg::connect_status _local_connect_status int _next_recommended_sleep int _next_spectator_frame int _num_players int _num_spectators Poll _poll UdpProtocol _spectators Sync _sync bool _synchronizing Udp _udp"},{"location":"GGPOUE4/class_peer2_peer_backend/#protected-functions","title":"Protected Functions","text":"Type Name void AddRemotePlayer (int connection_id, int queue)  GGPOErrorCode AddSpectator (int connection_id)  void CheckInitialSync (void)  void DisconnectPlayerQueue (int queue, int syncto)  virtual void OnSyncEvent (Sync::Event &amp; e)  virtual void OnUdpProtocolEvent (UdpProtocol::Event &amp; e, GGPOPlayerHandle handle)  virtual void OnUdpProtocolPeerEvent (UdpProtocol::Event &amp; e, int queue)  virtual void OnUdpProtocolSpectatorEvent (UdpProtocol::Event &amp; e, int queue)  GGPOErrorCode PlayerHandleToQueue (GGPOPlayerHandle player, int * queue)  int Poll2Players (int current_frame)  int PollNPlayers (int current_frame)  void PollSyncEvents (void)  void PollUdpProtocolEvents (void)  GGPOPlayerHandle QueueToPlayerHandle (int queue)  GGPOPlayerHandle QueueToSpectatorHandle (int queue)"},{"location":"GGPOUE4/class_peer2_peer_backend/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-remoteplayerid","title":"variable remoteplayerId","text":"<pre><code>int Peer2PeerBackend::remoteplayerId;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-remoteplayerqueueu","title":"variable remoteplayerQueueu","text":"<pre><code>int Peer2PeerBackend::remoteplayerQueueu;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_peer2_peer_backend/#function-addlocalinput","title":"function AddLocalInput","text":"<pre><code>virtual GGPOErrorCode Peer2PeerBackend::AddLocalInput (\n    GGPOPlayerHandle player,\n    void * values,\n    int size\n) \n</code></pre> <p>Implements GGPOSession::AddLocalInput</p>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-addplayer","title":"function AddPlayer","text":"<pre><code>virtual GGPOErrorCode Peer2PeerBackend::AddPlayer (\n    GGPOPlayer * player,\n    GGPOPlayerHandle * handle\n) \n</code></pre> <p>Implements GGPOSession::AddPlayer</p>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-disconnectplayer","title":"function DisconnectPlayer","text":"<pre><code>virtual GGPOErrorCode Peer2PeerBackend::DisconnectPlayer (\n    GGPOPlayerHandle handle\n) \n</code></pre> <p>Implements GGPOSession::DisconnectPlayer</p>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-dopoll","title":"function DoPoll","text":"<pre><code>virtual GGPOErrorCode Peer2PeerBackend::DoPoll (\n    int timeout\n) \n</code></pre> <p>Implements GGPOSession::DoPoll</p>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-getnetworkstats","title":"function GetNetworkStats","text":"<pre><code>virtual GGPOErrorCode Peer2PeerBackend::GetNetworkStats (\n    FGGPONetworkStats * stats,\n    GGPOPlayerHandle handle\n) override\n</code></pre> <p>Implements GGPOSession::GetNetworkStats</p>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-incrementframe","title":"function IncrementFrame","text":"<pre><code>virtual GGPOErrorCode Peer2PeerBackend::IncrementFrame (\n    void\n) \n</code></pre> <p>Implements GGPOSession::IncrementFrame</p>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-onmsg","title":"function OnMsg","text":"<pre><code>virtual void Peer2PeerBackend::OnMsg (\n    int connection_id,\n    UdpMsg * msg,\n    int len\n) override\n</code></pre> <p>Implements Udp::Callbacks::OnMsg</p>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-peer2peerbackend","title":"function Peer2PeerBackend","text":"<pre><code>Peer2PeerBackend::Peer2PeerBackend (\n    GGPOSessionCallbacks * cb,\n    const char * gamename,\n    ConnectionManager * connection_manager,\n    int num_players,\n    int input_size\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-setdisconnectnotifystart","title":"function SetDisconnectNotifyStart","text":"<pre><code>virtual GGPOErrorCode Peer2PeerBackend::SetDisconnectNotifyStart (\n    int timeout\n) \n</code></pre> <p>Implements GGPOSession::SetDisconnectNotifyStart</p>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-setdisconnecttimeout","title":"function SetDisconnectTimeout","text":"<pre><code>virtual GGPOErrorCode Peer2PeerBackend::SetDisconnectTimeout (\n    int timeout\n) \n</code></pre> <p>Implements GGPOSession::SetDisconnectTimeout</p>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-setframedelay","title":"function SetFrameDelay","text":"<pre><code>virtual GGPOErrorCode Peer2PeerBackend::SetFrameDelay (\n    GGPOPlayerHandle player,\n    int delay\n) \n</code></pre> <p>Implements GGPOSession::SetFrameDelay</p>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-syncinput","title":"function SyncInput","text":"<pre><code>virtual GGPOErrorCode Peer2PeerBackend::SyncInput (\n    void * values,\n    int size,\n    int * disconnect_flags\n) \n</code></pre> <p>Implements GGPOSession::SyncInput</p>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-trysynchronizelocal","title":"function TrySynchronizeLocal","text":"<pre><code>virtual GGPOErrorCode Peer2PeerBackend::TrySynchronizeLocal () override\n</code></pre> <p>Implements GGPOSession::TrySynchronizeLocal</p>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-peer2peerbackend_1","title":"function ~Peer2PeerBackend","text":"<pre><code>virtual Peer2PeerBackend::~Peer2PeerBackend () \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_callbacks","title":"variable _callbacks","text":"<pre><code>GGPOSessionCallbacks Peer2PeerBackend::_callbacks;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_disconnect_notify_start","title":"variable _disconnect_notify_start","text":"<pre><code>int Peer2PeerBackend::_disconnect_notify_start;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_disconnect_timeout","title":"variable _disconnect_timeout","text":"<pre><code>int Peer2PeerBackend::_disconnect_timeout;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_endpoints","title":"variable _endpoints","text":"<pre><code>UdpProtocol* Peer2PeerBackend::_endpoints;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_input_size","title":"variable _input_size","text":"<pre><code>int Peer2PeerBackend::_input_size;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_local_connect_status","title":"variable _local_connect_status","text":"<pre><code>UdpMsg::connect_status Peer2PeerBackend::_local_connect_status[UDP_MSG_MAX_PLAYERS];\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_next_recommended_sleep","title":"variable _next_recommended_sleep","text":"<pre><code>int Peer2PeerBackend::_next_recommended_sleep;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_next_spectator_frame","title":"variable _next_spectator_frame","text":"<pre><code>int Peer2PeerBackend::_next_spectator_frame;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_num_players","title":"variable _num_players","text":"<pre><code>int Peer2PeerBackend::_num_players;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_num_spectators","title":"variable _num_spectators","text":"<pre><code>int Peer2PeerBackend::_num_spectators;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_poll","title":"variable _poll","text":"<pre><code>Poll Peer2PeerBackend::_poll;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_spectators","title":"variable _spectators","text":"<pre><code>UdpProtocol Peer2PeerBackend::_spectators[GGPO_MAX_SPECTATORS];\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_sync","title":"variable _sync","text":"<pre><code>Sync Peer2PeerBackend::_sync;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_synchronizing","title":"variable _synchronizing","text":"<pre><code>bool Peer2PeerBackend::_synchronizing;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#variable-_udp","title":"variable _udp","text":"<pre><code>Udp Peer2PeerBackend::_udp;\n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"GGPOUE4/class_peer2_peer_backend/#function-addremoteplayer","title":"function AddRemotePlayer","text":"<pre><code>void Peer2PeerBackend::AddRemotePlayer (\n    int connection_id,\n    int queue\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-addspectator","title":"function AddSpectator","text":"<pre><code>GGPOErrorCode Peer2PeerBackend::AddSpectator (\n    int connection_id\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-checkinitialsync","title":"function CheckInitialSync","text":"<pre><code>void Peer2PeerBackend::CheckInitialSync (\n    void\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-disconnectplayerqueue","title":"function DisconnectPlayerQueue","text":"<pre><code>void Peer2PeerBackend::DisconnectPlayerQueue (\n    int queue,\n    int syncto\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-onsyncevent","title":"function OnSyncEvent","text":"<pre><code>inline virtual void Peer2PeerBackend::OnSyncEvent (\n    Sync::Event &amp; e\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-onudpprotocolevent","title":"function OnUdpProtocolEvent","text":"<pre><code>virtual void Peer2PeerBackend::OnUdpProtocolEvent (\n    UdpProtocol::Event &amp; e,\n    GGPOPlayerHandle handle\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-onudpprotocolpeerevent","title":"function OnUdpProtocolPeerEvent","text":"<pre><code>virtual void Peer2PeerBackend::OnUdpProtocolPeerEvent (\n    UdpProtocol::Event &amp; e,\n    int queue\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-onudpprotocolspectatorevent","title":"function OnUdpProtocolSpectatorEvent","text":"<pre><code>virtual void Peer2PeerBackend::OnUdpProtocolSpectatorEvent (\n    UdpProtocol::Event &amp; e,\n    int queue\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-playerhandletoqueue","title":"function PlayerHandleToQueue","text":"<pre><code>GGPOErrorCode Peer2PeerBackend::PlayerHandleToQueue (\n    GGPOPlayerHandle player,\n    int * queue\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-poll2players","title":"function Poll2Players","text":"<pre><code>int Peer2PeerBackend::Poll2Players (\n    int current_frame\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-pollnplayers","title":"function PollNPlayers","text":"<pre><code>int Peer2PeerBackend::PollNPlayers (\n    int current_frame\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-pollsyncevents","title":"function PollSyncEvents","text":"<pre><code>void Peer2PeerBackend::PollSyncEvents (\n    void\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-polludpprotocolevents","title":"function PollUdpProtocolEvents","text":"<pre><code>void Peer2PeerBackend::PollUdpProtocolEvents (\n    void\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-queuetoplayerhandle","title":"function QueueToPlayerHandle","text":"<pre><code>inline GGPOPlayerHandle Peer2PeerBackend::QueueToPlayerHandle (\n    int queue\n) \n</code></pre>"},{"location":"GGPOUE4/class_peer2_peer_backend/#function-queuetospectatorhandle","title":"function QueueToSpectatorHandle","text":"<pre><code>inline GGPOPlayerHandle Peer2PeerBackend::QueueToSpectatorHandle (\n    int queue\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/p2p.h</code></p>"},{"location":"GGPOUE4/class_poll/","title":"Class Poll","text":"<p>ClassList &gt; Poll</p>"},{"location":"GGPOUE4/class_poll/#public-functions","title":"Public Functions","text":"Type Name Poll (void)  bool Pump (int timeout)  void RegisterHandle (IPollSink * sink, HANDLE h, void * cookie=NULL)  void RegisterLoop (IPollSink * sink, void * cookie=NULL)  void RegisterMsgLoop (IPollSink * sink, void * cookie=NULL)  void RegisterPeriodic (IPollSink * sink, int interval, void * cookie=NULL)  void Run ()"},{"location":"GGPOUE4/class_poll/#protected-attributes","title":"Protected Attributes","text":"Type Name int _handle_count PollSinkCb _handle_sinks HANDLE _handles StaticBuffer&lt; PollSinkCb, 16 &gt; _loop_sinks StaticBuffer&lt; PollSinkCb, 16 &gt; _msg_sinks StaticBuffer&lt; PollPeriodicSinkCb, 16 &gt; _periodic_sinks int _start_time"},{"location":"GGPOUE4/class_poll/#protected-functions","title":"Protected Functions","text":"Type Name int ComputeWaitTime (int elapsed)"},{"location":"GGPOUE4/class_poll/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_poll/#function-poll","title":"function Poll","text":"<pre><code>Poll::Poll (\n    void\n) \n</code></pre>"},{"location":"GGPOUE4/class_poll/#function-pump","title":"function Pump","text":"<pre><code>bool Poll::Pump (\n    int timeout\n) \n</code></pre>"},{"location":"GGPOUE4/class_poll/#function-registerhandle","title":"function RegisterHandle","text":"<pre><code>void Poll::RegisterHandle (\n    IPollSink * sink,\n    HANDLE h,\n    void * cookie=NULL\n) \n</code></pre>"},{"location":"GGPOUE4/class_poll/#function-registerloop","title":"function RegisterLoop","text":"<pre><code>void Poll::RegisterLoop (\n    IPollSink * sink,\n    void * cookie=NULL\n) \n</code></pre>"},{"location":"GGPOUE4/class_poll/#function-registermsgloop","title":"function RegisterMsgLoop","text":"<pre><code>void Poll::RegisterMsgLoop (\n    IPollSink * sink,\n    void * cookie=NULL\n) \n</code></pre>"},{"location":"GGPOUE4/class_poll/#function-registerperiodic","title":"function RegisterPeriodic","text":"<pre><code>void Poll::RegisterPeriodic (\n    IPollSink * sink,\n    int interval,\n    void * cookie=NULL\n) \n</code></pre>"},{"location":"GGPOUE4/class_poll/#function-run","title":"function Run","text":"<pre><code>void Poll::Run () \n</code></pre>"},{"location":"GGPOUE4/class_poll/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"GGPOUE4/class_poll/#variable-_handle_count","title":"variable _handle_count","text":"<pre><code>int Poll::_handle_count;\n</code></pre>"},{"location":"GGPOUE4/class_poll/#variable-_handle_sinks","title":"variable _handle_sinks","text":"<pre><code>PollSinkCb Poll::_handle_sinks[MAX_POLLABLE_HANDLES];\n</code></pre>"},{"location":"GGPOUE4/class_poll/#variable-_handles","title":"variable _handles","text":"<pre><code>HANDLE Poll::_handles[MAX_POLLABLE_HANDLES];\n</code></pre>"},{"location":"GGPOUE4/class_poll/#variable-_loop_sinks","title":"variable _loop_sinks","text":"<pre><code>StaticBuffer&lt;PollSinkCb, 16&gt; Poll::_loop_sinks;\n</code></pre>"},{"location":"GGPOUE4/class_poll/#variable-_msg_sinks","title":"variable _msg_sinks","text":"<pre><code>StaticBuffer&lt;PollSinkCb, 16&gt; Poll::_msg_sinks;\n</code></pre>"},{"location":"GGPOUE4/class_poll/#variable-_periodic_sinks","title":"variable _periodic_sinks","text":"<pre><code>StaticBuffer&lt;PollPeriodicSinkCb, 16&gt; Poll::_periodic_sinks;\n</code></pre>"},{"location":"GGPOUE4/class_poll/#variable-_start_time","title":"variable _start_time","text":"<pre><code>int Poll::_start_time;\n</code></pre>"},{"location":"GGPOUE4/class_poll/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"GGPOUE4/class_poll/#function-computewaittime","title":"function ComputeWaitTime","text":"<pre><code>int Poll::ComputeWaitTime (\n    int elapsed\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/poll.h</code></p>"},{"location":"GGPOUE4/struct_poll_1_1_poll_periodic_sink_cb/","title":"Struct Poll::PollPeriodicSinkCb","text":"<p>ClassList &gt; Poll &gt; PollPeriodicSinkCb</p> <p>Inherits the following classes: Poll::PollSinkCb</p>"},{"location":"GGPOUE4/struct_poll_1_1_poll_periodic_sink_cb/#public-attributes","title":"Public Attributes","text":"Type Name int interval int last_fired"},{"location":"GGPOUE4/struct_poll_1_1_poll_periodic_sink_cb/#public-attributes-inherited-from-pollpollsinkcb","title":"Public Attributes inherited from Poll::PollSinkCb","text":"<p>See Poll::PollSinkCb</p> Type Name void * cookie IPollSink * sink"},{"location":"GGPOUE4/struct_poll_1_1_poll_periodic_sink_cb/#public-functions","title":"Public Functions","text":"Type Name PollPeriodicSinkCb ()  PollPeriodicSinkCb (IPollSink * s, void * c, int i)"},{"location":"GGPOUE4/struct_poll_1_1_poll_periodic_sink_cb/#public-functions-inherited-from-pollpollsinkcb","title":"Public Functions inherited from Poll::PollSinkCb","text":"<p>See Poll::PollSinkCb</p> Type Name PollSinkCb ()  PollSinkCb (IPollSink * s, void * c)"},{"location":"GGPOUE4/struct_poll_1_1_poll_periodic_sink_cb/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_poll_1_1_poll_periodic_sink_cb/#variable-interval","title":"variable interval","text":"<pre><code>int Poll::PollPeriodicSinkCb::interval;\n</code></pre>"},{"location":"GGPOUE4/struct_poll_1_1_poll_periodic_sink_cb/#variable-last_fired","title":"variable last_fired","text":"<pre><code>int Poll::PollPeriodicSinkCb::last_fired;\n</code></pre>"},{"location":"GGPOUE4/struct_poll_1_1_poll_periodic_sink_cb/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/struct_poll_1_1_poll_periodic_sink_cb/#function-pollperiodicsinkcb-12","title":"function PollPeriodicSinkCb [1/2]","text":"<pre><code>inline Poll::PollPeriodicSinkCb::PollPeriodicSinkCb () \n</code></pre>"},{"location":"GGPOUE4/struct_poll_1_1_poll_periodic_sink_cb/#function-pollperiodicsinkcb-22","title":"function PollPeriodicSinkCb [2/2]","text":"<pre><code>inline Poll::PollPeriodicSinkCb::PollPeriodicSinkCb (\n    IPollSink * s,\n    void * c,\n    int i\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/poll.h</code></p>"},{"location":"GGPOUE4/struct_poll_1_1_poll_sink_cb/","title":"Struct Poll::PollSinkCb","text":"<p>ClassList &gt; Poll &gt; PollSinkCb</p> <p>Inherited by the following classes: Poll::PollPeriodicSinkCb</p>"},{"location":"GGPOUE4/struct_poll_1_1_poll_sink_cb/#public-attributes","title":"Public Attributes","text":"Type Name void * cookie IPollSink * sink"},{"location":"GGPOUE4/struct_poll_1_1_poll_sink_cb/#public-functions","title":"Public Functions","text":"Type Name PollSinkCb ()  PollSinkCb (IPollSink * s, void * c)"},{"location":"GGPOUE4/struct_poll_1_1_poll_sink_cb/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_poll_1_1_poll_sink_cb/#variable-cookie","title":"variable cookie","text":"<pre><code>void* Poll::PollSinkCb::cookie;\n</code></pre>"},{"location":"GGPOUE4/struct_poll_1_1_poll_sink_cb/#variable-sink","title":"variable sink","text":"<pre><code>IPollSink* Poll::PollSinkCb::sink;\n</code></pre>"},{"location":"GGPOUE4/struct_poll_1_1_poll_sink_cb/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/struct_poll_1_1_poll_sink_cb/#function-pollsinkcb-12","title":"function PollSinkCb [1/2]","text":"<pre><code>inline Poll::PollSinkCb::PollSinkCb () \n</code></pre>"},{"location":"GGPOUE4/struct_poll_1_1_poll_sink_cb/#function-pollsinkcb-22","title":"function PollSinkCb [2/2]","text":"<pre><code>inline Poll::PollSinkCb::PollSinkCb (\n    IPollSink * s,\n    void * c\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/poll.h</code></p>"},{"location":"GGPOUE4/class_ring_buffer/","title":"Class RingBuffer","text":"<p>template &lt;class T, int N&gt;</p> <p>ClassList &gt; RingBuffer</p>"},{"location":"GGPOUE4/class_ring_buffer/#public-functions","title":"Public Functions","text":"Type Name RingBuffer ()  bool empty ()  T &amp; front ()  T &amp; item (int i)  void pop ()  void push (const T &amp; t)  int size ()"},{"location":"GGPOUE4/class_ring_buffer/#protected-attributes","title":"Protected Attributes","text":"Type Name T _elements int _head int _size int _tail"},{"location":"GGPOUE4/class_ring_buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_ring_buffer/#function-ringbuffer","title":"function RingBuffer","text":"<pre><code>inline RingBuffer::RingBuffer () \n</code></pre>"},{"location":"GGPOUE4/class_ring_buffer/#function-empty","title":"function empty","text":"<pre><code>inline bool RingBuffer::empty () \n</code></pre>"},{"location":"GGPOUE4/class_ring_buffer/#function-front","title":"function front","text":"<pre><code>inline T &amp; RingBuffer::front () \n</code></pre>"},{"location":"GGPOUE4/class_ring_buffer/#function-item","title":"function item","text":"<pre><code>inline T &amp; RingBuffer::item (\n    int i\n) \n</code></pre>"},{"location":"GGPOUE4/class_ring_buffer/#function-pop","title":"function pop","text":"<pre><code>inline void RingBuffer::pop () \n</code></pre>"},{"location":"GGPOUE4/class_ring_buffer/#function-push","title":"function push","text":"<pre><code>inline void RingBuffer::push (\n    const T &amp; t\n) \n</code></pre>"},{"location":"GGPOUE4/class_ring_buffer/#function-size","title":"function size","text":"<pre><code>inline int RingBuffer::size () \n</code></pre>"},{"location":"GGPOUE4/class_ring_buffer/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"GGPOUE4/class_ring_buffer/#variable-_elements","title":"variable _elements","text":"<pre><code>T RingBuffer&lt; T, N &gt;::_elements[N];\n</code></pre>"},{"location":"GGPOUE4/class_ring_buffer/#variable-_head","title":"variable _head","text":"<pre><code>int RingBuffer&lt; T, N &gt;::_head;\n</code></pre>"},{"location":"GGPOUE4/class_ring_buffer/#variable-_size","title":"variable _size","text":"<pre><code>int RingBuffer&lt; T, N &gt;::_size;\n</code></pre>"},{"location":"GGPOUE4/class_ring_buffer/#variable-_tail","title":"variable _tail","text":"<pre><code>int RingBuffer&lt; T, N &gt;::_tail;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/ring_buffer.h</code></p>"},{"location":"GGPOUE4/class_spectator_backend/","title":"Class SpectatorBackend","text":"<p>ClassList &gt; SpectatorBackend</p> <p>Inherits the following classes: GGPOSession,  IPollSink,  Udp::Callbacks</p>"},{"location":"GGPOUE4/class_spectator_backend/#public-functions","title":"Public Functions","text":"Type Name virtual GGPOErrorCode AddLocalInput (GGPOPlayerHandle player, void * values, int size)  virtual GGPOErrorCode AddPlayer (GGPOPlayer * player, GGPOPlayerHandle * handle)  virtual GGPOErrorCode DisconnectPlayer (GGPOPlayerHandle handle)  virtual GGPOErrorCode DoPoll (int timeout)  virtual GGPOErrorCode GetNetworkStats (FGGPONetworkStats * stats, GGPOPlayerHandle handle)  virtual GGPOErrorCode IncrementFrame (void)  virtual void OnMsg (int connection_id, UdpMsg * msg, int len)  virtual GGPOErrorCode SetDisconnectNotifyStart (int timeout)  virtual GGPOErrorCode SetDisconnectTimeout (int timeout)  virtual GGPOErrorCode SetFrameDelay (GGPOPlayerHandle player, int delay)  SpectatorBackend (GGPOSessionCallbacks * cb, const char * gamename, ConnectionManager * connection_manager, int num_players, int input_size, int connection_id)  virtual GGPOErrorCode SyncInput (void * values, int size, int * disconnect_flags)  virtual ~SpectatorBackend ()"},{"location":"GGPOUE4/class_spectator_backend/#public-functions-inherited-from-ggposession","title":"Public Functions inherited from GGPOSession","text":"<p>See GGPOSession</p> Type Name virtual GGPOErrorCode AddLocalInput (GGPOPlayerHandle player, void * values, int size) = 0 virtual GGPOErrorCode AddPlayer (GGPOPlayer * player, GGPOPlayerHandle * handle) = 0 virtual GGPOErrorCode Chat (char * text)  virtual GGPOErrorCode DisconnectPlayer (GGPOPlayerHandle handle)  virtual GGPOErrorCode DoPoll (int timeout)  virtual GGPOErrorCode GetNetworkStats (FGGPONetworkStats * stats, GGPOPlayerHandle handle)  virtual GGPOErrorCode IncrementFrame (void)  virtual GGPOErrorCode Logv (const char * fmt, va_list list)  virtual GGPOErrorCode SetDisconnectNotifyStart (int timeout)  virtual GGPOErrorCode SetDisconnectTimeout (int timeout)  virtual GGPOErrorCode SetFrameDelay (GGPOPlayerHandle player, int delay)  virtual GGPOErrorCode SyncInput (void * values, int size, int * disconnect_flags) = 0 virtual GGPOErrorCode TrySynchronizeLocal ()  virtual ~GGPOSession ()"},{"location":"GGPOUE4/class_spectator_backend/#public-functions-inherited-from-ipollsink","title":"Public Functions inherited from IPollSink","text":"<p>See IPollSink</p> Type Name virtual bool OnHandlePoll (void *)  virtual bool OnLoopPoll (void *)  virtual bool OnMsgPoll (void *)  virtual bool OnPeriodicPoll (void *, int)  virtual ~IPollSink ()"},{"location":"GGPOUE4/class_spectator_backend/#public-functions-inherited-from-udpcallbacks","title":"Public Functions inherited from Udp::Callbacks","text":"<p>See Udp::Callbacks</p> Type Name virtual void OnMsg (int connection_id, UdpMsg * msg, int len) = 0 virtual ~Callbacks ()"},{"location":"GGPOUE4/class_spectator_backend/#protected-attributes","title":"Protected Attributes","text":"Type Name GGPOSessionCallbacks _callbacks UdpProtocol _host int _input_size GameInput _inputs int _next_input_to_send int _num_players Poll _poll bool _synchronizing Udp _udp"},{"location":"GGPOUE4/class_spectator_backend/#protected-functions","title":"Protected Functions","text":"Type Name void CheckInitialSync (void)  void OnUdpProtocolEvent (UdpProtocol::Event &amp; e)  void PollUdpProtocolEvents (void)"},{"location":"GGPOUE4/class_spectator_backend/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_spectator_backend/#function-addlocalinput","title":"function AddLocalInput","text":"<pre><code>inline virtual GGPOErrorCode SpectatorBackend::AddLocalInput (\n    GGPOPlayerHandle player,\n    void * values,\n    int size\n) \n</code></pre> <p>Implements GGPOSession::AddLocalInput</p>"},{"location":"GGPOUE4/class_spectator_backend/#function-addplayer","title":"function AddPlayer","text":"<pre><code>inline virtual GGPOErrorCode SpectatorBackend::AddPlayer (\n    GGPOPlayer * player,\n    GGPOPlayerHandle * handle\n) \n</code></pre> <p>Implements GGPOSession::AddPlayer</p>"},{"location":"GGPOUE4/class_spectator_backend/#function-disconnectplayer","title":"function DisconnectPlayer","text":"<pre><code>inline virtual GGPOErrorCode SpectatorBackend::DisconnectPlayer (\n    GGPOPlayerHandle handle\n) \n</code></pre> <p>Implements GGPOSession::DisconnectPlayer</p>"},{"location":"GGPOUE4/class_spectator_backend/#function-dopoll","title":"function DoPoll","text":"<pre><code>virtual GGPOErrorCode SpectatorBackend::DoPoll (\n    int timeout\n) \n</code></pre> <p>Implements GGPOSession::DoPoll</p>"},{"location":"GGPOUE4/class_spectator_backend/#function-getnetworkstats","title":"function GetNetworkStats","text":"<pre><code>inline virtual GGPOErrorCode SpectatorBackend::GetNetworkStats (\n    FGGPONetworkStats * stats,\n    GGPOPlayerHandle handle\n) \n</code></pre> <p>Implements GGPOSession::GetNetworkStats</p>"},{"location":"GGPOUE4/class_spectator_backend/#function-incrementframe","title":"function IncrementFrame","text":"<pre><code>virtual GGPOErrorCode SpectatorBackend::IncrementFrame (\n    void\n) \n</code></pre> <p>Implements GGPOSession::IncrementFrame</p>"},{"location":"GGPOUE4/class_spectator_backend/#function-onmsg","title":"function OnMsg","text":"<pre><code>virtual void SpectatorBackend::OnMsg (\n    int connection_id,\n    UdpMsg * msg,\n    int len\n) \n</code></pre> <p>Implements Udp::Callbacks::OnMsg</p>"},{"location":"GGPOUE4/class_spectator_backend/#function-setdisconnectnotifystart","title":"function SetDisconnectNotifyStart","text":"<pre><code>inline virtual GGPOErrorCode SpectatorBackend::SetDisconnectNotifyStart (\n    int timeout\n) \n</code></pre> <p>Implements GGPOSession::SetDisconnectNotifyStart</p>"},{"location":"GGPOUE4/class_spectator_backend/#function-setdisconnecttimeout","title":"function SetDisconnectTimeout","text":"<pre><code>inline virtual GGPOErrorCode SpectatorBackend::SetDisconnectTimeout (\n    int timeout\n) \n</code></pre> <p>Implements GGPOSession::SetDisconnectTimeout</p>"},{"location":"GGPOUE4/class_spectator_backend/#function-setframedelay","title":"function SetFrameDelay","text":"<pre><code>inline virtual GGPOErrorCode SpectatorBackend::SetFrameDelay (\n    GGPOPlayerHandle player,\n    int delay\n) \n</code></pre> <p>Implements GGPOSession::SetFrameDelay</p>"},{"location":"GGPOUE4/class_spectator_backend/#function-spectatorbackend","title":"function SpectatorBackend","text":"<pre><code>SpectatorBackend::SpectatorBackend (\n    GGPOSessionCallbacks * cb,\n    const char * gamename,\n    ConnectionManager * connection_manager,\n    int num_players,\n    int input_size,\n    int connection_id\n) \n</code></pre>"},{"location":"GGPOUE4/class_spectator_backend/#function-syncinput","title":"function SyncInput","text":"<pre><code>virtual GGPOErrorCode SpectatorBackend::SyncInput (\n    void * values,\n    int size,\n    int * disconnect_flags\n) \n</code></pre> <p>Implements GGPOSession::SyncInput</p>"},{"location":"GGPOUE4/class_spectator_backend/#function-spectatorbackend_1","title":"function ~SpectatorBackend","text":"<pre><code>virtual SpectatorBackend::~SpectatorBackend () \n</code></pre>"},{"location":"GGPOUE4/class_spectator_backend/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"GGPOUE4/class_spectator_backend/#variable-_callbacks","title":"variable _callbacks","text":"<pre><code>GGPOSessionCallbacks SpectatorBackend::_callbacks;\n</code></pre>"},{"location":"GGPOUE4/class_spectator_backend/#variable-_host","title":"variable _host","text":"<pre><code>UdpProtocol SpectatorBackend::_host;\n</code></pre>"},{"location":"GGPOUE4/class_spectator_backend/#variable-_input_size","title":"variable _input_size","text":"<pre><code>int SpectatorBackend::_input_size;\n</code></pre>"},{"location":"GGPOUE4/class_spectator_backend/#variable-_inputs","title":"variable _inputs","text":"<pre><code>GameInput SpectatorBackend::_inputs[SPECTATOR_FRAME_BUFFER_SIZE];\n</code></pre>"},{"location":"GGPOUE4/class_spectator_backend/#variable-_next_input_to_send","title":"variable _next_input_to_send","text":"<pre><code>int SpectatorBackend::_next_input_to_send;\n</code></pre>"},{"location":"GGPOUE4/class_spectator_backend/#variable-_num_players","title":"variable _num_players","text":"<pre><code>int SpectatorBackend::_num_players;\n</code></pre>"},{"location":"GGPOUE4/class_spectator_backend/#variable-_poll","title":"variable _poll","text":"<pre><code>Poll SpectatorBackend::_poll;\n</code></pre>"},{"location":"GGPOUE4/class_spectator_backend/#variable-_synchronizing","title":"variable _synchronizing","text":"<pre><code>bool SpectatorBackend::_synchronizing;\n</code></pre>"},{"location":"GGPOUE4/class_spectator_backend/#variable-_udp","title":"variable _udp","text":"<pre><code>Udp SpectatorBackend::_udp;\n</code></pre>"},{"location":"GGPOUE4/class_spectator_backend/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"GGPOUE4/class_spectator_backend/#function-checkinitialsync","title":"function CheckInitialSync","text":"<pre><code>void SpectatorBackend::CheckInitialSync (\n    void\n) \n</code></pre>"},{"location":"GGPOUE4/class_spectator_backend/#function-onudpprotocolevent","title":"function OnUdpProtocolEvent","text":"<pre><code>void SpectatorBackend::OnUdpProtocolEvent (\n    UdpProtocol::Event &amp; e\n) \n</code></pre>"},{"location":"GGPOUE4/class_spectator_backend/#function-polludpprotocolevents","title":"function PollUdpProtocolEvents","text":"<pre><code>void SpectatorBackend::PollUdpProtocolEvents (\n    void\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/spectator.h</code></p>"},{"location":"GGPOUE4/class_static_buffer/","title":"Class StaticBuffer","text":"<p>template &lt;class T, int N&gt;</p> <p>ClassList &gt; StaticBuffer</p>"},{"location":"GGPOUE4/class_static_buffer/#public-functions","title":"Public Functions","text":"Type Name StaticBuffer ()  T &amp; operator[] (int i)  void push_back (const T &amp; t)  int size ()"},{"location":"GGPOUE4/class_static_buffer/#protected-attributes","title":"Protected Attributes","text":"Type Name T _elements int _size"},{"location":"GGPOUE4/class_static_buffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_static_buffer/#function-staticbuffer","title":"function StaticBuffer","text":"<pre><code>inline StaticBuffer::StaticBuffer () \n</code></pre>"},{"location":"GGPOUE4/class_static_buffer/#function-operator","title":"function operator[]","text":"<pre><code>inline T &amp; StaticBuffer::operator[] (\n    int i\n) \n</code></pre>"},{"location":"GGPOUE4/class_static_buffer/#function-push_back","title":"function push_back","text":"<pre><code>inline void StaticBuffer::push_back (\n    const T &amp; t\n) \n</code></pre>"},{"location":"GGPOUE4/class_static_buffer/#function-size","title":"function size","text":"<pre><code>inline int StaticBuffer::size () \n</code></pre>"},{"location":"GGPOUE4/class_static_buffer/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"GGPOUE4/class_static_buffer/#variable-_elements","title":"variable _elements","text":"<pre><code>T StaticBuffer&lt; T, N &gt;::_elements[N];\n</code></pre>"},{"location":"GGPOUE4/class_static_buffer/#variable-_size","title":"variable _size","text":"<pre><code>int StaticBuffer&lt; T, N &gt;::_size;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/static_buffer.h</code></p>"},{"location":"GGPOUE4/class_sync/","title":"Class Sync","text":"<p>ClassList &gt; Sync</p>"},{"location":"GGPOUE4/class_sync/#classes","title":"Classes","text":"Type Name struct Config struct Event"},{"location":"GGPOUE4/class_sync/#public-functions","title":"Public Functions","text":"Type Name bool AddLocalInput (int queue, GameInput &amp; input)  void AddRemoteInput (int queue, GameInput &amp; input)  void AdjustSimulation (int seek_to)  void CheckSimulation (int timeout)  int GetConfirmedInputs (void * values, int size, int frame)  bool GetEvent (Event &amp; e)  int GetFrameCount ()  bool InRollback ()  void IncrementFrame (void)  void Init (Config &amp; config)  void SetFrameDelay (int queue, int delay)  void SetLastConfirmedFrame (int frame)  Sync (UdpMsg::connect_status * connect_status)  int SynchronizeInputs (void * values, int size)  virtual ~Sync ()"},{"location":"GGPOUE4/class_sync/#protected-attributes","title":"Protected Attributes","text":"Type Name friend SyncTestBackend GGPOSessionCallbacks _callbacks Config _config RingBuffer&lt; Event, 32 &gt; _event_queue int _framecount InputQueue * _input_queues int _last_confirmed_frame UdpMsg::connect_status * _local_connect_status int _max_prediction_frames bool _rollingback SavedState _savedstate"},{"location":"GGPOUE4/class_sync/#protected-functions","title":"Protected Functions","text":"Type Name bool CheckSimulationConsistency (int * seekTo)  bool CreateQueues (Config &amp; config)  int FindSavedFrameIndex (int frame)  SavedFrame &amp; GetLastSavedFrame ()  void LoadFrame (int frame)  void ResetPrediction (int frameNumber)  void SaveCurrentFrame ()"},{"location":"GGPOUE4/class_sync/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_sync/#function-addlocalinput","title":"function AddLocalInput","text":"<pre><code>bool Sync::AddLocalInput (\n    int queue,\n    GameInput &amp; input\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-addremoteinput","title":"function AddRemoteInput","text":"<pre><code>void Sync::AddRemoteInput (\n    int queue,\n    GameInput &amp; input\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-adjustsimulation","title":"function AdjustSimulation","text":"<pre><code>void Sync::AdjustSimulation (\n    int seek_to\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-checksimulation","title":"function CheckSimulation","text":"<pre><code>void Sync::CheckSimulation (\n    int timeout\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-getconfirmedinputs","title":"function GetConfirmedInputs","text":"<pre><code>int Sync::GetConfirmedInputs (\n    void * values,\n    int size,\n    int frame\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-getevent","title":"function GetEvent","text":"<pre><code>bool Sync::GetEvent (\n    Event &amp; e\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-getframecount","title":"function GetFrameCount","text":"<pre><code>inline int Sync::GetFrameCount () \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-inrollback","title":"function InRollback","text":"<pre><code>inline bool Sync::InRollback () \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-incrementframe","title":"function IncrementFrame","text":"<pre><code>void Sync::IncrementFrame (\n    void\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-init","title":"function Init","text":"<pre><code>void Sync::Init (\n    Config &amp; config\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-setframedelay","title":"function SetFrameDelay","text":"<pre><code>void Sync::SetFrameDelay (\n    int queue,\n    int delay\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-setlastconfirmedframe","title":"function SetLastConfirmedFrame","text":"<pre><code>void Sync::SetLastConfirmedFrame (\n    int frame\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-sync","title":"function Sync","text":"<pre><code>Sync::Sync (\n    UdpMsg::connect_status * connect_status\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-synchronizeinputs","title":"function SynchronizeInputs","text":"<pre><code>int Sync::SynchronizeInputs (\n    void * values,\n    int size\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-sync_1","title":"function ~Sync","text":"<pre><code>virtual Sync::~Sync () \n</code></pre>"},{"location":"GGPOUE4/class_sync/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"GGPOUE4/class_sync/#variable-synctestbackend","title":"variable SyncTestBackend","text":"<pre><code>friend Sync::SyncTestBackend;\n</code></pre>"},{"location":"GGPOUE4/class_sync/#variable-_callbacks","title":"variable _callbacks","text":"<pre><code>GGPOSessionCallbacks Sync::_callbacks;\n</code></pre>"},{"location":"GGPOUE4/class_sync/#variable-_config","title":"variable _config","text":"<pre><code>Config Sync::_config;\n</code></pre>"},{"location":"GGPOUE4/class_sync/#variable-_event_queue","title":"variable _event_queue","text":"<pre><code>RingBuffer&lt;Event, 32&gt; Sync::_event_queue;\n</code></pre>"},{"location":"GGPOUE4/class_sync/#variable-_framecount","title":"variable _framecount","text":"<pre><code>int Sync::_framecount;\n</code></pre>"},{"location":"GGPOUE4/class_sync/#variable-_input_queues","title":"variable _input_queues","text":"<pre><code>InputQueue* Sync::_input_queues;\n</code></pre>"},{"location":"GGPOUE4/class_sync/#variable-_last_confirmed_frame","title":"variable _last_confirmed_frame","text":"<pre><code>int Sync::_last_confirmed_frame;\n</code></pre>"},{"location":"GGPOUE4/class_sync/#variable-_local_connect_status","title":"variable _local_connect_status","text":"<pre><code>UdpMsg::connect_status* Sync::_local_connect_status;\n</code></pre>"},{"location":"GGPOUE4/class_sync/#variable-_max_prediction_frames","title":"variable _max_prediction_frames","text":"<pre><code>int Sync::_max_prediction_frames;\n</code></pre>"},{"location":"GGPOUE4/class_sync/#variable-_rollingback","title":"variable _rollingback","text":"<pre><code>bool Sync::_rollingback;\n</code></pre>"},{"location":"GGPOUE4/class_sync/#variable-_savedstate","title":"variable _savedstate","text":"<pre><code>SavedState Sync::_savedstate;\n</code></pre>"},{"location":"GGPOUE4/class_sync/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"GGPOUE4/class_sync/#function-checksimulationconsistency","title":"function CheckSimulationConsistency","text":"<pre><code>bool Sync::CheckSimulationConsistency (\n    int * seekTo\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-createqueues","title":"function CreateQueues","text":"<pre><code>bool Sync::CreateQueues (\n    Config &amp; config\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-findsavedframeindex","title":"function FindSavedFrameIndex","text":"<pre><code>int Sync::FindSavedFrameIndex (\n    int frame\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-getlastsavedframe","title":"function GetLastSavedFrame","text":"<pre><code>SavedFrame &amp; Sync::GetLastSavedFrame () \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-loadframe","title":"function LoadFrame","text":"<pre><code>void Sync::LoadFrame (\n    int frame\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-resetprediction","title":"function ResetPrediction","text":"<pre><code>void Sync::ResetPrediction (\n    int frameNumber\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync/#function-savecurrentframe","title":"function SaveCurrentFrame","text":"<pre><code>void Sync::SaveCurrentFrame () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/sync.h</code></p>"},{"location":"GGPOUE4/struct_sync_1_1_config/","title":"Struct Sync::Config","text":"<p>ClassList &gt; Sync &gt; Config</p>"},{"location":"GGPOUE4/struct_sync_1_1_config/#public-attributes","title":"Public Attributes","text":"Type Name GGPOSessionCallbacks callbacks int input_size int num_players int num_prediction_frames"},{"location":"GGPOUE4/struct_sync_1_1_config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_sync_1_1_config/#variable-callbacks","title":"variable callbacks","text":"<pre><code>GGPOSessionCallbacks Sync::Config::callbacks;\n</code></pre>"},{"location":"GGPOUE4/struct_sync_1_1_config/#variable-input_size","title":"variable input_size","text":"<pre><code>int Sync::Config::input_size;\n</code></pre>"},{"location":"GGPOUE4/struct_sync_1_1_config/#variable-num_players","title":"variable num_players","text":"<pre><code>int Sync::Config::num_players;\n</code></pre>"},{"location":"GGPOUE4/struct_sync_1_1_config/#variable-num_prediction_frames","title":"variable num_prediction_frames","text":"<pre><code>int Sync::Config::num_prediction_frames;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/sync.h</code></p>"},{"location":"GGPOUE4/struct_sync_1_1_event/","title":"Struct Sync::Event","text":"<p>ClassList &gt; Sync &gt; Event</p>"},{"location":"GGPOUE4/struct_sync_1_1_event/#public-types","title":"Public Types","text":"Type Name enum Event"},{"location":"GGPOUE4/struct_sync_1_1_event/#public-attributes","title":"Public Attributes","text":"Type Name struct Sync::Event confirmedInput GameInput input enum Sync::Event type union Sync::Event u"},{"location":"GGPOUE4/struct_sync_1_1_event/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"GGPOUE4/struct_sync_1_1_event/#enum-event","title":"enum Event","text":"<pre><code>enum Sync::Event::Event {\n    ConfirmedInput\n};\n</code></pre>"},{"location":"GGPOUE4/struct_sync_1_1_event/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_sync_1_1_event/#variable-confirmedinput","title":"variable confirmedInput","text":"<pre><code>struct Sync::Event Sync::Event::confirmedInput;\n</code></pre>"},{"location":"GGPOUE4/struct_sync_1_1_event/#variable-input","title":"variable input","text":"<pre><code>GameInput Sync::Event::input;\n</code></pre>"},{"location":"GGPOUE4/struct_sync_1_1_event/#variable-type","title":"variable type","text":"<pre><code>enum Sync::Event Sync::Event::type;\n</code></pre>"},{"location":"GGPOUE4/struct_sync_1_1_event/#variable-u","title":"variable u","text":"<pre><code>union Sync::Event Sync::Event::u;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/sync.h</code></p>"},{"location":"GGPOUE4/struct_sync_1_1_saved_frame/","title":"Struct Sync::SavedFrame","text":"<p>ClassList &gt; Sync &gt; SavedFrame</p>"},{"location":"GGPOUE4/struct_sync_1_1_saved_frame/#public-attributes","title":"Public Attributes","text":"Type Name byte * buf int cbuf int checksum int frame"},{"location":"GGPOUE4/struct_sync_1_1_saved_frame/#public-functions","title":"Public Functions","text":"Type Name SavedFrame ()"},{"location":"GGPOUE4/struct_sync_1_1_saved_frame/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_sync_1_1_saved_frame/#variable-buf","title":"variable buf","text":"<pre><code>byte* Sync::SavedFrame::buf;\n</code></pre>"},{"location":"GGPOUE4/struct_sync_1_1_saved_frame/#variable-cbuf","title":"variable cbuf","text":"<pre><code>int Sync::SavedFrame::cbuf;\n</code></pre>"},{"location":"GGPOUE4/struct_sync_1_1_saved_frame/#variable-checksum","title":"variable checksum","text":"<pre><code>int Sync::SavedFrame::checksum;\n</code></pre>"},{"location":"GGPOUE4/struct_sync_1_1_saved_frame/#variable-frame","title":"variable frame","text":"<pre><code>int Sync::SavedFrame::frame;\n</code></pre>"},{"location":"GGPOUE4/struct_sync_1_1_saved_frame/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/struct_sync_1_1_saved_frame/#function-savedframe","title":"function SavedFrame","text":"<pre><code>inline Sync::SavedFrame::SavedFrame () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/sync.h</code></p>"},{"location":"GGPOUE4/struct_sync_1_1_saved_state/","title":"Struct Sync::SavedState","text":"<p>ClassList &gt; Sync &gt; SavedState</p>"},{"location":"GGPOUE4/struct_sync_1_1_saved_state/#public-attributes","title":"Public Attributes","text":"Type Name SavedFrame frames int head"},{"location":"GGPOUE4/struct_sync_1_1_saved_state/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_sync_1_1_saved_state/#variable-frames","title":"variable frames","text":"<pre><code>SavedFrame Sync::SavedState::frames[MAX_PREDICTION_FRAMES+2];\n</code></pre>"},{"location":"GGPOUE4/struct_sync_1_1_saved_state/#variable-head","title":"variable head","text":"<pre><code>int Sync::SavedState::head;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/sync.h</code></p>"},{"location":"GGPOUE4/class_sync_test_backend/","title":"Class SyncTestBackend","text":"<p>ClassList &gt; SyncTestBackend</p> <p>Inherits the following classes: GGPOSession</p>"},{"location":"GGPOUE4/class_sync_test_backend/#public-functions","title":"Public Functions","text":"Type Name virtual GGPOErrorCode AddLocalInput (GGPOPlayerHandle player, void * values, int size)  virtual GGPOErrorCode AddPlayer (GGPOPlayer * player, GGPOPlayerHandle * handle)  virtual GGPOErrorCode DoPoll (int timeout)  virtual GGPOErrorCode IncrementFrame (void)  virtual GGPOErrorCode Logv (const char * fmt, va_list list) override virtual GGPOErrorCode SyncInput (void * values, int size, int * disconnect_flags)  SyncTestBackend (GGPOSessionCallbacks * cb, const char * gamename, int frames, int num_players)  virtual ~SyncTestBackend ()"},{"location":"GGPOUE4/class_sync_test_backend/#public-functions-inherited-from-ggposession","title":"Public Functions inherited from GGPOSession","text":"<p>See GGPOSession</p> Type Name virtual GGPOErrorCode AddLocalInput (GGPOPlayerHandle player, void * values, int size) = 0 virtual GGPOErrorCode AddPlayer (GGPOPlayer * player, GGPOPlayerHandle * handle) = 0 virtual GGPOErrorCode Chat (char * text)  virtual GGPOErrorCode DisconnectPlayer (GGPOPlayerHandle handle)  virtual GGPOErrorCode DoPoll (int timeout)  virtual GGPOErrorCode GetNetworkStats (FGGPONetworkStats * stats, GGPOPlayerHandle handle)  virtual GGPOErrorCode IncrementFrame (void)  virtual GGPOErrorCode Logv (const char * fmt, va_list list)  virtual GGPOErrorCode SetDisconnectNotifyStart (int timeout)  virtual GGPOErrorCode SetDisconnectTimeout (int timeout)  virtual GGPOErrorCode SetFrameDelay (GGPOPlayerHandle player, int delay)  virtual GGPOErrorCode SyncInput (void * values, int size, int * disconnect_flags) = 0 virtual GGPOErrorCode TrySynchronizeLocal ()  virtual ~GGPOSession ()"},{"location":"GGPOUE4/class_sync_test_backend/#protected-attributes","title":"Protected Attributes","text":"Type Name GGPOSessionCallbacks _callbacks int _check_distance GameInput _current_input char _game GameInput _last_input int _last_verified FILE * _logfp int _num_players bool _rollingback bool _running RingBuffer&lt; SavedInfo, 32 &gt; _saved_frames Sync _sync"},{"location":"GGPOUE4/class_sync_test_backend/#protected-functions","title":"Protected Functions","text":"Type Name void BeginLog (int saving)  void EndLog ()  void LogSaveStates (SavedInfo &amp; info)  void RaiseSyncError (const char * fmt, ...)"},{"location":"GGPOUE4/class_sync_test_backend/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_sync_test_backend/#function-addlocalinput","title":"function AddLocalInput","text":"<pre><code>virtual GGPOErrorCode SyncTestBackend::AddLocalInput (\n    GGPOPlayerHandle player,\n    void * values,\n    int size\n) \n</code></pre> <p>Implements GGPOSession::AddLocalInput</p>"},{"location":"GGPOUE4/class_sync_test_backend/#function-addplayer","title":"function AddPlayer","text":"<pre><code>virtual GGPOErrorCode SyncTestBackend::AddPlayer (\n    GGPOPlayer * player,\n    GGPOPlayerHandle * handle\n) \n</code></pre> <p>Implements GGPOSession::AddPlayer</p>"},{"location":"GGPOUE4/class_sync_test_backend/#function-dopoll","title":"function DoPoll","text":"<pre><code>virtual GGPOErrorCode SyncTestBackend::DoPoll (\n    int timeout\n) \n</code></pre> <p>Implements GGPOSession::DoPoll</p>"},{"location":"GGPOUE4/class_sync_test_backend/#function-incrementframe","title":"function IncrementFrame","text":"<pre><code>virtual GGPOErrorCode SyncTestBackend::IncrementFrame (\n    void\n) \n</code></pre> <p>Implements GGPOSession::IncrementFrame</p>"},{"location":"GGPOUE4/class_sync_test_backend/#function-logv","title":"function Logv","text":"<pre><code>virtual GGPOErrorCode SyncTestBackend::Logv (\n    const char * fmt,\n    va_list list\n) override\n</code></pre> <p>Implements GGPOSession::Logv</p>"},{"location":"GGPOUE4/class_sync_test_backend/#function-syncinput","title":"function SyncInput","text":"<pre><code>virtual GGPOErrorCode SyncTestBackend::SyncInput (\n    void * values,\n    int size,\n    int * disconnect_flags\n) \n</code></pre> <p>Implements GGPOSession::SyncInput</p>"},{"location":"GGPOUE4/class_sync_test_backend/#function-synctestbackend","title":"function SyncTestBackend","text":"<pre><code>SyncTestBackend::SyncTestBackend (\n    GGPOSessionCallbacks * cb,\n    const char * gamename,\n    int frames,\n    int num_players\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#function-synctestbackend_1","title":"function ~SyncTestBackend","text":"<pre><code>virtual SyncTestBackend::~SyncTestBackend () \n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"GGPOUE4/class_sync_test_backend/#variable-_callbacks","title":"variable _callbacks","text":"<pre><code>GGPOSessionCallbacks SyncTestBackend::_callbacks;\n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#variable-_check_distance","title":"variable _check_distance","text":"<pre><code>int SyncTestBackend::_check_distance;\n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#variable-_current_input","title":"variable _current_input","text":"<pre><code>GameInput SyncTestBackend::_current_input;\n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#variable-_game","title":"variable _game","text":"<pre><code>char SyncTestBackend::_game[128];\n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#variable-_last_input","title":"variable _last_input","text":"<pre><code>GameInput SyncTestBackend::_last_input;\n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#variable-_last_verified","title":"variable _last_verified","text":"<pre><code>int SyncTestBackend::_last_verified;\n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#variable-_logfp","title":"variable _logfp","text":"<pre><code>FILE* SyncTestBackend::_logfp;\n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#variable-_num_players","title":"variable _num_players","text":"<pre><code>int SyncTestBackend::_num_players;\n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#variable-_rollingback","title":"variable _rollingback","text":"<pre><code>bool SyncTestBackend::_rollingback;\n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#variable-_running","title":"variable _running","text":"<pre><code>bool SyncTestBackend::_running;\n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#variable-_saved_frames","title":"variable _saved_frames","text":"<pre><code>RingBuffer&lt;SavedInfo, 32&gt; SyncTestBackend::_saved_frames;\n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#variable-_sync","title":"variable _sync","text":"<pre><code>Sync SyncTestBackend::_sync;\n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"GGPOUE4/class_sync_test_backend/#function-beginlog","title":"function BeginLog","text":"<pre><code>void SyncTestBackend::BeginLog (\n    int saving\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#function-endlog","title":"function EndLog","text":"<pre><code>void SyncTestBackend::EndLog () \n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#function-logsavestates","title":"function LogSaveStates","text":"<pre><code>void SyncTestBackend::LogSaveStates (\n    SavedInfo &amp; info\n) \n</code></pre>"},{"location":"GGPOUE4/class_sync_test_backend/#function-raisesyncerror","title":"function RaiseSyncError","text":"<pre><code>void SyncTestBackend::RaiseSyncError (\n    const char * fmt,\n    ...\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/synctest.h</code></p>"},{"location":"GGPOUE4/struct_sync_test_backend_1_1_saved_info/","title":"Struct SyncTestBackend::SavedInfo","text":"<p>ClassList &gt; SyncTestBackend &gt; SavedInfo</p>"},{"location":"GGPOUE4/struct_sync_test_backend_1_1_saved_info/#public-attributes","title":"Public Attributes","text":"Type Name char * buf int cbuf int checksum int frame GameInput input"},{"location":"GGPOUE4/struct_sync_test_backend_1_1_saved_info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_sync_test_backend_1_1_saved_info/#variable-buf","title":"variable buf","text":"<pre><code>char* SyncTestBackend::SavedInfo::buf;\n</code></pre>"},{"location":"GGPOUE4/struct_sync_test_backend_1_1_saved_info/#variable-cbuf","title":"variable cbuf","text":"<pre><code>int SyncTestBackend::SavedInfo::cbuf;\n</code></pre>"},{"location":"GGPOUE4/struct_sync_test_backend_1_1_saved_info/#variable-checksum","title":"variable checksum","text":"<pre><code>int SyncTestBackend::SavedInfo::checksum;\n</code></pre>"},{"location":"GGPOUE4/struct_sync_test_backend_1_1_saved_info/#variable-frame","title":"variable frame","text":"<pre><code>int SyncTestBackend::SavedInfo::frame;\n</code></pre>"},{"location":"GGPOUE4/struct_sync_test_backend_1_1_saved_info/#variable-input","title":"variable input","text":"<pre><code>GameInput SyncTestBackend::SavedInfo::input;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/synctest.h</code></p>"},{"location":"GGPOUE4/class_time_sync/","title":"Class TimeSync","text":"<p>ClassList &gt; TimeSync</p>"},{"location":"GGPOUE4/class_time_sync/#public-functions","title":"Public Functions","text":"Type Name TimeSync ()  void advance_frame (GameInput &amp; input, int advantage, int radvantage)  int recommend_frame_wait_duration (bool require_idle_input)  virtual ~TimeSync ()"},{"location":"GGPOUE4/class_time_sync/#protected-attributes","title":"Protected Attributes","text":"Type Name GameInput _last_inputs int _local int _next_prediction int _remote"},{"location":"GGPOUE4/class_time_sync/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_time_sync/#function-timesync","title":"function TimeSync","text":"<pre><code>TimeSync::TimeSync () \n</code></pre>"},{"location":"GGPOUE4/class_time_sync/#function-advance_frame","title":"function advance_frame","text":"<pre><code>void TimeSync::advance_frame (\n    GameInput &amp; input,\n    int advantage,\n    int radvantage\n) \n</code></pre>"},{"location":"GGPOUE4/class_time_sync/#function-recommend_frame_wait_duration","title":"function recommend_frame_wait_duration","text":"<pre><code>int TimeSync::recommend_frame_wait_duration (\n    bool require_idle_input\n) \n</code></pre>"},{"location":"GGPOUE4/class_time_sync/#function-timesync_1","title":"function ~TimeSync","text":"<pre><code>virtual TimeSync::~TimeSync () \n</code></pre>"},{"location":"GGPOUE4/class_time_sync/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"GGPOUE4/class_time_sync/#variable-_last_inputs","title":"variable _last_inputs","text":"<pre><code>GameInput TimeSync::_last_inputs[MIN_UNIQUE_FRAMES];\n</code></pre>"},{"location":"GGPOUE4/class_time_sync/#variable-_local","title":"variable _local","text":"<pre><code>int TimeSync::_local[FRAME_WINDOW_SIZE];\n</code></pre>"},{"location":"GGPOUE4/class_time_sync/#variable-_next_prediction","title":"variable _next_prediction","text":"<pre><code>int TimeSync::_next_prediction;\n</code></pre>"},{"location":"GGPOUE4/class_time_sync/#variable-_remote","title":"variable _remote","text":"<pre><code>int TimeSync::_remote[FRAME_WINDOW_SIZE];\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/timesync.h</code></p>"},{"location":"GGPOUE4/class_u_g_g_p_o_game_instance/","title":"Class UGGPOGameInstance","text":"<p>ClassList &gt; UGGPOGameInstance</p> <p>Inherits the following classes: UGameInstance</p>"},{"location":"GGPOUE4/class_u_g_g_p_o_game_instance/#public-attributes","title":"Public Attributes","text":"Type Name UGGPONetwork * NetworkAddresses"},{"location":"GGPOUE4/class_u_g_g_p_o_game_instance/#public-functions","title":"Public Functions","text":"Type Name void CreateNetwork (int32 NumPlayers, int32 PlayerIndex, int32 LocalPort, TArray&lt; FString &gt; RemoteAddresses)"},{"location":"GGPOUE4/class_u_g_g_p_o_game_instance/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/class_u_g_g_p_o_game_instance/#variable-networkaddresses","title":"variable NetworkAddresses","text":"<pre><code>UGGPONetwork* UGGPOGameInstance::NetworkAddresses;\n</code></pre>"},{"location":"GGPOUE4/class_u_g_g_p_o_game_instance/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_u_g_g_p_o_game_instance/#function-createnetwork","title":"function CreateNetwork","text":"<pre><code>void UGGPOGameInstance::CreateNetwork (\n    int32 NumPlayers,\n    int32 PlayerIndex,\n    int32 LocalPort,\n    TArray&lt; FString &gt; RemoteAddresses\n) \n</code></pre> <p>Creates a collection of network addresses. </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/GGPOGameInstance.h</code></p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network/","title":"Class UGGPONetwork","text":"<p>ClassList &gt; UGGPONetwork</p> <p>More...</p> <ul> <li><code>#include &lt;ggponet.h&gt;</code></li> </ul> <p>Inherits the following classes: UObject</p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network/#public-functions","title":"Public Functions","text":"Type Name bool AllUniqueAddresses () const bool AllValidAddresses () const UGGPONetworkAddress * GetAddress (int32 Index) const int32 GetLocalPort () const int32 GetPlayerIndex () const int32 NumPlayers () const UGGPONetwork ()"},{"location":"GGPOUE4/class_u_g_g_p_o_network/#public-static-functions","title":"Public Static Functions","text":"Type Name UGGPONetwork * CreateNetwork (UObject * Outer, const FName Name, int32 NumPlayers, int32 PlayerIndex, int32 LocalPort, TArray&lt; FString &gt; RemoteAddresses)"},{"location":"GGPOUE4/class_u_g_g_p_o_network/#detailed-description","title":"Detailed Description","text":"<p>A collection of network addresses. </p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_u_g_g_p_o_network/#function-alluniqueaddresses","title":"function AllUniqueAddresses","text":"<pre><code>bool UGGPONetwork::AllUniqueAddresses () const\n</code></pre> <p>Returns whether all addresses are unique. </p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network/#function-allvalidaddresses","title":"function AllValidAddresses","text":"<pre><code>bool UGGPONetwork::AllValidAddresses () const\n</code></pre> <p>Returns whether all addresses are valid. </p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network/#function-getaddress","title":"function GetAddress","text":"<pre><code>UGGPONetworkAddress * UGGPONetwork::GetAddress (\n    int32 Index\n) const\n</code></pre> <p>Gets one network address. </p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network/#function-getlocalport","title":"function GetLocalPort","text":"<pre><code>int32 UGGPONetwork::GetLocalPort () const\n</code></pre> <p>Gets the local port. </p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network/#function-getplayerindex","title":"function GetPlayerIndex","text":"<pre><code>int32 UGGPONetwork::GetPlayerIndex () const\n</code></pre> <p>Gets the local player index. </p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network/#function-numplayers","title":"function NumPlayers","text":"<pre><code>int32 UGGPONetwork::NumPlayers () const\n</code></pre> <p>Gets the total number of players on the network. </p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network/#function-uggponetwork","title":"function UGGPONetwork","text":"<pre><code>inline UGGPONetwork::UGGPONetwork () \n</code></pre>"},{"location":"GGPOUE4/class_u_g_g_p_o_network/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"GGPOUE4/class_u_g_g_p_o_network/#function-createnetwork","title":"function CreateNetwork","text":"<pre><code>static UGGPONetwork * UGGPONetwork::CreateNetwork (\n    UObject * Outer,\n    const FName Name,\n    int32 NumPlayers,\n    int32 PlayerIndex,\n    int32 LocalPort,\n    TArray&lt; FString &gt; RemoteAddresses\n) \n</code></pre> <p>Creates a collection of network addresses. </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/ggponet.h</code></p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network_address/","title":"Class UGGPONetworkAddress","text":"<p>ClassList &gt; UGGPONetworkAddress</p> <p>More...</p> <ul> <li><code>#include &lt;ggponet.h&gt;</code></li> </ul> <p>Inherits the following classes: UObject</p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network_address/#public-functions","title":"Public Functions","text":"Type Name void GetIpAddress (char OutAddress) const FString GetIpAddressString () const int32 GetPort () const bool IsSameAddress (const UGGPONetworkAddress * Other) const bool IsValidAddress () const UGGPONetworkAddress ()"},{"location":"GGPOUE4/class_u_g_g_p_o_network_address/#public-static-functions","title":"Public Static Functions","text":"Type Name UGGPONetworkAddress * CreateLocalAddress (UObject * Outer, const FName Name, int32 LocalPort)  UGGPONetworkAddress * CreateNetworkAddress (UObject * Outer, const FName Name, const FString Address)"},{"location":"GGPOUE4/class_u_g_g_p_o_network_address/#detailed-description","title":"Detailed Description","text":"<p>A network address object. Composed of an ip address and a port. </p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network_address/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_u_g_g_p_o_network_address/#function-getipaddress","title":"function GetIpAddress","text":"<pre><code>void UGGPONetworkAddress::GetIpAddress (\n    char OutAddress\n) const\n</code></pre> <p>Outputs the ip address array to the passed pointer. </p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network_address/#function-getipaddressstring","title":"function GetIpAddressString","text":"<pre><code>FString UGGPONetworkAddress::GetIpAddressString () const\n</code></pre> <p>Gets the ip address as a string. </p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network_address/#function-getport","title":"function GetPort","text":"<pre><code>int32 UGGPONetworkAddress::GetPort () const\n</code></pre> <p>Gets the port. </p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network_address/#function-issameaddress","title":"function IsSameAddress","text":"<pre><code>bool UGGPONetworkAddress::IsSameAddress (\n    const UGGPONetworkAddress * Other\n) const\n</code></pre> <p>Gets the port. </p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network_address/#function-isvalidaddress","title":"function IsValidAddress","text":"<pre><code>bool UGGPONetworkAddress::IsValidAddress () const\n</code></pre> <p>Returns whether the address is valid. </p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network_address/#function-uggponetworkaddress","title":"function UGGPONetworkAddress","text":"<pre><code>inline UGGPONetworkAddress::UGGPONetworkAddress () \n</code></pre>"},{"location":"GGPOUE4/class_u_g_g_p_o_network_address/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"GGPOUE4/class_u_g_g_p_o_network_address/#function-createlocaladdress","title":"function CreateLocalAddress","text":"<pre><code>static UGGPONetworkAddress * UGGPONetworkAddress::CreateLocalAddress (\n    UObject * Outer,\n    const FName Name,\n    int32 LocalPort\n) \n</code></pre> <p>Creates a GGPO local address. </p>"},{"location":"GGPOUE4/class_u_g_g_p_o_network_address/#function-createnetworkaddress","title":"function CreateNetworkAddress","text":"<pre><code>static UGGPONetworkAddress * UGGPONetworkAddress::CreateNetworkAddress (\n    UObject * Outer,\n    const FName Name,\n    const FString Address\n) \n</code></pre> <p>Creates a GGPO network address. </p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/ggponet.h</code></p>"},{"location":"GGPOUE4/class_udp/","title":"Class Udp","text":"<p>ClassList &gt; Udp</p> <p>Inherits the following classes: IPollSink</p>"},{"location":"GGPOUE4/class_udp/#classes","title":"Classes","text":"Type Name struct Callbacks struct Stats"},{"location":"GGPOUE4/class_udp/#public-functions","title":"Public Functions","text":"Type Name void Init (Poll * p, Callbacks * callbacks, ConnectionManager * connection_manager)  virtual bool OnLoopPoll (void * cookie)  void SendTo (char * buffer, int len, int flags, int connection_id)  Udp ()  ~Udp (void)"},{"location":"GGPOUE4/class_udp/#public-functions-inherited-from-ipollsink","title":"Public Functions inherited from IPollSink","text":"<p>See IPollSink</p> Type Name virtual bool OnHandlePoll (void *)  virtual bool OnLoopPoll (void *)  virtual bool OnMsgPoll (void *)  virtual bool OnPeriodicPoll (void *, int)  virtual ~IPollSink ()"},{"location":"GGPOUE4/class_udp/#protected-attributes","title":"Protected Attributes","text":"Type Name Callbacks * _callbacks ConnectionManager * _connection_manager Poll * _poll"},{"location":"GGPOUE4/class_udp/#protected-functions","title":"Protected Functions","text":"Type Name void Log (const char * fmt, ...)"},{"location":"GGPOUE4/class_udp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_udp/#function-init","title":"function Init","text":"<pre><code>void Udp::Init (\n    Poll * p,\n    Callbacks * callbacks,\n    ConnectionManager * connection_manager\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp/#function-onlooppoll","title":"function OnLoopPoll","text":"<pre><code>virtual bool Udp::OnLoopPoll (\n    void * cookie\n) \n</code></pre> <p>Implements IPollSink::OnLoopPoll</p>"},{"location":"GGPOUE4/class_udp/#function-sendto","title":"function SendTo","text":"<pre><code>void Udp::SendTo (\n    char * buffer,\n    int len,\n    int flags,\n    int connection_id\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp/#function-udp","title":"function Udp","text":"<pre><code>Udp::Udp () \n</code></pre>"},{"location":"GGPOUE4/class_udp/#function-udp_1","title":"function ~Udp","text":"<pre><code>Udp::~Udp (\n    void\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"GGPOUE4/class_udp/#variable-_callbacks","title":"variable _callbacks","text":"<pre><code>Callbacks* Udp::_callbacks;\n</code></pre>"},{"location":"GGPOUE4/class_udp/#variable-_connection_manager","title":"variable _connection_manager","text":"<pre><code>ConnectionManager* Udp::_connection_manager;\n</code></pre>"},{"location":"GGPOUE4/class_udp/#variable-_poll","title":"variable _poll","text":"<pre><code>Poll* Udp::_poll;\n</code></pre>"},{"location":"GGPOUE4/class_udp/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"GGPOUE4/class_udp/#function-log","title":"function Log","text":"<pre><code>void Udp::Log (\n    const char * fmt,\n    ...\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp.h</code></p>"},{"location":"GGPOUE4/struct_udp_1_1_callbacks/","title":"Struct Udp::Callbacks","text":"<p>ClassList &gt; Udp &gt; Callbacks</p> <p>Inherited by the following classes: Peer2PeerBackend,  SpectatorBackend</p>"},{"location":"GGPOUE4/struct_udp_1_1_callbacks/#public-functions","title":"Public Functions","text":"Type Name virtual void OnMsg (int connection_id, UdpMsg * msg, int len) = 0 virtual ~Callbacks ()"},{"location":"GGPOUE4/struct_udp_1_1_callbacks/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/struct_udp_1_1_callbacks/#function-onmsg","title":"function OnMsg","text":"<pre><code>virtual void Udp::Callbacks::OnMsg (\n    int connection_id,\n    UdpMsg * msg,\n    int len\n) = 0\n</code></pre>"},{"location":"GGPOUE4/struct_udp_1_1_callbacks/#function-callbacks","title":"function ~Callbacks","text":"<pre><code>inline virtual Udp::Callbacks::~Callbacks () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp.h</code></p>"},{"location":"GGPOUE4/struct_udp_1_1_stats/","title":"Struct Udp::Stats","text":"<p>ClassList &gt; Udp &gt; Stats</p>"},{"location":"GGPOUE4/struct_udp_1_1_stats/#public-attributes","title":"Public Attributes","text":"Type Name int bytes_sent float kbps_sent int packets_sent"},{"location":"GGPOUE4/struct_udp_1_1_stats/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_udp_1_1_stats/#variable-bytes_sent","title":"variable bytes_sent","text":"<pre><code>int Udp::Stats::bytes_sent;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_1_1_stats/#variable-kbps_sent","title":"variable kbps_sent","text":"<pre><code>float Udp::Stats::kbps_sent;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_1_1_stats/#variable-packets_sent","title":"variable packets_sent","text":"<pre><code>int Udp::Stats::packets_sent;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp.h</code></p>"},{"location":"GGPOUE4/struct_udp_msg/","title":"Struct UdpMsg","text":"<p>ClassList &gt; UdpMsg</p>"},{"location":"GGPOUE4/struct_udp_msg/#classes","title":"Classes","text":"Type Name struct connect_status"},{"location":"GGPOUE4/struct_udp_msg/#public-types","title":"Public Types","text":"Type Name enum MsgType"},{"location":"GGPOUE4/struct_udp_msg/#public-attributes","title":"Public Attributes","text":"Type Name int ack_frame uint8 bits int disconnect_requested int8 frame_advantage struct UdpMsg hdr struct UdpMsg input struct UdpMsg input_ack uint8 input_size uint16 magic uint16 num_bits connect_status peer_connect_status uint32 ping uint32 pong struct UdpMsg quality_reply struct UdpMsg quality_report uint32 random_reply uint32 random_request uint8 remote_endpoint uint16 remote_magic uint16 sequence_number uint32 start_frame struct UdpMsg sync_reply struct UdpMsg sync_request uint8 type union UdpMsg u"},{"location":"GGPOUE4/struct_udp_msg/#public-functions","title":"Public Functions","text":"Type Name int PacketSize ()  int PayloadSize ()  UdpMsg (MsgType t)"},{"location":"GGPOUE4/struct_udp_msg/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"GGPOUE4/struct_udp_msg/#enum-msgtype","title":"enum MsgType","text":"<pre><code>enum UdpMsg::MsgType {\n    Invalid = 0,\n    SyncRequest = 1,\n    SyncReply = 2,\n    Input = 3,\n    QualityReport = 4,\n    QualityReply = 5,\n    KeepAlive = 6,\n    InputAck = 7\n};\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_udp_msg/#variable-ack_frame","title":"variable ack_frame","text":"<pre><code>int UdpMsg::ack_frame;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-bits","title":"variable bits","text":"<pre><code>uint8 UdpMsg::bits[MAX_COMPRESSED_BITS];\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-disconnect_requested","title":"variable disconnect_requested","text":"<pre><code>int UdpMsg::disconnect_requested;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-frame_advantage","title":"variable frame_advantage","text":"<pre><code>int8 UdpMsg::frame_advantage;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-hdr","title":"variable hdr","text":"<pre><code>struct UdpMsg UdpMsg::hdr;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-input","title":"variable input","text":"<pre><code>struct UdpMsg UdpMsg::input;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-input_ack","title":"variable input_ack","text":"<pre><code>struct UdpMsg UdpMsg::input_ack;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-input_size","title":"variable input_size","text":"<pre><code>uint8 UdpMsg::input_size;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-magic","title":"variable magic","text":"<pre><code>uint16 UdpMsg::magic;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-num_bits","title":"variable num_bits","text":"<pre><code>uint16 UdpMsg::num_bits;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-peer_connect_status","title":"variable peer_connect_status","text":"<pre><code>connect_status UdpMsg::peer_connect_status[UDP_MSG_MAX_PLAYERS];\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-ping","title":"variable ping","text":"<pre><code>uint32 UdpMsg::ping;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-pong","title":"variable pong","text":"<pre><code>uint32 UdpMsg::pong;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-quality_reply","title":"variable quality_reply","text":"<pre><code>struct UdpMsg UdpMsg::quality_reply;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-quality_report","title":"variable quality_report","text":"<pre><code>struct UdpMsg UdpMsg::quality_report;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-random_reply","title":"variable random_reply","text":"<pre><code>uint32 UdpMsg::random_reply;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-random_request","title":"variable random_request","text":"<pre><code>uint32 UdpMsg::random_request;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-remote_endpoint","title":"variable remote_endpoint","text":"<pre><code>uint8 UdpMsg::remote_endpoint;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-remote_magic","title":"variable remote_magic","text":"<pre><code>uint16 UdpMsg::remote_magic;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-sequence_number","title":"variable sequence_number","text":"<pre><code>uint16 UdpMsg::sequence_number;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-start_frame","title":"variable start_frame","text":"<pre><code>uint32 UdpMsg::start_frame;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-sync_reply","title":"variable sync_reply","text":"<pre><code>struct UdpMsg UdpMsg::sync_reply;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-sync_request","title":"variable sync_request","text":"<pre><code>struct UdpMsg UdpMsg::sync_request;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-type","title":"variable type","text":"<pre><code>uint8 UdpMsg::type;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#variable-u","title":"variable u","text":"<pre><code>union UdpMsg UdpMsg::u;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/struct_udp_msg/#function-packetsize","title":"function PacketSize","text":"<pre><code>inline int UdpMsg::PacketSize () \n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#function-payloadsize","title":"function PayloadSize","text":"<pre><code>inline int UdpMsg::PayloadSize () \n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg/#function-udpmsg","title":"function UdpMsg","text":"<pre><code>inline UdpMsg::UdpMsg (\n    MsgType t\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp_msg.h</code></p>"},{"location":"GGPOUE4/struct_udp_msg_1_1connect__status/","title":"Struct UdpMsg::connect_status","text":"<p>ClassList &gt; UdpMsg &gt; connect_status</p>"},{"location":"GGPOUE4/struct_udp_msg_1_1connect__status/#public-attributes","title":"Public Attributes","text":"Type Name unsigned int disconnected int last_frame"},{"location":"GGPOUE4/struct_udp_msg_1_1connect__status/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_udp_msg_1_1connect__status/#variable-disconnected","title":"variable disconnected","text":"<pre><code>unsigned int UdpMsg::connect_status::disconnected;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_msg_1_1connect__status/#variable-last_frame","title":"variable last_frame","text":"<pre><code>int UdpMsg::connect_status::last_frame;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp_msg.h</code></p>"},{"location":"GGPOUE4/class_udp_protocol/","title":"Class UdpProtocol","text":"<p>ClassList &gt; UdpProtocol</p> <p>Inherits the following classes: IPollSink</p>"},{"location":"GGPOUE4/class_udp_protocol/#classes","title":"Classes","text":"Type Name struct Event struct Stats"},{"location":"GGPOUE4/class_udp_protocol/#public-attributes","title":"Public Attributes","text":"Type Name int connection_id uint32 last_input_packet_recv_time uint32 last_network_stats_interval uint32 last_quality_report_time UdpMsg * msg uint32 random uint32 roundtrips_remaining struct UdpProtocol running int send_time struct UdpProtocol sync"},{"location":"GGPOUE4/class_udp_protocol/#public-functions","title":"Public Functions","text":"Type Name void Disconnect ()  void GGPONetworkStats (Stats * stats)  bool GetEvent (UdpProtocol::Event &amp; e)  void GetNetworkStats (struct FGGPONetworkStats * stats)  bool GetPeerConnectStatus (int id, int * frame)  bool HandlesMsg (int connection_id, UdpMsg * msg)  void Init (Udp * udp, Poll &amp; p, int queue, int connection_id, UdpMsg::connect_status * status)  bool IsInitialized ()  bool IsRunning ()  bool IsSynchronized ()  virtual bool OnLoopPoll (void * cookie)  void OnMsg (UdpMsg * msg, int len)  int RecommendFrameDelay ()  void SendInput (GameInput &amp; input)  void SendInputAck ()  void SetDisconnectNotifyStart (int timeout)  void SetDisconnectTimeout (int timeout)  void SetLocalFrameNumber (int num)  void Synchronize ()  UdpProtocol ()  virtual ~UdpProtocol ()"},{"location":"GGPOUE4/class_udp_protocol/#public-functions-inherited-from-ipollsink","title":"Public Functions inherited from IPollSink","text":"<p>See IPollSink</p> Type Name virtual bool OnHandlePoll (void *)  virtual bool OnLoopPoll (void *)  virtual bool OnMsgPoll (void *)  virtual bool OnPeriodicPoll (void *, int)  virtual ~IPollSink ()"},{"location":"GGPOUE4/class_udp_protocol/#protected-types","title":"Protected Types","text":"Type Name enum State"},{"location":"GGPOUE4/class_udp_protocol/#protected-attributes","title":"Protected Attributes","text":"Type Name int _bytes_sent bool _connected int _connection_id State _current_state unsigned int _disconnect_event_sent bool _disconnect_notify_sent unsigned int _disconnect_notify_start unsigned int _disconnect_timeout RingBuffer&lt; UdpProtocol::Event, 64 &gt; _event_queue int _kbps_sent GameInput _last_acked_input GameInput _last_received_input unsigned int _last_recv_time unsigned int _last_send_time GameInput _last_sent_input UdpMsg::connect_status * _local_connect_status int _local_frame_advantage uint16 _magic_number uint16 _next_recv_seq uint16 _next_send_seq struct UdpProtocol _oo_packet int _oop_percent int _packets_sent UdpMsg::connect_status _peer_connect_status RingBuffer&lt; GameInput, 64 &gt; _pending_output int _queue int _remote_frame_advantage uint16 _remote_magic_number int _round_trip_time int _send_latency RingBuffer&lt; QueueEntry, 64 &gt; _send_queue unsigned int _shutdown_timeout union UdpProtocol _state int _stats_start_time TimeSync _timesync Udp * _udp ConnectionManager * connection_manager"},{"location":"GGPOUE4/class_udp_protocol/#protected-functions","title":"Protected Functions","text":"Type Name void ClearSendQueue (void)  bool CreateSocket (int retries)  void DispatchMsg (uint8 * buffer, int len)  void Log (const char * fmt, ...)  void LogEvent (const char * prefix, const UdpProtocol::Event &amp; evt)  void LogMsg (const char * prefix, UdpMsg * msg)  bool OnInput (UdpMsg * msg, int len)  bool OnInputAck (UdpMsg * msg, int len)  bool OnInvalid (UdpMsg * msg, int len)  bool OnKeepAlive (UdpMsg * msg, int len)  bool OnQualityReply (UdpMsg * msg, int len)  bool OnQualityReport (UdpMsg * msg, int len)  bool OnSyncReply (UdpMsg * msg, int len)  bool OnSyncRequest (UdpMsg * msg, int len)  void PumpSendQueue ()  void QueueEvent (const UdpProtocol::Event &amp; evt)  void SendMsg (UdpMsg * msg)  void SendPendingOutput ()  void SendSyncRequest ()  void UpdateNetworkStats (void)"},{"location":"GGPOUE4/class_udp_protocol/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/class_udp_protocol/#variable-connection_id","title":"variable connection_id","text":"<pre><code>int UdpProtocol::connection_id;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-last_input_packet_recv_time","title":"variable last_input_packet_recv_time","text":"<pre><code>uint32 UdpProtocol::last_input_packet_recv_time;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-last_network_stats_interval","title":"variable last_network_stats_interval","text":"<pre><code>uint32 UdpProtocol::last_network_stats_interval;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-last_quality_report_time","title":"variable last_quality_report_time","text":"<pre><code>uint32 UdpProtocol::last_quality_report_time;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-msg","title":"variable msg","text":"<pre><code>UdpMsg* UdpProtocol::msg;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-random","title":"variable random","text":"<pre><code>uint32 UdpProtocol::random;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-roundtrips_remaining","title":"variable roundtrips_remaining","text":"<pre><code>uint32 UdpProtocol::roundtrips_remaining;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-running","title":"variable running","text":"<pre><code>struct UdpProtocol UdpProtocol::running;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-send_time","title":"variable send_time","text":"<pre><code>int UdpProtocol::send_time;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-sync","title":"variable sync","text":"<pre><code>struct UdpProtocol UdpProtocol::sync;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/class_udp_protocol/#function-disconnect","title":"function Disconnect","text":"<pre><code>void UdpProtocol::Disconnect () \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-ggponetworkstats","title":"function GGPONetworkStats","text":"<pre><code>void UdpProtocol::GGPONetworkStats (\n    Stats * stats\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-getevent","title":"function GetEvent","text":"<pre><code>bool UdpProtocol::GetEvent (\n    UdpProtocol::Event &amp; e\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-getnetworkstats","title":"function GetNetworkStats","text":"<pre><code>void UdpProtocol::GetNetworkStats (\n    struct FGGPONetworkStats * stats\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-getpeerconnectstatus","title":"function GetPeerConnectStatus","text":"<pre><code>bool UdpProtocol::GetPeerConnectStatus (\n    int id,\n    int * frame\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-handlesmsg","title":"function HandlesMsg","text":"<pre><code>bool UdpProtocol::HandlesMsg (\n    int connection_id,\n    UdpMsg * msg\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-init","title":"function Init","text":"<pre><code>void UdpProtocol::Init (\n    Udp * udp,\n    Poll &amp; p,\n    int queue,\n    int connection_id,\n    UdpMsg::connect_status * status\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-isinitialized","title":"function IsInitialized","text":"<pre><code>inline bool UdpProtocol::IsInitialized () \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-isrunning","title":"function IsRunning","text":"<pre><code>inline bool UdpProtocol::IsRunning () \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-issynchronized","title":"function IsSynchronized","text":"<pre><code>inline bool UdpProtocol::IsSynchronized () \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-onlooppoll","title":"function OnLoopPoll","text":"<pre><code>virtual bool UdpProtocol::OnLoopPoll (\n    void * cookie\n) \n</code></pre> <p>Implements IPollSink::OnLoopPoll</p>"},{"location":"GGPOUE4/class_udp_protocol/#function-onmsg","title":"function OnMsg","text":"<pre><code>void UdpProtocol::OnMsg (\n    UdpMsg * msg,\n    int len\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-recommendframedelay","title":"function RecommendFrameDelay","text":"<pre><code>int UdpProtocol::RecommendFrameDelay () \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-sendinput","title":"function SendInput","text":"<pre><code>void UdpProtocol::SendInput (\n    GameInput &amp; input\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-sendinputack","title":"function SendInputAck","text":"<pre><code>void UdpProtocol::SendInputAck () \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-setdisconnectnotifystart","title":"function SetDisconnectNotifyStart","text":"<pre><code>void UdpProtocol::SetDisconnectNotifyStart (\n    int timeout\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-setdisconnecttimeout","title":"function SetDisconnectTimeout","text":"<pre><code>void UdpProtocol::SetDisconnectTimeout (\n    int timeout\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-setlocalframenumber","title":"function SetLocalFrameNumber","text":"<pre><code>void UdpProtocol::SetLocalFrameNumber (\n    int num\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-synchronize","title":"function Synchronize","text":"<pre><code>void UdpProtocol::Synchronize () \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-udpprotocol","title":"function UdpProtocol","text":"<pre><code>UdpProtocol::UdpProtocol () \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-udpprotocol_1","title":"function ~UdpProtocol","text":"<pre><code>virtual UdpProtocol::~UdpProtocol () \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#protected-types-documentation","title":"Protected Types Documentation","text":""},{"location":"GGPOUE4/class_udp_protocol/#enum-state","title":"enum State","text":"<pre><code>enum UdpProtocol::State {\n    Syncing,\n    Synchronzied,\n    Running,\n    Disconnected\n};\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"GGPOUE4/class_udp_protocol/#variable-_bytes_sent","title":"variable _bytes_sent","text":"<pre><code>int UdpProtocol::_bytes_sent;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_connected","title":"variable _connected","text":"<pre><code>bool UdpProtocol::_connected;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_connection_id","title":"variable _connection_id","text":"<pre><code>int UdpProtocol::_connection_id;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_current_state","title":"variable _current_state","text":"<pre><code>State UdpProtocol::_current_state;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_disconnect_event_sent","title":"variable _disconnect_event_sent","text":"<pre><code>unsigned int UdpProtocol::_disconnect_event_sent;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_disconnect_notify_sent","title":"variable _disconnect_notify_sent","text":"<pre><code>bool UdpProtocol::_disconnect_notify_sent;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_disconnect_notify_start","title":"variable _disconnect_notify_start","text":"<pre><code>unsigned int UdpProtocol::_disconnect_notify_start;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_disconnect_timeout","title":"variable _disconnect_timeout","text":"<pre><code>unsigned int UdpProtocol::_disconnect_timeout;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_event_queue","title":"variable _event_queue","text":"<pre><code>RingBuffer&lt;UdpProtocol::Event, 64&gt; UdpProtocol::_event_queue;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_kbps_sent","title":"variable _kbps_sent","text":"<pre><code>int UdpProtocol::_kbps_sent;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_last_acked_input","title":"variable _last_acked_input","text":"<pre><code>GameInput UdpProtocol::_last_acked_input;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_last_received_input","title":"variable _last_received_input","text":"<pre><code>GameInput UdpProtocol::_last_received_input;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_last_recv_time","title":"variable _last_recv_time","text":"<pre><code>unsigned int UdpProtocol::_last_recv_time;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_last_send_time","title":"variable _last_send_time","text":"<pre><code>unsigned int UdpProtocol::_last_send_time;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_last_sent_input","title":"variable _last_sent_input","text":"<pre><code>GameInput UdpProtocol::_last_sent_input;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_local_connect_status","title":"variable _local_connect_status","text":"<pre><code>UdpMsg::connect_status* UdpProtocol::_local_connect_status;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_local_frame_advantage","title":"variable _local_frame_advantage","text":"<pre><code>int UdpProtocol::_local_frame_advantage;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_magic_number","title":"variable _magic_number","text":"<pre><code>uint16 UdpProtocol::_magic_number;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_next_recv_seq","title":"variable _next_recv_seq","text":"<pre><code>uint16 UdpProtocol::_next_recv_seq;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_next_send_seq","title":"variable _next_send_seq","text":"<pre><code>uint16 UdpProtocol::_next_send_seq;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_oo_packet","title":"variable _oo_packet","text":"<pre><code>struct UdpProtocol UdpProtocol::_oo_packet;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_oop_percent","title":"variable _oop_percent","text":"<pre><code>int UdpProtocol::_oop_percent;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_packets_sent","title":"variable _packets_sent","text":"<pre><code>int UdpProtocol::_packets_sent;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_peer_connect_status","title":"variable _peer_connect_status","text":"<pre><code>UdpMsg::connect_status UdpProtocol::_peer_connect_status[UDP_MSG_MAX_PLAYERS];\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_pending_output","title":"variable _pending_output","text":"<pre><code>RingBuffer&lt;GameInput, 64&gt; UdpProtocol::_pending_output;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_queue","title":"variable _queue","text":"<pre><code>int UdpProtocol::_queue;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_remote_frame_advantage","title":"variable _remote_frame_advantage","text":"<pre><code>int UdpProtocol::_remote_frame_advantage;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_remote_magic_number","title":"variable _remote_magic_number","text":"<pre><code>uint16 UdpProtocol::_remote_magic_number;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_round_trip_time","title":"variable _round_trip_time","text":"<pre><code>int UdpProtocol::_round_trip_time;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_send_latency","title":"variable _send_latency","text":"<pre><code>int UdpProtocol::_send_latency;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_send_queue","title":"variable _send_queue","text":"<pre><code>RingBuffer&lt;QueueEntry, 64&gt; UdpProtocol::_send_queue;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_shutdown_timeout","title":"variable _shutdown_timeout","text":"<pre><code>unsigned int UdpProtocol::_shutdown_timeout;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_state","title":"variable _state","text":"<pre><code>union UdpProtocol UdpProtocol::_state;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_stats_start_time","title":"variable _stats_start_time","text":"<pre><code>int UdpProtocol::_stats_start_time;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_timesync","title":"variable _timesync","text":"<pre><code>TimeSync UdpProtocol::_timesync;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-_udp","title":"variable _udp","text":"<pre><code>Udp* UdpProtocol::_udp;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#variable-connection_manager","title":"variable connection_manager","text":"<pre><code>ConnectionManager* UdpProtocol::connection_manager;\n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"GGPOUE4/class_udp_protocol/#function-clearsendqueue","title":"function ClearSendQueue","text":"<pre><code>void UdpProtocol::ClearSendQueue (\n    void\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-createsocket","title":"function CreateSocket","text":"<pre><code>bool UdpProtocol::CreateSocket (\n    int retries\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-dispatchmsg","title":"function DispatchMsg","text":"<pre><code>void UdpProtocol::DispatchMsg (\n    uint8 * buffer,\n    int len\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-log","title":"function Log","text":"<pre><code>void UdpProtocol::Log (\n    const char * fmt,\n    ...\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-logevent","title":"function LogEvent","text":"<pre><code>void UdpProtocol::LogEvent (\n    const char * prefix,\n    const UdpProtocol::Event &amp; evt\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-logmsg","title":"function LogMsg","text":"<pre><code>void UdpProtocol::LogMsg (\n    const char * prefix,\n    UdpMsg * msg\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-oninput","title":"function OnInput","text":"<pre><code>bool UdpProtocol::OnInput (\n    UdpMsg * msg,\n    int len\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-oninputack","title":"function OnInputAck","text":"<pre><code>bool UdpProtocol::OnInputAck (\n    UdpMsg * msg,\n    int len\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-oninvalid","title":"function OnInvalid","text":"<pre><code>bool UdpProtocol::OnInvalid (\n    UdpMsg * msg,\n    int len\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-onkeepalive","title":"function OnKeepAlive","text":"<pre><code>bool UdpProtocol::OnKeepAlive (\n    UdpMsg * msg,\n    int len\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-onqualityreply","title":"function OnQualityReply","text":"<pre><code>bool UdpProtocol::OnQualityReply (\n    UdpMsg * msg,\n    int len\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-onqualityreport","title":"function OnQualityReport","text":"<pre><code>bool UdpProtocol::OnQualityReport (\n    UdpMsg * msg,\n    int len\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-onsyncreply","title":"function OnSyncReply","text":"<pre><code>bool UdpProtocol::OnSyncReply (\n    UdpMsg * msg,\n    int len\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-onsyncrequest","title":"function OnSyncRequest","text":"<pre><code>bool UdpProtocol::OnSyncRequest (\n    UdpMsg * msg,\n    int len\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-pumpsendqueue","title":"function PumpSendQueue","text":"<pre><code>void UdpProtocol::PumpSendQueue () \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-queueevent","title":"function QueueEvent","text":"<pre><code>void UdpProtocol::QueueEvent (\n    const UdpProtocol::Event &amp; evt\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-sendmsg","title":"function SendMsg","text":"<pre><code>void UdpProtocol::SendMsg (\n    UdpMsg * msg\n) \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-sendpendingoutput","title":"function SendPendingOutput","text":"<pre><code>void UdpProtocol::SendPendingOutput () \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-sendsyncrequest","title":"function SendSyncRequest","text":"<pre><code>void UdpProtocol::SendSyncRequest () \n</code></pre>"},{"location":"GGPOUE4/class_udp_protocol/#function-updatenetworkstats","title":"function UpdateNetworkStats","text":"<pre><code>void UdpProtocol::UpdateNetworkStats (\n    void\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp_proto.h</code></p>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/","title":"Struct UdpProtocol::Event","text":"<p>ClassList &gt; UdpProtocol &gt; Event</p>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#public-types","title":"Public Types","text":"Type Name enum Type"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#public-attributes","title":"Public Attributes","text":"Type Name int count int disconnect_timeout GameInput input struct UdpProtocol::Event input struct UdpProtocol::Event network_interrupted struct UdpProtocol::Event synchronizing int total Type type union UdpProtocol::Event u"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#public-functions","title":"Public Functions","text":"Type Name Event (Type t=Unknown)"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#enum-type","title":"enum Type","text":"<pre><code>enum UdpProtocol::Event::Type {\n    Unknown = -1,\n    Connected,\n    Synchronizing,\n    Synchronzied,\n    Input,\n    Disconnected,\n    NetworkInterrupted,\n    NetworkResumed\n};\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#variable-count","title":"variable count","text":"<pre><code>int UdpProtocol::Event::count;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#variable-disconnect_timeout","title":"variable disconnect_timeout","text":"<pre><code>int UdpProtocol::Event::disconnect_timeout;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#variable-input-12","title":"variable input [1/2]","text":"<pre><code>GameInput UdpProtocol::Event::input;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#variable-input-22","title":"variable input [2/2]","text":"<pre><code>struct UdpProtocol::Event UdpProtocol::Event::input;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#variable-network_interrupted","title":"variable network_interrupted","text":"<pre><code>struct UdpProtocol::Event UdpProtocol::Event::network_interrupted;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#variable-synchronizing","title":"variable synchronizing","text":"<pre><code>struct UdpProtocol::Event UdpProtocol::Event::synchronizing;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#variable-total","title":"variable total","text":"<pre><code>int UdpProtocol::Event::total;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#variable-type","title":"variable type","text":"<pre><code>Type UdpProtocol::Event::type;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#variable-u","title":"variable u","text":"<pre><code>union UdpProtocol::Event UdpProtocol::Event::u;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/struct_udp_protocol_1_1_event/#function-event","title":"function Event","text":"<pre><code>inline UdpProtocol::Event::Event (\n    Type t=Unknown\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp_proto.h</code></p>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_queue_entry/","title":"Struct UdpProtocol::QueueEntry","text":"<p>ClassList &gt; UdpProtocol &gt; QueueEntry</p>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_queue_entry/#public-attributes","title":"Public Attributes","text":"Type Name int connection_id UdpMsg * msg int queue_time"},{"location":"GGPOUE4/struct_udp_protocol_1_1_queue_entry/#public-functions","title":"Public Functions","text":"Type Name QueueEntry ()  QueueEntry (int time, int conn_id, UdpMsg * m)"},{"location":"GGPOUE4/struct_udp_protocol_1_1_queue_entry/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_udp_protocol_1_1_queue_entry/#variable-connection_id","title":"variable connection_id","text":"<pre><code>int UdpProtocol::QueueEntry::connection_id;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_queue_entry/#variable-msg","title":"variable msg","text":"<pre><code>UdpMsg* UdpProtocol::QueueEntry::msg;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_queue_entry/#variable-queue_time","title":"variable queue_time","text":"<pre><code>int UdpProtocol::QueueEntry::queue_time;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_queue_entry/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/struct_udp_protocol_1_1_queue_entry/#function-queueentry-12","title":"function QueueEntry [1/2]","text":"<pre><code>inline UdpProtocol::QueueEntry::QueueEntry () \n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_queue_entry/#function-queueentry-22","title":"function QueueEntry [2/2]","text":"<pre><code>inline UdpProtocol::QueueEntry::QueueEntry (\n    int time,\n    int conn_id,\n    UdpMsg * m\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp_proto.h</code></p>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_stats/","title":"Struct UdpProtocol::Stats","text":"<p>ClassList &gt; UdpProtocol &gt; Stats</p>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_stats/#public-attributes","title":"Public Attributes","text":"Type Name int local_frame_advantage int ping int remote_frame_advantage int send_queue_len Udp::Stats udp"},{"location":"GGPOUE4/struct_udp_protocol_1_1_stats/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/struct_udp_protocol_1_1_stats/#variable-local_frame_advantage","title":"variable local_frame_advantage","text":"<pre><code>int UdpProtocol::Stats::local_frame_advantage;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_stats/#variable-ping","title":"variable ping","text":"<pre><code>int UdpProtocol::Stats::ping;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_stats/#variable-remote_frame_advantage","title":"variable remote_frame_advantage","text":"<pre><code>int UdpProtocol::Stats::remote_frame_advantage;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_stats/#variable-send_queue_len","title":"variable send_queue_len","text":"<pre><code>int UdpProtocol::Stats::send_queue_len;\n</code></pre>"},{"location":"GGPOUE4/struct_udp_protocol_1_1_stats/#variable-udp","title":"variable udp","text":"<pre><code>Udp::Stats UdpProtocol::Stats::udp;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp_proto.h</code></p>"},{"location":"GGPOUE4/structinternal__state/","title":"Struct internal_state","text":"<p>ClassList &gt; internal_state</p>"},{"location":"GGPOUE4/structinternal__state/#public-attributes","title":"Public Attributes","text":"Type Name int dummy"},{"location":"GGPOUE4/structinternal__state/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/structinternal__state/#variable-dummy","title":"variable dummy","text":"<pre><code>int internal_state::dummy;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/zlib.h</code></p>"},{"location":"GGPOUE4/namespaceneosmart/","title":"Namespace neosmart","text":"<p>Namespace List &gt; neosmart</p>"},{"location":"GGPOUE4/namespaceneosmart/#classes","title":"Classes","text":"Type Name struct neosmart_event_t_ struct neosmart_wfmo_info_t_ struct neosmart_wfmo_t_"},{"location":"GGPOUE4/namespaceneosmart/#public-types","title":"Public Types","text":"Type Name typedef neosmart_event_t_ * neosmart_event_t typedef neosmart_wfmo_info_t_ * neosmart_wfmo_info_t typedef neosmart_wfmo_t_ * neosmart_wfmo_t"},{"location":"GGPOUE4/namespaceneosmart/#public-functions","title":"Public Functions","text":"Type Name neosmart_event_t CreateEvent (bool manualReset, bool initialState)  int DestroyEvent (neosmart_event_t event)  bool RemoveExpiredWaitHelper (neosmart_wfmo_info_t_ wait)  int ResetEvent (neosmart_event_t event)  int SetEvent (neosmart_event_t event)  int UnlockedWaitForEvent (neosmart_event_t event, uint64_t milliseconds)  int WaitForEvent (neosmart_event_t event, uint64_t milliseconds)  int WaitForMultipleEvents (neosmart_event_t * events, int count, bool waitAll, uint64_t milliseconds)  int WaitForMultipleEvents (neosmart_event_t * events, int count, bool waitAll, uint64_t milliseconds, int &amp; waitIndex)"},{"location":"GGPOUE4/namespaceneosmart/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"GGPOUE4/namespaceneosmart/#typedef-neosmart_event_t","title":"typedef neosmart_event_t","text":"<pre><code>typedef neosmart_event_t_* neosmart::neosmart_event_t;\n</code></pre>"},{"location":"GGPOUE4/namespaceneosmart/#typedef-neosmart_wfmo_info_t","title":"typedef neosmart_wfmo_info_t","text":"<pre><code>typedef neosmart_wfmo_info_t_* neosmart::neosmart_wfmo_info_t;\n</code></pre>"},{"location":"GGPOUE4/namespaceneosmart/#typedef-neosmart_wfmo_t","title":"typedef neosmart_wfmo_t","text":"<pre><code>typedef neosmart_wfmo_t_* neosmart::neosmart_wfmo_t;\n</code></pre>"},{"location":"GGPOUE4/namespaceneosmart/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/namespaceneosmart/#function-createevent","title":"function CreateEvent","text":"<pre><code>neosmart_event_t neosmart::CreateEvent (\n    bool manualReset,\n    bool initialState\n) \n</code></pre>"},{"location":"GGPOUE4/namespaceneosmart/#function-destroyevent","title":"function DestroyEvent","text":"<pre><code>int neosmart::DestroyEvent (\n    neosmart_event_t event\n) \n</code></pre>"},{"location":"GGPOUE4/namespaceneosmart/#function-removeexpiredwaithelper","title":"function RemoveExpiredWaitHelper","text":"<pre><code>bool neosmart::RemoveExpiredWaitHelper (\n    neosmart_wfmo_info_t_ wait\n) \n</code></pre>"},{"location":"GGPOUE4/namespaceneosmart/#function-resetevent","title":"function ResetEvent","text":"<pre><code>int neosmart::ResetEvent (\n    neosmart_event_t event\n) \n</code></pre>"},{"location":"GGPOUE4/namespaceneosmart/#function-setevent","title":"function SetEvent","text":"<pre><code>int neosmart::SetEvent (\n    neosmart_event_t event\n) \n</code></pre>"},{"location":"GGPOUE4/namespaceneosmart/#function-unlockedwaitforevent","title":"function UnlockedWaitForEvent","text":"<pre><code>int neosmart::UnlockedWaitForEvent (\n    neosmart_event_t event,\n    uint64_t milliseconds\n) \n</code></pre>"},{"location":"GGPOUE4/namespaceneosmart/#function-waitforevent","title":"function WaitForEvent","text":"<pre><code>int neosmart::WaitForEvent (\n    neosmart_event_t event,\n    uint64_t milliseconds\n) \n</code></pre>"},{"location":"GGPOUE4/namespaceneosmart/#function-waitformultipleevents","title":"function WaitForMultipleEvents","text":"<pre><code>int neosmart::WaitForMultipleEvents (\n    neosmart_event_t * events,\n    int count,\n    bool waitAll,\n    uint64_t milliseconds\n) \n</code></pre>"},{"location":"GGPOUE4/namespaceneosmart/#function-waitformultipleevents_1","title":"function WaitForMultipleEvents","text":"<pre><code>int neosmart::WaitForMultipleEvents (\n    neosmart_event_t * events,\n    int count,\n    bool waitAll,\n    uint64_t milliseconds,\n    int &amp; waitIndex\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/pevents.cpp</code></p>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__event__t__/","title":"Struct neosmart::neosmart_event_t_","text":"<p>ClassList &gt; neosmart &gt; neosmart_event_t_</p>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__event__t__/#public-attributes","title":"Public Attributes","text":"Type Name bool AutoReset pthread_cond_t CVariable pthread_mutex_t Mutex std::deque&lt; neosmart_wfmo_info_t_ &gt; RegisteredWaits bool State"},{"location":"GGPOUE4/structneosmart_1_1neosmart__event__t__/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/structneosmart_1_1neosmart__event__t__/#variable-autoreset","title":"variable AutoReset","text":"<pre><code>bool neosmart::neosmart_event_t_::AutoReset;\n</code></pre>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__event__t__/#variable-cvariable","title":"variable CVariable","text":"<pre><code>pthread_cond_t neosmart::neosmart_event_t_::CVariable;\n</code></pre>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__event__t__/#variable-mutex","title":"variable Mutex","text":"<pre><code>pthread_mutex_t neosmart::neosmart_event_t_::Mutex;\n</code></pre>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__event__t__/#variable-registeredwaits","title":"variable RegisteredWaits","text":"<pre><code>std::deque&lt;neosmart_wfmo_info_t_&gt; neosmart::neosmart_event_t_::RegisteredWaits;\n</code></pre>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__event__t__/#variable-state","title":"variable State","text":"<pre><code>bool neosmart::neosmart_event_t_::State;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/pevents.cpp</code></p>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__info__t__/","title":"Struct neosmart::neosmart_wfmo_info_t_","text":"<p>ClassList &gt; neosmart &gt; neosmart_wfmo_info_t_</p>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__info__t__/#public-attributes","title":"Public Attributes","text":"Type Name int WaitIndex neosmart_wfmo_t Waiter"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__info__t__/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__info__t__/#variable-waitindex","title":"variable WaitIndex","text":"<pre><code>int neosmart::neosmart_wfmo_info_t_::WaitIndex;\n</code></pre>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__info__t__/#variable-waiter","title":"variable Waiter","text":"<pre><code>neosmart_wfmo_t neosmart::neosmart_wfmo_info_t_::Waiter;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/pevents.cpp</code></p>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__t__/","title":"Struct neosmart::neosmart_wfmo_t_","text":"<p>ClassList &gt; neosmart &gt; neosmart_wfmo_t_</p>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__t__/#public-attributes","title":"Public Attributes","text":"Type Name pthread_cond_t CVariable int EventsLeft int FiredEvent pthread_mutex_t Mutex int RefCount union neosmart::neosmart_wfmo_t_ Status bool StillWaiting bool WaitAll"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__t__/#public-functions","title":"Public Functions","text":"Type Name void Destroy ()"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__t__/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__t__/#variable-cvariable","title":"variable CVariable","text":"<pre><code>pthread_cond_t neosmart::neosmart_wfmo_t_::CVariable;\n</code></pre>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__t__/#variable-eventsleft","title":"variable EventsLeft","text":"<pre><code>int neosmart::neosmart_wfmo_t_::EventsLeft;\n</code></pre>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__t__/#variable-firedevent","title":"variable FiredEvent","text":"<pre><code>int neosmart::neosmart_wfmo_t_::FiredEvent;\n</code></pre>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__t__/#variable-mutex","title":"variable Mutex","text":"<pre><code>pthread_mutex_t neosmart::neosmart_wfmo_t_::Mutex;\n</code></pre>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__t__/#variable-refcount","title":"variable RefCount","text":"<pre><code>int neosmart::neosmart_wfmo_t_::RefCount;\n</code></pre>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__t__/#variable-status","title":"variable Status","text":"<pre><code>union neosmart::neosmart_wfmo_t_ neosmart::neosmart_wfmo_t_::Status;\n</code></pre>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__t__/#variable-stillwaiting","title":"variable StillWaiting","text":"<pre><code>bool neosmart::neosmart_wfmo_t_::StillWaiting;\n</code></pre>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__t__/#variable-waitall","title":"variable WaitAll","text":"<pre><code>bool neosmart::neosmart_wfmo_t_::WaitAll;\n</code></pre>"},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__t__/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/structneosmart_1_1neosmart__wfmo__t__/#function-destroy","title":"function Destroy","text":"<pre><code>inline void neosmart::neosmart_wfmo_t_::Destroy () \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/pevents.cpp</code></p>"},{"location":"GGPOUE4/structz__stream__s/","title":"Struct z_stream_s","text":"<p>ClassList &gt; z_stream_s</p>"},{"location":"GGPOUE4/structz__stream__s/#public-attributes","title":"Public Attributes","text":"Type Name uLong adler uInt avail_in uInt avail_out int data_type char * msg Bytef * next_in Bytef * next_out voidpf opaque uLong reserved struct internal_state FAR * state uLong total_in uLong total_out alloc_func zalloc free_func zfree"},{"location":"GGPOUE4/structz__stream__s/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"GGPOUE4/structz__stream__s/#variable-adler","title":"variable adler","text":"<pre><code>uLong z_stream_s::adler;\n</code></pre>"},{"location":"GGPOUE4/structz__stream__s/#variable-avail_in","title":"variable avail_in","text":"<pre><code>uInt z_stream_s::avail_in;\n</code></pre>"},{"location":"GGPOUE4/structz__stream__s/#variable-avail_out","title":"variable avail_out","text":"<pre><code>uInt z_stream_s::avail_out;\n</code></pre>"},{"location":"GGPOUE4/structz__stream__s/#variable-data_type","title":"variable data_type","text":"<pre><code>int z_stream_s::data_type;\n</code></pre>"},{"location":"GGPOUE4/structz__stream__s/#variable-msg","title":"variable msg","text":"<pre><code>char* z_stream_s::msg;\n</code></pre>"},{"location":"GGPOUE4/structz__stream__s/#variable-next_in","title":"variable next_in","text":"<pre><code>Bytef* z_stream_s::next_in;\n</code></pre>"},{"location":"GGPOUE4/structz__stream__s/#variable-next_out","title":"variable next_out","text":"<pre><code>Bytef* z_stream_s::next_out;\n</code></pre>"},{"location":"GGPOUE4/structz__stream__s/#variable-opaque","title":"variable opaque","text":"<pre><code>voidpf z_stream_s::opaque;\n</code></pre>"},{"location":"GGPOUE4/structz__stream__s/#variable-reserved","title":"variable reserved","text":"<pre><code>uLong z_stream_s::reserved;\n</code></pre>"},{"location":"GGPOUE4/structz__stream__s/#variable-state","title":"variable state","text":"<pre><code>struct internal_state FAR* z_stream_s::state;\n</code></pre>"},{"location":"GGPOUE4/structz__stream__s/#variable-total_in","title":"variable total_in","text":"<pre><code>uLong z_stream_s::total_in;\n</code></pre>"},{"location":"GGPOUE4/structz__stream__s/#variable-total_out","title":"variable total_out","text":"<pre><code>uLong z_stream_s::total_out;\n</code></pre>"},{"location":"GGPOUE4/structz__stream__s/#variable-zalloc","title":"variable zalloc","text":"<pre><code>alloc_func z_stream_s::zalloc;\n</code></pre>"},{"location":"GGPOUE4/structz__stream__s/#variable-zfree","title":"variable zfree","text":"<pre><code>free_func z_stream_s::zfree;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/zlib.h</code></p>"},{"location":"GGPOUE4/dir_0b4eaef40a1fe20bedafe9e8e719ce66/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins","text":"<p>FileList &gt; Plugins</p>"},{"location":"GGPOUE4/dir_0b4eaef40a1fe20bedafe9e8e719ce66/#directories","title":"Directories","text":"Type Name dir NightSkyEngine <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/</code></p>"},{"location":"GGPOUE4/dir_01309b4faf1ec48651014f612e2b32bb/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine","text":"<p>FileList &gt; NightSkyEngine</p>"},{"location":"GGPOUE4/dir_01309b4faf1ec48651014f612e2b32bb/#directories","title":"Directories","text":"Type Name dir Source <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/</code></p>"},{"location":"GGPOUE4/dir_d32ee28216ed342fa25c01ae9dcd9cc4/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source","text":"<p>FileList &gt; NightSkyEngine &gt; Source</p>"},{"location":"GGPOUE4/dir_d32ee28216ed342fa25c01ae9dcd9cc4/#directories","title":"Directories","text":"Type Name dir GGPOUE4 <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/</code></p>"},{"location":"GGPOUE4/dir_61f8f2a9aed5edd4e8edeed0f59c7e8a/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4","text":"<p>FileList &gt; GGPOUE4</p>"},{"location":"GGPOUE4/dir_61f8f2a9aed5edd4e8edeed0f59c7e8a/#directories","title":"Directories","text":"Type Name dir Private dir Public <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/</code></p>"},{"location":"GGPOUE4/dir_37a60bd602479ee08f2dd49815e2e03d/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private","text":"<p>FileList &gt; GGPOUE4 &gt; Private</p>"},{"location":"GGPOUE4/dir_37a60bd602479ee08f2dd49815e2e03d/#files","title":"Files","text":"Type Name file GGPOGameInstance.cpp file GGPOUE4.cpp file bitvector.cpp file bitvector.h file game_input.cpp file game_input.h file input_queue.cpp file input_queue.h file log.cpp file log.h file main.cpp file pevents.cpp file pevents.h file platform_unix.cpp file platform_unix.h file platform_windows.cpp file platform_windows.h file poll.cpp file poll.h file ring_buffer.h file static_buffer.h file sync.cpp file sync.h file timesync.cpp file timesync.h file types.h file zconf.h file zlib.h"},{"location":"GGPOUE4/dir_37a60bd602479ee08f2dd49815e2e03d/#directories","title":"Directories","text":"Type Name dir backends dir include dir network <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/</code></p>"},{"location":"GGPOUE4/dir_fadaa0fd8ddaab1f868c01be974d2395/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends","text":"<p>FileList &gt; backends</p>"},{"location":"GGPOUE4/dir_fadaa0fd8ddaab1f868c01be974d2395/#files","title":"Files","text":"Type Name file backend.h file p2p.cpp file p2p.h file spectator.cpp file spectator.h file synctest.cpp file synctest.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/</code></p>"},{"location":"GGPOUE4/backend_8h/","title":"File backend.h","text":"<p>FileList &gt; backends &gt; backend.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"include/ggponet.h\"</code></li> <li><code>#include \"types.h\"</code></li> </ul>"},{"location":"GGPOUE4/backend_8h/#classes","title":"Classes","text":"Type Name struct GGPOSession"},{"location":"GGPOUE4/backend_8h/#public-types","title":"Public Types","text":"Type Name typedef struct GGPOSession IQuarkBackend typedef struct GGPOSession Quark"},{"location":"GGPOUE4/backend_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"GGPOUE4/backend_8h/#typedef-iquarkbackend","title":"typedef IQuarkBackend","text":"<pre><code>typedef struct GGPOSession IQuarkBackend;\n</code></pre>"},{"location":"GGPOUE4/backend_8h/#typedef-quark","title":"typedef Quark","text":"<pre><code>typedef struct GGPOSession Quark;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/backend.h</code></p>"},{"location":"GGPOUE4/backend_8h_source/","title":"File backend.h","text":"<p>File List &gt; backends &gt; backend.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _BACKEND_H\n#define _BACKEND_H\n\n#include \"include/ggponet.h\"\n#include \"types.h\"\n\nstruct GGPOSession {\n    virtual ~GGPOSession() { }\n    virtual GGPOErrorCode DoPoll(int timeout) { return GGPO_OK; }\n    virtual GGPOErrorCode AddPlayer(GGPOPlayer *player, GGPOPlayerHandle *handle) = 0;\n    virtual GGPOErrorCode AddLocalInput(GGPOPlayerHandle player, void *values, int size) = 0;\n    virtual GGPOErrorCode SyncInput(void *values, int size, int *disconnect_flags) = 0;\n    virtual GGPOErrorCode IncrementFrame(void) { return GGPO_OK; }\n    virtual GGPOErrorCode Chat(char *text) { return GGPO_OK; }\n    virtual GGPOErrorCode DisconnectPlayer(GGPOPlayerHandle handle) { return GGPO_OK; }\n    virtual GGPOErrorCode GetNetworkStats(FGGPONetworkStats *stats, GGPOPlayerHandle handle) { return GGPO_OK; }\n    virtual GGPOErrorCode Logv(const char *fmt, va_list list) { ::Logv(fmt, list); return GGPO_OK; }\n\n    virtual GGPOErrorCode SetFrameDelay(GGPOPlayerHandle player, int delay) { return GGPO_ERRORCODE_UNSUPPORTED; }\n    virtual GGPOErrorCode SetDisconnectTimeout(int timeout) { return GGPO_ERRORCODE_UNSUPPORTED; }\n    virtual GGPOErrorCode SetDisconnectNotifyStart(int timeout) { return GGPO_ERRORCODE_UNSUPPORTED; }\n    virtual GGPOErrorCode TrySynchronizeLocal() { return GGPO_ERRORCODE_UNSUPPORTED; } \n};\n\ntypedef struct GGPOSession Quark, IQuarkBackend; /* XXX: nuke this */\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/p2p_8cpp/","title":"File p2p.cpp","text":"<p>FileList &gt; backends &gt; p2p.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"p2p.h\"</code></li> <li><code>#include \"GGPOUE4.h\"</code></li> </ul>"},{"location":"GGPOUE4/p2p_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const int DEFAULT_DISCONNECT_NOTIFY_START   = <code>750</code> const int DEFAULT_DISCONNECT_TIMEOUT   = <code>5000</code> const int RECOMMENDATION_INTERVAL   = <code>240</code>"},{"location":"GGPOUE4/p2p_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"GGPOUE4/p2p_8cpp/#variable-default_disconnect_notify_start","title":"variable DEFAULT_DISCONNECT_NOTIFY_START","text":"<pre><code>const int DEFAULT_DISCONNECT_NOTIFY_START;\n</code></pre>"},{"location":"GGPOUE4/p2p_8cpp/#variable-default_disconnect_timeout","title":"variable DEFAULT_DISCONNECT_TIMEOUT","text":"<pre><code>const int DEFAULT_DISCONNECT_TIMEOUT;\n</code></pre>"},{"location":"GGPOUE4/p2p_8cpp/#variable-recommendation_interval","title":"variable RECOMMENDATION_INTERVAL","text":"<pre><code>const int RECOMMENDATION_INTERVAL;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/p2p.cpp</code></p>"},{"location":"GGPOUE4/p2p_8cpp_source/","title":"File p2p.cpp","text":"<p>File List &gt; backends &gt; p2p.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#include \"p2p.h\"\n\n#include \"GGPOUE4.h\"\n\nstatic const int RECOMMENDATION_INTERVAL           = 240;\nstatic const int DEFAULT_DISCONNECT_TIMEOUT        = 5000;\nstatic const int DEFAULT_DISCONNECT_NOTIFY_START   = 750;\n\nPeer2PeerBackend::Peer2PeerBackend(GGPOSessionCallbacks *cb,\n                                   const char *gamename,\n                                   ConnectionManager* connection_manager,\n                                   int num_players,\n                                   int input_size) :\n    _sync(_local_connect_status),\n    _num_spectators(0),\n    _input_size(input_size),\n    _num_players(num_players),\n    _next_spectator_frame(0),\n    _disconnect_timeout(DEFAULT_DISCONNECT_TIMEOUT),\n    _disconnect_notify_start(DEFAULT_DISCONNECT_NOTIFY_START)\n{\n   _callbacks = *cb;\n   _synchronizing = true;\n   _next_recommended_sleep = 0;\n\n   /*\n    * Initialize the synchronziation layer\n    */\n   Sync::Config config = Sync::Config();\n   config.num_players = num_players;\n   config.input_size = input_size;\n   config.callbacks = _callbacks;\n   config.num_prediction_frames = MAX_PREDICTION_FRAMES;\n   _sync.Init(config);\n\n   /*\n    * Initialize the UDP port\n    */\n   _udp.Init(&amp;_poll, this, connection_manager);\n\n   _endpoints = new UdpProtocol[_num_players];\n   memset(_local_connect_status, 0, sizeof(_local_connect_status));\n   for (int i = 0; i &lt; ARRAY_SIZE(_local_connect_status); i++) {\n      _local_connect_status[i].last_frame = -1;\n   }\n\n   /*\n    * Preload the ROM\n    */\n   _callbacks.begin_game(gamename);\n}\n\nPeer2PeerBackend::~Peer2PeerBackend()\n{\n   delete [] _endpoints;\n}\n\nvoid\nPeer2PeerBackend::AddRemotePlayer(int connection_id,\n                                  int queue)\n{\n   /*\n    * Start the state machine (xxx: no)\n    */\n   _synchronizing = true;\n   remoteplayerId = connection_id;\n   remoteplayerQueueu = queue;\n   _endpoints[queue].Init(&amp;_udp, _poll, queue, connection_id, _local_connect_status);\n   _endpoints[queue].SetDisconnectTimeout(_disconnect_timeout);\n   _endpoints[queue].SetDisconnectNotifyStart(_disconnect_notify_start);\n   _endpoints[queue].Synchronize();\n}\n\nGGPOErrorCode Peer2PeerBackend::AddSpectator(int connection_id)\n{\n   if (_num_spectators == GGPO_MAX_SPECTATORS) {\n      return GGPO_ERRORCODE_TOO_MANY_SPECTATORS;\n   }\n   /*\n    * Currently, we can only add spectators before the game starts.\n    */\n   if (!_synchronizing) {\n      return GGPO_ERRORCODE_INVALID_REQUEST;\n   }\n   int queue = _num_spectators++;\n\n   _spectators[queue].Init(&amp;_udp, _poll, queue + 1000, connection_id, _local_connect_status);\n   _spectators[queue].SetDisconnectTimeout(_disconnect_timeout);\n   _spectators[queue].SetDisconnectNotifyStart(_disconnect_notify_start);\n   _spectators[queue].Synchronize();\n\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nPeer2PeerBackend::DoPoll(int timeout)\n{\n   if (!_sync.InRollback()) {\n      _poll.Pump(0);\n\n      PollUdpProtocolEvents();\n\n      if (!_synchronizing) {\n         _sync.CheckSimulation(timeout);\n\n         // notify all of our endpoints of their local frame number for their\n         // next connection quality report\n         int current_frame = _sync.GetFrameCount();\n         for (int i = 0; i &lt; _num_players; i++) {\n            _endpoints[i].SetLocalFrameNumber(current_frame);\n         }\n\n         int total_min_confirmed;\n         if (_num_players &lt;= 2) {\n            total_min_confirmed = Poll2Players(current_frame);\n         } else {\n            total_min_confirmed = PollNPlayers(current_frame);\n         }\n\n         Log(\"last confirmed frame in p2p backend is %d.\\n\", total_min_confirmed);\n         if (total_min_confirmed &gt;= 0) {\n            ASSERT(total_min_confirmed != INT_MAX);\n            if (_num_spectators &gt; 0) {\n               while (_next_spectator_frame &lt;= total_min_confirmed) {\n                  Log(\"pushing frame %d to spectators.\\n\", _next_spectator_frame);\n\n                  GameInput input;\n                  input.frame = _next_spectator_frame;\n                  input.size = _input_size * _num_players;\n                  _sync.GetConfirmedInputs(input.bits, _input_size * _num_players, _next_spectator_frame);\n                  for (int i = 0; i &lt; _num_spectators; i++) {\n                     _spectators[i].SendInput(input);\n                  }\n                  _next_spectator_frame++;\n               }\n            }\n            Log(\"setting confirmed frame in sync to %d.\\n\", total_min_confirmed);\n            _sync.SetLastConfirmedFrame(total_min_confirmed);\n         }\n\n         // send timesync notifications if now is the proper time\n         if (current_frame &gt; _next_recommended_sleep) {\n            int interval = 0;\n            for (int i = 0; i &lt; _num_players; i++) {\n               interval = MAX(interval, _endpoints[i].RecommendFrameDelay());\n            }\n\n            if (interval &gt; 0) {\n               GGPOEvent info;\n               info.code = GGPO_EVENTCODE_TIMESYNC;\n               info.u.timesync.frames_ahead = interval;\n               _callbacks.on_event(&amp;info);\n               _next_recommended_sleep = current_frame + RECOMMENDATION_INTERVAL;\n            }\n         }\n         // XXX: this is obviously a farce...\n         if (timeout) {\n            Platform::SleepMS(1);\n         }\n      }\n   }\n   return GGPO_OK;\n}\n\nint Peer2PeerBackend::Poll2Players(int current_frame)\n{\n   int i;\n\n   // discard confirmed frames as appropriate\n   int total_min_confirmed = MAX_INT;\n   for (i = 0; i &lt; _num_players; i++) {\n      bool queue_connected = true;\n      if (_endpoints[i].IsRunning()) {\n         int ignore;\n         queue_connected = _endpoints[i].GetPeerConnectStatus(i, &amp;ignore);\n      }\n      if (!_local_connect_status[i].disconnected) {\n         total_min_confirmed = MIN(_local_connect_status[i].last_frame, total_min_confirmed);\n      }\n      Log(\"  local endp: connected = %d, last_received = %d, total_min_confirmed = %d.\\n\", !_local_connect_status[i].disconnected, _local_connect_status[i].last_frame, total_min_confirmed);\n      if (!queue_connected &amp;&amp; !_local_connect_status[i].disconnected) {\n         Log(\"disconnecting i %d by remote request.\\n\", i);\n         DisconnectPlayerQueue(i, total_min_confirmed);\n      }\n      Log(\"  total_min_confirmed = %d.\\n\", total_min_confirmed);\n   }\n   return total_min_confirmed;\n}\n\nint Peer2PeerBackend::PollNPlayers(int current_frame)\n{\n   int i, queue, last_received;\n\n   // discard confirmed frames as appropriate\n   int total_min_confirmed = MAX_INT;\n   for (queue = 0; queue &lt; _num_players; queue++) {\n      bool queue_connected = true;\n      int queue_min_confirmed = MAX_INT;\n      Log(\"considering queue %d.\\n\", queue);\n      for (i = 0; i &lt; _num_players; i++) {\n         // we're going to do a lot of logic here in consideration of endpoint i.\n         // keep accumulating the minimum confirmed point for all n*n packets and\n         // throw away the rest.\n         if (_endpoints[i].IsRunning()) {\n            bool connected = _endpoints[i].GetPeerConnectStatus(queue, &amp;last_received);\n\n            queue_connected = queue_connected &amp;&amp; connected;\n            queue_min_confirmed = MIN(last_received, queue_min_confirmed);\n            Log(\"  endpoint %d: connected = %d, last_received = %d, queue_min_confirmed = %d.\\n\", i, connected, last_received, queue_min_confirmed);\n         } else {\n            Log(\"  endpoint %d: ignoring... not running.\\n\", i);\n         }\n      }\n      // merge in our local status only if we're still connected!\n      if (!_local_connect_status[queue].disconnected) {\n         queue_min_confirmed = MIN(_local_connect_status[queue].last_frame, queue_min_confirmed);\n      }\n      Log(\"  local endp: connected = %d, last_received = %d, queue_min_confirmed = %d.\\n\", !_local_connect_status[queue].disconnected, _local_connect_status[queue].last_frame, queue_min_confirmed);\n\n      if (queue_connected) {\n         total_min_confirmed = MIN(queue_min_confirmed, total_min_confirmed);\n      } else {\n         // check to see if this disconnect notification is further back than we've been before.  If\n         // so, we need to re-adjust.  This can happen when we detect our own disconnect at frame n\n         // and later receive a disconnect notification for frame n-1.\n         if (!_local_connect_status[queue].disconnected || _local_connect_status[queue].last_frame &gt; queue_min_confirmed) {\n            Log(\"disconnecting queue %d by remote request.\\n\", queue);\n            DisconnectPlayerQueue(queue, queue_min_confirmed);\n         }\n      }\n      Log(\"  total_min_confirmed = %d.\\n\", total_min_confirmed);\n   }\n   return total_min_confirmed;\n}\n\n\nGGPOErrorCode\nPeer2PeerBackend::AddPlayer(GGPOPlayer *player,\n                            GGPOPlayerHandle *handle)\n{\n   if (player-&gt;type == GGPO_PLAYERTYPE_SPECTATOR) {\n      return AddSpectator(player-&gt;connection_id);\n   }\n\n   int queue = player-&gt;player_num - 1;\n   if (player-&gt;player_num &lt; 1 || player-&gt;player_num &gt; _num_players) {\n      return GGPO_ERRORCODE_PLAYER_OUT_OF_RANGE;\n   }\n   *handle = QueueToPlayerHandle(queue);\n\n   if (player-&gt;type == GGPO_PLAYERTYPE_REMOTE) {\n      AddRemotePlayer(player-&gt;connection_id, queue);\n   }\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nPeer2PeerBackend::AddLocalInput(GGPOPlayerHandle player,\n                                void *values,\n                                int size)\n{\n   int queue;\n   GameInput input;\n   GGPOErrorCode result;\n\n   if (_sync.InRollback()) {\n      return GGPO_ERRORCODE_IN_ROLLBACK;\n   }\n   if (_synchronizing) {\n      return GGPO_ERRORCODE_NOT_SYNCHRONIZED;\n   }\n\n   result = PlayerHandleToQueue(player, &amp;queue);\n   if (!GGPO_SUCCEEDED(result)) {\n      return result;\n   }\n\n   input.init(-1, (char *)values, size);\n\n   // Feed the input for the current frame into the synchronzation layer.\n   if (!_sync.AddLocalInput(queue, input)) {\n      return GGPO_ERRORCODE_PREDICTION_THRESHOLD;\n   }\n\n   if (input.frame != GameInput::NullFrame) { // xxx: &lt;- comment why this is the case\n      // Update the local connect status state to indicate that we've got a\n      // confirmed local frame for this player.  this must come first so it\n      // gets incorporated into the next packet we send.\n\n      Log(\"setting local connect status for local queue %d to %d\", queue, input.frame);\n      _local_connect_status[queue].last_frame = input.frame;\n\n      // Send the input to all the remote players.\n      for (int i = 0; i &lt; _num_players; i++) {\n         if (_endpoints[i].IsInitialized()) {\n            _endpoints[i].SendInput(input);\n         }\n      }\n   }\n\n   return GGPO_OK;\n}\n\n\nGGPOErrorCode\nPeer2PeerBackend::SyncInput(void *values,\n                            int size,\n                            int *disconnect_flags)\n{\n   int flags;\n\n   // Wait until we've started to return inputs.\n   if (_synchronizing) {\n      return GGPO_ERRORCODE_NOT_SYNCHRONIZED;\n   }\n   flags = _sync.SynchronizeInputs(values, size);\n   if (disconnect_flags) {\n      *disconnect_flags = flags;\n   }\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nPeer2PeerBackend::IncrementFrame(void)\n{  \n   Log(\"End of frame (%d)...\\n\", _sync.GetFrameCount());\n   _sync.IncrementFrame();\n   DoPoll(0);\n   PollSyncEvents();\n\n   return GGPO_OK;\n}\n\n\nvoid\nPeer2PeerBackend::PollSyncEvents(void)\n{\n   Sync::Event e;\n   while (_sync.GetEvent(e)) {\n      OnSyncEvent(e);\n   }\n   return;\n}\n\nvoid\nPeer2PeerBackend::PollUdpProtocolEvents(void)\n{\n   UdpProtocol::Event evt;\n   for (int i = 0; i &lt; _num_players; i++) {\n      while (_endpoints[i].GetEvent(evt)) {\n         OnUdpProtocolPeerEvent(evt, i);\n      }\n   }\n   for (int i = 0; i &lt; _num_spectators; i++) {\n      while (_spectators[i].GetEvent(evt)) {\n         OnUdpProtocolSpectatorEvent(evt, i);\n      }\n   }\n}\n\nvoid\nPeer2PeerBackend::OnUdpProtocolPeerEvent(UdpProtocol::Event &amp;evt, int queue)\n{\n   OnUdpProtocolEvent(evt, QueueToPlayerHandle(queue));\n   switch (evt.type) {\n      case UdpProtocol::Event::Input:\n         if (!_local_connect_status[queue].disconnected) {\n            int current_remote_frame = _local_connect_status[queue].last_frame;\n            int new_remote_frame = evt.u.input.input.frame;\n            ASSERT(current_remote_frame == -1 || new_remote_frame == (current_remote_frame + 1));\n\n            _sync.AddRemoteInput(queue, evt.u.input.input);\n            // Notify the other endpoints which frame we received from a peer\n            Log(\"setting remote connect status for queue %d to %d\\n\", queue, evt.u.input.input.frame);\n            _local_connect_status[queue].last_frame = evt.u.input.input.frame;\n         }\n         break;\n\n   case UdpProtocol::Event::Disconnected:\n      DisconnectPlayer(QueueToPlayerHandle(queue));\n      break;\n   }\n}\n\n\nvoid\nPeer2PeerBackend::OnUdpProtocolSpectatorEvent(UdpProtocol::Event &amp;evt, int queue)\n{\n   GGPOPlayerHandle handle = QueueToSpectatorHandle(queue);\n   OnUdpProtocolEvent(evt, handle);\n\n   GGPOEvent info;\n\n   switch (evt.type) {\n   case UdpProtocol::Event::Disconnected:\n      _spectators[queue].Disconnect();\n\n      info.code = GGPO_EVENTCODE_DISCONNECTED_FROM_PEER;\n      info.u.disconnected.player = handle;\n      _callbacks.on_event(&amp;info);\n\n      break;\n   }\n}\n\nvoid\nPeer2PeerBackend::OnUdpProtocolEvent(UdpProtocol::Event &amp;evt, GGPOPlayerHandle handle)\n{\n   GGPOEvent info;\n\n   switch (evt.type) {\n   case UdpProtocol::Event::Connected:\n      info.code = GGPO_EVENTCODE_CONNECTED_TO_PEER;\n      info.u.connected.player = handle;\n      _callbacks.on_event(&amp;info);\n      break;\n   case UdpProtocol::Event::Synchronizing:\n      info.code = GGPO_EVENTCODE_SYNCHRONIZING_WITH_PEER;\n      info.u.synchronizing.player = handle;\n      info.u.synchronizing.count = evt.u.synchronizing.count;\n      info.u.synchronizing.total = evt.u.synchronizing.total;\n      _callbacks.on_event(&amp;info);\n      break;\n   case UdpProtocol::Event::Synchronzied:\n      info.code = GGPO_EVENTCODE_SYNCHRONIZED_WITH_PEER;\n      info.u.synchronized.player = handle;\n      _callbacks.on_event(&amp;info);\n\n      CheckInitialSync();\n      break;\n\n   case UdpProtocol::Event::NetworkInterrupted:\n      info.code = GGPO_EVENTCODE_CONNECTION_INTERRUPTED;\n      info.u.connection_interrupted.player = handle;\n      info.u.connection_interrupted.disconnect_timeout = evt.u.network_interrupted.disconnect_timeout;\n      _callbacks.on_event(&amp;info);\n      break;\n\n   case UdpProtocol::Event::NetworkResumed:\n      info.code = GGPO_EVENTCODE_CONNECTION_RESUMED;\n      info.u.connection_resumed.player = handle;\n      _callbacks.on_event(&amp;info);\n      break;\n   }\n}\n\n/*\n * Called only as the result of a local decision to disconnect.  The remote\n * decisions to disconnect are a result of us parsing the peer_connect_settings\n * blob in every endpoint periodically.\n */\nGGPOErrorCode\nPeer2PeerBackend::DisconnectPlayer(GGPOPlayerHandle player)\n{\n   int queue;\n   GGPOErrorCode result;\n\n   result = PlayerHandleToQueue(player, &amp;queue);\n   if (!GGPO_SUCCEEDED(result)) {\n      return result;\n   }\n\n   if (_local_connect_status[queue].disconnected) {\n      return GGPO_ERRORCODE_PLAYER_DISCONNECTED;\n   }\n\n   if (!_endpoints[queue].IsInitialized()) {\n      int current_frame = _sync.GetFrameCount();\n      // xxx: we should be tracking who the local player is, but for now assume\n      // that if the endpoint is not initalized, this must be the local player.\n      Log(\"Disconnecting local player %d at frame %d by user request.\\n\", queue, _local_connect_status[queue].last_frame);\n      for (int i = 0; i &lt; _num_players; i++) {\n         if (_endpoints[i].IsInitialized()) {\n            DisconnectPlayerQueue(i, current_frame);\n         }\n      }\n   } else {\n      Log(\"Disconnecting queue %d at frame %d by user request.\\n\", queue, _local_connect_status[queue].last_frame);\n      DisconnectPlayerQueue(queue, _local_connect_status[queue].last_frame);\n   }\n   return GGPO_OK;\n}\n\nvoid\nPeer2PeerBackend::DisconnectPlayerQueue(int queue, int syncto)\n{\n   GGPOEvent info;\n   int framecount = _sync.GetFrameCount();\n\n   _endpoints[queue].Disconnect();\n\n   Log(\"Changing queue %d local connect status for last frame from %d to %d on disconnect request (current: %d).\\n\",\n       queue, _local_connect_status[queue].last_frame, syncto, framecount);\n\n   _local_connect_status[queue].disconnected = 1;\n   _local_connect_status[queue].last_frame = syncto;\n\n   if (syncto &lt; framecount) {\n      Log(\"adjusting simulation to account for the fact that %d disconnected @ %d.\\n\", queue, syncto);\n      _sync.AdjustSimulation(syncto);\n      Log(\"finished adjusting simulation.\\n\");\n   }\n\n   info.code = GGPO_EVENTCODE_DISCONNECTED_FROM_PEER;\n   info.u.disconnected.player = QueueToPlayerHandle(queue);\n   _callbacks.on_event(&amp;info);\n\n   CheckInitialSync();\n}\n\n\nGGPOErrorCode\nPeer2PeerBackend::GetNetworkStats(FGGPONetworkStats *stats, GGPOPlayerHandle player)\n{\n   int queue;\n   GGPOErrorCode result;\n\n   result = PlayerHandleToQueue(player, &amp;queue);\n   if (!GGPO_SUCCEEDED(result)) {\n      return result;\n   }\n\n   memset(stats, 0, sizeof *stats);\n   _endpoints[queue].GetNetworkStats(stats);\n\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nPeer2PeerBackend::SetFrameDelay(GGPOPlayerHandle player, int delay) \n{ \n   int queue;\n   GGPOErrorCode result;\n\n   result = PlayerHandleToQueue(player, &amp;queue);\n   if (!GGPO_SUCCEEDED(result)) {\n      return result;\n   }\n   _sync.SetFrameDelay(queue, delay);\n   return GGPO_OK; \n}\n\nGGPOErrorCode\nPeer2PeerBackend::SetDisconnectTimeout(int timeout)\n{\n   _disconnect_timeout = timeout;\n   for (int i = 0; i &lt; _num_players; i++) {\n      if (_endpoints[i].IsInitialized()) {\n         _endpoints[i].SetDisconnectTimeout(_disconnect_timeout);\n      }\n   }\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nPeer2PeerBackend::SetDisconnectNotifyStart(int timeout)\n{\n   _disconnect_notify_start = timeout;\n   for (int i = 0; i &lt; _num_players; i++) {\n      if (_endpoints[i].IsInitialized()) {\n         _endpoints[i].SetDisconnectNotifyStart(_disconnect_notify_start);\n      }\n   }\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nPeer2PeerBackend::TrySynchronizeLocal()\n{\n   if (_num_players &lt;= 1 &amp;&amp; _num_spectators == 0)\n   {\n      if (_num_players == 0 || !_endpoints[0].IsInitialized())\n         CheckInitialSync();\n   }\n\n   if (_synchronizing)\n      return GGPO_ERRORCODE_NOT_SYNCHRONIZED;\n   UE_LOG(GGPOLOG, Verbose, TEXT(\"Peer2PeerBackend::TrySynchronizeLocal Synchronized local-only simulation.\"))\n   return GGPO_OK;\n}\n\n\nGGPOErrorCode\nPeer2PeerBackend::PlayerHandleToQueue(GGPOPlayerHandle player, int *queue)\n{\n   int offset = ((int)player - 1);\n   if (offset &lt; 0 || offset &gt;= _num_players) {\n      return GGPO_ERRORCODE_INVALID_PLAYER_HANDLE;\n   }\n   *queue = offset;\n   return GGPO_OK;\n}\n\n\nvoid\nPeer2PeerBackend::OnMsg(int connection_id, UdpMsg *msg, int len)\n{\n   for (int i = 0; i &lt; _num_players; i++) {\n      if (_endpoints[i].HandlesMsg(connection_id, msg)) {\n         _endpoints[i].OnMsg(msg, len);\n         return;\n      }\n   }\n   for (int i = 0; i &lt; _num_spectators; i++) {\n      if (_spectators[i].HandlesMsg(connection_id, msg)) {\n         _spectators[i].OnMsg(msg, len);\n         return;\n      }\n   }\n}\n\nvoid\nPeer2PeerBackend::CheckInitialSync()\n{\n   int i;\n\n   if (_synchronizing) {\n      // Check to see if everyone is now synchronized.  If so,\n      // go ahead and tell the client that we're ok to accept input.\n      for (i = 0; i &lt; _num_players; i++) {\n         // xxx: IsInitialized() must go... we're actually using it as a proxy for \"represents the local player\"\n         if (_endpoints[i].IsInitialized() &amp;&amp; !_endpoints[i].IsSynchronized() &amp;&amp; !_local_connect_status[i].disconnected) {\n            return;\n         }\n      }\n      for (i = 0; i &lt; _num_spectators; i++) {\n         if (_spectators[i].IsInitialized() &amp;&amp; !_spectators[i].IsSynchronized()) {\n            return;\n         }\n      }\n\n      GGPOEvent info;\n      info.code = GGPO_EVENTCODE_RUNNING;\n      _callbacks.on_event(&amp;info);\n      _synchronizing = false;\n   }\n}\n</code></pre>"},{"location":"GGPOUE4/p2p_8h/","title":"File p2p.h","text":"<p>FileList &gt; backends &gt; p2p.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"types.h\"</code></li> <li><code>#include \"poll.h\"</code></li> <li><code>#include \"sync.h\"</code></li> <li><code>#include \"backend.h\"</code></li> <li><code>#include \"timesync.h\"</code></li> <li><code>#include \"network/udp_proto.h\"</code></li> </ul>"},{"location":"GGPOUE4/p2p_8h/#classes","title":"Classes","text":"Type Name class Peer2PeerBackend <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/p2p.h</code></p>"},{"location":"GGPOUE4/p2p_8h_source/","title":"File p2p.h","text":"<p>File List &gt; backends &gt; p2p.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _P2P_H\n#define _P2P_H\n\n#include \"types.h\"\n#include \"poll.h\"\n#include \"sync.h\"\n#include \"backend.h\"\n#include \"timesync.h\"\n#include \"network/udp_proto.h\"\n\nclass Peer2PeerBackend : public IQuarkBackend, IPollSink, Udp::Callbacks {\npublic:\n   Peer2PeerBackend(GGPOSessionCallbacks *cb, const char *gamename, ConnectionManager* connection_manager, int num_players, int input_size);\n   virtual ~Peer2PeerBackend();\n\n\npublic:\n   int remoteplayerId;\n   int remoteplayerQueueu;\n   virtual GGPOErrorCode DoPoll(int timeout);\n   virtual GGPOErrorCode AddPlayer(GGPOPlayer *player, GGPOPlayerHandle *handle);\n   virtual GGPOErrorCode AddLocalInput(GGPOPlayerHandle player, void *values, int size);\n   virtual GGPOErrorCode SyncInput(void *values, int size, int *disconnect_flags);\n   virtual GGPOErrorCode IncrementFrame(void);\n   virtual GGPOErrorCode DisconnectPlayer(GGPOPlayerHandle handle);\n   virtual GGPOErrorCode GetNetworkStats(FGGPONetworkStats *stats, GGPOPlayerHandle handle) override;\n   virtual GGPOErrorCode SetFrameDelay(GGPOPlayerHandle player, int delay);\n   virtual GGPOErrorCode SetDisconnectTimeout(int timeout);\n   virtual GGPOErrorCode SetDisconnectNotifyStart(int timeout);\n   virtual GGPOErrorCode TrySynchronizeLocal() override;\n\npublic:\n   virtual void OnMsg(int connection_id, UdpMsg *msg, int len) override;\n\nprotected:\n   GGPOErrorCode PlayerHandleToQueue(GGPOPlayerHandle player, int *queue);\n   GGPOPlayerHandle QueueToPlayerHandle(int queue) { return (GGPOPlayerHandle)(queue + 1); }\n   GGPOPlayerHandle QueueToSpectatorHandle(int queue) { return (GGPOPlayerHandle)(queue + 1000); } /* out of range of the player array, basically */\n   void DisconnectPlayerQueue(int queue, int syncto);\n   void PollSyncEvents(void);\n   void PollUdpProtocolEvents(void);\n   void CheckInitialSync(void);\n   int Poll2Players(int current_frame);\n   int PollNPlayers(int current_frame);\n   void AddRemotePlayer(int connection_id, int queue);\n   GGPOErrorCode AddSpectator(int connection_id);\n   virtual void OnSyncEvent(Sync::Event &amp;e) { }\n   virtual void OnUdpProtocolEvent(UdpProtocol::Event &amp;e, GGPOPlayerHandle handle);\n   virtual void OnUdpProtocolPeerEvent(UdpProtocol::Event &amp;e, int queue);\n   virtual void OnUdpProtocolSpectatorEvent(UdpProtocol::Event &amp;e, int queue);\n\nprotected:\n   GGPOSessionCallbacks  _callbacks;\n   Poll                  _poll;\n   Sync                  _sync;\n   Udp                   _udp;\n   UdpProtocol           *_endpoints;\n   UdpProtocol           _spectators[GGPO_MAX_SPECTATORS];\n   int                   _num_spectators;\n   int                   _input_size;\n\n   bool                  _synchronizing;\n   int                   _num_players;\n   int                   _next_recommended_sleep;\n\n   int                   _next_spectator_frame;\n   int                   _disconnect_timeout;\n   int                   _disconnect_notify_start;\n\n   UdpMsg::connect_status _local_connect_status[UDP_MSG_MAX_PLAYERS];\n};\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/spectator_8cpp/","title":"File spectator.cpp","text":"<p>FileList &gt; backends &gt; spectator.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"spectator.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/spectator.cpp</code></p>"},{"location":"GGPOUE4/spectator_8cpp_source/","title":"File spectator.cpp","text":"<p>File List &gt; backends &gt; spectator.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#include \"spectator.h\"\n\nSpectatorBackend::SpectatorBackend(GGPOSessionCallbacks *cb,\n                                   const char* gamename,\n                                   ConnectionManager* connection_manager,\n                                   int num_players,\n                                   int input_size,\n                                   int connection_id) :\n   _input_size(input_size),\n   _num_players(num_players),\n   _next_input_to_send(0)\n{\n   _callbacks = *cb;\n   _synchronizing = true;\n\n   for (int i = 0; i &lt; ARRAY_SIZE(_inputs); i++) {\n      _inputs[i].frame = -1;\n   }\n\n   /*\n    * Initialize the UDP port\n    */\n   _udp.Init(&amp;_poll, this, connection_manager);\n\n   /*\n    * Init the host endpoint\n    */\n   _host.Init(&amp;_udp, _poll, 0, connection_id, NULL);\n   _host.Synchronize();\n\n   /*\n    * Preload the ROM\n    */\n   _callbacks.begin_game(gamename);\n}\n\nSpectatorBackend::~SpectatorBackend()\n{\n}\n\nGGPOErrorCode\nSpectatorBackend::DoPoll(int timeout)\n{\n   _poll.Pump(0);\n\n   PollUdpProtocolEvents();\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nSpectatorBackend::SyncInput(void *values,\n                            int size,\n                            int *disconnect_flags)\n{\n   // Wait until we've started to return inputs.\n   if (_synchronizing) {\n      return GGPO_ERRORCODE_NOT_SYNCHRONIZED;\n   }\n\n   GameInput &amp;input = _inputs[_next_input_to_send % SPECTATOR_FRAME_BUFFER_SIZE];\n   if (input.frame &lt; _next_input_to_send) {\n      // Haven't received the input from the host yet.  Wait\n      return GGPO_ERRORCODE_PREDICTION_THRESHOLD;\n   }\n   if (input.frame &gt; _next_input_to_send) {\n      // The host is way way way far ahead of the spectator.  How'd this\n      // happen?  Anyway, the input we need is gone forever.\n      return GGPO_ERRORCODE_GENERAL_FAILURE;\n   }\n\n   ASSERT(size &gt;= _input_size * _num_players);\n   memcpy(values, input.bits, _input_size * _num_players);\n   if (disconnect_flags) {\n      *disconnect_flags = 0; // xxx: should get them from the host!\n   }\n   _next_input_to_send++;\n\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nSpectatorBackend::IncrementFrame(void)\n{  \n   Log(\"End of frame (%d)...\\n\", _next_input_to_send - 1);\n   DoPoll(0);\n   PollUdpProtocolEvents();\n\n   return GGPO_OK;\n}\n\nvoid\nSpectatorBackend::PollUdpProtocolEvents(void)\n{\n   UdpProtocol::Event evt;\n   while (_host.GetEvent(evt)) {\n      OnUdpProtocolEvent(evt);\n   }\n}\n\nvoid\nSpectatorBackend::OnUdpProtocolEvent(UdpProtocol::Event &amp;evt)\n{\n   GGPOEvent info;\n\n   switch (evt.type) {\n   case UdpProtocol::Event::Connected:\n      info.code = GGPO_EVENTCODE_CONNECTED_TO_PEER;\n      info.u.connected.player = 0;\n      _callbacks.on_event(&amp;info);\n      break;\n   case UdpProtocol::Event::Synchronizing:\n      info.code = GGPO_EVENTCODE_SYNCHRONIZING_WITH_PEER;\n      info.u.synchronizing.player = 0;\n      info.u.synchronizing.count = evt.u.synchronizing.count;\n      info.u.synchronizing.total = evt.u.synchronizing.total;\n      _callbacks.on_event(&amp;info);\n      break;\n   case UdpProtocol::Event::Synchronzied:\n      if (_synchronizing) {\n         info.code = GGPO_EVENTCODE_SYNCHRONIZED_WITH_PEER;\n         info.u.synchronized.player = 0;\n         _callbacks.on_event(&amp;info);\n\n         info.code = GGPO_EVENTCODE_RUNNING;\n         _callbacks.on_event(&amp;info);\n         _synchronizing = false;\n      }\n      break;\n\n   case UdpProtocol::Event::NetworkInterrupted:\n      info.code = GGPO_EVENTCODE_CONNECTION_INTERRUPTED;\n      info.u.connection_interrupted.player = 0;\n      info.u.connection_interrupted.disconnect_timeout = evt.u.network_interrupted.disconnect_timeout;\n      _callbacks.on_event(&amp;info);\n      break;\n\n   case UdpProtocol::Event::NetworkResumed:\n      info.code = GGPO_EVENTCODE_CONNECTION_RESUMED;\n      info.u.connection_resumed.player = 0;\n      _callbacks.on_event(&amp;info);\n      break;\n\n   case UdpProtocol::Event::Disconnected:\n      info.code = GGPO_EVENTCODE_DISCONNECTED_FROM_PEER;\n      info.u.disconnected.player = 0;\n      _callbacks.on_event(&amp;info);\n      break;\n\n   case UdpProtocol::Event::Input:\n      GameInput&amp; input = evt.u.input.input;\n\n      _host.SetLocalFrameNumber(input.frame);\n      _host.SendInputAck();\n      _inputs[input.frame % SPECTATOR_FRAME_BUFFER_SIZE] = input;\n      break;\n   }\n}\n\nvoid\nSpectatorBackend::OnMsg(int connection_id, UdpMsg *msg, int len)\n{\n   if (_host.HandlesMsg(connection_id, msg)) {\n      _host.OnMsg(msg, len);\n   }\n}\n</code></pre>"},{"location":"GGPOUE4/spectator_8h/","title":"File spectator.h","text":"<p>FileList &gt; backends &gt; spectator.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"types.h\"</code></li> <li><code>#include \"poll.h\"</code></li> <li><code>#include \"sync.h\"</code></li> <li><code>#include \"backend.h\"</code></li> <li><code>#include \"timesync.h\"</code></li> <li><code>#include \"network/udp_proto.h\"</code></li> </ul>"},{"location":"GGPOUE4/spectator_8h/#classes","title":"Classes","text":"Type Name class SpectatorBackend"},{"location":"GGPOUE4/spectator_8h/#macros","title":"Macros","text":"Type Name define SPECTATOR_FRAME_BUFFER_SIZE <code>64</code>"},{"location":"GGPOUE4/spectator_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/spectator_8h/#define-spectator_frame_buffer_size","title":"define SPECTATOR_FRAME_BUFFER_SIZE","text":"<pre><code>#define SPECTATOR_FRAME_BUFFER_SIZE `64`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/spectator.h</code></p>"},{"location":"GGPOUE4/spectator_8h_source/","title":"File spectator.h","text":"<p>File List &gt; backends &gt; spectator.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _SPECTATOR_H\n#define _SPECTATOR_H\n\n#include \"types.h\"\n#include \"poll.h\"\n#include \"sync.h\"\n#include \"backend.h\"\n#include \"timesync.h\"\n#include \"network/udp_proto.h\"\n\n#define SPECTATOR_FRAME_BUFFER_SIZE    64\n\nclass SpectatorBackend : public IQuarkBackend, IPollSink, Udp::Callbacks {\npublic:\n   SpectatorBackend(GGPOSessionCallbacks *cb, const char *gamename, ConnectionManager* connection_manager, int num_players, int input_size, int connection_id);\n   virtual ~SpectatorBackend();\n\n\npublic:\n   virtual GGPOErrorCode DoPoll(int timeout);\n   virtual GGPOErrorCode AddPlayer(GGPOPlayer *player, GGPOPlayerHandle *handle) { return GGPO_ERRORCODE_UNSUPPORTED; }\n   virtual GGPOErrorCode AddLocalInput(GGPOPlayerHandle player, void *values, int size) { return GGPO_OK; }\n   virtual GGPOErrorCode SyncInput(void *values, int size, int *disconnect_flags);\n   virtual GGPOErrorCode IncrementFrame(void);\n   virtual GGPOErrorCode DisconnectPlayer(GGPOPlayerHandle handle) { return GGPO_ERRORCODE_UNSUPPORTED; }\n   virtual GGPOErrorCode GetNetworkStats(FGGPONetworkStats *stats, GGPOPlayerHandle handle) { return GGPO_ERRORCODE_UNSUPPORTED; }\n   virtual GGPOErrorCode SetFrameDelay(GGPOPlayerHandle player, int delay) { return GGPO_ERRORCODE_UNSUPPORTED; }\n   virtual GGPOErrorCode SetDisconnectTimeout(int timeout) { return GGPO_ERRORCODE_UNSUPPORTED; }\n   virtual GGPOErrorCode SetDisconnectNotifyStart(int timeout) { return GGPO_ERRORCODE_UNSUPPORTED; }\n\npublic:\n   virtual void OnMsg(int connection_id, UdpMsg *msg, int len);\n\nprotected:\n   void PollUdpProtocolEvents(void);\n   void CheckInitialSync(void);\n\n   void OnUdpProtocolEvent(UdpProtocol::Event &amp;e);\n\nprotected:\n   GGPOSessionCallbacks  _callbacks;\n   Poll                  _poll;\n   Udp                   _udp;\n   UdpProtocol           _host;\n   bool                  _synchronizing;\n   int                   _input_size;\n   int                   _num_players;\n   int                   _next_input_to_send;\n   GameInput             _inputs[SPECTATOR_FRAME_BUFFER_SIZE];\n};\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/synctest_8cpp/","title":"File synctest.cpp","text":"<p>FileList &gt; backends &gt; synctest.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"synctest.h\"</code></li> <li><code>#include \"Kismet/KismetSystemLibrary.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/synctest.cpp</code></p>"},{"location":"GGPOUE4/synctest_8cpp_source/","title":"File synctest.cpp","text":"<p>File List &gt; backends &gt; synctest.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#include \"synctest.h\"\n\n#include \"Kismet/KismetSystemLibrary.h\"\n\nSyncTestBackend::SyncTestBackend(GGPOSessionCallbacks *cb,\n                                 const char *gamename,\n                                 int frames,\n                                 int num_players) :\n   _sync(NULL)\n{\n   _callbacks = *cb;\n   _num_players = num_players;\n   _check_distance = frames;\n   _last_verified = 0;\n   _rollingback = false;\n   _running = false;\n   _logfp = NULL;\n   _current_input.erase();\n   strcpy(_game, gamename);\n\n   /*\n    * Initialize the synchronziation layer\n    */\n   Sync::Config config = Sync::Config();\n   config.callbacks = _callbacks;\n   config.num_prediction_frames = MAX_PREDICTION_FRAMES;\n   _sync.Init(config);\n\n   /*\n    * Preload the ROM\n    */\n   _callbacks.begin_game(gamename);\n}\n\nSyncTestBackend::~SyncTestBackend()\n{\n}\n\nGGPOErrorCode\nSyncTestBackend::DoPoll(int timeout)\n{\n   if (!_running) {\n      GGPOEvent info;\n\n      info.code = GGPO_EVENTCODE_RUNNING;\n      _callbacks.on_event(&amp;info);\n      _running = true;\n   }\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nSyncTestBackend::AddPlayer(GGPOPlayer *player, GGPOPlayerHandle *handle)\n{\n   if (player-&gt;player_num &lt; 1 || player-&gt;player_num &gt; _num_players) {\n      return GGPO_ERRORCODE_PLAYER_OUT_OF_RANGE;\n   }\n   *handle = (GGPOPlayerHandle)(player-&gt;player_num - 1);\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nSyncTestBackend::AddLocalInput(GGPOPlayerHandle player, void *values, int size)\n{\n   if (!_running) {\n      return GGPO_ERRORCODE_NOT_SYNCHRONIZED;\n   }\n\n   int index = (int)player;\n   for (int i = 0; i &lt; size; i++) {\n      _current_input.bits[(index * size) + i] |= ((char *)values)[i];\n   }\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nSyncTestBackend::SyncInput(void *values,\n                           int size,\n                           int *disconnect_flags)\n{\n   BeginLog(false);\n   if (_rollingback) {\n      _last_input = _saved_frames.front().input;\n   } else {\n      if (_sync.GetFrameCount() == 0) {\n         _sync.SaveCurrentFrame();\n      }\n      _last_input = _current_input;\n   }\n   memcpy(values, _last_input.bits, size);\n   if (disconnect_flags) {\n      *disconnect_flags = 0;\n   }\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nSyncTestBackend::IncrementFrame(void)\n{  \n   _sync.IncrementFrame();\n   _current_input.erase();\n\n   Log(\"End of frame(%d)...\\n\", _sync.GetFrameCount());\n   EndLog();\n\n   if (_rollingback) {\n      return GGPO_OK;\n   }\n\n   int frame = _sync.GetFrameCount();\n   // Hold onto the current frame in our queue of saved states.  We'll need\n   // the checksum later to verify that our replay of the same frame got the\n   // same results.\n   SavedInfo info;\n   info.frame = frame;\n   info.input = _last_input;\n   info.cbuf = _sync.GetLastSavedFrame().cbuf;\n   info.buf = (char *)malloc(info.cbuf);\n   memcpy(info.buf, _sync.GetLastSavedFrame().buf, info.cbuf);\n   info.checksum = _sync.GetLastSavedFrame().checksum;\n   _saved_frames.push(info);\n\n   if (frame - _last_verified == _check_distance) {\n      // We've gone far enough ahead and should now start replaying frames.\n      // Load the last verified frame and set the rollback flag to true.\n      _sync.LoadFrame(_last_verified);\n\n      _rollingback = true;\n      while(!_saved_frames.empty()) {\n         _callbacks.advance_frame(0);\n\n         // Verify that the checksumn of this frame is the same as the one in our\n         // list.\n         info = _saved_frames.front();\n         _saved_frames.pop();\n\n         if (info.frame != _sync.GetFrameCount()) {\n            RaiseSyncError(\"Frame number %d does not match saved frame number %d\", info.frame, frame);\n         }\n         int checksum = _sync.GetLastSavedFrame().checksum;\n         if (info.checksum != checksum) {\n            LogSaveStates(info);\n            RaiseSyncError(\"Checksum for frame %d does not match saved (%d != %d)\", frame, checksum, info.checksum);\n         }\n         printf(\"Checksum %08d for frame %d matches.\\n\", checksum, info.frame);\n         free(info.buf);\n      }\n      _last_verified = frame;\n      _rollingback = false;\n   }\n\n   return GGPO_OK;\n}\n\nvoid\nSyncTestBackend::RaiseSyncError(const char *fmt, ...)\n{\n   char buf[1024];\n   va_list args;\n   va_start(args, fmt);\n   vsprintf(buf, fmt, args);\n   va_end(args);\n\n   puts(buf);\n   EndLog();\n   DebugBreak();\n}\n\nGGPOErrorCode\nSyncTestBackend::Logv(const char *fmt, va_list list)\n{\n   if (_logfp) {\n      vfprintf(_logfp, fmt, list);\n   }\n   return GGPO_OK;\n}\n\nvoid\nSyncTestBackend::BeginLog(int saving)\n{\n   EndLog();\n\n   char filename[MAX_PATH];\n   Platform::CreateDirectory(TCHAR_TO_ANSI(*(UKismetSystemLibrary::GetProjectSavedDirectory() + \"synclogs\")), NULL);\n   sprintf(filename, \"synclogs\\\\%s-%04d-%s.log\",\n           saving ? \"state\" : \"log\",\n           _sync.GetFrameCount(),\n           _rollingback ? \"replay\" : \"original\");\n\n    fopen(filename, \"w\");\n}\n\nvoid\nSyncTestBackend::EndLog()\n{\n   if (_logfp) {\n      fprintf(_logfp, \"Closing log file.\\n\");\n      fclose(_logfp);\n      _logfp = NULL;\n   }\n}\nvoid\nSyncTestBackend::LogSaveStates(SavedInfo &amp;info)\n{\n   char filename[MAX_PATH];\n   sprintf(filename,  \"synclogs\\\\state-%04d-original.log\", _sync.GetFrameCount());\n   _callbacks.log_game_state(filename, (unsigned char *)info.buf, info.cbuf);\n\n   sprintf(filename, \"synclogs\\\\state-%04d-replay.log\", _sync.GetFrameCount());\n   _callbacks.log_game_state(filename, _sync.GetLastSavedFrame().buf, _sync.GetLastSavedFrame().cbuf);\n}\n</code></pre>"},{"location":"GGPOUE4/synctest_8h/","title":"File synctest.h","text":"<p>FileList &gt; backends &gt; synctest.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"types.h\"</code></li> <li><code>#include \"backend.h\"</code></li> <li><code>#include \"sync.h\"</code></li> <li><code>#include \"ring_buffer.h\"</code></li> </ul>"},{"location":"GGPOUE4/synctest_8h/#classes","title":"Classes","text":"Type Name class SyncTestBackend <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/backends/synctest.h</code></p>"},{"location":"GGPOUE4/synctest_8h_source/","title":"File synctest.h","text":"<p>File List &gt; backends &gt; synctest.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _SYNCTEST_H\n#define _SYNCTEST_H\n\n#include \"types.h\"\n#include \"backend.h\"\n#include \"sync.h\"\n#include \"ring_buffer.h\"\n\nclass SyncTestBackend : public IQuarkBackend {\npublic:\n   SyncTestBackend(GGPOSessionCallbacks *cb, const char *gamename, int frames, int num_players);\n   virtual ~SyncTestBackend();\n\n   virtual GGPOErrorCode DoPoll(int timeout);\n   virtual GGPOErrorCode AddPlayer(GGPOPlayer *player, GGPOPlayerHandle *handle);\n   virtual GGPOErrorCode AddLocalInput(GGPOPlayerHandle player, void *values, int size);\n   virtual GGPOErrorCode SyncInput(void *values, int size, int *disconnect_flags);\n   virtual GGPOErrorCode IncrementFrame(void);\n   virtual GGPOErrorCode Logv(const char *fmt, va_list list) override;\n\nprotected:\n   struct SavedInfo {\n      int         frame;\n      int         checksum;\n      char        *buf;\n      int         cbuf;\n      GameInput   input;\n   };\n\n   void RaiseSyncError(const char *fmt, ...);\n   void BeginLog(int saving);\n   void EndLog();\n   void LogSaveStates(SavedInfo &amp;info);\n\nprotected:\n   GGPOSessionCallbacks   _callbacks;\n   Sync                   _sync;\n   int                    _num_players;\n   int                    _check_distance;\n   int                    _last_verified;\n   bool                   _rollingback;\n   bool                   _running;\n   FILE                   *_logfp;\n   char                   _game[128];\n\n   GameInput                  _current_input;\n   GameInput                  _last_input;\n   RingBuffer&lt;SavedInfo, 32&gt;  _saved_frames;\n};\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/dir_318b426d8cd05d152bbbb07da75dfdce/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/include","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; include</p>"},{"location":"GGPOUE4/dir_318b426d8cd05d152bbbb07da75dfdce/#files","title":"Files","text":"Type Name file connection_manager.cpp <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/include/</code></p>"},{"location":"GGPOUE4/connection__manager_8cpp/","title":"File connection_manager.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; include &gt; connection_manager.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"include/connection_manager.h\"</code></li> <li><code>#include \"types.h\"</code></li> <li><code>#include \"GGPOUE4.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/include/connection_manager.cpp</code></p>"},{"location":"GGPOUE4/connection__manager_8cpp_source/","title":"File connection_manager.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; include &gt; connection_manager.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"include/connection_manager.h\"\n#include \"types.h\"\n#include \"GGPOUE4.h\"\n\n\n#if defined(_WINDOWS)\nSOCKET\nCreateSocket(uint16 bind_port, int retries)\n{\n    SOCKET s;\n    sockaddr_in sin;\n    uint16 port;\n    int optval = 1;\n\n    s = socket(AF_INET, SOCK_DGRAM, 0);\n    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (const char*)&amp;optval, sizeof optval);\n    setsockopt(s, SOL_SOCKET, SO_DONTLINGER, (const char*)&amp;optval, sizeof optval);\n\n    // non-blocking...\n    u_long iMode = 1;\n    ioctlsocket(s, FIONBIO, &amp;iMode);\n\n    sin.sin_family = AF_INET;\n    sin.sin_addr.s_addr = htonl(INADDR_ANY);\n    for (port = bind_port; port &lt;= bind_port + retries; port++) {\n        sin.sin_port = htons(port);\n        if (bind(s, (sockaddr*)&amp;sin, sizeof sin) != SOCKET_ERROR) {\n            UE_LOG(GGPOLOG, Verbose, TEXT(\"Udp bound to port: %d.\"), port);\n            return s;\n        }\n    }\n    closesocket(s);\n    return INVALID_SOCKET;\n}\n#endif\n\nConnectionManager::~ConnectionManager() {\n    _connection_map.clear();\n}\n\nstd::string ConnectionManager::ToString(int connection_id) {\n    check(_connection_map.count(connection_id));\n    std::shared_ptr&lt;ConnectionInfo&gt; dest_addr = _connection_map.find(connection_id)-&gt;second;\n    return dest_addr-&gt;ToString();\n}\n\n\n#if defined(_WINDOWS)\nUDPConnectionManager::UDPConnectionManager() : _socket(INVALID_SOCKET), _peer_addr() {}\n\nint UDPConnectionManager::SendTo(const char* buffer, int len, int flags, int connection_id) {\n\n    check(_connection_map.count(connection_id));\n    if (_connection_map.count(connection_id) == 0) {\n        UE_LOG(GGPOLOG, Warning, TEXT(\"Connection not in map Connection ID: %d).\"), connection_id);\n    }\n\n    std::shared_ptr&lt;ConnectionInfo&gt; dest_addr = _connection_map.find(connection_id)-&gt;second;\n\n    int res = sendto(_socket, buffer, len, flags,\n        (struct sockaddr*) &amp; static_cast &lt;UPDInfo&amp;&gt;(*dest_addr).addr,\n        sizeof(static_cast &lt;UPDInfo&amp;&gt;(*dest_addr).addr));\n\n    if (res == SOCKET_ERROR) {\n        DWORD err = WSAGetLastError();\n\n        UE_LOG(GGPOLOG, Error, TEXT(\"Unknown error in sendto (erro: %d  wsaerr: %d), Connection ID: %d.\\n\"), res, err, connection_id)       \n        check(false &amp;&amp; \"Unknown error in sendto\");\n    }\n    UE_LOG(GGPOLOG, Verbose, TEXT(\"Connection not in map Connection ID: %d).\"), len,\n        ToString(connection_id).c_str(), res);\n\n    return 0;\n}\n\nint UDPConnectionManager::RecvFrom(char* buffer, int len, int flags, int* connection_id) {\n\n    sockaddr_in    recv_addr;\n    int            recv_addr_len;\n    recv_addr_len = sizeof(recv_addr);\n\n    // &gt;0 indicates data length.\n    // 0 indicates a disconnect.\n    // -1 indicates no data or some other error.\n    int inlen = recvfrom(_socket, (char*)buffer, len, flags, (struct sockaddr*) &amp; recv_addr, &amp;recv_addr_len);\n\n    // Assign connection_id to the id we recieved the data from.\n    *connection_id = FindIDFromIP(&amp;recv_addr);\n\n    // Platform specific error message handling should be done in the connection manager.\n    if (inlen == -1) {\n        int error = WSAGetLastError();\n        if (error != WSAEWOULDBLOCK) {\n            UE_LOG(GGPOLOG, Error, TEXT(\"recvfrom WSAGetLastError returned %d (%x).\"), error, error);\n        }\n    }\n\n    return inlen;\n}\n\nint UDPConnectionManager::FindIDFromIP(sockaddr_in* addr) {\n\n    for (std::map&lt;int, std::shared_ptr&lt;ConnectionInfo&gt;&gt;::iterator it = _connection_map.begin();\n        it != _connection_map.end();\n        ++it) {\n        std::shared_ptr&lt;ConnectionInfo&gt; dest_addr(it-&gt;second);\n        // Note: dynamic casts don't work here because UE4 doesn't allow for normal dynamic casting.\n        if( static_cast &lt;UPDInfo&amp;&gt;(*dest_addr).addr.sin_addr.S_un.S_addr == addr-&gt;sin_addr.S_un.S_addr\n            &amp;&amp;\n            static_cast &lt;UPDInfo&amp;&gt;(*dest_addr).addr.sin_port == addr-&gt;sin_port) {\n            return it-&gt;first;\n        }\n    }\n    return -1;\n}\n\nvoid UDPConnectionManager::Init(uint16 port) {\n    UE_LOG(GGPOLOG, Verbose, TEXT(\"Binding udp socket to port %d.\"), port);\n    _socket = CreateSocket(port, 0);\n}\n\nint UDPConnectionManager::AddConnection(const char* ip_address, uint16 port) {\n    return ConnectionManager::AddConnection(BuildConnectionInfo(ip_address, port));\n}\n\nUDPConnectionManager::~UDPConnectionManager() {\n    if (_socket != INVALID_SOCKET) {\n        closesocket(_socket);\n        _socket = INVALID_SOCKET;\n    }\n}\n\nstd::shared_ptr&lt;ConnectionInfo&gt; UDPConnectionManager::BuildConnectionInfo(const char* ip_address, uint16 port) {\n    return std::static_pointer_cast&lt;ConnectionInfo&gt;(std::make_shared&lt;UPDInfo&gt;(ip_address, port));\n}\n\nUPDInfo::UPDInfo(const char* ip_address, uint16 port) {\n    addr.sin_family = AF_INET;\n    inet_pton(AF_INET, ip_address, &amp;addr.sin_addr.s_addr);\n    addr.sin_port = htons(port);\n}\n\nstd::string UPDInfo::ToString() {\n    char dst_ip[1024];\n    char buffer[100];\n    sprintf(buffer, \"Connection: IP: %s, Port: %d\",\n        inet_ntop(AF_INET, (void*)(&amp;addr.sin_addr), dst_ip, ARRAY_SIZE(dst_ip)),\n        ntohs(addr.sin_port));\n    return std::string(buffer);\n\n}\n#endif\n</code></pre>"},{"location":"GGPOUE4/dir_ecf22e3aebc35a5fe7ab40162c798880/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; network</p>"},{"location":"GGPOUE4/dir_ecf22e3aebc35a5fe7ab40162c798880/#files","title":"Files","text":"Type Name file udp.cpp file udp.h file udp_msg.h file udp_proto.cpp file udp_proto.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/</code></p>"},{"location":"GGPOUE4/udp_8cpp/","title":"File udp.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; network &gt; udp.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"udp.h\"</code></li> <li><code>#include \"types.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp.cpp</code></p>"},{"location":"GGPOUE4/udp_8cpp_source/","title":"File udp.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; network &gt; udp.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#include \"udp.h\"\n#include \"types.h\"\n\nUdp::Udp() :\n   _connection_manager(),\n   _callbacks(NULL),\n   _poll(NULL)\n{\n}\n\nUdp::~Udp(void)\n{\n}\n\nvoid\nUdp::Init(Poll *poll, Callbacks *callbacks, ConnectionManager* connection_manager)\n{\n   _callbacks = callbacks;\n\n   _poll = poll;\n   _connection_manager = connection_manager;\n   _poll-&gt;RegisterLoop(this);\n}\n\nvoid\nUdp::SendTo(char *buffer, int len, int flags, int connection_id)\n{\n   _connection_manager-&gt;SendTo(buffer, len, flags, connection_id);\n}\n\nbool\nUdp::OnLoopPoll(void *cookie)\n{\n   uint8          recv_buf[MAX_UDP_PACKET_SIZE];\n\n   for (;;) {\n      int connection_id = -1;\n      int len = _connection_manager-&gt;RecvFrom((char*)recv_buf, MAX_UDP_PACKET_SIZE, 0, &amp;connection_id);\n\n      // TODO: handle len == 0... indicates a disconnect.\n\n      if (len == -1 || connection_id == -1) {\n#ifdef _WIN32\n         int error = WSAGetLastError();\n#else\n         int error = 1;\n#endif\n         if (error != WSAEWOULDBLOCK) {\n            Log(\"recvfrom WSAGetLastError returned %d (%x).\\n\", error, error);\n         }\n         break;\n      } else if (len &gt; 0) {\n         //Log(\"recvfrom returned (len:%d  from:%s).\\n\", len, _connection_manager-&gt;ToString(connection_id).c_str());\n         UdpMsg *msg = (UdpMsg *)recv_buf;\n         _callbacks-&gt;OnMsg(connection_id, msg, len);\n      } \n   }\n   return true;\n}\n\n\nvoid\nUdp::Log(const char *fmt, ...)\n{\n   char buf[1024];\n   size_t offset;\n   va_list args;\n\n   strcpy(buf, \"udp | \");\n   offset = strlen(buf);\n   va_start(args, fmt);\n   vsnprintf(buf + offset, ARRAY_SIZE(buf) - offset - 1, fmt, args);\n   buf[ARRAY_SIZE(buf)-1] = '\\0';\n   ::Log(buf);\n   va_end(args);\n}\n</code></pre>"},{"location":"GGPOUE4/udp_8h/","title":"File udp.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; network &gt; udp.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"poll.h\"</code></li> <li><code>#include \"udp_msg.h\"</code></li> <li><code>#include \"include/ggponet.h\"</code></li> <li><code>#include \"include/connection_manager.h\"</code></li> </ul>"},{"location":"GGPOUE4/udp_8h/#classes","title":"Classes","text":"Type Name class Udp struct Callbacks struct Stats"},{"location":"GGPOUE4/udp_8h/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const int MAX_UDP_PACKET_SIZE   = <code>4096</code>"},{"location":"GGPOUE4/udp_8h/#macros","title":"Macros","text":"Type Name define MAX_UDP_ENDPOINTS <code>16</code>"},{"location":"GGPOUE4/udp_8h/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"GGPOUE4/udp_8h/#variable-max_udp_packet_size","title":"variable MAX_UDP_PACKET_SIZE","text":"<pre><code>const int MAX_UDP_PACKET_SIZE;\n</code></pre>"},{"location":"GGPOUE4/udp_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/udp_8h/#define-max_udp_endpoints","title":"define MAX_UDP_ENDPOINTS","text":"<pre><code>#define MAX_UDP_ENDPOINTS `16`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp.h</code></p>"},{"location":"GGPOUE4/udp_8h_source/","title":"File udp.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; network &gt; udp.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _UDP_H\n#define _UDP_H\n\n#include \"poll.h\"\n#include \"udp_msg.h\"\n#include \"include/ggponet.h\"\n#include \"include/connection_manager.h\"\n\n#define MAX_UDP_ENDPOINTS     16\n\nstatic const int MAX_UDP_PACKET_SIZE = 4096;\n\nclass Udp : public IPollSink\n{\npublic:\n   struct Stats {\n      int      bytes_sent;\n      int      packets_sent;\n      float    kbps_sent;\n   };\n\n   struct Callbacks {\n      virtual ~Callbacks() { }\n      virtual void OnMsg(int connection_id, UdpMsg *msg, int len) = 0;\n   };\n\n\nprotected:\n   void Log(const char *fmt, ...);\n\npublic:\n   Udp();\n\n   void Init(Poll *p, Callbacks *callbacks, ConnectionManager* connection_manager);\n\n   void SendTo(char *buffer, int len, int flags, int connection_id);\n\n   virtual bool OnLoopPoll(void *cookie);\n\npublic:\n   ~Udp(void);\n\nprotected:\n   ConnectionManager* _connection_manager;\n\n   // state management\n   Callbacks      *_callbacks;\n   Poll           *_poll;\n};\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/udp__msg_8h/","title":"File udp_msg.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; network &gt; udp_msg.h</p> <p>Go to the source code of this file</p>"},{"location":"GGPOUE4/udp__msg_8h/#classes","title":"Classes","text":"Type Name struct UdpMsg struct connect_status"},{"location":"GGPOUE4/udp__msg_8h/#macros","title":"Macros","text":"Type Name define MAX_COMPRESSED_BITS <code>4096</code> define UDP_MSG_MAX_PLAYERS <code>4</code>"},{"location":"GGPOUE4/udp__msg_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/udp__msg_8h/#define-max_compressed_bits","title":"define MAX_COMPRESSED_BITS","text":"<pre><code>#define MAX_COMPRESSED_BITS `4096`\n</code></pre>"},{"location":"GGPOUE4/udp__msg_8h/#define-udp_msg_max_players","title":"define UDP_MSG_MAX_PLAYERS","text":"<pre><code>#define UDP_MSG_MAX_PLAYERS `4`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp_msg.h</code></p>"},{"location":"GGPOUE4/udp__msg_8h_source/","title":"File udp_msg.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; network &gt; udp_msg.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _UDP_MSG_H\n#define _UDP_MSG_H\n\n#define MAX_COMPRESSED_BITS       4096\n#define UDP_MSG_MAX_PLAYERS          4\n\n#pragma pack(push, 1)\n\nstruct UdpMsg\n{\n   enum MsgType {\n      Invalid       = 0,\n      SyncRequest   = 1,\n      SyncReply     = 2,\n      Input         = 3,\n      QualityReport = 4,\n      QualityReply  = 5,\n      KeepAlive     = 6,\n      InputAck      = 7,\n   };\n\n   struct connect_status {\n      unsigned int   disconnected:1;\n      int            last_frame:31;\n   };\n\n   struct {\n      uint16         magic;\n      uint16         sequence_number;\n      uint8          type;            /* packet type */\n   } hdr;\n   union {\n      struct {\n         uint32      random_request;  /* please reply back with this random data */\n         uint16      remote_magic;\n         uint8       remote_endpoint;\n      } sync_request;\n\n      struct {\n         uint32      random_reply;    /* OK, here's your random data back */\n      } sync_reply;\n\n      struct {\n         int8        frame_advantage; /* what's the other guy's frame advantage? */\n         uint32      ping;\n      } quality_report;\n\n      struct {\n         uint32      pong;\n      } quality_reply;\n\n      struct {\n         connect_status    peer_connect_status[UDP_MSG_MAX_PLAYERS];\n\n         uint32            start_frame;\n\n         int               disconnect_requested:1;\n         int               ack_frame:31;\n\n         uint16            num_bits;\n         uint8             input_size; // XXX: shouldn't be in every single packet!\n         uint8             bits[MAX_COMPRESSED_BITS]; /* must be last */\n      } input;\n\n      struct {\n         int               ack_frame:31;\n      } input_ack;\n\n   } u;\n\npublic:\n   int PacketSize() {\n      return sizeof(hdr) + PayloadSize();\n   }\n\n   int PayloadSize() {\n      int size;\n\n      switch (hdr.type) {\n      case SyncRequest:   return sizeof(u.sync_request);\n      case SyncReply:     return sizeof(u.sync_reply);\n      case QualityReport: return sizeof(u.quality_report);\n      case QualityReply:  return sizeof(u.quality_reply);\n      case InputAck:      return sizeof(u.input_ack);\n      case KeepAlive:     return 0;\n      case Input:\n         size = (int)((char *)&amp;u.input.bits - (char *)&amp;u.input);\n         size += (u.input.num_bits + 7) / 8;\n         return size;\n      }\n      ASSERT(false);\n      return 0;\n   }\n\n   UdpMsg(MsgType t) { hdr.type = (uint8)t; }\n};\n\n#pragma pack(pop)\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/udp__proto_8cpp/","title":"File udp_proto.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; network &gt; udp_proto.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"udp_proto.h\"</code></li> <li><code>#include \"types.h\"</code></li> <li><code>#include \"bitvector.h\"</code></li> </ul>"},{"location":"GGPOUE4/udp__proto_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const int KEEP_ALIVE_INTERVAL   = <code>200</code> const int MAX_SEQ_DISTANCE   = <code>(1 &amp;lt;&amp;lt; 15)</code> const int NETWORK_STATS_INTERVAL   = <code>1000</code> const int NUM_SYNC_PACKETS   = <code>5</code> const int QUALITY_REPORT_INTERVAL   = <code>1000</code> const int RUNNING_RETRY_INTERVAL   = <code>200</code> const int SYNC_FIRST_RETRY_INTERVAL   = <code>500</code> const int SYNC_RETRY_INTERVAL   = <code>2000</code> const int UDP_HEADER_SIZE   = <code>28</code> const int UDP_SHUTDOWN_TIMER   = <code>5000</code>"},{"location":"GGPOUE4/udp__proto_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"GGPOUE4/udp__proto_8cpp/#variable-keep_alive_interval","title":"variable KEEP_ALIVE_INTERVAL","text":"<pre><code>const int KEEP_ALIVE_INTERVAL;\n</code></pre>"},{"location":"GGPOUE4/udp__proto_8cpp/#variable-max_seq_distance","title":"variable MAX_SEQ_DISTANCE","text":"<pre><code>const int MAX_SEQ_DISTANCE;\n</code></pre>"},{"location":"GGPOUE4/udp__proto_8cpp/#variable-network_stats_interval","title":"variable NETWORK_STATS_INTERVAL","text":"<pre><code>const int NETWORK_STATS_INTERVAL;\n</code></pre>"},{"location":"GGPOUE4/udp__proto_8cpp/#variable-num_sync_packets","title":"variable NUM_SYNC_PACKETS","text":"<pre><code>const int NUM_SYNC_PACKETS;\n</code></pre>"},{"location":"GGPOUE4/udp__proto_8cpp/#variable-quality_report_interval","title":"variable QUALITY_REPORT_INTERVAL","text":"<pre><code>const int QUALITY_REPORT_INTERVAL;\n</code></pre>"},{"location":"GGPOUE4/udp__proto_8cpp/#variable-running_retry_interval","title":"variable RUNNING_RETRY_INTERVAL","text":"<pre><code>const int RUNNING_RETRY_INTERVAL;\n</code></pre>"},{"location":"GGPOUE4/udp__proto_8cpp/#variable-sync_first_retry_interval","title":"variable SYNC_FIRST_RETRY_INTERVAL","text":"<pre><code>const int SYNC_FIRST_RETRY_INTERVAL;\n</code></pre>"},{"location":"GGPOUE4/udp__proto_8cpp/#variable-sync_retry_interval","title":"variable SYNC_RETRY_INTERVAL","text":"<pre><code>const int SYNC_RETRY_INTERVAL;\n</code></pre>"},{"location":"GGPOUE4/udp__proto_8cpp/#variable-udp_header_size","title":"variable UDP_HEADER_SIZE","text":"<pre><code>const int UDP_HEADER_SIZE;\n</code></pre>"},{"location":"GGPOUE4/udp__proto_8cpp/#variable-udp_shutdown_timer","title":"variable UDP_SHUTDOWN_TIMER","text":"<pre><code>const int UDP_SHUTDOWN_TIMER;\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp_proto.cpp</code></p>"},{"location":"GGPOUE4/udp__proto_8cpp_source/","title":"File udp_proto.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; network &gt; udp_proto.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#include \"udp_proto.h\"\n#include \"types.h\"\n#include \"bitvector.h\"\n\nstatic const int UDP_HEADER_SIZE = 28;     /* Size of IP + UDP headers */\nstatic const int NUM_SYNC_PACKETS = 5;\nstatic const int SYNC_RETRY_INTERVAL = 2000;\nstatic const int SYNC_FIRST_RETRY_INTERVAL = 500;\nstatic const int RUNNING_RETRY_INTERVAL = 200;\nstatic const int KEEP_ALIVE_INTERVAL    = 200;\nstatic const int QUALITY_REPORT_INTERVAL = 1000;\nstatic const int NETWORK_STATS_INTERVAL  = 1000;\nstatic const int UDP_SHUTDOWN_TIMER = 5000;\nstatic const int MAX_SEQ_DISTANCE = (1 &lt;&lt; 15);\n\nUdpProtocol::UdpProtocol() :\n   _udp(NULL),\n   _magic_number(0),\n   _queue(-1),\n   _remote_magic_number(0),\n   _connected(false),\n   _packets_sent(0),\n   _bytes_sent(0),\n   _stats_start_time(0),\n   _local_frame_advantage(0),\n   _remote_frame_advantage(0),\n   _last_send_time(0),\n   _shutdown_timeout(0),\n   _disconnect_event_sent(false),\n   _disconnect_timeout(0),\n   _disconnect_notify_start(0),\n   _disconnect_notify_sent(false),\n   _next_send_seq(0),\n   _next_recv_seq(0)\n{\n   _last_sent_input.init(-1, NULL, 1);\n   _last_received_input.init(-1, NULL, 1);\n   _last_acked_input.init(-1, NULL, 1);\n\n   memset(&amp;_state, 0, sizeof _state);\n   memset(_peer_connect_status, 0, sizeof(_peer_connect_status));\n   for (int i = 0; i &lt; ARRAY_SIZE(_peer_connect_status); i++) {\n      _peer_connect_status[i].last_frame = -1;\n   }\n   _oo_packet.msg = NULL;\n\n   _send_latency = 2;\n   _oop_percent = 0;\n}\n\nUdpProtocol::~UdpProtocol()\n{\n   ClearSendQueue();\n}\n\nvoid\nUdpProtocol::Init(Udp *udp,\n                  Poll &amp;poll,\n                  int queue,\n                  int connection_id,\n                  UdpMsg::connect_status *status)\n{  \n   _udp = udp;\n   _queue = queue;\n   _local_connect_status = status;\n\n   _connection_id = connection_id;\n\n   do {\n      _magic_number = (uint16)rand();\n   } while (_magic_number == 0);\n   poll.RegisterLoop(this);\n}\n\nvoid\nUdpProtocol::SendInput(GameInput &amp;input)\n{\n   if (_udp) {\n      if (_current_state == Running) {\n         /*\n          * Check to see if this is a good time to adjust for the rift...\n          */\n         _timesync.advance_frame(input, _local_frame_advantage, _remote_frame_advantage);\n\n         /*\n          * Save this input packet\n          *\n          * XXX: This queue may fill up for spectators who do not ack input packets in a timely\n          * manner.  When this happens, we can either resize the queue (ug) or disconnect them\n          * (better, but still ug).  For the meantime, make this queue really big to decrease\n          * the odds of this happening...\n          */\n         _pending_output.push(input);\n      }\n      SendPendingOutput();\n   }  \n}\n\nvoid\nUdpProtocol::SendPendingOutput()\n{\n   UdpMsg *msg = new UdpMsg(UdpMsg::Input);\n   int i, j, offset = 0;\n   uint8 *bits;\n   GameInput last;\n\n   if (_pending_output.size()) {\n      last = _last_acked_input;\n      bits = msg-&gt;u.input.bits;\n\n      msg-&gt;u.input.start_frame = _pending_output.front().frame;\n      msg-&gt;u.input.input_size = (uint8)_pending_output.front().size;\n\n      ASSERT(last.frame == -1 || last.frame + 1 == msg-&gt;u.input.start_frame);\n      for (j = 0; j &lt; _pending_output.size(); j++) {\n         GameInput &amp;current = _pending_output.item(j);\n         if (memcmp(current.bits, last.bits, current.size) != 0) {\n            ASSERT((GAMEINPUT_MAX_BYTES * GAMEINPUT_MAX_PLAYERS * 8) &lt; (1 &lt;&lt; BITVECTOR_NIBBLE_SIZE));\n            for (i = 0; i &lt; current.size * 8; i++) {\n               ASSERT(i &lt; (1 &lt;&lt; BITVECTOR_NIBBLE_SIZE));\n               if (current.value(i) != last.value(i)) {\n                  BitVector_SetBit(msg-&gt;u.input.bits, &amp;offset);\n                  (current.value(i) ? BitVector_SetBit : BitVector_ClearBit)(bits, &amp;offset);\n                  BitVector_WriteNibblet(bits, i, &amp;offset);\n               }\n            }\n         }\n         BitVector_ClearBit(msg-&gt;u.input.bits, &amp;offset);\n         last = _last_sent_input = current;\n      }\n   } else {\n      msg-&gt;u.input.start_frame = 0;\n      msg-&gt;u.input.input_size = 0;\n   }\n   msg-&gt;u.input.ack_frame = _last_received_input.frame;\n   msg-&gt;u.input.num_bits = (uint16)offset;\n\n   msg-&gt;u.input.disconnect_requested = _current_state == Disconnected;\n   if (_local_connect_status) {\n      memcpy(msg-&gt;u.input.peer_connect_status, _local_connect_status, sizeof(UdpMsg::connect_status) * UDP_MSG_MAX_PLAYERS);\n   } else {\n      memset(msg-&gt;u.input.peer_connect_status, 0, sizeof(UdpMsg::connect_status) * UDP_MSG_MAX_PLAYERS);\n   }\n\n   ASSERT(offset &lt; MAX_COMPRESSED_BITS);\n\n   SendMsg(msg);\n}\n\nvoid\nUdpProtocol::SendInputAck()\n{\n   UdpMsg *msg = new UdpMsg(UdpMsg::InputAck);\n   msg-&gt;u.input_ack.ack_frame = _last_received_input.frame;\n   SendMsg(msg);\n}\n\nbool\nUdpProtocol::GetEvent(UdpProtocol::Event &amp;e)\n{\n   if (_event_queue.size() == 0) {\n      return false;\n   }\n   e = _event_queue.front();\n   _event_queue.pop();\n   return true;\n}\n\n\nbool\nUdpProtocol::OnLoopPoll(void *cookie)\n{\n   if (!_udp) {\n      return true;\n   }\n\n   unsigned int now = Platform::GetCurrentTimeMS();\n   unsigned int next_interval;\n\n   PumpSendQueue();\n   switch (_current_state) {\n   case Syncing:\n      next_interval = (_state.sync.roundtrips_remaining == NUM_SYNC_PACKETS) ? SYNC_FIRST_RETRY_INTERVAL : SYNC_RETRY_INTERVAL;\n      if (_last_send_time &amp;&amp; _last_send_time + next_interval &lt; now) {\n         Log(\"No luck syncing after %d ms... Re-queueing sync packet.\\n\", next_interval);\n         SendSyncRequest();\n      }\n      break;\n\n   case Running:\n      // xxx: rig all this up with a timer wrapper\n      if (!_state.running.last_input_packet_recv_time || _state.running.last_input_packet_recv_time + RUNNING_RETRY_INTERVAL &lt; now) {\n         Log(\"Haven't exchanged packets in a while (last received:%d  last sent:%d).  Resending.\\n\", _last_received_input.frame, _last_sent_input.frame);\n         SendPendingOutput();\n         _state.running.last_input_packet_recv_time = now;\n      }\n\n      if (!_state.running.last_quality_report_time || _state.running.last_quality_report_time + QUALITY_REPORT_INTERVAL &lt; now) {\n         UdpMsg *msg = new UdpMsg(UdpMsg::QualityReport);\n         msg-&gt;u.quality_report.ping = Platform::GetCurrentTimeMS();\n         msg-&gt;u.quality_report.frame_advantage = (uint8)_local_frame_advantage;\n         SendMsg(msg);\n         _state.running.last_quality_report_time = now;\n      }\n\n      if (!_state.running.last_network_stats_interval || _state.running.last_network_stats_interval + NETWORK_STATS_INTERVAL &lt; now) {\n         UpdateNetworkStats();\n         _state.running.last_network_stats_interval =  now;\n      }\n\n      if (_last_send_time &amp;&amp; _last_send_time + KEEP_ALIVE_INTERVAL &lt; now) {\n         Log(\"Sending keep alive packet\\n\");\n         SendMsg(new UdpMsg(UdpMsg::KeepAlive));\n      }\n\n      if (_disconnect_timeout &amp;&amp; _disconnect_notify_start &amp;&amp; \n         !_disconnect_notify_sent &amp;&amp; (_last_recv_time + _disconnect_notify_start &lt; now)) {\n         Log(\"Endpoint has stopped receiving packets for %d ms.  Sending notification.\\n\", _disconnect_notify_start);\n         Event e(Event::NetworkInterrupted);\n         e.u.network_interrupted.disconnect_timeout = _disconnect_timeout - _disconnect_notify_start;\n         QueueEvent(e);\n         _disconnect_notify_sent = true;\n      }\n\n      if (_disconnect_timeout &amp;&amp; (_last_recv_time + _disconnect_timeout &lt; now)) {\n         if (!_disconnect_event_sent) {\n            Log(\"Endpoint has stopped receiving packets for %d ms.  Disconnecting.\\n\", _disconnect_timeout);\n            QueueEvent(Event(Event::Disconnected));\n            _disconnect_event_sent = true;\n         }\n      }\n      break;\n\n   case Disconnected:\n      if (_shutdown_timeout &lt; now) {\n         Log(\"Shutting down udp connection.\\n\");\n         _udp = NULL;\n         _shutdown_timeout = 0;\n      }\n\n   }\n\n\n   return true;\n}\n\nvoid\nUdpProtocol::Disconnect()\n{\n   _current_state = Disconnected;\n   _shutdown_timeout = Platform::GetCurrentTimeMS() + UDP_SHUTDOWN_TIMER;\n}\n\nvoid\nUdpProtocol::SendSyncRequest()\n{\n   _state.sync.random = rand() &amp; 0xFFFF;\n   UdpMsg *msg = new UdpMsg(UdpMsg::SyncRequest);\n   msg-&gt;u.sync_request.random_request = _state.sync.random;\n   SendMsg(msg);\n}\n\nvoid\nUdpProtocol::SendMsg(UdpMsg *msg)\n{\n   LogMsg(\"send\", msg);\n\n   _packets_sent++;\n   _last_send_time = Platform::GetCurrentTimeMS();\n   _bytes_sent += msg-&gt;PacketSize();\n\n   msg-&gt;hdr.magic = _magic_number;\n   msg-&gt;hdr.sequence_number = _next_send_seq++;\n\n   _send_queue.push(QueueEntry(Platform::GetCurrentTimeMS(), _connection_id, msg));\n   PumpSendQueue();\n}\n\nbool\nUdpProtocol::HandlesMsg(int connection_id,\n                        UdpMsg *msg)\n{\n   if (!_udp) {\n      return false;\n   }\n   return _connection_id == connection_id;\n}\n\nvoid\nUdpProtocol::OnMsg(UdpMsg *msg, int len)\n{\n   bool handled = false;\n   typedef bool (UdpProtocol::*DispatchFn)(UdpMsg *msg, int len);\n   static const DispatchFn table[] = {\n      &amp;UdpProtocol::OnInvalid,             /* Invalid */\n      &amp;UdpProtocol::OnSyncRequest,         /* SyncRequest */\n      &amp;UdpProtocol::OnSyncReply,           /* SyncReply */\n      &amp;UdpProtocol::OnInput,               /* Input */\n      &amp;UdpProtocol::OnQualityReport,       /* QualityReport */\n      &amp;UdpProtocol::OnQualityReply,        /* QualityReply */\n      &amp;UdpProtocol::OnKeepAlive,           /* KeepAlive */\n      &amp;UdpProtocol::OnInputAck,            /* InputAck */\n   };\n\n   // filter out messages that don't match what we expect\n   uint16 seq = msg-&gt;hdr.sequence_number;\n   if (msg-&gt;hdr.type != UdpMsg::SyncRequest &amp;&amp;\n       msg-&gt;hdr.type != UdpMsg::SyncReply) {\n      if (msg-&gt;hdr.magic != _remote_magic_number) {\n         LogMsg(\"recv rejecting\", msg);\n         return;\n      }\n\n      // filter out out-of-order packets\n      uint16 skipped = (uint16)((int)seq - (int)_next_recv_seq);\n      // Log(\"checking sequence number -&gt; next - seq : %d - %d = %d\\n\", seq, _next_recv_seq, skipped);\n      if (skipped &gt; MAX_SEQ_DISTANCE) {\n         Log(\"dropping out of order packet (seq: %d, last seq:%d)\\n\", seq, _next_recv_seq);\n         return;\n      }\n   }\n\n   _next_recv_seq = seq;\n   LogMsg(\"recv\", msg);\n   if (msg-&gt;hdr.type &gt;= ARRAY_SIZE(table)) {\n      OnInvalid(msg, len);\n   } else {\n      handled = (this-&gt;*(table[msg-&gt;hdr.type]))(msg, len);\n   }\n   if (handled) {\n      _last_recv_time = Platform::GetCurrentTimeMS();\n      if (_disconnect_notify_sent &amp;&amp; _current_state == Running) {\n         QueueEvent(Event(Event::NetworkResumed));   \n         _disconnect_notify_sent = false;\n      }\n   }\n}\n\nvoid\nUdpProtocol::UpdateNetworkStats(void)\n{\n   int now = Platform::GetCurrentTimeMS();\n\n   if (_stats_start_time == 0) {\n      _stats_start_time = now;\n   }\n\n   int total_bytes_sent = _bytes_sent + (UDP_HEADER_SIZE * _packets_sent);\n   float seconds = (float)((now - _stats_start_time) / 1000.0);\n   float Bps = total_bytes_sent / seconds;\n   float udp_overhead = (float)(100.0 * (UDP_HEADER_SIZE * _packets_sent) / _bytes_sent);\n\n   _kbps_sent = int(Bps / 1024);\n\n   Log(\"Network Stats -- Bandwidth: %.2f KBps   Packets Sent: %5d (%.2f pps)   \"\n       \"KB Sent: %.2f    UDP Overhead: %.2f %%.\\n\",\n       _kbps_sent, \n       _packets_sent,\n       (float)_packets_sent * 1000 / (now - _stats_start_time),\n       total_bytes_sent / 1024.0,\n       udp_overhead);\n}\n\n\nvoid\nUdpProtocol::QueueEvent(const UdpProtocol::Event &amp;evt)\n{\n   LogEvent(\"Queuing event\", evt);\n   _event_queue.push(evt);\n}\n\nvoid\nUdpProtocol::Synchronize()\n{\n   if (_udp) {\n      _current_state = Syncing;\n      _state.sync.roundtrips_remaining = NUM_SYNC_PACKETS;\n      SendSyncRequest();\n   }\n}\n\nbool\nUdpProtocol::GetPeerConnectStatus(int id, int *frame)\n{\n   *frame = _peer_connect_status[id].last_frame;\n   return !_peer_connect_status[id].disconnected;\n}\n\nvoid\nUdpProtocol::Log(const char *fmt, ...)\n{\n   char buf[1024];\n   size_t offset;\n   va_list args;\n\n   sprintf(buf, \"udpproto%d | \", _queue);\n   offset = strlen(buf);\n   va_start(args, fmt);\n   vsnprintf(buf + offset, ARRAY_SIZE(buf) - offset - 1, fmt, args);\n   buf[ARRAY_SIZE(buf)-1] = '\\0';\n   ::Log(buf);\n   va_end(args);\n}\n\nvoid\nUdpProtocol::LogMsg(const char *prefix, UdpMsg *msg)\n{\n   switch (msg-&gt;hdr.type) {\n   case UdpMsg::SyncRequest:\n      Log(\"%s sync-request (%d).\\n\", prefix,\n          msg-&gt;u.sync_request.random_request);\n      break;\n   case UdpMsg::SyncReply:\n      Log(\"%s sync-reply (%d).\\n\", prefix,\n          msg-&gt;u.sync_reply.random_reply);\n      break;\n   case UdpMsg::QualityReport:\n      Log(\"%s quality report.\\n\", prefix);\n      break;\n   case UdpMsg::QualityReply:\n      Log(\"%s quality reply.\\n\", prefix);\n      break;\n   case UdpMsg::KeepAlive:\n      Log(\"%s keep alive.\\n\", prefix);\n      break;\n   case UdpMsg::Input:\n      Log(\"%s game-compressed-input %d (+ %d bits).\\n\", prefix, msg-&gt;u.input.start_frame, msg-&gt;u.input.num_bits);\n      break;\n   case UdpMsg::InputAck:\n      Log(\"%s input ack.\\n\", prefix);\n      break;\n   default:\n      ASSERT(false &amp;&amp; \"Unknown UdpMsg type.\");\n   }\n}\n\nvoid\nUdpProtocol::LogEvent(const char *prefix, const UdpProtocol::Event &amp;evt)\n{\n   switch (evt.type) {\n   case UdpProtocol::Event::Synchronzied:\n      Log(\"%s (event: Synchronzied).\\n\", prefix);\n      break;\n   }\n}\n\nbool\nUdpProtocol::OnInvalid(UdpMsg *msg, int len)\n{\n   ASSERT(false &amp;&amp; \"Invalid msg in UdpProtocol\");\n   return false;\n}\n\nbool\nUdpProtocol::OnSyncRequest(UdpMsg *msg, int len)\n{\n   if (_remote_magic_number != 0 &amp;&amp; msg-&gt;hdr.magic != _remote_magic_number) {\n      Log(\"Ignoring sync request from unknown endpoint (%d != %d).\\n\", \n           msg-&gt;hdr.magic, _remote_magic_number);\n      return false;\n   }\n   UdpMsg *reply = new UdpMsg(UdpMsg::SyncReply);\n   reply-&gt;u.sync_reply.random_reply = msg-&gt;u.sync_request.random_request;\n   SendMsg(reply);\n   return true;\n}\n\nbool\nUdpProtocol::OnSyncReply(UdpMsg *msg, int len)\n{\n   if (_current_state != Syncing) {\n      Log(\"Ignoring SyncReply while not synching.\\n\");\n      return msg-&gt;hdr.magic == _remote_magic_number;\n   }\n\n   if (msg-&gt;u.sync_reply.random_reply != _state.sync.random) {\n      Log(\"sync reply %d != %d.  Keep looking...\\n\",\n          msg-&gt;u.sync_reply.random_reply, _state.sync.random);\n      return false;\n   }\n\n   if (!_connected) {\n      QueueEvent(Event(Event::Connected));\n      _connected = true;\n   }\n\n   Log(\"Checking sync state (%d round trips remaining).\\n\", _state.sync.roundtrips_remaining);\n   if (--_state.sync.roundtrips_remaining == 0) {\n      Log(\"Synchronized!\\n\");\n      QueueEvent(UdpProtocol::Event(UdpProtocol::Event::Synchronzied));\n      _current_state = Running;\n      _last_received_input.frame = -1;\n      _remote_magic_number = msg-&gt;hdr.magic;\n   } else {\n      UdpProtocol::Event evt(UdpProtocol::Event::Synchronizing);\n      evt.u.synchronizing.total = NUM_SYNC_PACKETS;\n      evt.u.synchronizing.count = NUM_SYNC_PACKETS - _state.sync.roundtrips_remaining;\n      QueueEvent(evt);\n      SendSyncRequest();\n   }\n   return true;\n}\n\nbool\nUdpProtocol::OnInput(UdpMsg *msg, int len)\n{\n   /*\n    * If a disconnect is requested, go ahead and disconnect now.\n    */\n   bool disconnect_requested = msg-&gt;u.input.disconnect_requested;\n   if (disconnect_requested) {\n      if (_current_state != Disconnected &amp;&amp; !_disconnect_event_sent) {\n         Log(\"Disconnecting endpoint on remote request.\\n\");\n         QueueEvent(Event(Event::Disconnected));\n         _disconnect_event_sent = true;\n      }\n   } else {\n      /*\n       * Update the peer connection status if this peer is still considered to be part\n       * of the network.\n       */\n      UdpMsg::connect_status* remote_status = msg-&gt;u.input.peer_connect_status;\n      for (int i = 0; i &lt; ARRAY_SIZE(_peer_connect_status); i++) {\n         ASSERT(remote_status[i].last_frame &gt;= _peer_connect_status[i].last_frame);\n         _peer_connect_status[i].disconnected = _peer_connect_status[i].disconnected || remote_status[i].disconnected;\n         _peer_connect_status[i].last_frame = MAX(_peer_connect_status[i].last_frame, remote_status[i].last_frame);\n      }\n   }\n\n   /*\n    * Decompress the input.\n    */\n   int last_received_frame_number = _last_received_input.frame;\n   if (msg-&gt;u.input.num_bits) {\n      int offset = 0;\n      uint8 *bits = (uint8 *)msg-&gt;u.input.bits;\n      int numBits = msg-&gt;u.input.num_bits;\n      int currentFrame = msg-&gt;u.input.start_frame;\n\n      _last_received_input.size = msg-&gt;u.input.input_size;\n      if (_last_received_input.frame &lt; 0) {\n         _last_received_input.frame = msg-&gt;u.input.start_frame - 1;\n      }\n      while (offset &lt; numBits) {\n         /*\n          * Keep walking through the frames (parsing bits) until we reach\n          * the inputs for the frame right after the one we're on.\n          */\n         ASSERT(currentFrame &lt;= (_last_received_input.frame + 1));\n         bool useInputs = currentFrame == _last_received_input.frame + 1;\n\n         while (BitVector_ReadBit(bits, &amp;offset)) {\n            int on = BitVector_ReadBit(bits, &amp;offset);\n            int button = BitVector_ReadNibblet(bits, &amp;offset);\n            if (useInputs) {\n               if (on) {\n                  _last_received_input.set(button);\n               } else {\n                  _last_received_input.clear(button);\n               }\n            }\n         }\n         ASSERT(offset &lt;= numBits);\n\n         /*\n          * Now if we want to use these inputs, go ahead and send them to\n          * the emulator.\n          */\n         if (useInputs) {\n            /*\n             * Move forward 1 frame in the stream.\n             */\n            char desc[1024];\n            ASSERT(currentFrame == _last_received_input.frame + 1);\n            _last_received_input.frame = currentFrame;\n\n            /*\n             * Send the event to the emualtor\n             */\n            UdpProtocol::Event evt(UdpProtocol::Event::Input);\n            evt.u.input.input = _last_received_input;\n\n            _last_received_input.desc(desc, ARRAY_SIZE(desc));\n\n            _state.running.last_input_packet_recv_time = Platform::GetCurrentTimeMS();\n\n            Log(\"Sending frame %d to emu queue %d (%s).\\n\", _last_received_input.frame, _queue, desc);\n            QueueEvent(evt);\n\n         } else {\n            Log(\"Skipping past frame:(%d) current is %d.\\n\", currentFrame, _last_received_input.frame);\n         }\n\n         /*\n          * Move forward 1 frame in the input stream.\n          */\n         currentFrame++;\n      }\n   }\n   ASSERT(_last_received_input.frame &gt;= last_received_frame_number);\n\n   /*\n    * Get rid of our buffered input\n    */\n   while (_pending_output.size() &amp;&amp; _pending_output.front().frame &lt; msg-&gt;u.input.ack_frame) {\n      Log(\"Throwing away pending output frame %d\\n\", _pending_output.front().frame);\n      _last_acked_input = _pending_output.front();\n      _pending_output.pop();\n   }\n   return true;\n}\n\n\nbool\nUdpProtocol::OnInputAck(UdpMsg *msg, int len)\n{\n   /*\n    * Get rid of our buffered input\n    */\n   while (_pending_output.size() &amp;&amp; _pending_output.front().frame &lt; msg-&gt;u.input_ack.ack_frame) {\n      Log(\"Throwing away pending output frame %d\\n\", _pending_output.front().frame);\n      _last_acked_input = _pending_output.front();\n      _pending_output.pop();\n   }\n   return true;\n}\n\nbool\nUdpProtocol::OnQualityReport(UdpMsg *msg, int len)\n{\n   // send a reply so the other side can compute the round trip transmit time.\n   UdpMsg *reply = new UdpMsg(UdpMsg::QualityReply);\n   reply-&gt;u.quality_reply.pong = msg-&gt;u.quality_report.ping;\n   SendMsg(reply);\n\n   _remote_frame_advantage = msg-&gt;u.quality_report.frame_advantage;\n   return true;\n}\n\nbool\nUdpProtocol::OnQualityReply(UdpMsg *msg, int len)\n{\n   _round_trip_time = Platform::GetCurrentTimeMS() - msg-&gt;u.quality_reply.pong;\n   return true;\n}\n\nbool\nUdpProtocol::OnKeepAlive(UdpMsg *msg, int len)\n{\n   return true;\n}\n\nvoid\nUdpProtocol::GetNetworkStats(struct FGGPONetworkStats *s)\n{\n   s-&gt;network.ping = _round_trip_time;\n   s-&gt;network.send_queue_len = _pending_output.size();\n   s-&gt;network.kbps_sent = _kbps_sent;\n   s-&gt;timesync.remote_frames_behind = _remote_frame_advantage;\n   s-&gt;timesync.local_frames_behind = _local_frame_advantage;\n}\n\nvoid\nUdpProtocol::SetLocalFrameNumber(int localFrame)\n{\n   /*\n    * Estimate which frame the other guy is one by looking at the\n    * last frame they gave us plus some delta for the one-way packet\n    * trip time.\n    */\n   int remoteFrame = _last_received_input.frame + (_round_trip_time * 60 / 1000);\n\n   /*\n    * Our frame advantage is how many frames *behind* the other guy\n    * we are.  Counter-intuative, I know.  It's an advantage because\n    * it means they'll have to predict more often and our moves will\n    * pop more frequenetly.\n    */\n   _local_frame_advantage = remoteFrame - localFrame;\n}\n\nint\nUdpProtocol::RecommendFrameDelay()\n{\n   // XXX: require idle input should be a configuration parameter\n   return _timesync.recommend_frame_wait_duration(false);\n}\n\n\nvoid\nUdpProtocol::SetDisconnectTimeout(int timeout)\n{\n   _disconnect_timeout = timeout;\n}\n\nvoid\nUdpProtocol::SetDisconnectNotifyStart(int timeout)\n{\n   _disconnect_notify_start = timeout;\n}\n\nvoid\nUdpProtocol::PumpSendQueue()\n{\n   while (!_send_queue.empty()) {\n      QueueEntry &amp;entry = _send_queue.front();\n\n      if (_send_latency) {\n         // should really come up with a gaussian distributation based on the configured\n         // value, but this will do for now.\n         int jitter = (_send_latency * 2 / 3) + ((rand() % _send_latency) / 3);\n         if (Platform::GetCurrentTimeMS() &lt; _send_queue.front().queue_time + jitter) {\n            break;\n         }\n      }\n      if (_oop_percent &amp;&amp; !_oo_packet.msg &amp;&amp; ((rand() % 100) &lt; _oop_percent)) {\n         int delay = rand() % (_send_latency * 10 + 1000);\n         Log(\"creating rogue oop (seq: %d  delay: %d)\\n\", entry.msg-&gt;hdr.sequence_number, delay);\n         _oo_packet.send_time = Platform::GetCurrentTimeMS() + delay;\n         _oo_packet.msg = entry.msg;\n         _oo_packet.connection_id = entry.connection_id;\n      } else {\n         _udp-&gt;SendTo((char *)entry.msg, entry.msg-&gt;PacketSize(), 0, entry.connection_id);\n\n         delete entry.msg;\n      }\n      _send_queue.pop();\n   }\n   if (_oo_packet.msg &amp;&amp; _oo_packet.send_time &lt; Platform::GetCurrentTimeMS()) {\n      Log(\"sending rogue oop!\");\n      _udp-&gt;SendTo((char *)_oo_packet.msg, _oo_packet.msg-&gt;PacketSize(), 0, _oo_packet.connection_id);\n\n      delete _oo_packet.msg;\n      _oo_packet.msg = NULL;\n   }\n}\n\nvoid\nUdpProtocol::ClearSendQueue()\n{\n   while (!_send_queue.empty()) {\n      delete _send_queue.front().msg;\n      _send_queue.pop();\n   }\n}\n</code></pre>"},{"location":"GGPOUE4/udp__proto_8h/","title":"File udp_proto.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; network &gt; udp_proto.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"poll.h\"</code></li> <li><code>#include \"udp.h\"</code></li> <li><code>#include \"udp_msg.h\"</code></li> <li><code>#include \"game_input.h\"</code></li> <li><code>#include \"timesync.h\"</code></li> <li><code>#include \"include/ggponet.h\"</code></li> <li><code>#include \"ring_buffer.h\"</code></li> </ul>"},{"location":"GGPOUE4/udp__proto_8h/#classes","title":"Classes","text":"Type Name class UdpProtocol struct Event struct Stats <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/network/udp_proto.h</code></p>"},{"location":"GGPOUE4/udp__proto_8h_source/","title":"File udp_proto.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; network &gt; udp_proto.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _UDP_PROTO_H_\n#define _UDP_PROTO_H_\n\n#include \"poll.h\"\n#include \"udp.h\"\n#include \"udp_msg.h\"\n#include \"game_input.h\"\n#include \"timesync.h\"\n#include \"include/ggponet.h\"\n#include \"ring_buffer.h\"\n\nclass UdpProtocol : public IPollSink\n{\npublic:\n   struct Stats {\n      int                 ping;\n      int                 remote_frame_advantage;\n      int                 local_frame_advantage;\n      int                 send_queue_len;\n      Udp::Stats          udp;\n   };\n\n   struct Event {\n      enum Type {\n         Unknown = -1,\n         Connected,\n         Synchronizing,\n         Synchronzied,\n         Input,\n         Disconnected,\n         NetworkInterrupted,\n         NetworkResumed,\n      };\n\n      Type      type;\n      union {\n         struct {\n            GameInput   input;\n         } input;\n         struct {\n            int         total;\n            int         count;\n         } synchronizing;\n         struct {\n            int         disconnect_timeout;\n         } network_interrupted;\n      } u;\n\n      Event(Type t = Unknown) : type(t) { }\n   };\n\npublic:\n   virtual bool OnLoopPoll(void *cookie);\n\npublic:\n   UdpProtocol();\n   virtual ~UdpProtocol();\n\n   void Init(Udp *udp, Poll &amp;p, int queue, int connection_id, UdpMsg::connect_status *status);\n\n   void Synchronize();\n   bool GetPeerConnectStatus(int id, int *frame);\n   bool IsInitialized() { return _udp != NULL; }\n   bool IsSynchronized() { return _current_state == Running; }\n   bool IsRunning() { return _current_state == Running; }\n   void SendInput(GameInput &amp;input);\n   void SendInputAck();\n   bool HandlesMsg(int connection_id, UdpMsg *msg);\n   void OnMsg(UdpMsg *msg, int len);\n   void Disconnect();\n\n   void GetNetworkStats(struct FGGPONetworkStats *stats);\n   bool GetEvent(UdpProtocol::Event &amp;e);\n   void GGPONetworkStats(Stats *stats);\n   void SetLocalFrameNumber(int num);\n   int RecommendFrameDelay();\n\n   void SetDisconnectTimeout(int timeout);\n   void SetDisconnectNotifyStart(int timeout);\n\nprotected:\n   enum State {\n      Syncing,\n      Synchronzied,\n      Running,\n      Disconnected\n   };\n   struct QueueEntry {\n      int         queue_time;\n      int         connection_id;\n      UdpMsg      *msg;\n\n      QueueEntry() {}\n      QueueEntry(int time, int conn_id, UdpMsg *m) : queue_time(time), connection_id(conn_id), msg(m) { }\n   };\n\n   bool CreateSocket(int retries);\n   void UpdateNetworkStats(void);\n   void QueueEvent(const UdpProtocol::Event &amp;evt);\n   void ClearSendQueue(void);\n   void Log(const char *fmt, ...);\n   void LogMsg(const char *prefix, UdpMsg *msg);\n   void LogEvent(const char *prefix, const UdpProtocol::Event &amp;evt);\n   void SendSyncRequest();\n   void SendMsg(UdpMsg *msg);\n   void PumpSendQueue();\n   void DispatchMsg(uint8 *buffer, int len);\n   void SendPendingOutput();\n   bool OnInvalid(UdpMsg *msg, int len);\n   bool OnSyncRequest(UdpMsg *msg, int len);\n   bool OnSyncReply(UdpMsg *msg, int len);\n   bool OnInput(UdpMsg *msg, int len);\n   bool OnInputAck(UdpMsg *msg, int len);\n   bool OnQualityReport(UdpMsg *msg, int len);\n   bool OnQualityReply(UdpMsg *msg, int len);\n   bool OnKeepAlive(UdpMsg *msg, int len);\n\nprotected:\n   /*\n    * Network transmission information\n    */\n   ConnectionManager* connection_manager;\n   Udp            *_udp;\n   int             _connection_id; \n   uint16         _magic_number;\n   int            _queue;\n   uint16         _remote_magic_number;\n   bool           _connected;\n   int            _send_latency;\n   int            _oop_percent;\n   struct {\n      int         send_time;\n      int         connection_id;\n      UdpMsg*     msg;\n   }              _oo_packet;\n   RingBuffer&lt;QueueEntry, 64&gt; _send_queue;\n\n   /*\n    * Stats\n    */\n   int            _round_trip_time;\n   int            _packets_sent;\n   int            _bytes_sent;\n   int            _kbps_sent;\n   int            _stats_start_time;\n\n   /*\n    * The state machine\n    */\n   UdpMsg::connect_status *_local_connect_status;\n   UdpMsg::connect_status _peer_connect_status[UDP_MSG_MAX_PLAYERS];\n\n   State          _current_state;\n   union {\n      struct {\n         uint32   roundtrips_remaining;\n         uint32   random;\n      } sync;\n      struct {\n         uint32   last_quality_report_time;\n         uint32   last_network_stats_interval;\n         uint32   last_input_packet_recv_time;\n      } running;\n   } _state;\n\n   /*\n    * Fairness.\n    */\n   int               _local_frame_advantage;\n   int               _remote_frame_advantage;\n\n   /*\n    * Packet loss...\n    */\n   RingBuffer&lt;GameInput, 64&gt;  _pending_output;\n   GameInput                  _last_received_input;\n   GameInput                  _last_sent_input;\n   GameInput                  _last_acked_input;\n   unsigned int               _last_send_time;\n   unsigned int               _last_recv_time;\n   unsigned int               _shutdown_timeout;\n   unsigned int               _disconnect_event_sent;\n   unsigned int               _disconnect_timeout;\n   unsigned int               _disconnect_notify_start;\n   bool                       _disconnect_notify_sent;\n\n   uint16                     _next_send_seq;\n   uint16                     _next_recv_seq;\n\n   /*\n    * Rift synchronization.\n    */\n   TimeSync                   _timesync;\n\n   /*\n    * Event queue\n    */\n   RingBuffer&lt;UdpProtocol::Event, 64&gt;  _event_queue;\n};\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/_g_g_p_o_game_instance_8cpp/","title":"File GGPOGameInstance.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; GGPOGameInstance.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GGPOGameInstance.h\"</code></li> <li><code>#include \"include/ggponet.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/GGPOGameInstance.cpp</code></p>"},{"location":"GGPOUE4/_g_g_p_o_game_instance_8cpp_source/","title":"File GGPOGameInstance.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; GGPOGameInstance.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2020 BwdYeti.\n\n\n#include \"GGPOGameInstance.h\"\n#include \"include/ggponet.h\"\n\nvoid UGGPOGameInstance::CreateNetwork(int32 NumPlayers, int32 PlayerIndex, int32 LocalPort, TArray&lt;FString&gt; RemoteAddresses)\n{\n    UGGPONetwork* addresses = UGGPONetwork::CreateNetwork(\n        this,\n        FName(FString(TEXT(\"GGPONetwork\"))),\n        NumPlayers,\n        PlayerIndex,\n        LocalPort,\n        RemoteAddresses);\n    NetworkAddresses = addresses;\n}\n</code></pre>"},{"location":"GGPOUE4/_g_g_p_o_u_e4_8cpp/","title":"File GGPOUE4.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; GGPOUE4.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"GGPOUE4.h\"</code></li> </ul>"},{"location":"GGPOUE4/_g_g_p_o_u_e4_8cpp/#public-functions","title":"Public Functions","text":"Type Name DEFINE_LOG_CATEGORY (GGPOLOG)"},{"location":"GGPOUE4/_g_g_p_o_u_e4_8cpp/#macros","title":"Macros","text":"Type Name define LOCTEXT_NAMESPACE <code>\"FGGPOUE4Module\"</code>"},{"location":"GGPOUE4/_g_g_p_o_u_e4_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/_g_g_p_o_u_e4_8cpp/#function-define_log_category","title":"function DEFINE_LOG_CATEGORY","text":"<pre><code>DEFINE_LOG_CATEGORY (\n    GGPOLOG\n) \n</code></pre>"},{"location":"GGPOUE4/_g_g_p_o_u_e4_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/_g_g_p_o_u_e4_8cpp/#define-loctext_namespace","title":"define LOCTEXT_NAMESPACE","text":"<pre><code>#define LOCTEXT_NAMESPACE `\"FGGPOUE4Module\"`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/GGPOUE4.cpp</code></p>"},{"location":"GGPOUE4/_g_g_p_o_u_e4_8cpp_source/","title":"File GGPOUE4.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; GGPOUE4.cpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright Epic Games, Inc. All Rights Reserved.\n\n#include \"GGPOUE4.h\"\n\n#define LOCTEXT_NAMESPACE \"FGGPOUE4Module\"\n\nDEFINE_LOG_CATEGORY(GGPOLOG);\n\nvoid FGGPOUE4Module::StartupModule()\n{\n    // This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module\n}\n\nvoid FGGPOUE4Module::ShutdownModule()\n{\n    // This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,\n    // we call this function before unloading the module.\n}\n\n#undef LOCTEXT_NAMESPACE\n\nIMPLEMENT_MODULE(FGGPOUE4Module, GGPOUE4)\n</code></pre>"},{"location":"GGPOUE4/bitvector_8cpp/","title":"File bitvector.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; bitvector.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"bitvector.h\"</code></li> <li><code>#include \"types.h\"</code></li> </ul>"},{"location":"GGPOUE4/bitvector_8cpp/#public-functions","title":"Public Functions","text":"Type Name void BitVector_ClearBit (uint8 * vector, int * offset)  int BitVector_ReadBit (uint8 * vector, int * offset)  int BitVector_ReadNibblet (uint8 * vector, int * offset)  void BitVector_SetBit (uint8 * vector, int * offset)  void BitVector_WriteNibblet (uint8 * vector, int nibble, int * offset)"},{"location":"GGPOUE4/bitvector_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/bitvector_8cpp/#function-bitvector_clearbit","title":"function BitVector_ClearBit","text":"<pre><code>void BitVector_ClearBit (\n    uint8 * vector,\n    int * offset\n) \n</code></pre>"},{"location":"GGPOUE4/bitvector_8cpp/#function-bitvector_readbit","title":"function BitVector_ReadBit","text":"<pre><code>int BitVector_ReadBit (\n    uint8 * vector,\n    int * offset\n) \n</code></pre>"},{"location":"GGPOUE4/bitvector_8cpp/#function-bitvector_readnibblet","title":"function BitVector_ReadNibblet","text":"<pre><code>int BitVector_ReadNibblet (\n    uint8 * vector,\n    int * offset\n) \n</code></pre>"},{"location":"GGPOUE4/bitvector_8cpp/#function-bitvector_setbit","title":"function BitVector_SetBit","text":"<pre><code>void BitVector_SetBit (\n    uint8 * vector,\n    int * offset\n) \n</code></pre>"},{"location":"GGPOUE4/bitvector_8cpp/#function-bitvector_writenibblet","title":"function BitVector_WriteNibblet","text":"<pre><code>void BitVector_WriteNibblet (\n    uint8 * vector,\n    int nibble,\n    int * offset\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/bitvector.cpp</code></p>"},{"location":"GGPOUE4/bitvector_8cpp_source/","title":"File bitvector.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; bitvector.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#include \"bitvector.h\"\n#include \"types.h\"\n\nvoid\nBitVector_SetBit(uint8 *vector, int *offset)\n{\n   vector[(*offset) / 8] |= (1 &lt;&lt; ((*offset) % 8));\n   *offset += 1;\n}\n\nvoid\nBitVector_ClearBit(uint8 *vector, int *offset)\n{\n   vector[(*offset) / 8] &amp;= ~(1 &lt;&lt; ((*offset) % 8));\n   *offset += 1;\n}\n\nvoid\nBitVector_WriteNibblet(uint8 *vector, int nibble, int *offset)\n{\n   ASSERT(nibble &lt; (1 &lt;&lt; BITVECTOR_NIBBLE_SIZE));\n   for (int i = 0; i &lt; BITVECTOR_NIBBLE_SIZE; i++) {\n      if (nibble &amp; (1 &lt;&lt; i)) {\n         BitVector_SetBit(vector, offset);\n      } else {\n         BitVector_ClearBit(vector, offset);\n      }\n   }\n}\n\nint\nBitVector_ReadBit(uint8 *vector, int *offset)\n{\n   int retval = !!(vector[(*offset) / 8] &amp; (1 &lt;&lt; ((*offset) % 8)));\n   *offset += 1;\n   return retval;\n}\n\nint\nBitVector_ReadNibblet(uint8 *vector, int *offset)\n{\n   int nibblet = 0;\n   for (int i = 0; i &lt; BITVECTOR_NIBBLE_SIZE; i++) {\n      nibblet |= (BitVector_ReadBit(vector, offset) &lt;&lt; i);\n   }\n   return nibblet;\n}\n</code></pre>"},{"location":"GGPOUE4/bitvector_8h/","title":"File bitvector.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; bitvector.h</p> <p>Go to the source code of this file</p>"},{"location":"GGPOUE4/bitvector_8h/#public-functions","title":"Public Functions","text":"Type Name void BitVector_ClearBit (uint8 * vector, int * offset)  int BitVector_ReadBit (uint8 * vector, int * offset)  int BitVector_ReadNibblet (uint8 * vector, int * offset)  void BitVector_SetBit (uint8 * vector, int * offset)  void BitVector_WriteNibblet (uint8 * vector, int nibble, int * offset)"},{"location":"GGPOUE4/bitvector_8h/#macros","title":"Macros","text":"Type Name define BITVECTOR_NIBBLE_SIZE <code>8</code>"},{"location":"GGPOUE4/bitvector_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/bitvector_8h/#function-bitvector_clearbit","title":"function BitVector_ClearBit","text":"<pre><code>void BitVector_ClearBit (\n    uint8 * vector,\n    int * offset\n) \n</code></pre>"},{"location":"GGPOUE4/bitvector_8h/#function-bitvector_readbit","title":"function BitVector_ReadBit","text":"<pre><code>int BitVector_ReadBit (\n    uint8 * vector,\n    int * offset\n) \n</code></pre>"},{"location":"GGPOUE4/bitvector_8h/#function-bitvector_readnibblet","title":"function BitVector_ReadNibblet","text":"<pre><code>int BitVector_ReadNibblet (\n    uint8 * vector,\n    int * offset\n) \n</code></pre>"},{"location":"GGPOUE4/bitvector_8h/#function-bitvector_setbit","title":"function BitVector_SetBit","text":"<pre><code>void BitVector_SetBit (\n    uint8 * vector,\n    int * offset\n) \n</code></pre>"},{"location":"GGPOUE4/bitvector_8h/#function-bitvector_writenibblet","title":"function BitVector_WriteNibblet","text":"<pre><code>void BitVector_WriteNibblet (\n    uint8 * vector,\n    int nibble,\n    int * offset\n) \n</code></pre>"},{"location":"GGPOUE4/bitvector_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/bitvector_8h/#define-bitvector_nibble_size","title":"define BITVECTOR_NIBBLE_SIZE","text":"<pre><code>#define BITVECTOR_NIBBLE_SIZE `8`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/bitvector.h</code></p>"},{"location":"GGPOUE4/bitvector_8h_source/","title":"File bitvector.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; bitvector.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _BITVECTOR_H\n#define _BITVECTOR_H\n\n#define BITVECTOR_NIBBLE_SIZE 8\n\nvoid BitVector_SetBit(uint8 *vector, int *offset);\nvoid BitVector_ClearBit(uint8 *vector, int *offset);\nvoid BitVector_WriteNibblet(uint8 *vector, int nibble, int *offset);\nint BitVector_ReadBit(uint8 *vector, int *offset);\nint BitVector_ReadNibblet(uint8 *vector, int *offset);\n\n#endif // _BITVECTOR_H\n</code></pre>"},{"location":"GGPOUE4/game__input_8cpp/","title":"File game_input.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; game_input.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"game_input.h\"</code></li> <li><code>#include \"types.h\"</code></li> <li><code>#include \"log.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/game_input.cpp</code></p>"},{"location":"GGPOUE4/game__input_8cpp_source/","title":"File game_input.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; game_input.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#include \"game_input.h\"\n#include \"types.h\"\n#include \"log.h\"\n\nvoid\nGameInput::init(int iframe, char *ibits, int isize, int offset)\n{\n   ASSERT(isize);\n   ASSERT(isize &lt;= GAMEINPUT_MAX_BYTES);\n   frame = iframe;\n   size = isize;\n   memset(bits, 0, sizeof(bits));\n   if (ibits) {\n      memcpy(bits + (offset * isize), ibits, isize);\n   }\n}\n\nvoid\nGameInput::init(int iframe, char *ibits, int isize)\n{\n   ASSERT(isize);\n   ASSERT(isize &lt;= GAMEINPUT_MAX_BYTES * GAMEINPUT_MAX_PLAYERS);\n   frame = iframe;\n   size = isize;\n   memset(bits, 0, sizeof(bits));\n   if (ibits) {\n      memcpy(bits, ibits, isize);\n   }\n}\n\nvoid\nGameInput::desc(char *buf, size_t buf_size, bool show_frame) const\n{\n   ASSERT(size);\n   size_t remaining = buf_size;\n   if (show_frame) {\n      remaining -= sprintf(buf, \"(frame:%d size:%d \", frame, size);\n   } else {\n      remaining -= sprintf(buf, \"(size:%d \", size);\n   }\n\n   for (int i = 0; i &lt; size * 8; i++) {\n      char buf2[16];\n      if (value(i)) {\n         int c = sprintf(buf2, \"%2d \", i);\n         strncat(buf, buf2, ARRAY_SIZE(buf2));\n         remaining -= c;\n      }\n   }\n   strncat(buf, \")\", 1);\n}\n\nvoid\nGameInput::log(char *prefix, bool show_frame) const\n{\n    char buf[1024];\n   size_t c = strlen(prefix);\n    strcpy(buf, prefix);\n    desc(buf + c, ARRAY_SIZE(buf) - c, show_frame);\n   strncat(buf, \"\\n\", 1);\n    Log(buf);\n}\n\nbool\nGameInput::equal(GameInput &amp;other, bool bitsonly)\n{\n   if (!bitsonly &amp;&amp; frame != other.frame) {\n      Log(\"frames don't match: %d, %d\\n\", frame, other.frame);\n   }\n   if (size != other.size) {\n      Log(\"sizes don't match: %d, %d\\n\", size, other.size);\n   }\n   if (memcmp(bits, other.bits, size)) {\n      Log(\"bits don't match\\n\");\n   }\n   ASSERT(size &amp;&amp; other.size);\n   return (bitsonly || frame == other.frame) &amp;&amp;\n          size == other.size &amp;&amp;\n          memcmp(bits, other.bits, size) == 0;\n}\n</code></pre>"},{"location":"GGPOUE4/game__input_8h/","title":"File game_input.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; game_input.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;stdio.h&gt;</code></li> <li><code>#include &lt;memory.h&gt;</code></li> </ul>"},{"location":"GGPOUE4/game__input_8h/#classes","title":"Classes","text":"Type Name struct GameInput"},{"location":"GGPOUE4/game__input_8h/#macros","title":"Macros","text":"Type Name define GAMEINPUT_MAX_BYTES <code>9</code> define GAMEINPUT_MAX_PLAYERS <code>2</code>"},{"location":"GGPOUE4/game__input_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/game__input_8h/#define-gameinput_max_bytes","title":"define GAMEINPUT_MAX_BYTES","text":"<pre><code>#define GAMEINPUT_MAX_BYTES `9`\n</code></pre>"},{"location":"GGPOUE4/game__input_8h/#define-gameinput_max_players","title":"define GAMEINPUT_MAX_PLAYERS","text":"<pre><code>#define GAMEINPUT_MAX_PLAYERS `2`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/game_input.h</code></p>"},{"location":"GGPOUE4/game__input_8h_source/","title":"File game_input.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; game_input.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _GAMEINPUT_H\n#define _GAMEINPUT_H\n\n#include &lt;stdio.h&gt;\n#include &lt;memory.h&gt;\n\n// GAMEINPUT_MAX_BYTES * GAMEINPUT_MAX_PLAYERS * 8 must be less than\n// 2^BITVECTOR_NIBBLE_SIZE (see bitvector.h)\n\n#define GAMEINPUT_MAX_BYTES      9\n#define GAMEINPUT_MAX_PLAYERS    2\n\nstruct GameInput {\n   enum Constants {\n      NullFrame = -1\n   };\n   int      frame;\n   int      size; /* size in bytes of the entire input for all players */\n   char     bits[GAMEINPUT_MAX_BYTES * GAMEINPUT_MAX_PLAYERS];\n\n   bool is_null() { return frame == NullFrame; }\n   void init(int frame, char *bits, int size, int offset);\n   void init(int frame, char *bits, int size);\n   bool value(int i) const { return (bits[i/8] &amp; (1 &lt;&lt; (i%8))) != 0; }\n   void set(int i) { bits[i/8] |= (1 &lt;&lt; (i%8)); }\n   void clear(int i) { bits[i/8] &amp;= ~(1 &lt;&lt; (i%8)); }\n   void erase() { memset(bits, 0, sizeof(bits)); }\n   void desc(char *buf, size_t buf_size, bool show_frame = true) const;\n   void log(char *prefix, bool show_frame = true) const;\n   bool equal(GameInput &amp;input, bool bitsonly = false);\n};\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/input__queue_8cpp/","title":"File input_queue.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; input_queue.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"input_queue.h\"</code></li> <li><code>#include \"types.h\"</code></li> </ul>"},{"location":"GGPOUE4/input__queue_8cpp/#macros","title":"Macros","text":"Type Name define PREVIOUS_FRAME (offset) <code>(((offset) == 0) ? (INPUT\\_QUEUE\\_LENGTH - 1) : ((offset) - 1))</code>"},{"location":"GGPOUE4/input__queue_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/input__queue_8cpp/#define-previous_frame","title":"define PREVIOUS_FRAME","text":"<pre><code>#define PREVIOUS_FRAME (\n    offset\n) `(((offset) == 0) ? (INPUT_QUEUE_LENGTH - 1) : ((offset) - 1))`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/input_queue.cpp</code></p>"},{"location":"GGPOUE4/input__queue_8cpp_source/","title":"File input_queue.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; input_queue.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#include \"input_queue.h\"\n#include \"types.h\"\n\n#define PREVIOUS_FRAME(offset)   (((offset) == 0) ? (INPUT_QUEUE_LENGTH - 1) : ((offset) - 1))\n\nInputQueue::InputQueue(int input_size)\n{\n   Init(-1, input_size);\n}\n\nInputQueue::~InputQueue()\n{\n}\n\nvoid\nInputQueue::Init(int id, int input_size)\n{\n   _id = id;\n   _head = 0;\n   _tail = 0;\n   _length = 0;\n   _frame_delay = 0;\n   _first_frame = true;\n   _last_user_added_frame = GameInput::NullFrame;\n   _first_incorrect_frame = GameInput::NullFrame;\n   _last_frame_requested = GameInput::NullFrame;\n   _last_added_frame = GameInput::NullFrame;\n\n   _prediction.init(GameInput::NullFrame, NULL, input_size);\n\n   /*\n    * This is safe because we know the GameInput is a proper structure (as in,\n    * no virtual methods, no contained classes, etc.).\n    */\n   memset(_inputs, 0, sizeof _inputs);\n   for (int i = 0; i &lt; ARRAY_SIZE(_inputs); i++) {\n      _inputs[i].size = input_size;\n   }\n}\n\nint\nInputQueue::GetLastConfirmedFrame()\n{\n   Log(\"returning last confirmed frame %d.\\n\", _last_added_frame);\n   return _last_added_frame;\n}\n\nint\nInputQueue::GetFirstIncorrectFrame()\n{\n   return _first_incorrect_frame;\n}\n\nvoid\nInputQueue::DiscardConfirmedFrames(int frame)\n{\n   ASSERT(frame &gt;= 0);\n\n   if (_last_frame_requested != GameInput::NullFrame) {\n      frame = MIN(frame, _last_frame_requested);\n   }\n\n   Log(\"discarding confirmed frames up to %d (last_added:%d length:%d [head:%d tail:%d]).\\n\", \n       frame, _last_added_frame, _length, _head, _tail);\n   if (frame &gt;= _last_added_frame) {\n      _tail = _head;\n   } else {\n      int offset = frame - _inputs[_tail].frame + 1;\n\n      Log(\"difference of %d frames.\\n\", offset);\n      ASSERT(offset &gt;= 0);\n\n      _tail = (_tail + offset) % INPUT_QUEUE_LENGTH;\n      _length -= offset;\n   }\n\n   Log(\"after discarding, new tail is %d (frame:%d).\\n\", _tail, _inputs[_tail].frame);\n   ASSERT(_length &gt;= 0);\n}\n\nvoid\nInputQueue::ResetPrediction(int frame)\n{\n   ASSERT(_first_incorrect_frame == GameInput::NullFrame || frame &lt;= _first_incorrect_frame);\n\n   Log(\"resetting all prediction errors back to frame %d.\\n\", frame);\n\n   /*\n    * There's nothing really to do other than reset our prediction\n    * state and the incorrect frame counter...\n    */\n   _prediction.frame = GameInput::NullFrame;\n   _first_incorrect_frame = GameInput::NullFrame;\n   _last_frame_requested = GameInput::NullFrame;\n}\n\nbool\nInputQueue::GetConfirmedInput(int requested_frame, GameInput *input)\n{\n   ASSERT(_first_incorrect_frame == GameInput::NullFrame || requested_frame &lt; _first_incorrect_frame);\n   int offset = requested_frame % INPUT_QUEUE_LENGTH; \n   if (_inputs[offset].frame != requested_frame) {\n      return false;\n   }\n   *input = _inputs[offset];\n   return true;\n}\n\nbool\nInputQueue::GetInput(int requested_frame, GameInput *input)\n{\n   Log(\"requesting input frame %d.\\n\", requested_frame);\n\n   /*\n    * No one should ever try to grab any input when we have a prediction\n    * error.  Doing so means that we're just going further down the wrong\n    * path.  ASSERT this to verify that it's true.\n    */\n   ASSERT(_first_incorrect_frame == GameInput::NullFrame);\n\n   /*\n    * Remember the last requested frame number for later.  We'll need\n    * this in AddInput() to drop out of prediction mode.\n    */\n   _last_frame_requested = requested_frame;\n\n   ASSERT(requested_frame &gt;= _inputs[_tail].frame);\n\n   if (_prediction.frame == GameInput::NullFrame) {\n      /*\n       * If the frame requested is in our range, fetch it out of the queue and\n       * return it.\n       */\n      int offset = requested_frame - _inputs[_tail].frame;\n\n      if (offset &lt; _length) {\n         offset = (offset + _tail) % INPUT_QUEUE_LENGTH;\n         ASSERT(_inputs[offset].frame == requested_frame);\n         *input = _inputs[offset];\n         Log(\"returning confirmed frame number %d.\\n\", input-&gt;frame);\n         return true;\n      }\n\n      /*\n       * The requested frame isn't in the queue.  Bummer.  This means we need\n       * to return a prediction frame.  Predict that the user will do the\n       * same thing they did last time.\n       */\n      if (requested_frame == 0) {\n         Log(\"basing new prediction frame from nothing, you're client wants frame 0.\\n\");\n         _prediction.erase();\n      } else if (_last_added_frame == GameInput::NullFrame) {\n         Log(\"basing new prediction frame from nothing, since we have no frames yet.\\n\");\n         _prediction.erase();\n      } else {\n         Log(\"basing new prediction frame from previously added frame (queue entry:%d, frame:%d).\\n\",\n              PREVIOUS_FRAME(_head), _inputs[PREVIOUS_FRAME(_head)].frame);\n         _prediction = _inputs[PREVIOUS_FRAME(_head)];\n      }\n      _prediction.frame++;\n   }\n\n   ASSERT(_prediction.frame &gt;= 0);\n\n   /*\n    * If we've made it this far, we must be predicting.  Go ahead and\n    * forward the prediction frame contents.  Be sure to return the\n    * frame number requested by the client, though.\n    */\n   *input = _prediction;\n   input-&gt;frame = requested_frame;\n   Log(\"returning prediction frame number %d (%d).\\n\", input-&gt;frame, _prediction.frame);\n\n   return false;\n}\n\nvoid\nInputQueue::AddInput(GameInput &amp;input)\n{\n   int new_frame;\n\n   Log(\"adding input frame number %d to queue.\\n\", input.frame);\n\n   /*\n    * These next two lines simply verify that inputs are passed in \n    * sequentially by the user, regardless of frame delay.\n    */\n   ASSERT(_last_user_added_frame == GameInput::NullFrame ||\n          input.frame == _last_user_added_frame + 1);\n   _last_user_added_frame = input.frame;\n\n   /*\n    * Move the queue head to the correct point in preparation to\n    * input the frame into the queue.\n    */\n   new_frame = AdvanceQueueHead(input.frame);\n   if (new_frame != GameInput::NullFrame) {\n      AddDelayedInputToQueue(input, new_frame);\n   }\n\n   /*\n    * Update the frame number for the input.  This will also set the\n    * frame to GameInput::NullFrame for frames that get dropped (by\n    * design).\n    */\n   input.frame = new_frame;\n}\n\nvoid\nInputQueue::AddDelayedInputToQueue(GameInput &amp;input, int frame_number)\n{\n   Log(\"adding delayed input frame number %d to queue.\\n\", frame_number);\n\n   ASSERT(input.size == _prediction.size);\n\n   ASSERT(_last_added_frame == GameInput::NullFrame || frame_number == _last_added_frame + 1);\n\n   ASSERT(frame_number == 0 || _inputs[PREVIOUS_FRAME(_head)].frame == frame_number - 1);\n\n   /*\n    * Add the frame to the back of the queue\n    */ \n   _inputs[_head] = input;\n   _inputs[_head].frame = frame_number;\n   _head = (_head + 1) % INPUT_QUEUE_LENGTH;\n   _length++;\n   _first_frame = false;\n\n   _last_added_frame = frame_number;\n\n   if (_prediction.frame != GameInput::NullFrame) {\n      ASSERT(frame_number == _prediction.frame);\n\n      /*\n       * We've been predicting...  See if the inputs we've gotten match\n       * what we've been predicting.  If so, don't worry about it.  If not,\n       * remember the first input which was incorrect so we can report it\n       * in GetFirstIncorrectFrame()\n       */\n      if (_first_incorrect_frame == GameInput::NullFrame &amp;&amp; !_prediction.equal(input, true)) {\n         Log(\"frame %d does not match prediction.  marking error.\\n\", frame_number);\n         _first_incorrect_frame = frame_number;\n      }\n\n      /*\n       * If this input is the same frame as the last one requested and we\n       * still haven't found any mis-predicted inputs, we can dump out\n       * of predition mode entirely!  Otherwise, advance the prediction frame\n       * count up.\n       */\n      if (_prediction.frame == _last_frame_requested &amp;&amp; _first_incorrect_frame == GameInput::NullFrame) {\n         Log(\"prediction is correct!  dumping out of prediction mode.\\n\");\n         _prediction.frame = GameInput::NullFrame;\n      } else {\n         _prediction.frame++;\n      }\n   }\n   ASSERT(_length &lt;= INPUT_QUEUE_LENGTH);\n}\n\nint\nInputQueue::AdvanceQueueHead(int frame)\n{\n   Log(\"advancing queue head to frame %d.\\n\", frame);\n\n   int expected_frame = _first_frame ? 0 : _inputs[PREVIOUS_FRAME(_head)].frame + 1;\n\n   frame += _frame_delay;\n\n   if (expected_frame &gt; frame) {\n      /*\n       * This can occur when the frame delay has dropped since the last\n       * time we shoved a frame into the system.  In this case, there's\n       * no room on the queue.  Toss it.\n       */\n      Log(\"Dropping input frame %d (expected next frame to be %d).\\n\",\n          frame, expected_frame);\n      return GameInput::NullFrame;\n   }\n\n   while (expected_frame &lt; frame) {\n      /*\n       * This can occur when the frame delay has been increased since the last\n       * time we shoved a frame into the system.  We need to replicate the\n       * last frame in the queue several times in order to fill the space\n       * left.\n       */\n      Log(\"Adding padding frame %d to account for change in frame delay.\\n\",\n          expected_frame);\n      GameInput &amp;last_frame = _inputs[PREVIOUS_FRAME(_head)];     \n      AddDelayedInputToQueue(last_frame, expected_frame);\n      expected_frame++;\n   }\n\n   ASSERT(frame == 0 || frame == _inputs[PREVIOUS_FRAME(_head)].frame + 1);\n   return frame;\n}\n\n\nvoid\nInputQueue::Log(const char *fmt, ...)\n{\n   char buf[1024];\n   size_t offset;\n   va_list args;\n\n   offset = sprintf(buf, \"input q%d | \", _id);\n   va_start(args, fmt);\n   vsnprintf(buf + offset, ARRAY_SIZE(buf) - offset - 1, fmt, args);\n   buf[ARRAY_SIZE(buf)-1] = '\\0';\n   ::Log(buf);\n   va_end(args);\n}\n</code></pre>"},{"location":"GGPOUE4/input__queue_8h/","title":"File input_queue.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; input_queue.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"game_input.h\"</code></li> </ul>"},{"location":"GGPOUE4/input__queue_8h/#classes","title":"Classes","text":"Type Name class InputQueue"},{"location":"GGPOUE4/input__queue_8h/#macros","title":"Macros","text":"Type Name define DEFAULT_INPUT_SIZE <code>4</code> define INPUT_QUEUE_LENGTH <code>128</code>"},{"location":"GGPOUE4/input__queue_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/input__queue_8h/#define-default_input_size","title":"define DEFAULT_INPUT_SIZE","text":"<pre><code>#define DEFAULT_INPUT_SIZE `4`\n</code></pre>"},{"location":"GGPOUE4/input__queue_8h/#define-input_queue_length","title":"define INPUT_QUEUE_LENGTH","text":"<pre><code>#define INPUT_QUEUE_LENGTH `128`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/input_queue.h</code></p>"},{"location":"GGPOUE4/input__queue_8h_source/","title":"File input_queue.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; input_queue.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _INPUT_QUEUE_H\n#define _INPUT_QUEUE_H\n\n#include \"game_input.h\"\n\n#define INPUT_QUEUE_LENGTH    128\n#define DEFAULT_INPUT_SIZE      4\n\nclass InputQueue {\npublic:\n   InputQueue(int input_size = DEFAULT_INPUT_SIZE);\n   ~InputQueue();\n\npublic:\n   void Init(int id, int input_size);\n   int GetLastConfirmedFrame();\n   int GetFirstIncorrectFrame();\n   int GetLength() { return _length; }\n\n   void SetFrameDelay(int delay) { _frame_delay = delay; }\n   void ResetPrediction(int frame);\n   void DiscardConfirmedFrames(int frame);\n   bool GetConfirmedInput(int frame, GameInput *input);\n   bool GetInput(int frame, GameInput *input);\n   void AddInput(GameInput &amp;input);\n\nprotected:\n   int AdvanceQueueHead(int frame);\n   void AddDelayedInputToQueue(GameInput &amp;input, int i);\n   void Log(const char *fmt, ...);\n\nprotected:\n   int                  _id;\n   int                  _head;\n   int                  _tail;\n   int                  _length;\n   bool                 _first_frame;\n\n   int                  _last_user_added_frame;\n   int                  _last_added_frame;\n   int                  _first_incorrect_frame;\n   int                  _last_frame_requested;\n\n   int                  _frame_delay;\n\n   GameInput            _inputs[INPUT_QUEUE_LENGTH];\n   GameInput            _prediction;\n};\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/log_8cpp/","title":"File log.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; log.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"log.h\"</code></li> <li><code>#include \"types.h\"</code></li> </ul>"},{"location":"GGPOUE4/log_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name char logbuf FILE * logfile   = <code>NULL</code>"},{"location":"GGPOUE4/log_8cpp/#public-functions","title":"Public Functions","text":"Type Name void Log (const char * fmt, ...)  void LogFlush ()  void Logv (const char * fmt, va_list args)  void Logv (FILE * fp, const char * fmt, va_list args)"},{"location":"GGPOUE4/log_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"GGPOUE4/log_8cpp/#variable-logbuf","title":"variable logbuf","text":"<pre><code>char logbuf[4 *1024 *1024];\n</code></pre>"},{"location":"GGPOUE4/log_8cpp/#variable-logfile","title":"variable logfile","text":"<pre><code>FILE* logfile;\n</code></pre>"},{"location":"GGPOUE4/log_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/log_8cpp/#function-log","title":"function Log","text":"<pre><code>void Log (\n    const char * fmt,\n    ...\n) \n</code></pre>"},{"location":"GGPOUE4/log_8cpp/#function-logflush","title":"function LogFlush","text":"<pre><code>void LogFlush () \n</code></pre>"},{"location":"GGPOUE4/log_8cpp/#function-logv","title":"function Logv","text":"<pre><code>void Logv (\n    const char * fmt,\n    va_list args\n) \n</code></pre>"},{"location":"GGPOUE4/log_8cpp/#function-logv_1","title":"function Logv","text":"<pre><code>void Logv (\n    FILE * fp,\n    const char * fmt,\n    va_list args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/log.cpp</code></p>"},{"location":"GGPOUE4/log_8cpp_source/","title":"File log.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; log.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#include \"log.h\"\n#include \"types.h\"\n\nstatic FILE *logfile = NULL;\n\nvoid LogFlush()\n{\n   if (logfile) {\n      fflush(logfile);\n   }\n}\n\nstatic char logbuf[4 * 1024 * 1024];\n\nvoid Log(const char *fmt, ...)\n{\n   va_list args;\n   va_start(args, fmt);\n   Logv(fmt, args);\n   va_end(args);\n}\n\nvoid Logv(const char *fmt, va_list args)\n{\n   if (!getenv(\"GGPO_LOG\") || getenv(\"GGPO_LOG_IGNORE\")) {\n      return;\n   }\n   if (!logfile) {\n      sprintf(logbuf, \"log-%d.log\", static_cast&lt;int&gt;(Platform::GetProcessID()));\n      fopen(logbuf, \"w\");\n   }\n   Logv(logfile, fmt, args);\n}\n\nvoid Logv(FILE *fp, const char *fmt, va_list args)\n{\n   static int start = 0;\n   int t = 0;\n   if (!start) {\n      start = Platform::GetCurrentTimeMS();\n   } else {\n      t = Platform::GetCurrentTimeMS() - start;\n   }\n   fprintf(fp, \"%d.%03d : \", t / 1000, t % 1000);\n\n   vfprintf(fp, fmt, args);\n   fflush(fp);\n\n   vsprintf(logbuf, fmt, args);\n}\n</code></pre>"},{"location":"GGPOUE4/log_8h/","title":"File log.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; log.h</p> <p>Go to the source code of this file</p>"},{"location":"GGPOUE4/log_8h/#public-functions","title":"Public Functions","text":"Type Name void Log (const char * fmt, ...)  void LogFlush ()  void LogFlushOnLog (bool flush)  void Logv (const char * fmt, va_list list)  void Logv (FILE * fp, const char * fmt, va_list args)"},{"location":"GGPOUE4/log_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/log_8h/#function-log","title":"function Log","text":"<pre><code>void Log (\n    const char * fmt,\n    ...\n) \n</code></pre>"},{"location":"GGPOUE4/log_8h/#function-logflush","title":"function LogFlush","text":"<pre><code>void LogFlush () \n</code></pre>"},{"location":"GGPOUE4/log_8h/#function-logflushonlog","title":"function LogFlushOnLog","text":"<pre><code>void LogFlushOnLog (\n    bool flush\n) \n</code></pre>"},{"location":"GGPOUE4/log_8h/#function-logv","title":"function Logv","text":"<pre><code>void Logv (\n    const char * fmt,\n    va_list list\n) \n</code></pre>"},{"location":"GGPOUE4/log_8h/#function-logv_1","title":"function Logv","text":"<pre><code>void Logv (\n    FILE * fp,\n    const char * fmt,\n    va_list args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/log.h</code></p>"},{"location":"GGPOUE4/log_8h_source/","title":"File log.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; log.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _LOG_H\n#define _LOG_H\n\nextern void Log(const char *fmt, ...);\nextern void Logv(const char *fmt, va_list list);\nextern void Logv(FILE *fp, const char *fmt, va_list args);\nextern void LogFlush();\nextern void LogFlushOnLog(bool flush);\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; main.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"types.h\"</code></li> <li><code>#include \"backends/p2p.h\"</code></li> <li><code>#include \"backends/synctest.h\"</code></li> <li><code>#include \"backends/spectator.h\"</code></li> <li><code>#include \"include/ggponet.h\"</code></li> </ul>"},{"location":"GGPOUE4/main_8cpp/#public-functions","title":"Public Functions","text":"Type Name GGPOErrorCode ggpo_client_chat (GGPOSession * ggpo, char * text)  void ggpo_log (GGPOSession * ggpo, const char * fmt, ...)  void ggpo_logv (GGPOSession * ggpo, const char * fmt, va_list args)"},{"location":"GGPOUE4/main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/main_8cpp/#function-ggpo_client_chat","title":"function ggpo_client_chat","text":"<pre><code>GGPOErrorCode ggpo_client_chat (\n    GGPOSession * ggpo,\n    char * text\n) \n</code></pre>"},{"location":"GGPOUE4/main_8cpp/#function-ggpo_log","title":"function ggpo_log","text":"<pre><code>void ggpo_log (\n    GGPOSession * ggpo,\n    const char * fmt,\n    ...\n) \n</code></pre>"},{"location":"GGPOUE4/main_8cpp/#function-ggpo_logv","title":"function ggpo_logv","text":"<pre><code>void ggpo_logv (\n    GGPOSession * ggpo,\n    const char * fmt,\n    va_list args\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/main.cpp</code></p>"},{"location":"GGPOUE4/main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; main.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#include \"types.h\"\n#include \"backends/p2p.h\"\n#include \"backends/synctest.h\"\n#include \"backends/spectator.h\"\n#include \"include/ggponet.h\"\n\nvoid\nggpo_log(GGPOSession *ggpo, const char *fmt, ...)\n{\n   va_list args;\n   va_start(args, fmt);\n   //GGPONet::ggpo_logv(ggpo, fmt, args);\n   va_end(args);\n}\n\nvoid\nggpo_logv(GGPOSession *ggpo, const char *fmt, va_list args)\n{\n   if (ggpo) {\n      ggpo-&gt;Logv(fmt, args);\n   }\n}\n\nGGPOErrorCode\nGGPONet::ggpo_start_session(GGPOSession **session,\n                   GGPOSessionCallbacks *cb,\n                   ConnectionManager* connection_manager,\n                   const char *game,\n                   int num_players,\n                   int input_size)\n{\n   *session= (GGPOSession *)new Peer2PeerBackend(cb,\n                                                 game,\n                                                 connection_manager,\n                                                 num_players,\n                                                 input_size);\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nGGPONet::ggpo_add_player(GGPOSession *ggpo,\n                GGPOPlayer *player,\n                GGPOPlayerHandle *handle)\n{\n   if (!ggpo) {\n      return GGPO_ERRORCODE_INVALID_SESSION;\n   }\n   return ggpo-&gt;AddPlayer(player, handle);\n}\n\n\n\nGGPOErrorCode\nGGPONet::ggpo_start_synctest(GGPOSession **ggpo,\n                    GGPOSessionCallbacks *cb,\n                    const char *game,\n                    int num_players,\n                    int input_size,\n                    int frames)\n{\n   *ggpo = (GGPOSession *)new SyncTestBackend(cb, game, frames, num_players);\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nGGPONet::ggpo_set_frame_delay(GGPOSession *ggpo,\n                     GGPOPlayerHandle player,\n                     int frame_delay)\n{\n   if (!ggpo) {\n      return GGPO_ERRORCODE_INVALID_SESSION;\n   }\n   return ggpo-&gt;SetFrameDelay(player, frame_delay);\n}\n\nGGPOErrorCode\nGGPONet::ggpo_idle(GGPOSession *ggpo, int timeout)\n{\n   if (!ggpo) {\n      return GGPO_ERRORCODE_INVALID_SESSION;\n   }\n   return ggpo-&gt;DoPoll(timeout);\n}\n\nGGPOErrorCode\nGGPONet::ggpo_add_local_input(GGPOSession *ggpo,\n                     GGPOPlayerHandle player,\n                     void *values,\n                     int size)\n{\n   if (!ggpo) {\n      return GGPO_ERRORCODE_INVALID_SESSION;\n   }\n   return ggpo-&gt;AddLocalInput(player, values, size);\n}\n\nGGPOErrorCode\nGGPONet::ggpo_synchronize_input(GGPOSession *ggpo,\n                       void *values,\n                       int size,\n                       int *disconnect_flags)\n{\n   if (!ggpo) {\n      return GGPO_ERRORCODE_INVALID_SESSION;\n   }\n   return ggpo-&gt;SyncInput(values, size, disconnect_flags);\n}\n\nGGPOErrorCode GGPONet::ggpo_disconnect_player(GGPOSession *ggpo,\n                                     GGPOPlayerHandle player)\n{\n   if (!ggpo) {\n      return GGPO_ERRORCODE_INVALID_SESSION;\n   }\n   return ggpo-&gt;DisconnectPlayer(player);\n}\n\nGGPOErrorCode\nGGPONet::ggpo_advance_frame(GGPOSession *ggpo)\n{\n   if (!ggpo) {\n      return GGPO_ERRORCODE_INVALID_SESSION;\n   }\n   return ggpo-&gt;IncrementFrame();\n}\n\nGGPOErrorCode\nggpo_client_chat(GGPOSession *ggpo, char *text)\n{\n   if (!ggpo) {\n      return GGPO_ERRORCODE_INVALID_SESSION;\n   }\n   return ggpo-&gt;Chat(text);\n}\n\nGGPOErrorCode\nGGPONet::ggpo_get_network_stats(GGPOSession *ggpo,\n                       GGPOPlayerHandle player,\n                       FGGPONetworkStats *stats)\n{\n   if (!ggpo) {\n      return GGPO_ERRORCODE_INVALID_SESSION;\n   }\n   return ggpo-&gt;GetNetworkStats(stats, player);\n}\n\n\nGGPOErrorCode\nGGPONet::ggpo_close_session(GGPOSession *ggpo)\n{\n   if (!ggpo) {\n      return GGPO_ERRORCODE_INVALID_SESSION;\n   }\n   delete ggpo;\n   return GGPO_OK;\n}\n\nGGPOErrorCode\nGGPONet::ggpo_set_disconnect_timeout(GGPOSession *ggpo, int timeout)\n{\n   if (!ggpo) {\n      return GGPO_ERRORCODE_INVALID_SESSION;\n   }\n   return ggpo-&gt;SetDisconnectTimeout(timeout);\n}\n\nGGPOErrorCode\nGGPONet::ggpo_set_disconnect_notify_start(GGPOSession *ggpo, int timeout)\n{\n   if (!ggpo) {\n      return GGPO_ERRORCODE_INVALID_SESSION;\n   }\n   return ggpo-&gt;SetDisconnectNotifyStart(timeout);\n}\n\nGGPOErrorCode GGPONet::ggpo_try_synchronize_local(GGPOSession* ggpo)\n{\n   if (!ggpo)\n      return GGPO_ERRORCODE_INVALID_SESSION;\n   return ggpo-&gt;TrySynchronizeLocal();\n}\n\nGGPOErrorCode GGPONet::ggpo_start_spectating(GGPOSession **session,\n                                    GGPOSessionCallbacks *cb,\n                                    ConnectionManager* connection_manager,\n                                    const char *game,\n                                    int num_players,\n                                    int input_size,\n                                    int connection_id)\n{\n   *session= (GGPOSession *)new SpectatorBackend(cb,\n                                                 game,\n                                                 connection_manager,\n                                                 num_players,\n                                                 input_size,\n                                                 connection_id);\n   return GGPO_OK;\n}\n</code></pre>"},{"location":"GGPOUE4/pevents_8cpp/","title":"File pevents.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; pevents.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"pevents.h\"</code></li> <li><code>#include &lt;assert.h&gt;</code></li> <li><code>#include &lt;errno.h&gt;</code></li> <li><code>#include &lt;pthread.h&gt;</code></li> <li><code>#include &lt;sys/time.h&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;deque&gt;</code></li> </ul>"},{"location":"GGPOUE4/pevents_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace neosmart"},{"location":"GGPOUE4/pevents_8cpp/#classes","title":"Classes","text":"Type Name struct neosmart_event_t_ struct neosmart_wfmo_info_t_ struct neosmart_wfmo_t_ <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/pevents.cpp</code></p>"},{"location":"GGPOUE4/pevents_8cpp_source/","title":"File pevents.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; pevents.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * WIN32 Events for POSIX\n * Author: Mahmoud Al-Qudsi &lt;mqudsi@neosmart.net&gt;\n * Copyright (C) 2011 - 2019 by NeoSmart Technologies\n * This code is released under the terms of the MIT License\n */\n\n#ifndef _WIN32\n\n#include \"pevents.h\"\n#include &lt;assert.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;sys/time.h&gt;\n#ifdef WFMO\n#include &lt;algorithm&gt;\n#include &lt;deque&gt;\n#endif\n\nnamespace neosmart {\n#ifdef WFMO\n    // Each call to WaitForMultipleObjects initializes a neosmart_wfmo_t object which tracks\n    // the progress of the caller's multi-object wait and dispatches responses accordingly.\n    // One neosmart_wfmo_t struct is shared for all events in a single WFMO call\n    struct neosmart_wfmo_t_ {\n        pthread_mutex_t Mutex;\n        pthread_cond_t CVariable;\n        int RefCount;\n        union {\n            int FiredEvent; // WFSO\n            int EventsLeft; // WFMO\n        } Status;\n        bool WaitAll;\n        bool StillWaiting;\n\n        void Destroy() {\n            pthread_mutex_destroy(&amp;Mutex);\n            pthread_cond_destroy(&amp;CVariable);\n        }\n    };\n    typedef neosmart_wfmo_t_ *neosmart_wfmo_t;\n\n    // A neosmart_wfmo_info_t object is registered with each event waited on in a WFMO\n    // This reference to neosmart_wfmo_t_ is how the event knows whom to notify when triggered\n    struct neosmart_wfmo_info_t_ {\n        neosmart_wfmo_t Waiter;\n        int WaitIndex;\n    };\n    typedef neosmart_wfmo_info_t_ *neosmart_wfmo_info_t;\n#endif // WFMO\n\n    // The basic event structure, passed to the caller as an opaque pointer when creating events\n    struct neosmart_event_t_ {\n        pthread_cond_t CVariable;\n        pthread_mutex_t Mutex;\n        bool AutoReset;\n        bool State;\n#ifdef WFMO\n        std::deque&lt;neosmart_wfmo_info_t_&gt; RegisteredWaits;\n#endif\n    };\n\n#ifdef WFMO\n    bool RemoveExpiredWaitHelper(neosmart_wfmo_info_t_ wait) {\n        int result = pthread_mutex_trylock(&amp;wait.Waiter-&gt;Mutex);\n\n        if (result == EBUSY) {\n            return false;\n        }\n\n        assert(result == 0);\n\n        if (wait.Waiter-&gt;StillWaiting == false) {\n            --wait.Waiter-&gt;RefCount;\n            assert(wait.Waiter-&gt;RefCount &gt;= 0);\n            bool destroy = wait.Waiter-&gt;RefCount == 0;\n            result = pthread_mutex_unlock(&amp;wait.Waiter-&gt;Mutex);\n            assert(result == 0);\n            if (destroy) {\n                wait.Waiter-&gt;Destroy();\n                delete wait.Waiter;\n            }\n\n            return true;\n        }\n\n        result = pthread_mutex_unlock(&amp;wait.Waiter-&gt;Mutex);\n        assert(result == 0);\n\n        return false;\n    }\n#endif // WFMO\n\n    neosmart_event_t CreateEvent(bool manualReset, bool initialState) {\n        neosmart_event_t event = new neosmart_event_t_;\n\n        int result = pthread_cond_init(&amp;event-&gt;CVariable, 0);\n        assert(result == 0);\n\n        result = pthread_mutex_init(&amp;event-&gt;Mutex, 0);\n        assert(result == 0);\n\n        event-&gt;State = false;\n        event-&gt;AutoReset = !manualReset;\n\n        if (initialState) {\n            result = SetEvent(event);\n            assert(result == 0);\n        }\n\n        return event;\n    }\n\n    int UnlockedWaitForEvent(neosmart_event_t event, uint64_t milliseconds) {\n        int result = 0;\n        if (!event-&gt;State) {\n            // Zero-timeout event state check optimization\n            if (milliseconds == 0) {\n                return WAIT_TIMEOUT;\n            }\n\n            timespec ts;\n            if (milliseconds != (uint64_t)-1) {\n                timeval tv;\n                gettimeofday(&amp;tv, NULL);\n\n                uint64_t nanoseconds = ((uint64_t)tv.tv_sec) * 1000 * 1000 * 1000 +\n                                       milliseconds * 1000 * 1000 + ((uint64_t)tv.tv_usec) * 1000;\n\n                ts.tv_sec = nanoseconds / 1000 / 1000 / 1000;\n                ts.tv_nsec = (nanoseconds - ((uint64_t)ts.tv_sec) * 1000 * 1000 * 1000);\n            }\n\n            do {\n                // Regardless of whether it's an auto-reset or manual-reset event:\n                // wait to obtain the event, then lock anyone else out\n                if (milliseconds != (uint64_t)-1) {\n                    result = pthread_cond_timedwait(&amp;event-&gt;CVariable, &amp;event-&gt;Mutex, &amp;ts);\n                } else {\n                    result = pthread_cond_wait(&amp;event-&gt;CVariable, &amp;event-&gt;Mutex);\n                }\n            } while (result == 0 &amp;&amp; !event-&gt;State);\n\n            if (result == 0 &amp;&amp; event-&gt;AutoReset) {\n                // We've only accquired the event if the wait succeeded\n                event-&gt;State = false;\n            }\n        } else if (event-&gt;AutoReset) {\n            // It's an auto-reset event that's currently available;\n            // we need to stop anyone else from using it\n            result = 0;\n            event-&gt;State = false;\n        }\n        // Else we're trying to obtain a manual reset event with a signaled state;\n        // don't do anything\n\n        return result;\n    }\n\n    int WaitForEvent(neosmart_event_t event, uint64_t milliseconds) {\n        int tempResult;\n        if (milliseconds == 0) {\n            tempResult = pthread_mutex_trylock(&amp;event-&gt;Mutex);\n            if (tempResult == EBUSY) {\n                return WAIT_TIMEOUT;\n            }\n        } else {\n            tempResult = pthread_mutex_lock(&amp;event-&gt;Mutex);\n        }\n\n        assert(tempResult == 0);\n\n        int result = UnlockedWaitForEvent(event, milliseconds);\n\n        tempResult = pthread_mutex_unlock(&amp;event-&gt;Mutex);\n        assert(tempResult == 0);\n\n        return result;\n    }\n\n#ifdef WFMO\n    int WaitForMultipleEvents(neosmart_event_t *events, int count, bool waitAll,\n                              uint64_t milliseconds) {\n        int unused;\n        return WaitForMultipleEvents(events, count, waitAll, milliseconds, unused);\n    }\n\n    int WaitForMultipleEvents(neosmart_event_t *events, int count, bool waitAll,\n                              uint64_t milliseconds, int &amp;waitIndex) {\n        neosmart_wfmo_t wfmo = new neosmart_wfmo_t_;\n\n        int result = 0;\n        int tempResult = pthread_mutex_init(&amp;wfmo-&gt;Mutex, 0);\n        assert(tempResult == 0);\n\n        tempResult = pthread_cond_init(&amp;wfmo-&gt;CVariable, 0);\n        assert(tempResult == 0);\n\n        neosmart_wfmo_info_t_ waitInfo;\n        waitInfo.Waiter = wfmo;\n        waitInfo.WaitIndex = -1;\n\n        wfmo-&gt;WaitAll = waitAll;\n        wfmo-&gt;StillWaiting = true;\n        wfmo-&gt;RefCount = 1;\n\n        if (waitAll) {\n            wfmo-&gt;Status.EventsLeft = count;\n        } else {\n            wfmo-&gt;Status.FiredEvent = -1;\n        }\n\n        tempResult = pthread_mutex_lock(&amp;wfmo-&gt;Mutex);\n        assert(tempResult == 0);\n\n        bool done = false;\n        waitIndex = -1;\n\n        for (int i = 0; i &lt; count; ++i) {\n            waitInfo.WaitIndex = i;\n\n            // Must not release lock until RegisteredWait is potentially added\n            tempResult = pthread_mutex_lock(&amp;events[i]-&gt;Mutex);\n            assert(tempResult == 0);\n\n            // Before adding this wait to the list of registered waits, let's clean up old, expired\n            // waits while we have the event lock anyway\n            events[i]-&gt;RegisteredWaits.erase(std::remove_if(events[i]-&gt;RegisteredWaits.begin(),\n                                                            events[i]-&gt;RegisteredWaits.end(),\n                                                            RemoveExpiredWaitHelper),\n                                             events[i]-&gt;RegisteredWaits.end());\n\n            if (UnlockedWaitForEvent(events[i], 0) == 0) {\n                tempResult = pthread_mutex_unlock(&amp;events[i]-&gt;Mutex);\n                assert(tempResult == 0);\n\n                if (waitAll) {\n                    --wfmo-&gt;Status.EventsLeft;\n                    assert(wfmo-&gt;Status.EventsLeft &gt;= 0);\n                } else {\n                    wfmo-&gt;Status.FiredEvent = i;\n                    waitIndex = i;\n                    done = true;\n                    break;\n                }\n            } else {\n                events[i]-&gt;RegisteredWaits.push_back(waitInfo);\n                ++wfmo-&gt;RefCount;\n\n                tempResult = pthread_mutex_unlock(&amp;events[i]-&gt;Mutex);\n                assert(tempResult == 0);\n            }\n        }\n\n        // We set the `done` flag above in case of WaitAny and at least one event was set.\n        // But we need to check again here if we were doing a WaitAll or else we'll incorrectly\n        // return WAIT_TIMEOUT.\n        if (waitAll &amp;&amp; wfmo-&gt;Status.EventsLeft == 0) {\n            done = true;\n        }\n\n        timespec ts;\n        if (!done) {\n            if (milliseconds == 0) {\n                result = WAIT_TIMEOUT;\n                done = true;\n            } else if (milliseconds != (uint64_t)-1) {\n                timeval tv;\n                gettimeofday(&amp;tv, NULL);\n\n                uint64_t nanoseconds = ((uint64_t)tv.tv_sec) * 1000 * 1000 * 1000 +\n                                       milliseconds * 1000 * 1000 + ((uint64_t)tv.tv_usec) * 1000;\n\n                ts.tv_sec = nanoseconds / 1000 / 1000 / 1000;\n                ts.tv_nsec = (nanoseconds - ((uint64_t)ts.tv_sec) * 1000 * 1000 * 1000);\n            }\n        }\n\n        while (!done) {\n            // One (or more) of the events we're monitoring has been triggered?\n\n            // If we're waiting for all events, assume we're done and check if there's an event that\n            // hasn't fired But if we're waiting for just one event, assume we're not done until we\n            // find a fired event\n            done = (waitAll &amp;&amp; wfmo-&gt;Status.EventsLeft == 0) ||\n                   (!waitAll &amp;&amp; wfmo-&gt;Status.FiredEvent != -1);\n\n            if (!done) {\n                if (milliseconds != (uint64_t)-1) {\n                    result = pthread_cond_timedwait(&amp;wfmo-&gt;CVariable, &amp;wfmo-&gt;Mutex, &amp;ts);\n                } else {\n                    result = pthread_cond_wait(&amp;wfmo-&gt;CVariable, &amp;wfmo-&gt;Mutex);\n                }\n\n                if (result != 0) {\n                    break;\n                }\n            }\n        }\n\n        waitIndex = wfmo-&gt;Status.FiredEvent;\n        wfmo-&gt;StillWaiting = false;\n\n        --wfmo-&gt;RefCount;\n        assert(wfmo-&gt;RefCount &gt;= 0);\n        bool destroy = wfmo-&gt;RefCount == 0;\n        tempResult = pthread_mutex_unlock(&amp;wfmo-&gt;Mutex);\n        assert(tempResult == 0);\n        if (destroy) {\n            wfmo-&gt;Destroy();\n            delete wfmo;\n        }\n\n        return result;\n    }\n#endif // WFMO\n\n    int DestroyEvent(neosmart_event_t event) {\n        int result = 0;\n\n#ifdef WFMO\n        result = pthread_mutex_lock(&amp;event-&gt;Mutex);\n        assert(result == 0);\n        event-&gt;RegisteredWaits.erase(std::remove_if(event-&gt;RegisteredWaits.begin(),\n                                                    event-&gt;RegisteredWaits.end(),\n                                                    RemoveExpiredWaitHelper),\n                                     event-&gt;RegisteredWaits.end());\n        result = pthread_mutex_unlock(&amp;event-&gt;Mutex);\n        assert(result == 0);\n#endif\n\n        result = pthread_cond_destroy(&amp;event-&gt;CVariable);\n        assert(result == 0);\n\n        result = pthread_mutex_destroy(&amp;event-&gt;Mutex);\n        assert(result == 0);\n\n        delete event;\n\n        return 0;\n    }\n\n    int SetEvent(neosmart_event_t event) {\n        int result = pthread_mutex_lock(&amp;event-&gt;Mutex);\n        assert(result == 0);\n\n        event-&gt;State = true;\n\n        // Depending on the event type, we either trigger everyone or only one\n        if (event-&gt;AutoReset) {\n#ifdef WFMO\n            while (!event-&gt;RegisteredWaits.empty()) {\n                neosmart_wfmo_info_t i = &amp;event-&gt;RegisteredWaits.front();\n\n                result = pthread_mutex_lock(&amp;i-&gt;Waiter-&gt;Mutex);\n                assert(result == 0);\n\n                --i-&gt;Waiter-&gt;RefCount;\n                assert(i-&gt;Waiter-&gt;RefCount &gt;= 0);\n                if (!i-&gt;Waiter-&gt;StillWaiting) {\n                    bool destroy = i-&gt;Waiter-&gt;RefCount == 0;\n                    result = pthread_mutex_unlock(&amp;i-&gt;Waiter-&gt;Mutex);\n                    assert(result == 0);\n                    if (destroy) {\n                        i-&gt;Waiter-&gt;Destroy();\n                        delete i-&gt;Waiter;\n                    }\n                    event-&gt;RegisteredWaits.pop_front();\n                    continue;\n                }\n\n                event-&gt;State = false;\n\n                if (i-&gt;Waiter-&gt;WaitAll) {\n                    --i-&gt;Waiter-&gt;Status.EventsLeft;\n                    assert(i-&gt;Waiter-&gt;Status.EventsLeft &gt;= 0);\n                    // We technically should do i-&gt;Waiter-&gt;StillWaiting = Waiter-&gt;Status.EventsLeft\n                    // != 0 but the only time it'll be equal to zero is if we're the last event, so\n                    // no one else will be checking the StillWaiting flag. We're good to go without\n                    // it.\n                } else {\n                    i-&gt;Waiter-&gt;Status.FiredEvent = i-&gt;WaitIndex;\n                    i-&gt;Waiter-&gt;StillWaiting = false;\n                }\n\n                result = pthread_mutex_unlock(&amp;i-&gt;Waiter-&gt;Mutex);\n                assert(result == 0);\n\n                result = pthread_cond_signal(&amp;i-&gt;Waiter-&gt;CVariable);\n                assert(result == 0);\n\n                event-&gt;RegisteredWaits.pop_front();\n\n                result = pthread_mutex_unlock(&amp;event-&gt;Mutex);\n                assert(result == 0);\n\n                return 0;\n            }\n#endif // WFMO\n       // event-&gt;State can be false if compiled with WFMO support\n            if (event-&gt;State) {\n                result = pthread_mutex_unlock(&amp;event-&gt;Mutex);\n                assert(result == 0);\n\n                result = pthread_cond_signal(&amp;event-&gt;CVariable);\n                assert(result == 0);\n\n                return 0;\n            }\n        } else {\n#ifdef WFMO\n            for (size_t i = 0; i &lt; event-&gt;RegisteredWaits.size(); ++i) {\n                neosmart_wfmo_info_t info = &amp;event-&gt;RegisteredWaits[i];\n\n                result = pthread_mutex_lock(&amp;info-&gt;Waiter-&gt;Mutex);\n                assert(result == 0);\n\n                --info-&gt;Waiter-&gt;RefCount;\n                assert(info-&gt;Waiter-&gt;RefCount &gt;= 0);\n\n                if (!info-&gt;Waiter-&gt;StillWaiting) {\n                    bool destroy = info-&gt;Waiter-&gt;RefCount == 0;\n                    result = pthread_mutex_unlock(&amp;info-&gt;Waiter-&gt;Mutex);\n                    assert(result == 0);\n                    if (destroy) {\n                        info-&gt;Waiter-&gt;Destroy();\n                        delete info-&gt;Waiter;\n                    }\n                    continue;\n                }\n\n                if (info-&gt;Waiter-&gt;WaitAll) {\n                    --info-&gt;Waiter-&gt;Status.EventsLeft;\n                    assert(info-&gt;Waiter-&gt;Status.EventsLeft &gt;= 0);\n                    // We technically should do i-&gt;Waiter-&gt;StillWaiting = Waiter-&gt;Status.EventsLeft\n                    // != 0 but the only time it'll be equal to zero is if we're the last event, so\n                    // no one else will be checking the StillWaiting flag. We're good to go without\n                    // it.\n                } else {\n                    info-&gt;Waiter-&gt;Status.FiredEvent = info-&gt;WaitIndex;\n                    info-&gt;Waiter-&gt;StillWaiting = false;\n                }\n\n                result = pthread_mutex_unlock(&amp;info-&gt;Waiter-&gt;Mutex);\n                assert(result == 0);\n\n                result = pthread_cond_signal(&amp;info-&gt;Waiter-&gt;CVariable);\n                assert(result == 0);\n            }\n            event-&gt;RegisteredWaits.clear();\n#endif // WFMO\n            result = pthread_mutex_unlock(&amp;event-&gt;Mutex);\n            assert(result == 0);\n\n            result = pthread_cond_broadcast(&amp;event-&gt;CVariable);\n            assert(result == 0);\n        }\n\n        return 0;\n    }\n\n    int ResetEvent(neosmart_event_t event) {\n        int result = pthread_mutex_lock(&amp;event-&gt;Mutex);\n        assert(result == 0);\n\n        event-&gt;State = false;\n\n        result = pthread_mutex_unlock(&amp;event-&gt;Mutex);\n        assert(result == 0);\n\n        return 0;\n    }\n\n#ifdef PULSE\n    int PulseEvent(neosmart_event_t event) {\n        // This may look like it's a horribly inefficient kludge with the sole intention of reducing\n        // code duplication, but in reality this is what any PulseEvent() implementation must look\n        // like. The only overhead (function calls aside, which your compiler will likely optimize\n        // away, anyway), is if only WFMO auto-reset waits are active there will be overhead to\n        // unnecessarily obtain the event mutex for ResetEvent() after. In all other cases (being no\n        // pending waits, WFMO manual-reset waits, or any WFSO waits), the event mutex must first be\n        // released for the waiting thread to resume action prior to locking the mutex again in\n        // order to set the event state to unsignaled, or else the waiting threads will loop back\n        // into a wait (due to checks for spurious CVariable wakeups).\n\n        int result = SetEvent(event);\n        assert(result == 0);\n        result = ResetEvent(event);\n        assert(result == 0);\n\n        return 0;\n    }\n#endif\n} // namespace neosmart\n\n#else //_WIN32\n\n#include &lt;Windows.h&gt;\n#include \"pevents.h\"\n\nnamespace neosmart {\n    neosmart_event_t CreateEvent(bool manualReset, bool initialState) {\n        return static_cast&lt;neosmart_event_t&gt;(::CreateEvent(NULL, manualReset, initialState, NULL));\n    }\n\n    int DestroyEvent(neosmart_event_t event) {\n        HANDLE handle = static_cast&lt;HANDLE&gt;(event);\n        return CloseHandle(handle) ? 0 : GetLastError();\n    }\n\n    int WaitForEvent(neosmart_event_t event, uint64_t milliseconds) {\n        uint32_t result = 0;\n        HANDLE handle = static_cast&lt;HANDLE&gt;(event);\n\n        // WaitForSingleObject(Ex) and WaitForMultipleObjects(Ex) only support 32-bit timeout\n        if (milliseconds == ((uint64_t)-1) || (milliseconds &gt;&gt; 32) == 0) {\n            result = WaitForSingleObject(handle, static_cast&lt;uint32_t&gt;(milliseconds));\n        } else {\n            // Cannot wait for 0xFFFFFFFF because that means infinity to WIN32\n            uint32_t waitUnit = (INFINITE - 1);\n            uint64_t rounds = milliseconds / waitUnit;\n            uint32_t remainder = milliseconds % waitUnit;\n\n            result = WaitForSingleObject(handle, remainder);\n            while (result == WAIT_TIMEOUT &amp;&amp; rounds-- != 0) {\n                result = WaitForSingleObject(handle, waitUnit);\n            }\n        }\n\n        if (result == WAIT_OBJECT_0 || result == WAIT_ABANDONED) {\n            // We must swallow WAIT_ABANDONED because there is no such equivalent on *nix\n            return 0;\n        }\n\n        if (result == WAIT_TIMEOUT) {\n            return WAIT_TIMEOUT;\n        }\n\n        return GetLastError();\n    }\n\n    int SetEvent(neosmart_event_t event) {\n        HANDLE handle = static_cast&lt;HANDLE&gt;(event);\n        return ::SetEvent(handle) ? 0 : GetLastError();\n    }\n\n    int ResetEvent(neosmart_event_t event) {\n        HANDLE handle = static_cast&lt;HANDLE&gt;(event);\n        return ::ResetEvent(handle) ? 0 : GetLastError();\n    }\n\n#ifdef WFMO\n    int WaitForMultipleEvents(neosmart_event_t *events, int count, bool waitAll,\n                              uint64_t milliseconds) {\n        int index = 0;\n        return WaitForMultipleEvents(events, count, waitAll, milliseconds, index);\n    }\n\n    int WaitForMultipleEvents(neosmart_event_t *events, int count, bool waitAll,\n                              uint64_t milliseconds, int &amp;index) {\n        HANDLE *handles = reinterpret_cast&lt;HANDLE *&gt;(events);\n        uint32_t result = 0;\n\n        // WaitForSingleObject(Ex) and WaitForMultipleObjects(Ex) only support 32-bit timeout\n        if (milliseconds == ((uint64_t)-1) || (milliseconds &gt;&gt; 32) == 0) {\n            result = WaitForMultipleObjects(count, handles, waitAll,\n                                            static_cast&lt;uint32_t&gt;(milliseconds));\n        } else {\n            // Cannot wait for 0xFFFFFFFF because that means infinity to WIN32\n            uint32_t waitUnit = (INFINITE - 1);\n            uint64_t rounds = milliseconds / waitUnit;\n            uint32_t remainder = milliseconds % waitUnit;\n\n            uint32_t result2 = WaitForMultipleObjects(count, handles, waitAll, remainder);\n            while (result2 == WAIT_TIMEOUT &amp;&amp; rounds-- != 0) {\n                result2 = WaitForMultipleObjects(count, handles, waitAll, waitUnit);\n            }\n        }\n\n        if (result &gt;= WAIT_OBJECT_0 &amp;&amp; result &lt; WAIT_OBJECT_0 + count) {\n            index = result - WAIT_OBJECT_0;\n            return 0;\n        } else if (result &gt;= WAIT_ABANDONED_0 &amp;&amp; result &lt; WAIT_ABANDONED_0 + count) {\n            index = result - WAIT_ABANDONED_0;\n            return 0;\n        }\n\n        if (result == WAIT_FAILED) {\n            return GetLastError();\n        }\n        return result;\n    }\n#endif\n\n#ifdef PULSE\n    int PulseEvent(neosmart_event_t event) {\n        HANDLE handle = static_cast&lt;HANDLE&gt;(event);\n        return ::PulseEvent(handle) ? 0 : GetLastError();\n    }\n#endif\n} // namespace neosmart\n\n#endif //_WIN32\n</code></pre>"},{"location":"GGPOUE4/pevents_8h/","title":"File pevents.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; pevents.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;errno.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"GGPOUE4/pevents_8h/#namespaces","title":"Namespaces","text":"Type Name namespace neosmart"},{"location":"GGPOUE4/pevents_8h/#macros","title":"Macros","text":"Type Name define WAIT_TIMEOUT <code>ETIMEDOUT</code> define WFMO <code>1</code>"},{"location":"GGPOUE4/pevents_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/pevents_8h/#define-wait_timeout","title":"define WAIT_TIMEOUT","text":"<pre><code>#define WAIT_TIMEOUT `ETIMEDOUT`\n</code></pre>"},{"location":"GGPOUE4/pevents_8h/#define-wfmo","title":"define WFMO","text":"<pre><code>#define WFMO `1`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/pevents.h</code></p>"},{"location":"GGPOUE4/pevents_8h_source/","title":"File pevents.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; pevents.h</p> <p>Go to the documentation of this file</p> <pre><code>/*\n * WIN32 Events for POSIX\n * Author: Mahmoud Al-Qudsi &lt;mqudsi@neosmart.net&gt;\n * Copyright (C) 2011 - 2019 by NeoSmart Technologies\n * This code is released under the terms of the MIT License\n */\n\n#pragma once\n\n#if defined(_WIN32) &amp;&amp; !defined(CreateEvent)\n#error Must include Windows.h prior to including pevents.h!\n#endif\n#ifndef WAIT_TIMEOUT\n#include &lt;errno.h&gt;\n#define WAIT_TIMEOUT ETIMEDOUT\n#endif\n\n#include &lt;stdint.h&gt;\n\n#define WFMO 1\n\nnamespace neosmart {\n    // Type declarations\n    struct neosmart_event_t_;\n    typedef neosmart_event_t_ *neosmart_event_t;\n\n    // Function declarations\n    neosmart_event_t CreateEvent(bool manualReset = false, bool initialState = false);\n    int DestroyEvent(neosmart_event_t event);\n    int WaitForEvent(neosmart_event_t event, uint64_t milliseconds = -1);\n    int SetEvent(neosmart_event_t event);\n    int ResetEvent(neosmart_event_t event);\n#ifdef WFMO\n    int WaitForMultipleEvents(neosmart_event_t *events, int count, bool waitAll,\n                              uint64_t milliseconds);\n    int WaitForMultipleEvents(neosmart_event_t *events, int count, bool waitAll,\n                              uint64_t milliseconds, int &amp;index);\n#endif\n#ifdef PULSE\n    int PulseEvent(neosmart_event_t event);\n#endif\n} // namespace neosmart\n</code></pre>"},{"location":"GGPOUE4/platform__unix_8cpp/","title":"File platform_unix.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; platform_unix.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/platform_unix.cpp</code></p>"},{"location":"GGPOUE4/platform__unix_8cpp_source/","title":"File platform_unix.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; platform_unix.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n#ifdef __linux__\n\n#include \"platform_unix.h\"\n\nuint32_t Platform::GetCurrentTimeMS() {\n  struct timespec ts;\n  clock_gettime(CLOCK_MONOTONIC, &amp;ts);\n  return (ts.tv_sec * 1000) + (ts.tv_nsec / (1000*1000));\n}\n\nvoid Platform::SleepMS(int milliseconds) {\n  usleep(milliseconds * 1000);\n}\n\nvoid Platform::CreateDirectory(const char* pathname, const void* junk) {\n  mkdir(pathname, -1);\n}\n\nstatic void __attribute__((constructor)) DllMain() {\n   srand(Platform::GetCurrentTimeMS() + Platform::GetProcessID());\n}\n#endif\n</code></pre>"},{"location":"GGPOUE4/platform__unix_8h/","title":"File platform_unix.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; platform_unix.h</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/platform_unix.h</code></p>"},{"location":"GGPOUE4/platform__unix_8h_source/","title":"File platform_unix.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; platform_unix.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifdef __linux__\n\n#ifndef _GGPO_UNIX_H_\n#define _GGPO_UNIX_H_\n\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;sys/ioctl.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdarg.h&gt;\n#include &lt;climits&gt;\n#include &lt;signal.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;string.h&gt;\n#include &lt;time.h&gt;\n#include &lt;arpa/inet.h&gt;\n\n#include \"pevents.h\"\n\n#define DebugBreak() (raise(SIGTRAP))\n#define ioctlsocket ioctl\n#define closesocket close\n#define WSAEWOULDBLOCK EWOULDBLOCK\n#define INFINITE (-1)\n#define WAIT_OBJECT_0 (0x00000000L)\n#define FALSE (false)\n#define MAX_PATH (4096)\n#define INVALID_SOCKET ((SOCKET)(~0))\n#define SOCKET_ERROR (-1)\n\ntypedef neosmart::neosmart_event_t HANDLE;\ntypedef uint8_t byte;\ntypedef int SOCKET;\ntypedef uint32_t DWORD;\n\nclass Platform {\npublic:  // types\n   typedef pid_t ProcessID;\npublic:  // functions\n   static ProcessID GetProcessID() { return getpid(); }\n   static void AssertFailed(char *msg) { }\n   static uint32_t GetCurrentTimeMS();\n   static void SleepMS(int milliseconds);\n   static void CreateDirectory(const char* pathname, const void* junk);\n};\n\n#endif\n#endif\n</code></pre>"},{"location":"GGPOUE4/platform__windows_8cpp/","title":"File platform_windows.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; platform_windows.cpp</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/platform_windows.cpp</code></p>"},{"location":"GGPOUE4/platform__windows_8cpp_source/","title":"File platform_windows.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; platform_windows.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n* GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n#ifdef _WINDOWS\n#include \"platform_windows.h\"\n\nBOOL WINAPI\nDllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n   srand(Platform::GetCurrentTimeMS() + Platform::GetProcessID());\n   return true;\n}\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/platform__windows_8h/","title":"File platform_windows.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; platform_windows.h</p> <p>Go to the source code of this file</p> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/platform_windows.h</code></p>"},{"location":"GGPOUE4/platform__windows_8h_source/","title":"File platform_windows.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; platform_windows.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifdef _WINDOWS\n#ifndef _GGPO_WINDOWS_H_\n#define _GGPO_WINDOWS_H_\n\n#include \"Windows/AllowWindowsPlatformTypes.h\"\n#include \"Windows/WindowsHWrapper.h\"\n\n#include &lt;winsock2.h&gt;\n#include &lt;WS2tcpip.h&gt;\n#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;timeapi.h&gt;\n#include \"types.h\"\n\nclass Platform {\npublic:  // types\n   typedef DWORD ProcessID;\n\npublic:  // functions\n   static ProcessID GetProcessID() { return GetCurrentProcessId(); }\n   static void AssertFailed(char *msg) { MessageBoxA(NULL, msg, \"GGPO Assertion Failed\", MB_OK | MB_ICONEXCLAMATION); }\n   static uint32_t GetCurrentTimeMS() { return timeGetTime(); }\n   static void SleepMS(int ms) { Sleep(ms); }\n   static void CreateDirectory(const char* pathname, const void* junk) { CreateDirectoryA(pathname, (LPSECURITY_ATTRIBUTES)junk); }\n};\n\n#include \"Windows/WindowsHWrapper.h\"\n#include \"Windows/HideWindowsPlatformTypes.h\"\n\n#endif\n#endif\n</code></pre>"},{"location":"GGPOUE4/poll_8cpp/","title":"File poll.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; poll.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"poll.h\"</code></li> <li><code>#include \"types.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/poll.cpp</code></p>"},{"location":"GGPOUE4/poll_8cpp_source/","title":"File poll.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; poll.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#include \"poll.h\"\n#include \"types.h\"\n\n#ifndef _WIN32\nusing namespace neosmart;\n#endif\n\nPoll::Poll(void) :\n   _start_time(0),\n   _handle_count(0)\n{\n   /*\n    * Create a dummy handle to simplify things.\n    */\n#ifdef _WIN32\n   _handles[_handle_count++] = CreateEvent(NULL, true, false, NULL);\n#else\n   _handles[_handle_count++] = CreateEvent(true, false);\n#endif\n}\n\nvoid\nPoll::RegisterHandle(IPollSink *sink, HANDLE h, void *cookie)\n{\n   ASSERT(_handle_count &lt; MAX_POLLABLE_HANDLES - 1);\n\n   _handles[_handle_count] = h;\n   _handle_sinks[_handle_count] = PollSinkCb(sink, cookie);\n   _handle_count++;\n}\n\nvoid\nPoll::RegisterMsgLoop(IPollSink *sink, void *cookie)\n{\n   _msg_sinks.push_back(PollSinkCb(sink, cookie));\n}\n\nvoid\nPoll::RegisterLoop(IPollSink *sink, void *cookie)\n{\n   _loop_sinks.push_back(PollSinkCb(sink, cookie));\n}\nvoid\nPoll::RegisterPeriodic(IPollSink *sink, int interval, void *cookie)\n{\n   _periodic_sinks.push_back(PollPeriodicSinkCb(sink, cookie, interval));\n}\n\nvoid\nPoll::Run()\n{\n   while (Pump(100)) {\n      continue;\n   }\n}\n\nbool\nPoll::Pump(int timeout)\n{\n   int i, res;\n   bool finished = false;\n\n   if (_start_time == 0) {\n      _start_time = Platform::GetCurrentTimeMS();\n   }\n   int elapsed = Platform::GetCurrentTimeMS() - _start_time;\n   int maxwait = ComputeWaitTime(elapsed);\n   if (maxwait != INFINITE) {\n      timeout = MIN(timeout, maxwait);\n   }\n\n#ifdef _WIN32\n   res = WaitForMultipleObjects(_handle_count, _handles, false, timeout);\n#else\n   res = WaitForMultipleEvents(_handles, _handle_count, false, timeout);\n#endif\n   if (res &gt;= WAIT_OBJECT_0 &amp;&amp; res &lt; WAIT_OBJECT_0 + _handle_count) {\n      i = res - WAIT_OBJECT_0;\n      finished = !_handle_sinks[i].sink-&gt;OnHandlePoll(_handle_sinks[i].cookie) || finished;\n   }\n   for (i = 0; i &lt; _msg_sinks.size(); i++) {\n      PollSinkCb &amp;cb = _msg_sinks[i];\n      finished = !cb.sink-&gt;OnMsgPoll(cb.cookie) || finished;\n   }\n\n   for (i = 0; i &lt; _periodic_sinks.size(); i++) {\n      PollPeriodicSinkCb &amp;cb = _periodic_sinks[i];\n      if (cb.interval + cb.last_fired &lt;= elapsed) {\n         cb.last_fired = (elapsed / cb.interval) * cb.interval;\n         finished = !cb.sink-&gt;OnPeriodicPoll(cb.cookie, cb.last_fired) || finished;\n      }\n   }\n\n   for (i = 0; i &lt; _loop_sinks.size(); i++) {\n      PollSinkCb &amp;cb = _loop_sinks[i];\n      finished = !cb.sink-&gt;OnLoopPoll(cb.cookie) || finished;\n   }\n   return finished;\n}\n\nint\nPoll::ComputeWaitTime(int elapsed)\n{\n   int waitTime = INFINITE;\n   size_t count = _periodic_sinks.size();\n\n   if (count &gt; 0) {\n      for (int i = 0; i &lt; count; i++) {\n         PollPeriodicSinkCb &amp;cb = _periodic_sinks[i];\n         int timeout = (cb.interval + cb.last_fired) - elapsed;\n         if (waitTime == INFINITE || (timeout &lt; waitTime)) {\n            waitTime = MAX(timeout, 0);\n         }         \n      }\n   }\n   return waitTime;\n}\n</code></pre>"},{"location":"GGPOUE4/poll_8h/","title":"File poll.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; poll.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"static_buffer.h\"</code></li> </ul>"},{"location":"GGPOUE4/poll_8h/#classes","title":"Classes","text":"Type Name class IPollSink class Poll struct PollPeriodicSinkCb struct PollSinkCb"},{"location":"GGPOUE4/poll_8h/#macros","title":"Macros","text":"Type Name define MAX_POLLABLE_HANDLES <code>64</code>"},{"location":"GGPOUE4/poll_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/poll_8h/#define-max_pollable_handles","title":"define MAX_POLLABLE_HANDLES","text":"<pre><code>#define MAX_POLLABLE_HANDLES `64`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/poll.h</code></p>"},{"location":"GGPOUE4/poll_8h_source/","title":"File poll.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; poll.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _POLL_H\n#define _POLL_H\n\n#include \"static_buffer.h\"\n\n#define MAX_POLLABLE_HANDLES     64\n\n\nclass IPollSink {\npublic:\n   virtual ~IPollSink() { }\n   virtual bool OnHandlePoll(void *) { return true; }\n   virtual bool OnMsgPoll(void *) { return true; }\n   virtual bool OnPeriodicPoll(void *, int ) { return true; }\n   virtual bool OnLoopPoll(void *) { return true; }\n};\n\nclass Poll {\npublic:\n   Poll(void);\n   void RegisterHandle(IPollSink *sink, HANDLE h, void *cookie = NULL);\n   void RegisterMsgLoop(IPollSink *sink, void *cookie = NULL);\n   void RegisterPeriodic(IPollSink *sink, int interval, void *cookie = NULL);\n   void RegisterLoop(IPollSink *sink, void *cookie = NULL);\n\n   void Run();\n   bool Pump(int timeout);\n\nprotected:\n   int ComputeWaitTime(int elapsed);\n\n   struct PollSinkCb {\n      IPollSink   *sink;\n      void        *cookie;\n      PollSinkCb() : sink(NULL), cookie(NULL) { }\n      PollSinkCb(IPollSink *s, void *c) : sink(s), cookie(c) { }\n   };\n\n   struct PollPeriodicSinkCb : public PollSinkCb {\n      int         interval;\n      int         last_fired;\n      PollPeriodicSinkCb() : PollSinkCb(NULL, NULL), interval(0), last_fired(0) { }\n      PollPeriodicSinkCb(IPollSink *s, void *c, int i) :\n         PollSinkCb(s, c), interval(i), last_fired(0) { }\n   };\n\n   int               _start_time;\n   int               _handle_count;\n   HANDLE            _handles[MAX_POLLABLE_HANDLES];\n   PollSinkCb        _handle_sinks[MAX_POLLABLE_HANDLES];\n\n   StaticBuffer&lt;PollSinkCb, 16&gt;          _msg_sinks;\n   StaticBuffer&lt;PollSinkCb, 16&gt;          _loop_sinks;\n   StaticBuffer&lt;PollPeriodicSinkCb, 16&gt;  _periodic_sinks;\n};\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/ring__buffer_8h/","title":"File ring_buffer.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; ring_buffer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;types.h&gt;</code></li> </ul>"},{"location":"GGPOUE4/ring__buffer_8h/#classes","title":"Classes","text":"Type Name class RingBuffer &lt;class T, N&gt; <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/ring_buffer.h</code></p>"},{"location":"GGPOUE4/ring__buffer_8h_source/","title":"File ring_buffer.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; ring_buffer.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _RING_BUFFER_H\n#define _RING_BUFFER_H\n\n#include &lt;types.h&gt;\n\ntemplate&lt;class T, int N&gt; class RingBuffer\n{\npublic:\n   RingBuffer&lt;T, N&gt;() : \n      _head(0),\n      _tail(0),\n      _size(0) {\n  } \n\n   T &amp;front() {\n      ASSERT(_size != N);\n      return _elements[_tail];\n   }\n\n   T &amp;item(int i) {\n      ASSERT(i &lt; _size);\n      return _elements[(_tail + i) % N];\n   }\n\n   void pop() {\n      ASSERT(_size != N);\n      _tail = (_tail + 1) % N;\n      _size--;\n   }\n\n   void push(const T &amp;t) {\n      ASSERT(_size != (N-1));\n      _elements[_head] = t;\n      _head = (_head + 1) % N;\n      _size++;\n   }\n\n   int size() {\n      return _size;\n   }\n\n   bool empty() {\n      return _size == 0;\n   }\n\nprotected:\n   T        _elements[N];\n   int      _head;\n   int      _tail;\n   int      _size;\n};\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/static__buffer_8h/","title":"File static_buffer.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; static_buffer.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;types.h&gt;</code></li> </ul>"},{"location":"GGPOUE4/static__buffer_8h/#classes","title":"Classes","text":"Type Name class StaticBuffer &lt;class T, N&gt; <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/static_buffer.h</code></p>"},{"location":"GGPOUE4/static__buffer_8h_source/","title":"File static_buffer.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; static_buffer.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _STATIC_BUFFER_H\n#define _STATIC_BUFFER_H\n\n#include &lt;types.h&gt;\n\ntemplate&lt;class T, int N&gt; class StaticBuffer\n{\npublic:\n   StaticBuffer&lt;T, N&gt;() :\n      _size(0) {\n   } \n\n   T&amp; operator[](int i) {\n      ASSERT(i &gt;= 0 &amp;&amp; i &lt; _size);\n      return _elements[i];\n   }\n\n   void push_back(const T &amp;t) {\n      ASSERT(_size != (N-1));\n      _elements[_size++] = t;\n   }\n\n   int size() {\n      return _size;\n   }\n\n\nprotected:\n   T        _elements[N];\n   int      _size;\n};\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/sync_8cpp/","title":"File sync.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; sync.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"sync.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/sync.cpp</code></p>"},{"location":"GGPOUE4/sync_8cpp_source/","title":"File sync.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; sync.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#include \"sync.h\"\n\nSync::Sync(UdpMsg::connect_status *connect_status) :\n _input_queues(NULL),\n _local_connect_status(connect_status)\n{\n   _framecount = 0;\n   _last_confirmed_frame = -1;\n   _max_prediction_frames = 0;\n   memset(&amp;_savedstate, 0, sizeof(_savedstate));\n}\n\nSync::~Sync()\n{\n   /*\n    * Delete frames manually here rather than in a destructor of the SavedFrame\n    * structure so we can efficently copy frames via weak references.\n    */\n   for (int i = 0; i &lt; ARRAY_SIZE(_savedstate.frames); i++) {\n      _callbacks.free_buffer(_savedstate.frames[i].buf);\n   }\n   delete [] _input_queues;\n   _input_queues = NULL;\n}\n\nvoid\nSync::Init(Sync::Config &amp;config)\n{\n   _config = config;\n   _callbacks = config.callbacks;\n   _framecount = 0;\n   _rollingback = false;\n\n   _max_prediction_frames = config.num_prediction_frames;\n\n   CreateQueues(config);\n}\n\nvoid\nSync::SetLastConfirmedFrame(int frame) \n{   \n   _last_confirmed_frame = frame;\n   if (_last_confirmed_frame &gt; 0) {\n      for (int i = 0; i &lt; _config.num_players; i++) {\n         _input_queues[i].DiscardConfirmedFrames(frame - 1);\n      }\n   }\n}\n\nbool\nSync::AddLocalInput(int queue, GameInput &amp;input)\n{\n   int frames_behind = _framecount - _last_confirmed_frame; \n   if (_framecount &gt;= _max_prediction_frames &amp;&amp; frames_behind &gt;= _max_prediction_frames) {\n      Log(\"Rejecting input from emulator: reached prediction barrier.\\n\");\n      return false;\n   }\n\n   if (_framecount == 0) {\n      SaveCurrentFrame();\n   }\n\n   Log(\"Sending undelayed local frame %d to queue %d.\\n\", _framecount, queue);\n   input.frame = _framecount;\n   _input_queues[queue].AddInput(input);\n\n   return true;\n}\n\nvoid\nSync::AddRemoteInput(int queue, GameInput &amp;input)\n{\n   _input_queues[queue].AddInput(input);\n}\n\nint\nSync::GetConfirmedInputs(void *values, int size, int frame)\n{\n   int disconnect_flags = 0;\n   char *output = (char *)values;\n\n   ASSERT(size &gt;= _config.num_players * _config.input_size);\n\n   memset(output, 0, size);\n   for (int i = 0; i &lt; _config.num_players; i++) {\n      GameInput input;\n      if (_local_connect_status[i].disconnected &amp;&amp; frame &gt; _local_connect_status[i].last_frame) {\n         disconnect_flags |= (1 &lt;&lt; i);\n         input.erase();\n      } else {\n         _input_queues[i].GetConfirmedInput(frame, &amp;input);\n      }\n      memcpy(output + (i * _config.input_size), input.bits, _config.input_size);\n   }\n   return disconnect_flags;\n}\n\nint\nSync::SynchronizeInputs(void *values, int size)\n{\n   int disconnect_flags = 0;\n   char *output = (char *)values;\n\n   ASSERT(size &gt;= _config.num_players * _config.input_size);\n\n   memset(output, 0, size);\n   for (int i = 0; i &lt; _config.num_players; i++) {\n      GameInput input;\n      if (_local_connect_status[i].disconnected &amp;&amp; _framecount &gt; _local_connect_status[i].last_frame) {\n         disconnect_flags |= (1 &lt;&lt; i);\n         input.erase();\n      } else {\n         _input_queues[i].GetInput(_framecount, &amp;input);\n      }\n      memcpy(output + (i * _config.input_size), input.bits, _config.input_size);\n   }\n   return disconnect_flags;\n}\n\nvoid\nSync::CheckSimulation(int timeout)\n{\n   int seek_to;\n   if (!CheckSimulationConsistency(&amp;seek_to)) {\n      AdjustSimulation(seek_to);\n   }\n}\n\nvoid\nSync::IncrementFrame(void)\n{\n   _framecount++;\n   SaveCurrentFrame();\n}\n\nvoid\nSync::AdjustSimulation(int seek_to)\n{\n   int framecount = _framecount;\n   int count = _framecount - seek_to;\n\n   Log(\"Catching up\\n\");\n   _rollingback = true;\n\n   /*\n    * Flush our input queue and load the last frame.\n    */\n   LoadFrame(seek_to);\n   ASSERT(_framecount == seek_to);\n\n   /*\n    * Advance frame by frame (stuffing notifications back to \n    * the master).\n    */\n   ResetPrediction(_framecount);\n   for (int i = 0; i &lt; count; i++) {\n      _callbacks.advance_frame(0);\n   }\n   ASSERT(_framecount == framecount);\n\n   _rollingback = false;\n\n   Log(\"---\\n\");   \n}\n\nvoid\nSync::LoadFrame(int frame)\n{\n   // find the frame in question\n   if (frame == _framecount) {\n      Log(\"Skipping NOP.\\n\");\n      return;\n   }\n\n   // Move the head pointer back and load it up\n   _savedstate.head = FindSavedFrameIndex(frame);\n   SavedFrame *state = _savedstate.frames + _savedstate.head;\n\n   Log(\"=== Loading frame info %d (size: %d  checksum: %08x).\\n\",\n       state-&gt;frame, state-&gt;cbuf, state-&gt;checksum);\n\n   ASSERT(state-&gt;buf &amp;&amp; state-&gt;cbuf);\n   _callbacks.load_game_state(state-&gt;buf, state-&gt;cbuf);\n\n   // Reset framecount and the head of the state ring-buffer to point in\n   // advance of the current frame (as if we had just finished executing it).\n   _framecount = state-&gt;frame;\n   _savedstate.head = (_savedstate.head + 1) % ARRAY_SIZE(_savedstate.frames);\n}\n\nvoid\nSync::SaveCurrentFrame()\n{\n   /*\n    * See StateCompress for the real save feature implemented by FinalBurn.\n    * Write everything into the head, then advance the head pointer.\n    */\n   SavedFrame *state = _savedstate.frames + _savedstate.head;\n   if (state-&gt;buf) {\n      _callbacks.free_buffer(state-&gt;buf);\n      state-&gt;buf = NULL;\n   }\n   state-&gt;frame = _framecount;\n   _callbacks.save_game_state(&amp;state-&gt;buf, &amp;state-&gt;cbuf, &amp;state-&gt;checksum, state-&gt;frame);\n\n   Log(\"=== Saved frame info %d (size: %d  checksum: %08x).\\n\", state-&gt;frame, state-&gt;cbuf, state-&gt;checksum);\n   _savedstate.head = (_savedstate.head + 1) % ARRAY_SIZE(_savedstate.frames);\n}\n\nSync::SavedFrame&amp;\nSync::GetLastSavedFrame()\n{\n   int i = _savedstate.head - 1;\n   if (i &lt; 0) {\n      i = ARRAY_SIZE(_savedstate.frames) - 1;\n   }\n   return _savedstate.frames[i];\n}\n\n\nint\nSync::FindSavedFrameIndex(int frame)\n{\n   int i, count = ARRAY_SIZE(_savedstate.frames);\n   for (i = 0; i &lt; count; i++) {\n      if (_savedstate.frames[i].frame == frame) {\n         break;\n      }\n   }\n   if (i == count) {\n      ASSERT(false);\n   }\n   return i;\n}\n\n\nbool\nSync::CreateQueues(Config &amp;config)\n{\n   delete [] _input_queues;\n   _input_queues = new InputQueue[_config.num_players];\n\n   for (int i = 0; i &lt; _config.num_players; i++) {\n      _input_queues[i].Init(i, _config.input_size);\n   }\n   return true;\n}\n\nbool\nSync::CheckSimulationConsistency(int *seekTo)\n{\n   int first_incorrect = GameInput::NullFrame;\n   for (int i = 0; i &lt; _config.num_players; i++) {\n      int incorrect = _input_queues[i].GetFirstIncorrectFrame();\n      Log(\"considering incorrect frame %d reported by queue %d.\\n\", incorrect, i);\n\n      if (incorrect != GameInput::NullFrame &amp;&amp; (first_incorrect == GameInput::NullFrame || incorrect &lt; first_incorrect)) {\n         first_incorrect = incorrect;\n      }\n   }\n\n   if (first_incorrect == GameInput::NullFrame) {\n      Log(\"prediction ok.  proceeding.\\n\");\n      return true;\n   }\n   *seekTo = first_incorrect;\n   return false;\n}\n\nvoid\nSync::SetFrameDelay(int queue, int delay)\n{\n   _input_queues[queue].SetFrameDelay(delay);\n}\n\n\nvoid\nSync::ResetPrediction(int frameNumber)\n{\n   for (int i = 0; i &lt; _config.num_players; i++) {\n      _input_queues[i].ResetPrediction(frameNumber);\n   }\n}\n\n\nbool\nSync::GetEvent(Event &amp;e)\n{\n   if (_event_queue.size()) {\n      e = _event_queue.front();\n      _event_queue.pop();\n      return true;\n   }\n   return false;\n}\n</code></pre>"},{"location":"GGPOUE4/sync_8h/","title":"File sync.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; sync.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"types.h\"</code></li> <li><code>#include \"include/ggponet.h\"</code></li> <li><code>#include \"game_input.h\"</code></li> <li><code>#include \"input_queue.h\"</code></li> <li><code>#include \"ring_buffer.h\"</code></li> <li><code>#include \"network/udp_msg.h\"</code></li> </ul>"},{"location":"GGPOUE4/sync_8h/#classes","title":"Classes","text":"Type Name class Sync struct Config struct Event"},{"location":"GGPOUE4/sync_8h/#macros","title":"Macros","text":"Type Name define MAX_PREDICTION_FRAMES <code>8</code>"},{"location":"GGPOUE4/sync_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/sync_8h/#define-max_prediction_frames","title":"define MAX_PREDICTION_FRAMES","text":"<pre><code>#define MAX_PREDICTION_FRAMES `8`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/sync.h</code></p>"},{"location":"GGPOUE4/sync_8h_source/","title":"File sync.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; sync.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _SYNC_H\n#define _SYNC_H\n\n#include \"types.h\"\n#include \"include/ggponet.h\"\n#include \"game_input.h\"\n#include \"input_queue.h\"\n#include \"ring_buffer.h\"\n#include \"network/udp_msg.h\"\n\n#define MAX_PREDICTION_FRAMES    8\n\nclass SyncTestBackend;\n\nclass Sync {\npublic:\n   struct Config {\n      GGPOSessionCallbacks    callbacks;\n      int                     num_prediction_frames;\n      int                     num_players;\n      int                     input_size;\n   };\n   struct Event {\n      enum {\n         ConfirmedInput,\n      } type;\n      union {\n         struct {\n            GameInput   input;\n         } confirmedInput;\n      } u;\n   };\n\npublic:\n   Sync(UdpMsg::connect_status *connect_status);\n   virtual ~Sync();\n\n   void Init(Config &amp;config);\n\n   void SetLastConfirmedFrame(int frame);\n   void SetFrameDelay(int queue, int delay);\n   bool AddLocalInput(int queue, GameInput &amp;input);\n   void AddRemoteInput(int queue, GameInput &amp;input);\n   int GetConfirmedInputs(void *values, int size, int frame);\n   int SynchronizeInputs(void *values, int size);\n\n   void CheckSimulation(int timeout);\n   void AdjustSimulation(int seek_to);\n   void IncrementFrame(void);\n\n   int GetFrameCount() { return _framecount; }\n   bool InRollback() { return _rollingback; }\n\n   bool GetEvent(Event &amp;e);\n\nprotected:\n   friend SyncTestBackend;\n\n   struct SavedFrame {\n      byte    *buf;\n      int      cbuf;\n      int      frame;\n      int      checksum;\n      SavedFrame() : buf(NULL), cbuf(0), frame(-1), checksum(0) { }\n   };\n   struct SavedState {\n      SavedFrame frames[MAX_PREDICTION_FRAMES + 2];\n      int head;\n   };\n\n   void LoadFrame(int frame);\n   void SaveCurrentFrame();\n   int FindSavedFrameIndex(int frame);\n   SavedFrame &amp;GetLastSavedFrame();\n\n   bool CreateQueues(Config &amp;config);\n   bool CheckSimulationConsistency(int *seekTo);\n   void ResetPrediction(int frameNumber);\n\nprotected:\n   GGPOSessionCallbacks _callbacks;\n   SavedState     _savedstate;\n   Config         _config;\n\n   bool           _rollingback;\n   int            _last_confirmed_frame;\n   int            _framecount;\n   int            _max_prediction_frames;\n\n   InputQueue     *_input_queues;\n\n   RingBuffer&lt;Event, 32&gt; _event_queue;\n   UdpMsg::connect_status *_local_connect_status;\n};\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/timesync_8cpp/","title":"File timesync.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; timesync.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"timesync.h\"</code></li> </ul> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/timesync.cpp</code></p>"},{"location":"GGPOUE4/timesync_8cpp_source/","title":"File timesync.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; timesync.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#include \"timesync.h\"\n\nTimeSync::TimeSync()\n{\n   memset(_local, 0, sizeof(_local));\n   memset(_remote, 0, sizeof(_remote));\n   _next_prediction = FRAME_WINDOW_SIZE * 3;\n}\n\nTimeSync::~TimeSync()\n{\n}\n\nvoid\nTimeSync::advance_frame(GameInput &amp;input, int advantage, int radvantage)\n{\n   // Remember the last frame and frame advantage\n   _last_inputs[input.frame % ARRAY_SIZE(_last_inputs)] = input;\n   _local[input.frame % ARRAY_SIZE(_local)] = advantage;\n   _remote[input.frame % ARRAY_SIZE(_remote)] = radvantage;\n}\n\nint\nTimeSync::recommend_frame_wait_duration(bool require_idle_input)\n{\n   // Average our local and remote frame advantages\n   int i, sum = 0;\n   float advantage, radvantage;\n   for (i = 0; i &lt; ARRAY_SIZE(_local); i++) {\n      sum += _local[i];\n   }\n   advantage = sum / (float)ARRAY_SIZE(_local);\n\n   sum = 0;\n   for (i = 0; i &lt; ARRAY_SIZE(_remote); i++) {\n      sum += _remote[i];\n   }\n   radvantage = sum / (float)ARRAY_SIZE(_remote);\n\n   static int count = 0;\n   count++;\n\n   // See if someone should take action.  The person furthest ahead\n   // needs to slow down so the other user can catch up.\n   // Only do this if both clients agree on who's ahead!!\n   if (advantage &gt;= radvantage) {\n      return 0;\n   }\n\n   // Both clients agree that we're the one ahead.  Split\n   // the difference between the two to figure out how long to\n   // sleep for.\n   int sleep_frames = (int)(((radvantage - advantage) / 2) + 0.5);\n\n   Log(\"iteration %d:  sleep frames is %d\\n\", count, sleep_frames);\n\n   // Some things just aren't worth correcting for.  Make sure\n   // the difference is relevant before proceeding.\n   if (sleep_frames &lt; MIN_FRAME_ADVANTAGE) {\n      return 0;\n   }\n\n   // Make sure our input had been \"idle enough\" before recommending\n   // a sleep.  This tries to make the emulator sleep while the\n   // user's input isn't sweeping in arcs (e.g. fireball motions in\n   // Street Fighter), which could cause the player to miss moves.\n   if (require_idle_input) {\n      for (i = 1; i &lt; ARRAY_SIZE(_last_inputs); i++) {\n         if (!_last_inputs[i].equal(_last_inputs[0], true)) {\n            Log(\"iteration %d:  rejecting due to input stuff at position %d...!!!\\n\", count, i);\n            return 0;\n         }\n      }\n   }\n\n   // Success!!! Recommend the number of frames to sleep and adjust\n   return MIN(sleep_frames, MAX_FRAME_ADVANTAGE);\n}\n</code></pre>"},{"location":"GGPOUE4/timesync_8h/","title":"File timesync.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; timesync.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"types.h\"</code></li> <li><code>#include \"game_input.h\"</code></li> </ul>"},{"location":"GGPOUE4/timesync_8h/#classes","title":"Classes","text":"Type Name class TimeSync"},{"location":"GGPOUE4/timesync_8h/#macros","title":"Macros","text":"Type Name define FRAME_WINDOW_SIZE <code>40</code> define MAX_FRAME_ADVANTAGE <code>9</code> define MIN_FRAME_ADVANTAGE <code>3</code> define MIN_UNIQUE_FRAMES <code>10</code>"},{"location":"GGPOUE4/timesync_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/timesync_8h/#define-frame_window_size","title":"define FRAME_WINDOW_SIZE","text":"<pre><code>#define FRAME_WINDOW_SIZE `40`\n</code></pre>"},{"location":"GGPOUE4/timesync_8h/#define-max_frame_advantage","title":"define MAX_FRAME_ADVANTAGE","text":"<pre><code>#define MAX_FRAME_ADVANTAGE `9`\n</code></pre>"},{"location":"GGPOUE4/timesync_8h/#define-min_frame_advantage","title":"define MIN_FRAME_ADVANTAGE","text":"<pre><code>#define MIN_FRAME_ADVANTAGE `3`\n</code></pre>"},{"location":"GGPOUE4/timesync_8h/#define-min_unique_frames","title":"define MIN_UNIQUE_FRAMES","text":"<pre><code>#define MIN_UNIQUE_FRAMES `10`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/timesync.h</code></p>"},{"location":"GGPOUE4/timesync_8h_source/","title":"File timesync.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; timesync.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _TIMESYNC_H\n#define _TIMESYNC_H\n\n#include \"types.h\"\n#include \"game_input.h\"\n\n#define FRAME_WINDOW_SIZE           40\n#define MIN_UNIQUE_FRAMES           10\n#define MIN_FRAME_ADVANTAGE          3\n#define MAX_FRAME_ADVANTAGE          9\n\nclass TimeSync {\npublic:\n   TimeSync();\n   virtual ~TimeSync ();\n\n   void advance_frame(GameInput &amp;input, int advantage, int radvantage);\n   int recommend_frame_wait_duration(bool require_idle_input);\n\nprotected:\n   int         _local[FRAME_WINDOW_SIZE];\n   int         _remote[FRAME_WINDOW_SIZE];\n   GameInput   _last_inputs[MIN_UNIQUE_FRAMES];\n   int         _next_prediction;\n};\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/types_8h/","title":"File types.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; types.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"log.h\"</code></li> </ul>"},{"location":"GGPOUE4/types_8h/#public-types","title":"Public Types","text":"Type Name typedef unsigned char byte"},{"location":"GGPOUE4/types_8h/#macros","title":"Macros","text":"Type Name define ARRAY_SIZE (a) <code>(sizeof(a) / sizeof((a)[0]))</code> define ASSERT (x) <code>/* multi line expression */</code> define MAX (x, y) <code>(((x) &amp;gt; (y)) ? (x) : (y))</code> define MAX_INT <code>0xEFFFFFF</code> define MIN (x, y) <code>(((x) &amp;lt; (y)) ? (x) : (y))</code>"},{"location":"GGPOUE4/types_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"GGPOUE4/types_8h/#typedef-byte","title":"typedef byte","text":"<pre><code>typedef unsigned char byte;\n</code></pre>"},{"location":"GGPOUE4/types_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/types_8h/#define-array_size","title":"define ARRAY_SIZE","text":"<pre><code>#define ARRAY_SIZE (\n    a\n) `(sizeof(a) / sizeof((a)[0]))`\n</code></pre>"},{"location":"GGPOUE4/types_8h/#define-assert","title":"define ASSERT","text":"<pre><code>#define ASSERT (\n    x\n) `/* multi line expression */`\n</code></pre>"},{"location":"GGPOUE4/types_8h/#define-max","title":"define MAX","text":"<pre><code>#define MAX (\n    x,\n    y\n) `(((x) &gt; (y)) ? (x) : (y))`\n</code></pre>"},{"location":"GGPOUE4/types_8h/#define-max_int","title":"define MAX_INT","text":"<pre><code>#define MAX_INT `0xEFFFFFF`\n</code></pre>"},{"location":"GGPOUE4/types_8h/#define-min","title":"define MIN","text":"<pre><code>#define MIN (\n    x,\n    y\n) `(((x) &lt; (y)) ? (x) : (y))`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/types.h</code></p>"},{"location":"GGPOUE4/types_8h_source/","title":"File types.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; types.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#ifndef _TYPES_H\n#define _TYPES_H\n/*\n * Keep the compiler happy\n */\n\n/*\n * Disable specific compiler warnings\n *   4018 - '&lt;' : signed/unsigned mismatch\n *   4100 - 'xxx' : unreferenced formal parameter\n *   4127 - conditional expression is constant\n *   4201 - nonstandard extension used : nameless struct/union\n *   4389 - '!=' : signed/unsigned mismatch\n *   4800 - 'int' : forcing value to bool 'true' or 'false' (performance warning)\n */\n#pragma warning(disable: 4018 4100 4127 4201 4389 4800)\n\n/*\n * Simple types\n */\ntypedef unsigned char byte;\n\n/*\n * Additional headers\n */\n#if defined(_WINDOWS)\n#  include \"platform_windows.h\"\n#elif defined(__APPLE__) or defined(__GNUC__)\n#  include \"platform_unix.h\"\n#else\n#  error Unsupported platform\n#endif\n\n#include \"log.h\"\n\n\n\n/*\n * Macros\n */\n#define ASSERT(x)                                           \\\n   do {                                                     \\\n      if (!(x)) {                                           \\\n         char assert_buf[1024];                             \\\n         snprintf(assert_buf, sizeof(assert_buf) - 1, \"Assertion: %s @ %s:%d (pid:%d)\", #x, __FILE__, __LINE__, (int)Platform::GetProcessID()); \\\n         Log(\"%s\\n\", assert_buf);                           \\\n         Log(\"\\n\");                                         \\\n         Log(\"\\n\");                                         \\\n         Log(\"\\n\");                                         \\\n         Platform::AssertFailed(assert_buf);                \\\n         exit(0);                                           \\\n      }                                                     \\\n   } while (false)\n\n#ifndef ARRAY_SIZE\n#  define ARRAY_SIZE(a)    (sizeof(a) / sizeof((a)[0]))\n#endif\n\n#ifndef MAX_INT\n#  define MAX_INT          0xEFFFFFF\n#endif\n\n#ifndef MAX\n#  define MAX(x, y)        (((x) &gt; (y)) ? (x) : (y))\n#endif\n\n#ifndef MIN\n#  define MIN(x, y)        (((x) &lt; (y)) ? (x) : (y))\n#endif\n\n#endif // _TYPES_H\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/","title":"File zconf.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; zconf.h</p> <p>Go to the source code of this file</p>"},{"location":"GGPOUE4/zconf_8h/#public-types","title":"Public Types","text":"Type Name typedef unsigned char Byte typedef Byte FAR Bytef typedef char FAR charf typedef int FAR intf typedef unsigned int uInt typedef uInt FAR uIntf typedef unsigned long uLong typedef uLong FAR uLongf typedef Byte * voidp typedef Byte FAR * voidpf"},{"location":"GGPOUE4/zconf_8h/#macros","title":"Macros","text":"Type Name define FAR define MAX_MEM_LEVEL <code>9</code> define MAX_WBITS <code>15 /\\* 32K LZ77 window \\*/</code> define OF (args) <code>()</code> define SEEK_CUR <code>1       /\\* Seek from current position.  \\*/</code> define SEEK_END <code>2       /\\* Set file pointer to EOF plus \"offset\" \\*/</code> define SEEK_SET <code>0       /\\* Seek from beginning of file.  \\*/</code> define ZEXPORT <code>\\_\\_fastcall</code> define ZEXPORTVA <code>\\_\\_cdecl</code> define ZEXTERN <code>extern</code> define const define z_off_t <code>long</code>"},{"location":"GGPOUE4/zconf_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"GGPOUE4/zconf_8h/#typedef-byte","title":"typedef Byte","text":"<pre><code>typedef unsigned char Byte;\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#typedef-bytef","title":"typedef Bytef","text":"<pre><code>typedef Byte FAR Bytef;\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#typedef-charf","title":"typedef charf","text":"<pre><code>typedef char FAR charf;\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#typedef-intf","title":"typedef intf","text":"<pre><code>typedef int FAR intf;\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#typedef-uint","title":"typedef uInt","text":"<pre><code>typedef unsigned int uInt;\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#typedef-uintf","title":"typedef uIntf","text":"<pre><code>typedef uInt FAR uIntf;\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#typedef-ulong","title":"typedef uLong","text":"<pre><code>typedef unsigned long uLong;\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#typedef-ulongf","title":"typedef uLongf","text":"<pre><code>typedef uLong FAR uLongf;\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#typedef-voidp","title":"typedef voidp","text":"<pre><code>typedef Byte* voidp;\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#typedef-voidpf","title":"typedef voidpf","text":"<pre><code>typedef Byte FAR* voidpf;\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/zconf_8h/#define-far","title":"define FAR","text":"<pre><code>#define FAR \n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#define-max_mem_level","title":"define MAX_MEM_LEVEL","text":"<pre><code>#define MAX_MEM_LEVEL `9`\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#define-max_wbits","title":"define MAX_WBITS","text":"<pre><code>#define MAX_WBITS `15 /* 32K LZ77 window */`\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#define-of","title":"define OF","text":"<pre><code>#define OF (\n    args\n) `()`\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#define-seek_cur","title":"define SEEK_CUR","text":"<pre><code>#define SEEK_CUR `1       /* Seek from current position.  */`\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#define-seek_end","title":"define SEEK_END","text":"<pre><code>#define SEEK_END `2       /* Set file pointer to EOF plus \"offset\" */`\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#define-seek_set","title":"define SEEK_SET","text":"<pre><code>#define SEEK_SET `0       /* Seek from beginning of file.  */`\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#define-zexport","title":"define ZEXPORT","text":"<pre><code>#define ZEXPORT `__fastcall`\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#define-zexportva","title":"define ZEXPORTVA","text":"<pre><code>#define ZEXPORTVA `__cdecl`\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#define-zextern","title":"define ZEXTERN","text":"<pre><code>#define ZEXTERN `extern`\n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#define-const","title":"define const","text":"<pre><code>#define const \n</code></pre>"},{"location":"GGPOUE4/zconf_8h/#define-z_off_t","title":"define z_off_t","text":"<pre><code>#define z_off_t `long`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/zconf.h</code></p>"},{"location":"GGPOUE4/zconf_8h_source/","title":"File zconf.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; zconf.h</p> <p>Go to the documentation of this file</p> <pre><code>/* zconf.h -- configuration of the zlib compression library\n * Copyright (C) 1995-2002 Jean-loup Gailly.\n * For conditions of distribution and use, see copyright notice in zlib.h \n */\n\n// Dave:\n#define ZEXPORT __fastcall\n#define ZEXPORTVA __cdecl\n\n/* @(#) $Id$ */\n\n#ifndef _ZCONF_H\n#define _ZCONF_H\n\n/*\n * If you *really* need a unique prefix for all types and library functions,\n * compile with -DZ_PREFIX. The \"standard\" zlib should be compiled without it.\n */\n#ifdef Z_PREFIX\n#  define deflateInit_  z_deflateInit_\n#  define deflate   z_deflate\n#  define deflateEnd    z_deflateEnd\n#  define inflateInit_  z_inflateInit_\n#  define inflate   z_inflate\n#  define inflateEnd    z_inflateEnd\n#  define deflateInit2_ z_deflateInit2_\n#  define deflateSetDictionary z_deflateSetDictionary\n#  define deflateCopy   z_deflateCopy\n#  define deflateReset  z_deflateReset\n#  define deflateParams z_deflateParams\n#  define inflateInit2_ z_inflateInit2_\n#  define inflateSetDictionary z_inflateSetDictionary\n#  define inflateSync   z_inflateSync\n#  define inflateSyncPoint z_inflateSyncPoint\n#  define inflateReset  z_inflateReset\n#  define compress  z_compress\n#  define compress2 z_compress2\n#  define uncompress    z_uncompress\n#  define adler32   z_adler32\n#  define crc32     z_crc32\n#  define get_crc_table z_get_crc_table\n\n#  define Byte      z_Byte\n#  define uInt      z_uInt\n#  define uLong     z_uLong\n#  define Bytef         z_Bytef\n#  define charf     z_charf\n#  define intf      z_intf\n#  define uIntf     z_uIntf\n#  define uLongf    z_uLongf\n#  define voidpf    z_voidpf\n#  define voidp     z_voidp\n#endif\n\n#if (defined(_WIN32) || defined(__WIN32__)) &amp;&amp; !defined(WIN32)\n#  define WIN32\n#endif\n#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)\n#  ifndef __32BIT__\n#    define __32BIT__\n#  endif\n#endif\n#if defined(__MSDOS__) &amp;&amp; !defined(MSDOS)\n#  define MSDOS\n#endif\n\n/*\n * Compile with -DMAXSEG_64K if the alloc function cannot allocate more\n * than 64k bytes at a time (needed on systems with 16-bit int).\n */\n#if defined(MSDOS) &amp;&amp; !defined(__32BIT__)\n#  define MAXSEG_64K\n#endif\n#ifdef MSDOS\n#  define UNALIGNED_OK\n#endif\n\n#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  &amp;&amp; !defined(STDC)\n#  define STDC\n#endif\n#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)\n#  ifndef STDC\n#    define STDC\n#  endif\n#endif\n\n#ifndef STDC\n#  ifndef const /* cannot use !defined(STDC) &amp;&amp; !defined(const) on Mac */\n#    define const\n#  endif\n#endif\n\n/* Some Mac compilers merge all .h files incorrectly: */\n#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)\n#  define NO_DUMMY_DECL\n#endif\n\n/* Old Borland C incorrectly complains about missing returns: */\n#if defined(__BORLANDC__) &amp;&amp; (__BORLANDC__ &lt; 0x500)\n#  define NEED_DUMMY_RETURN\n#endif\n\n\n/* Maximum value for memLevel in deflateInit2 */\n#ifndef MAX_MEM_LEVEL\n#  ifdef MAXSEG_64K\n#    define MAX_MEM_LEVEL 8\n#  else\n#    define MAX_MEM_LEVEL 9\n#  endif\n#endif\n\n/* Maximum value for windowBits in deflateInit2 and inflateInit2.\n * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files\n * created by gzip. (Files created by minigzip can still be extracted by\n * gzip.)\n */\n#ifndef MAX_WBITS\n#  define MAX_WBITS   15 /* 32K LZ77 window */\n#endif\n\n/* The memory requirements for deflate are (in bytes):\n            (1 &lt;&lt; (windowBits+2)) +  (1 &lt;&lt; (memLevel+9))\n that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)\n plus a few kilobytes for small objects. For example, if you want to reduce\n the default memory requirements from 256K to 128K, compile with\n     make CFLAGS=\"-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7\"\n Of course this will generally degrade compression (there's no free lunch).\n\n   The memory requirements for inflate are (in bytes) 1 &lt;&lt; windowBits\n that is, 32K for windowBits=15 (default value) plus a few kilobytes\n for small objects.\n*/\n\n                        /* Type declarations */\n\n#ifndef OF /* function prototypes */\n#  ifdef STDC\n#    define OF(args)  args\n#  else\n#    define OF(args)  ()\n#  endif\n#endif\n\n/* The following definitions for FAR are needed only for MSDOS mixed\n * model programming (small or medium model with some far allocations).\n * This was tsted only with MSC; for other MSDOS compilers you may have\n * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,\n * just define FAR to be empty.\n */\n#if (defined(M_I86SM) || defined(M_I86MM)) &amp;&amp; !defined(__32BIT__)\n   /* MSC small or medium model */\n#  define SMALL_MEDIUM\n#  ifdef _MSC_VER\n#    define FAR _far\n#  else\n#    define FAR far\n#  endif\n#endif\n#if defined(__BORLANDC__) &amp;&amp; (defined(__SMALL__) || defined(__MEDIUM__))\n#  ifndef __32BIT__\n#    define SMALL_MEDIUM\n#    define FAR _far\n#  endif\n#endif\n\n/* Compile with -DZLIB_DLL for Windows DLL support */\n#if defined(ZLIB_DLL)\n#  if defined(_WINDOWS) || defined(WINDOWS)\n#    ifdef FAR\n#      undef FAR\n#    endif\n#    include &lt;windows.h&gt;\n#    define ZEXPORT  WINAPI\n#    ifdef WIN32\n#      define ZEXPORTVA  WINAPIV\n#    else\n#      define ZEXPORTVA  FAR _cdecl _export\n#    endif\n#  endif\n#  if defined (__BORLANDC__)\n#    if (__BORLANDC__ &gt;= 0x0500) &amp;&amp; defined (WIN32)\n#      include &lt;windows.h&gt;\n#      define ZEXPORT EXPORT WINAPI\n#      define ZEXPORTRVA EXPORT WINAPIV\n#    else\n#      if defined (_Windows) &amp;&amp; defined (__DLL__)\n#        define ZEXPORT _export\n#        define ZEXPORTVA _export\n#      endif\n#    endif\n#  endif\n#endif\n\n#if defined (__BEOS__)\n#  if defined (ZLIB_DLL)\n#    define ZEXTERN extern EXPORT\n#  else\n#    define ZEXTERN extern __declspec(dllimport)\n#  endif\n#endif\n\n#ifndef ZEXPORT\n#  define ZEXPORT\n#endif\n#ifndef ZEXPORTVA\n#  define ZEXPORTVA\n#endif\n#ifndef ZEXTERN\n#  define ZEXTERN extern\n#endif\n\n#ifndef FAR\n#   define FAR\n#endif\n\n#if !defined(MACOS) &amp;&amp; !defined(TARGET_OS_MAC)\ntypedef unsigned char  Byte;  /* 8 bits */\n#endif\ntypedef unsigned int   uInt;  /* 16 bits or more */\ntypedef unsigned long  uLong; /* 32 bits or more */\n\n#ifdef SMALL_MEDIUM\n   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */\n#  define Bytef Byte FAR\n#else\n   typedef Byte  FAR Bytef;\n#endif\ntypedef char  FAR charf;\ntypedef int   FAR intf;\ntypedef uInt  FAR uIntf;\ntypedef uLong FAR uLongf;\n\n#ifdef STDC\n   typedef void FAR *voidpf;\n   typedef void     *voidp;\n#else\n   typedef Byte FAR *voidpf;\n   typedef Byte     *voidp;\n#endif\n\n#ifdef HAVE_UNISTD_H\n#  include &lt;sys/types.h&gt; /* for off_t */\n#  include &lt;unistd.h&gt;    /* for SEEK_* and off_t */\n#  define z_off_t  off_t\n#endif\n#ifndef SEEK_SET\n#  define SEEK_SET        0       /* Seek from beginning of file.  */\n#  define SEEK_CUR        1       /* Seek from current position.  */\n#  define SEEK_END        2       /* Set file pointer to EOF plus \"offset\" */\n#endif\n#ifndef z_off_t\n#  define  z_off_t long\n#endif\n\n/* MVS linker does not support external names larger than 8 bytes */\n#if defined(__MVS__)\n#   pragma map(deflateInit_,\"DEIN\")\n#   pragma map(deflateInit2_,\"DEIN2\")\n#   pragma map(deflateEnd,\"DEEND\")\n#   pragma map(inflateInit_,\"ININ\")\n#   pragma map(inflateInit2_,\"ININ2\")\n#   pragma map(inflateEnd,\"INEND\")\n#   pragma map(inflateSync,\"INSY\")\n#   pragma map(inflateSetDictionary,\"INSEDI\")\n#   pragma map(inflate_blocks,\"INBL\")\n#   pragma map(inflate_blocks_new,\"INBLNE\")\n#   pragma map(inflate_blocks_free,\"INBLFR\")\n#   pragma map(inflate_blocks_reset,\"INBLRE\")\n#   pragma map(inflate_codes_free,\"INCOFR\")\n#   pragma map(inflate_codes,\"INCO\")\n#   pragma map(inflate_fast,\"INFA\")\n#   pragma map(inflate_flush,\"INFLU\")\n#   pragma map(inflate_mask,\"INMA\")\n#   pragma map(inflate_set_dictionary,\"INSEDI2\")\n#   pragma map(inflate_copyright,\"INCOPY\")\n#   pragma map(inflate_trees_bits,\"INTRBI\")\n#   pragma map(inflate_trees_dynamic,\"INTRDY\")\n#   pragma map(inflate_trees_fixed,\"INTRFI\")\n#   pragma map(inflate_trees_free,\"INTRFR\")\n#endif\n\n#endif /* _ZCONF_H */\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/","title":"File zlib.h","text":"<p>FileList &gt; GGPOUE4 &gt; Private &gt; zlib.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"zconf.h\"</code></li> </ul>"},{"location":"GGPOUE4/zlib_8h/#classes","title":"Classes","text":"Type Name struct internal_state struct z_stream_s"},{"location":"GGPOUE4/zlib_8h/#public-types","title":"Public Types","text":"Type Name typedef voidpf alloc_func OF typedef voidp gzFile typedef struct z_stream_s z_stream typedef z_stream FAR * z_streamp"},{"location":"GGPOUE4/zlib_8h/#public-functions","title":"Public Functions","text":"Type Name ZEXTERN const char *ZEXPORT zlibVersion OF ((void))  ZEXTERN int ZEXPORT deflate OF ((z_streamp strm, int flush))  ZEXTERN int ZEXPORT deflateEnd OF ((z_streamp strm))  ZEXTERN int ZEXPORT deflateSetDictionary OF ((z_streamp strm, const Bytef *dictionary, uInt dictLength))  ZEXTERN int ZEXPORT deflateCopy OF ((z_streamp dest, z_streamp source))  ZEXTERN int ZEXPORT deflateParams OF ((z_streamp strm, int level, int strategy))  ZEXTERN int ZEXPORT compress OF ((Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen))  ZEXTERN int ZEXPORT compress2 OF ((Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen, int level))  ZEXTERN gzFile ZEXPORT gzopen OF ((const char *path, const char *mode))  ZEXTERN gzFile ZEXPORT gzdopen OF ((int fd, const char *mode))  ZEXTERN int ZEXPORT gzsetparams OF ((gzFile file, int level, int strategy))  ZEXTERN int ZEXPORT gzread OF ((gzFile file, voidp buf, unsigned len))  ZEXTERN int ZEXPORTVA gzprintf OF ((gzFile file, const char *format,...))  ZEXTERN int ZEXPORT gzputs OF ((gzFile file, const char *s))  ZEXTERN char *ZEXPORT gzgets OF ((gzFile file, char *buf, int len))  ZEXTERN int ZEXPORT gzputc OF ((gzFile file, int c))  ZEXTERN int ZEXPORT gzgetc OF ((gzFile file))  ZEXTERN int ZEXPORT gzflush OF ((gzFile file, int flush))  ZEXTERN z_off_t ZEXPORT gzseek OF ((gzFile file, z_off_t offset, int whence))  ZEXTERN const char *ZEXPORT gzerror OF ((gzFile file, int *errnum))  ZEXTERN uLong ZEXPORT adler32 OF ((uLong adler, const Bytef *buf, uInt len))  ZEXTERN uLong ZEXPORT crc32 OF ((uLong crc, const Bytef *buf, uInt len))  ZEXTERN int ZEXPORT deflateInit_ OF ((z_streamp strm, int level, const char *version, int stream_size))  ZEXTERN int ZEXPORT inflateInit_ OF ((z_streamp strm, const char *version, int stream_size))  ZEXTERN int ZEXPORT deflateInit2_ OF ((z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size))  ZEXTERN int ZEXPORT inflateInit2_ OF ((z_streamp strm, int windowBits, const char *version, int stream_size))  ZEXTERN const char *ZEXPORT zError OF ((int err))  ZEXTERN int ZEXPORT inflateSyncPoint OF ((z_streamp z))"},{"location":"GGPOUE4/zlib_8h/#macros","title":"Macros","text":"Type Name define ZLIB_VERSION <code>\"1.1.4\"</code> define Z_ASCII <code>1</code> define Z_BEST_COMPRESSION <code>9</code> define Z_BEST_SPEED <code>1</code> define Z_BINARY <code>0</code> define Z_BUF_ERROR <code>(-5)</code> define Z_DATA_ERROR <code>(-3)</code> define Z_DEFAULT_COMPRESSION <code>(-1)</code> define Z_DEFAULT_STRATEGY <code>0</code> define Z_DEFLATED <code>8</code> define Z_ERRNO <code>(-1)</code> define Z_FILTERED <code>1</code> define Z_FINISH <code>4</code> define Z_FULL_FLUSH <code>3</code> define Z_HUFFMAN_ONLY <code>2</code> define Z_MEM_ERROR <code>(-4)</code> define Z_NEED_DICT <code>2</code> define Z_NO_COMPRESSION <code>0</code> define Z_NO_FLUSH <code>0</code> define Z_NULL <code>0  /\\* for initializing zalloc, zfree, opaque \\*/</code> define Z_OK <code>0</code> define Z_PARTIAL_FLUSH <code>1 /\\* will be removed, use Z\\_SYNC\\_FLUSH instead \\*/</code> define Z_STREAM_END <code>1</code> define Z_STREAM_ERROR <code>(-2)</code> define Z_SYNC_FLUSH <code>2</code> define Z_UNKNOWN <code>2</code> define Z_VERSION_ERROR <code>(-6)</code> define deflateInit (strm, level) <code>deflateInit\\_((strm), (level),       ZLIB\\_VERSION, sizeof([**z\\_stream**](structz__stream__s.md)))</code> define deflateInit2 (strm, level, method, windowBits, memLevel, strategy) <code>/* multi line expression */</code> define inflateInit (strm) <code>inflateInit\\_((strm),                ZLIB\\_VERSION, sizeof([**z\\_stream**](structz__stream__s.md)))</code> define inflateInit2 (strm, windowBits) <code>inflateInit2\\_((strm), (windowBits), ZLIB\\_VERSION, sizeof([**z\\_stream**](structz__stream__s.md)))</code> define zlib_version <code>zlibVersion()</code>"},{"location":"GGPOUE4/zlib_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"GGPOUE4/zlib_8h/#typedef-of","title":"typedef OF","text":"<pre><code>ZEXTERN const uLongf *ZEXPORT get_crc_table OF;\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#typedef-gzfile","title":"typedef gzFile","text":"<pre><code>typedef voidp gzFile;\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#typedef-z_stream","title":"typedef z_stream","text":"<pre><code>typedef struct z_stream_s z_stream;\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#typedef-z_streamp","title":"typedef z_streamp","text":"<pre><code>typedef z_stream FAR* z_streamp;\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/zlib_8h/#function-of","title":"function OF","text":"<pre><code>ZEXTERN const char *ZEXPORT zlibVersion OF (\n    (void)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_1","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT deflate OF (\n    (z_streamp strm, int flush)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_2","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT deflateEnd OF (\n    (z_streamp strm)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_3","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT deflateSetDictionary OF (\n    (z_streamp strm, const Bytef *dictionary, uInt dictLength)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_4","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT deflateCopy OF (\n    (z_streamp dest, z_streamp source)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_5","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT deflateParams OF (\n    (z_streamp strm, int level, int strategy)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_6","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT compress OF (\n    (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_7","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT compress2 OF (\n    (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen, int level)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_8","title":"function OF","text":"<pre><code>ZEXTERN gzFile ZEXPORT gzopen OF (\n    (const char *path, const char *mode)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_9","title":"function OF","text":"<pre><code>ZEXTERN gzFile ZEXPORT gzdopen OF (\n    (int fd, const char *mode)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_10","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT gzsetparams OF (\n    (gzFile file, int level, int strategy)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_11","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT gzread OF (\n    (gzFile file, voidp buf, unsigned len)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_12","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORTVA gzprintf OF (\n    (gzFile file, const char *format,...)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_13","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT gzputs OF (\n    (gzFile file, const char *s)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_14","title":"function OF","text":"<pre><code>ZEXTERN char *ZEXPORT gzgets OF (\n    (gzFile file, char *buf, int len)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_15","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT gzputc OF (\n    (gzFile file, int c)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_16","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT gzgetc OF (\n    (gzFile file)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_17","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT gzflush OF (\n    (gzFile file, int flush)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_18","title":"function OF","text":"<pre><code>ZEXTERN z_off_t ZEXPORT gzseek OF (\n    (gzFile file, z_off_t offset, int whence)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_19","title":"function OF","text":"<pre><code>ZEXTERN const char *ZEXPORT gzerror OF (\n    (gzFile file, int *errnum)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_20","title":"function OF","text":"<pre><code>ZEXTERN uLong ZEXPORT adler32 OF (\n    (uLong adler, const Bytef *buf, uInt len)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_21","title":"function OF","text":"<pre><code>ZEXTERN uLong ZEXPORT crc32 OF (\n    (uLong crc, const Bytef *buf, uInt len)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_22","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT deflateInit_ OF (\n    (z_streamp strm, int level, const char *version, int stream_size)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_23","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT inflateInit_ OF (\n    (z_streamp strm, const char *version, int stream_size)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_24","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT deflateInit2_ OF (\n    (z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_25","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT inflateInit2_ OF (\n    (z_streamp strm, int windowBits, const char *version, int stream_size)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_26","title":"function OF","text":"<pre><code>ZEXTERN const char *ZEXPORT zError OF (\n    (int err)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#function-of_27","title":"function OF","text":"<pre><code>ZEXTERN int ZEXPORT inflateSyncPoint OF (\n    (z_streamp z)\n) \n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/zlib_8h/#define-zlib_version","title":"define ZLIB_VERSION","text":"<pre><code>#define ZLIB_VERSION `\"1.1.4\"`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_ascii","title":"define Z_ASCII","text":"<pre><code>#define Z_ASCII `1`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_best_compression","title":"define Z_BEST_COMPRESSION","text":"<pre><code>#define Z_BEST_COMPRESSION `9`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_best_speed","title":"define Z_BEST_SPEED","text":"<pre><code>#define Z_BEST_SPEED `1`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_binary","title":"define Z_BINARY","text":"<pre><code>#define Z_BINARY `0`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_buf_error","title":"define Z_BUF_ERROR","text":"<pre><code>#define Z_BUF_ERROR `(-5)`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_data_error","title":"define Z_DATA_ERROR","text":"<pre><code>#define Z_DATA_ERROR `(-3)`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_default_compression","title":"define Z_DEFAULT_COMPRESSION","text":"<pre><code>#define Z_DEFAULT_COMPRESSION `(-1)`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_default_strategy","title":"define Z_DEFAULT_STRATEGY","text":"<pre><code>#define Z_DEFAULT_STRATEGY `0`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_deflated","title":"define Z_DEFLATED","text":"<pre><code>#define Z_DEFLATED `8`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_errno","title":"define Z_ERRNO","text":"<pre><code>#define Z_ERRNO `(-1)`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_filtered","title":"define Z_FILTERED","text":"<pre><code>#define Z_FILTERED `1`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_finish","title":"define Z_FINISH","text":"<pre><code>#define Z_FINISH `4`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_full_flush","title":"define Z_FULL_FLUSH","text":"<pre><code>#define Z_FULL_FLUSH `3`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_huffman_only","title":"define Z_HUFFMAN_ONLY","text":"<pre><code>#define Z_HUFFMAN_ONLY `2`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_mem_error","title":"define Z_MEM_ERROR","text":"<pre><code>#define Z_MEM_ERROR `(-4)`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_need_dict","title":"define Z_NEED_DICT","text":"<pre><code>#define Z_NEED_DICT `2`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_no_compression","title":"define Z_NO_COMPRESSION","text":"<pre><code>#define Z_NO_COMPRESSION `0`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_no_flush","title":"define Z_NO_FLUSH","text":"<pre><code>#define Z_NO_FLUSH `0`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_null","title":"define Z_NULL","text":"<pre><code>#define Z_NULL `0  /* for initializing zalloc, zfree, opaque */`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_ok","title":"define Z_OK","text":"<pre><code>#define Z_OK `0`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_partial_flush","title":"define Z_PARTIAL_FLUSH","text":"<pre><code>#define Z_PARTIAL_FLUSH `1 /* will be removed, use Z_SYNC_FLUSH instead */`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_stream_end","title":"define Z_STREAM_END","text":"<pre><code>#define Z_STREAM_END `1`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_stream_error","title":"define Z_STREAM_ERROR","text":"<pre><code>#define Z_STREAM_ERROR `(-2)`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_sync_flush","title":"define Z_SYNC_FLUSH","text":"<pre><code>#define Z_SYNC_FLUSH `2`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_unknown","title":"define Z_UNKNOWN","text":"<pre><code>#define Z_UNKNOWN `2`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-z_version_error","title":"define Z_VERSION_ERROR","text":"<pre><code>#define Z_VERSION_ERROR `(-6)`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-deflateinit","title":"define deflateInit","text":"<pre><code>#define deflateInit (\n    strm,\n    level\n) `deflateInit_((strm), (level),       ZLIB_VERSION, sizeof( z_stream ))`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-deflateinit2","title":"define deflateInit2","text":"<pre><code>#define deflateInit2 (\n    strm,\n    level,\n    method,\n    windowBits,\n    memLevel,\n    strategy\n) `/* multi line expression */`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-inflateinit","title":"define inflateInit","text":"<pre><code>#define inflateInit (\n    strm\n) `inflateInit_((strm),                ZLIB_VERSION, sizeof( z_stream ))`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-inflateinit2","title":"define inflateInit2","text":"<pre><code>#define inflateInit2 (\n    strm,\n    windowBits\n) `inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof( z_stream ))`\n</code></pre>"},{"location":"GGPOUE4/zlib_8h/#define-zlib_version_1","title":"define zlib_version","text":"<pre><code>#define zlib_version `zlibVersion()`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Private/zlib.h</code></p>"},{"location":"GGPOUE4/zlib_8h_source/","title":"File zlib.h","text":"<p>File List &gt; GGPOUE4 &gt; Private &gt; zlib.h</p> <p>Go to the documentation of this file</p> <pre><code> /* zlib.h -- interface of the 'zlib' general purpose compression library\n  version 1.1.4, March 11th, 2002\n\n  Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Jean-loup Gailly        Mark Adler\n  jloup@gzip.org          madler@alumni.caltech.edu\n\n\n  The data format used by the zlib library is described by RFCs (Request for\n  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt\n  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).\n*/\n\n#ifndef _ZLIB_H\n#define _ZLIB_H\n\n#include \"zconf.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define ZLIB_VERSION \"1.1.4\"\n\n/* \n     The 'zlib' compression library provides in-memory compression and\n  decompression functions, including integrity checks of the uncompressed\n  data.  This version of the library supports only one compression method\n  (deflation) but other algorithms will be added later and will have the same\n  stream interface.\n\n     Compression can be done in a single step if the buffers are large\n  enough (for example if an input file is mmap'ed), or can be done by\n  repeated calls of the compression function.  In the latter case, the\n  application must provide more input and/or consume the output\n  (providing more output space) before each call.\n\n     The library also supports reading and writing files in gzip (.gz) format\n  with an interface similar to that of stdio.\n\n     The library does not install any signal handler. The decoder checks\n  the consistency of the compressed data, so the library should never\n  crash even in case of corrupted input.\n*/\n\ntypedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));\ntypedef void   (*free_func)  OF((voidpf opaque, voidpf address));\n\nstruct internal_state;\n\ntypedef struct z_stream_s {\n    Bytef    *next_in;  /* next input byte */\n    uInt     avail_in;  /* number of bytes available at next_in */\n    uLong    total_in;  /* total nb of input bytes read so far */\n\n    Bytef    *next_out; /* next output byte should be put there */\n    uInt     avail_out; /* remaining free space at next_out */\n    uLong    total_out; /* total nb of bytes output so far */\n\n    char     *msg;      /* last error message, NULL if no error */\n    struct internal_state FAR *state; /* not visible by applications */\n\n    alloc_func zalloc;  /* used to allocate the internal state */\n    free_func  zfree;   /* used to free the internal state */\n    voidpf     opaque;  /* private data object passed to zalloc and zfree */\n\n    int     data_type;  /* best guess about the data type: ascii or binary */\n    uLong   adler;      /* adler32 value of the uncompressed data */\n    uLong   reserved;   /* reserved for future use */\n} z_stream;\n\ntypedef z_stream FAR *z_streamp;\n\n/*\n   The application must update next_in and avail_in when avail_in has\n   dropped to zero. It must update next_out and avail_out when avail_out\n   has dropped to zero. The application must initialize zalloc, zfree and\n   opaque before calling the init function. All other fields are set by the\n   compression library and must not be updated by the application.\n\n   The opaque value provided by the application will be passed as the first\n   parameter for calls of zalloc and zfree. This can be useful for custom\n   memory management. The compression library attaches no meaning to the\n   opaque value.\n\n   zalloc must return Z_NULL if there is not enough memory for the object.\n   If zlib is used in a multi-threaded application, zalloc and zfree must be\n   thread safe.\n\n   On 16-bit systems, the functions zalloc and zfree must be able to allocate\n   exactly 65536 bytes, but will not be required to allocate more than this\n   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,\n   pointers returned by zalloc for objects of exactly 65536 bytes *must*\n   have their offset normalized to zero. The default allocation function\n   provided by this library ensures this (see zutil.c). To reduce memory\n   requirements and avoid any allocation of 64K objects, at the expense of\n   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).\n\n   The fields total_in and total_out can be used for statistics or\n   progress reports. After compression, total_in holds the total size of\n   the uncompressed data and may be saved for use in the decompressor\n   (particularly if the decompressor wants to decompress everything in\n   a single step).\n*/\n\n                        /* constants */\n\n#define Z_NO_FLUSH      0\n#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */\n#define Z_SYNC_FLUSH    2\n#define Z_FULL_FLUSH    3\n#define Z_FINISH        4\n/* Allowed flush values; see deflate() below for details */\n\n#define Z_OK            0\n#define Z_STREAM_END    1\n#define Z_NEED_DICT     2\n#define Z_ERRNO        (-1)\n#define Z_STREAM_ERROR (-2)\n#define Z_DATA_ERROR   (-3)\n#define Z_MEM_ERROR    (-4)\n#define Z_BUF_ERROR    (-5)\n#define Z_VERSION_ERROR (-6)\n/* Return codes for the compression/decompression functions. Negative\n * values are errors, positive values are used for special but normal events.\n */\n\n#define Z_NO_COMPRESSION         0\n#define Z_BEST_SPEED             1\n#define Z_BEST_COMPRESSION       9\n#define Z_DEFAULT_COMPRESSION  (-1)\n/* compression levels */\n\n#define Z_FILTERED            1\n#define Z_HUFFMAN_ONLY        2\n#define Z_DEFAULT_STRATEGY    0\n/* compression strategy; see deflateInit2() below for details */\n\n#define Z_BINARY   0\n#define Z_ASCII    1\n#define Z_UNKNOWN  2\n/* Possible values of the data_type field */\n\n#define Z_DEFLATED   8\n/* The deflate compression method (the only one supported in this version) */\n\n#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */\n\n#define zlib_version zlibVersion()\n/* for compatibility with versions &lt; 1.0.2 */\n\n                        /* basic functions */\n\nZEXTERN const char * ZEXPORT zlibVersion OF((void));\n/* The application can compare zlibVersion and ZLIB_VERSION for consistency.\n   If the first character differs, the library code actually used is\n   not compatible with the zlib.h header file used by the application.\n   This check is automatically made by deflateInit and inflateInit.\n */\n\n/* \nZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));\n\n     Initializes the internal stream state for compression. The fields\n   zalloc, zfree and opaque must be initialized before by the caller.\n   If zalloc and zfree are set to Z_NULL, deflateInit updates them to\n   use default allocation functions.\n\n     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:\n   1 gives best speed, 9 gives best compression, 0 gives no compression at\n   all (the input data is simply copied a block at a time).\n   Z_DEFAULT_COMPRESSION requests a default compromise between speed and\n   compression (currently equivalent to level 6).\n\n     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_STREAM_ERROR if level is not a valid compression level,\n   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible\n   with the version assumed by the caller (ZLIB_VERSION).\n   msg is set to null if there is no error message.  deflateInit does not\n   perform any compression: this will be done by deflate().\n*/\n\n\nZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));\n/*\n    deflate compresses as much data as possible, and stops when the input\n  buffer becomes empty or the output buffer becomes full. It may introduce some\n  output latency (reading input without producing any output) except when\n  forced to flush.\n\n    The detailed semantics are as follows. deflate performs one or both of the\n  following actions:\n\n  - Compress more input starting at next_in and update next_in and avail_in\n    accordingly. If not all input can be processed (because there is not\n    enough room in the output buffer), next_in and avail_in are updated and\n    processing will resume at this point for the next call of deflate().\n\n  - Provide more output starting at next_out and update next_out and avail_out\n    accordingly. This action is forced if the parameter flush is non zero.\n    Forcing flush frequently degrades the compression ratio, so this parameter\n    should be set only when necessary (in interactive applications).\n    Some output may be provided even if flush is not set.\n\n  Before the call of deflate(), the application should ensure that at least\n  one of the actions is possible, by providing more input and/or consuming\n  more output, and updating avail_in or avail_out accordingly; avail_out\n  should never be zero before the call. The application can consume the\n  compressed output when it wants, for example when the output buffer is full\n  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK\n  and with zero avail_out, it must be called again after making room in the\n  output buffer because there might be more output pending.\n\n    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is\n  flushed to the output buffer and the output is aligned on a byte boundary, so\n  that the decompressor can get all input data available so far. (In particular\n  avail_in is zero after the call if enough output space has been provided\n  before the call.)  Flushing may degrade compression for some compression\n  algorithms and so it should be used only when necessary.\n\n    If flush is set to Z_FULL_FLUSH, all output is flushed as with\n  Z_SYNC_FLUSH, and the compression state is reset so that decompression can\n  restart from this point if previous compressed data has been damaged or if\n  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade\n  the compression.\n\n    If deflate returns with avail_out == 0, this function must be called again\n  with the same value of the flush parameter and more output space (updated\n  avail_out), until the flush is complete (deflate returns with non-zero\n  avail_out).\n\n    If the parameter flush is set to Z_FINISH, pending input is processed,\n  pending output is flushed and deflate returns with Z_STREAM_END if there\n  was enough output space; if deflate returns with Z_OK, this function must be\n  called again with Z_FINISH and more output space (updated avail_out) but no\n  more input data, until it returns with Z_STREAM_END or an error. After\n  deflate has returned Z_STREAM_END, the only possible operations on the\n  stream are deflateReset or deflateEnd.\n\n    Z_FINISH can be used immediately after deflateInit if all the compression\n  is to be done in a single step. In this case, avail_out must be at least\n  0.1% larger than avail_in plus 12 bytes.  If deflate does not return\n  Z_STREAM_END, then it must be called again as described above.\n\n    deflate() sets strm-&gt;adler to the adler32 checksum of all input read\n  so far (that is, total_in bytes).\n\n    deflate() may update data_type if it can make a good guess about\n  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered\n  binary. This field is only for information purposes and does not affect\n  the compression algorithm in any manner.\n\n    deflate() returns Z_OK if some progress has been made (more input\n  processed or more output produced), Z_STREAM_END if all input has been\n  consumed and all output has been produced (only when flush is set to\n  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example\n  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible\n  (for example avail_in or avail_out was zero).\n*/\n\n\nZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));\n/*\n     All dynamically allocated data structures for this stream are freed.\n   This function discards any unprocessed input and does not flush any\n   pending output.\n\n     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the\n   stream state was inconsistent, Z_DATA_ERROR if the stream was freed\n   prematurely (some input or output was discarded). In the error case,\n   msg may be set but then points to a static string (which must not be\n   deallocated).\n*/\n\n\n/* \nZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));\n\n     Initializes the internal stream state for decompression. The fields\n   next_in, avail_in, zalloc, zfree and opaque must be initialized before by\n   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact\n   value depends on the compression method), inflateInit determines the\n   compression method from the zlib header and allocates all data structures\n   accordingly; otherwise the allocation will be deferred to the first call of\n   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to\n   use default allocation functions.\n\n     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the\n   version assumed by the caller.  msg is set to null if there is no error\n   message. inflateInit does not perform any decompression apart from reading\n   the zlib header if present: this will be done by inflate().  (So next_in and\n   avail_in may be modified, but next_out and avail_out are unchanged.)\n*/\n\n\nZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));\n/*\n    inflate decompresses as much data as possible, and stops when the input\n  buffer becomes empty or the output buffer becomes full. It may some\n  introduce some output latency (reading input without producing any output)\n  except when forced to flush.\n\n  The detailed semantics are as follows. inflate performs one or both of the\n  following actions:\n\n  - Decompress more input starting at next_in and update next_in and avail_in\n    accordingly. If not all input can be processed (because there is not\n    enough room in the output buffer), next_in is updated and processing\n    will resume at this point for the next call of inflate().\n\n  - Provide more output starting at next_out and update next_out and avail_out\n    accordingly.  inflate() provides as much output as possible, until there\n    is no more input data or no more space in the output buffer (see below\n    about the flush parameter).\n\n  Before the call of inflate(), the application should ensure that at least\n  one of the actions is possible, by providing more input and/or consuming\n  more output, and updating the next_* and avail_* values accordingly.\n  The application can consume the uncompressed output when it wants, for\n  example when the output buffer is full (avail_out == 0), or after each\n  call of inflate(). If inflate returns Z_OK and with zero avail_out, it\n  must be called again after making room in the output buffer because there\n  might be more output pending.\n\n    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much\n  output as possible to the output buffer. The flushing behavior of inflate is\n  not specified for values of the flush parameter other than Z_SYNC_FLUSH\n  and Z_FINISH, but the current implementation actually flushes as much output\n  as possible anyway.\n\n    inflate() should normally be called until it returns Z_STREAM_END or an\n  error. However if all decompression is to be performed in a single step\n  (a single call of inflate), the parameter flush should be set to\n  Z_FINISH. In this case all pending input is processed and all pending\n  output is flushed; avail_out must be large enough to hold all the\n  uncompressed data. (The size of the uncompressed data may have been saved\n  by the compressor for this purpose.) The next operation on this stream must\n  be inflateEnd to deallocate the decompression state. The use of Z_FINISH\n  is never required, but can be used to inform inflate that a faster routine\n  may be used for the single inflate() call.\n\n     If a preset dictionary is needed at this point (see inflateSetDictionary\n  below), inflate sets strm-adler to the adler32 checksum of the\n  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise \n  it sets strm-&gt;adler to the adler32 checksum of all output produced\n  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or\n  an error code as described below. At the end of the stream, inflate()\n  checks that its computed adler32 checksum is equal to that saved by the\n  compressor and returns Z_STREAM_END only if the checksum is correct.\n\n    inflate() returns Z_OK if some progress has been made (more input processed\n  or more output produced), Z_STREAM_END if the end of the compressed data has\n  been reached and all uncompressed output has been produced, Z_NEED_DICT if a\n  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was\n  corrupted (input stream not conforming to the zlib format or incorrect\n  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent\n  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not\n  enough memory, Z_BUF_ERROR if no progress is possible or if there was not\n  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR\n  case, the application may then call inflateSync to look for a good\n  compression block.\n*/\n\n\nZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));\n/*\n     All dynamically allocated data structures for this stream are freed.\n   This function discards any unprocessed input and does not flush any\n   pending output.\n\n     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state\n   was inconsistent. In the error case, msg may be set but then points to a\n   static string (which must not be deallocated).\n*/\n\n                        /* Advanced functions */\n\n/*\n    The following functions are needed only in some special applications.\n*/\n\n/*   \nZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,\n                                     int  level,\n                                     int  method,\n                                     int  windowBits,\n                                     int  memLevel,\n                                     int  strategy));\n\n     This is another version of deflateInit with more compression options. The\n   fields next_in, zalloc, zfree and opaque must be initialized before by\n   the caller.\n\n     The method parameter is the compression method. It must be Z_DEFLATED in\n   this version of the library.\n\n     The windowBits parameter is the base two logarithm of the window size\n   (the size of the history buffer).  It should be in the range 8..15 for this\n   version of the library. Larger values of this parameter result in better\n   compression at the expense of memory usage. The default value is 15 if\n   deflateInit is used instead.\n\n     The memLevel parameter specifies how much memory should be allocated\n   for the internal compression state. memLevel=1 uses minimum memory but\n   is slow and reduces compression ratio; memLevel=9 uses maximum memory\n   for optimal speed. The default value is 8. See zconf.h for total memory\n   usage as a function of windowBits and memLevel.\n\n     The strategy parameter is used to tune the compression algorithm. Use the\n   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a\n   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no\n   string match).  Filtered data consists mostly of small values with a\n   somewhat random distribution. In this case, the compression algorithm is\n   tuned to compress them better. The effect of Z_FILTERED is to force more\n   Huffman coding and less string matching; it is somewhat intermediate\n   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects\n   the compression ratio but not the correctness of the compressed output even\n   if it is not set appropriately.\n\n      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid\n   method). msg is set to null if there is no error message.  deflateInit2 does\n   not perform any compression: this will be done by deflate().\n*/\n\nZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,\n                                             const Bytef *dictionary,\n                                             uInt  dictLength));\n/*\n     Initializes the compression dictionary from the given byte sequence\n   without producing any compressed output. This function must be called\n   immediately after deflateInit, deflateInit2 or deflateReset, before any\n   call of deflate. The compressor and decompressor must use exactly the same\n   dictionary (see inflateSetDictionary).\n\n     The dictionary should consist of strings (byte sequences) that are likely\n   to be encountered later in the data to be compressed, with the most commonly\n   used strings preferably put towards the end of the dictionary. Using a\n   dictionary is most useful when the data to be compressed is short and can be\n   predicted with good accuracy; the data can then be compressed better than\n   with the default empty dictionary.\n\n     Depending on the size of the compression data structures selected by\n   deflateInit or deflateInit2, a part of the dictionary may in effect be\n   discarded, for example if the dictionary is larger than the window size in\n   deflate or deflate2. Thus the strings most likely to be useful should be\n   put at the end of the dictionary, not at the front.\n\n     Upon return of this function, strm-&gt;adler is set to the Adler32 value\n   of the dictionary; the decompressor may later use this value to determine\n   which dictionary has been used by the compressor. (The Adler32 value\n   applies to the whole dictionary even if only a subset of the dictionary is\n   actually used by the compressor.)\n\n     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a\n   parameter is invalid (such as NULL dictionary) or the stream state is\n   inconsistent (for example if deflate has already been called for this stream\n   or if the compression method is bsort). deflateSetDictionary does not\n   perform any compression: this will be done by deflate().\n*/\n\nZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,\n                                    z_streamp source));\n/*\n     Sets the destination stream as a complete copy of the source stream.\n\n     This function can be useful when several compression strategies will be\n   tried, for example when there are several ways of pre-processing the input\n   data with a filter. The streams that will be discarded should then be freed\n   by calling deflateEnd.  Note that deflateCopy duplicates the internal\n   compression state which can be quite large, so this strategy is slow and\n   can consume lots of memory.\n\n     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent\n   (such as zalloc being NULL). msg is left unchanged in both source and\n   destination.\n*/\n\nZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));\n/*\n     This function is equivalent to deflateEnd followed by deflateInit,\n   but does not free and reallocate all the internal compression state.\n   The stream will keep the same compression level and any other attributes\n   that may have been set by deflateInit2.\n\n      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent (such as zalloc or state being NULL).\n*/\n\nZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,\n                      int level,\n                      int strategy));\n/*\n     Dynamically update the compression level and compression strategy.  The\n   interpretation of level and strategy is as in deflateInit2.  This can be\n   used to switch between compression and straight copy of the input data, or\n   to switch to a different kind of input data requiring a different\n   strategy. If the compression level is changed, the input available so far\n   is compressed with the old level (and may be flushed); the new level will\n   take effect only at the next call of deflate().\n\n     Before the call of deflateParams, the stream state must be set as for\n   a call of deflate(), since the currently available input may have to\n   be compressed and flushed. In particular, strm-&gt;avail_out must be non-zero.\n\n     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source\n   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR\n   if strm-&gt;avail_out was zero.\n*/\n\n/*   \nZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,\n                                     int  windowBits));\n\n     This is another version of inflateInit with an extra parameter. The\n   fields next_in, avail_in, zalloc, zfree and opaque must be initialized\n   before by the caller.\n\n     The windowBits parameter is the base two logarithm of the maximum window\n   size (the size of the history buffer).  It should be in the range 8..15 for\n   this version of the library. The default value is 15 if inflateInit is used\n   instead. If a compressed stream with a larger window size is given as\n   input, inflate() will return with the error code Z_DATA_ERROR instead of\n   trying to allocate a larger window.\n\n      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative\n   memLevel). msg is set to null if there is no error message.  inflateInit2\n   does not perform any decompression apart from reading the zlib header if\n   present: this will be done by inflate(). (So next_in and avail_in may be\n   modified, but next_out and avail_out are unchanged.)\n*/\n\nZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,\n                                             const Bytef *dictionary,\n                                             uInt  dictLength));\n/*\n     Initializes the decompression dictionary from the given uncompressed byte\n   sequence. This function must be called immediately after a call of inflate\n   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor\n   can be determined from the Adler32 value returned by this call of\n   inflate. The compressor and decompressor must use exactly the same\n   dictionary (see deflateSetDictionary).\n\n     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a\n   parameter is invalid (such as NULL dictionary) or the stream state is\n   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the\n   expected one (incorrect Adler32 value). inflateSetDictionary does not\n   perform any decompression: this will be done by subsequent calls of\n   inflate().\n*/\n\nZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));\n/* \n    Skips invalid compressed data until a full flush point (see above the\n  description of deflate with Z_FULL_FLUSH) can be found, or until all\n  available input is skipped. No output is provided.\n\n    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR\n  if no more input was provided, Z_DATA_ERROR if no flush point has been found,\n  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success\n  case, the application may save the current current value of total_in which\n  indicates where valid compressed data was found. In the error case, the\n  application may repeatedly call inflateSync, providing more input each time,\n  until success or end of the input data.\n*/\n\nZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));\n/*\n     This function is equivalent to inflateEnd followed by inflateInit,\n   but does not free and reallocate all the internal decompression state.\n   The stream will keep attributes that may have been set by inflateInit2.\n\n      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source\n   stream state was inconsistent (such as zalloc or state being NULL).\n*/\n\n\n                        /* utility functions */\n\n/*\n     The following utility functions are implemented on top of the\n   basic stream-oriented functions. To simplify the interface, some\n   default options are assumed (compression level and memory usage,\n   standard memory allocation functions). The source code of these\n   utility functions can easily be modified if you need special options.\n*/\n\nZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,\n                                 const Bytef *source, uLong sourceLen));\n/*\n     Compresses the source buffer into the destination buffer.  sourceLen is\n   the byte length of the source buffer. Upon entry, destLen is the total\n   size of the destination buffer, which must be at least 0.1% larger than\n   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the\n   compressed buffer.\n     This function can be used to compress a whole file at once if the\n   input file is mmap'ed.\n     compress returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_BUF_ERROR if there was not enough room in the output\n   buffer.\n*/\n\nZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,\n                                  const Bytef *source, uLong sourceLen,\n                                  int level));\n/*\n     Compresses the source buffer into the destination buffer. The level\n   parameter has the same meaning as in deflateInit.  sourceLen is the byte\n   length of the source buffer. Upon entry, destLen is the total size of the\n   destination buffer, which must be at least 0.1% larger than sourceLen plus\n   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.\n\n     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough\n   memory, Z_BUF_ERROR if there was not enough room in the output buffer,\n   Z_STREAM_ERROR if the level parameter is invalid.\n*/\n\nZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,\n                                   const Bytef *source, uLong sourceLen));\n/*\n     Decompresses the source buffer into the destination buffer.  sourceLen is\n   the byte length of the source buffer. Upon entry, destLen is the total\n   size of the destination buffer, which must be large enough to hold the\n   entire uncompressed data. (The size of the uncompressed data must have\n   been saved previously by the compressor and transmitted to the decompressor\n   by some mechanism outside the scope of this compression library.)\n   Upon exit, destLen is the actual size of the compressed buffer.\n     This function can be used to decompress a whole file at once if the\n   input file is mmap'ed.\n\n     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not\n   enough memory, Z_BUF_ERROR if there was not enough room in the output\n   buffer, or Z_DATA_ERROR if the input data was corrupted.\n*/\n\n\ntypedef voidp gzFile;\n\nZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));\n/*\n     Opens a gzip (.gz) file for reading or writing. The mode parameter\n   is as in fopen (\"rb\" or \"wb\") but can also include a compression level\n   (\"wb9\") or a strategy: 'f' for filtered data as in \"wb6f\", 'h' for\n   Huffman only compression as in \"wb1h\". (See the description\n   of deflateInit2 for more information about the strategy parameter.)\n\n     gzopen can be used to read a file which is not in gzip format; in this\n   case gzread will directly read from the file without decompression.\n\n     gzopen returns NULL if the file could not be opened or if there was\n   insufficient memory to allocate the (de)compression state; errno\n   can be checked to distinguish the two cases (if errno is zero, the\n   zlib error is Z_MEM_ERROR).  */\n\nZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));\n/*\n     gzdopen() associates a gzFile with the file descriptor fd.  File\n   descriptors are obtained from calls like open, dup, creat, pipe or\n   fileno (in the file has been previously opened with fopen).\n   The mode parameter is as in gzopen.\n     The next call of gzclose on the returned gzFile will also close the\n   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file\n   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).\n     gzdopen returns NULL if there was insufficient memory to allocate\n   the (de)compression state.\n*/\n\nZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));\n/*\n     Dynamically update the compression level or strategy. See the description\n   of deflateInit2 for the meaning of these parameters.\n     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not\n   opened for writing.\n*/\n\nZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));\n/*\n     Reads the given number of uncompressed bytes from the compressed file.\n   If the input file was not in gzip format, gzread copies the given number\n   of bytes into the buffer.\n     gzread returns the number of uncompressed bytes actually read (0 for\n   end of file, -1 for error). */\n\nZEXTERN int ZEXPORT    gzwrite OF((gzFile file, \n                   const voidp buf, unsigned len));\n/*\n     Writes the given number of uncompressed bytes into the compressed file.\n   gzwrite returns the number of uncompressed bytes actually written\n   (0 in case of error).\n*/\n\nZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));\n/*\n     Converts, formats, and writes the args to the compressed file under\n   control of the format string, as in fprintf. gzprintf returns the number of\n   uncompressed bytes actually written (0 in case of error).\n*/\n\nZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));\n/*\n      Writes the given null-terminated string to the compressed file, excluding\n   the terminating null character.\n      gzputs returns the number of characters written, or -1 in case of error.\n*/\n\nZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));\n/*\n      Reads bytes from the compressed file until len-1 characters are read, or\n   a newline character is read and transferred to buf, or an end-of-file\n   condition is encountered.  The string is then terminated with a null\n   character.\n      gzgets returns buf, or Z_NULL in case of error.\n*/\n\nZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));\n/*\n      Writes c, converted to an unsigned char, into the compressed file.\n   gzputc returns the value that was written, or -1 in case of error.\n*/\n\nZEXTERN int ZEXPORT    gzgetc OF((gzFile file));\n/*\n      Reads one byte from the compressed file. gzgetc returns this byte\n   or -1 in case of end of file or error.\n*/\n\nZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));\n/*\n     Flushes all pending output into the compressed file. The parameter\n   flush is as in the deflate() function. The return value is the zlib\n   error number (see function gzerror below). gzflush returns Z_OK if\n   the flush parameter is Z_FINISH and all output could be flushed.\n     gzflush should be called only when strictly necessary because it can\n   degrade compression.\n*/\n\nZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,\n                      z_off_t offset, int whence));\n/* \n      Sets the starting position for the next gzread or gzwrite on the\n   given compressed file. The offset represents a number of bytes in the\n   uncompressed data stream. The whence parameter is defined as in lseek(2);\n   the value SEEK_END is not supported.\n     If the file is opened for reading, this function is emulated but can be\n   extremely slow. If the file is opened for writing, only forward seeks are\n   supported; gzseek then compresses a sequence of zeroes up to the new\n   starting position.\n\n      gzseek returns the resulting offset location as measured in bytes from\n   the beginning of the uncompressed stream, or -1 in case of error, in\n   particular if the file is opened for writing and the new starting position\n   would be before the current position.\n*/\n\nZEXTERN int ZEXPORT    gzrewind OF((gzFile file));\n/*\n     Rewinds the given file. This function is supported only for reading.\n\n   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)\n*/\n\nZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));\n/*\n     Returns the starting position for the next gzread or gzwrite on the\n   given compressed file. This position represents a number of bytes in the\n   uncompressed data stream.\n\n   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)\n*/\n\nZEXTERN int ZEXPORT gzeof OF((gzFile file));\n/*\n     Returns 1 when EOF has previously been detected reading the given\n   input stream, otherwise zero.\n*/\n\nZEXTERN int ZEXPORT    gzclose OF((gzFile file));\n/*\n     Flushes all pending output if necessary, closes the compressed file\n   and deallocates all the (de)compression state. The return value is the zlib\n   error number (see function gzerror below).\n*/\n\nZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));\n/*\n     Returns the error message for the last error which occurred on the\n   given compressed file. errnum is set to zlib error number. If an\n   error occurred in the file system and not in the compression library,\n   errnum is set to Z_ERRNO and the application may consult errno\n   to get the exact error code.\n*/\n\n                        /* checksum functions */\n\n/*\n     These functions are not related to compression but are exported\n   anyway because they might be useful in applications using the\n   compression library.\n*/\n\nZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));\n\n/*\n     Update a running Adler-32 checksum with the bytes buf[0..len-1] and\n   return the updated checksum. If buf is NULL, this function returns\n   the required initial value for the checksum.\n   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed\n   much faster. Usage example:\n\n     uLong adler = adler32(0L, Z_NULL, 0);\n\n     while (read_buffer(buffer, length) != EOF) {\n       adler = adler32(adler, buffer, length);\n     }\n     if (adler != original_adler) error();\n*/\n\nZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));\n/*\n     Update a running crc with the bytes buf[0..len-1] and return the updated\n   crc. If buf is NULL, this function returns the required initial value\n   for the crc. Pre- and post-conditioning (one's complement) is performed\n   within this function so it shouldn't be done by the application.\n   Usage example:\n\n     uLong crc = crc32(0L, Z_NULL, 0);\n\n     while (read_buffer(buffer, length) != EOF) {\n       crc = crc32(crc, buffer, length);\n     }\n     if (crc != original_crc) error();\n*/\n\n\n                        /* various hacks, don't look :) */\n\n/* deflateInit and inflateInit are macros to allow checking the zlib version\n * and the compiler's view of z_stream:\n */\nZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,\n                                     const char *version, int stream_size));\nZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,\n                                     const char *version, int stream_size));\nZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,\n                                      int windowBits, int memLevel,\n                                      int strategy, const char *version,\n                                      int stream_size));\nZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,\n                                      const char *version, int stream_size));\n#define deflateInit(strm, level) \\\n        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))\n#define inflateInit(strm) \\\n        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))\n#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \\\n        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\\\n                      (strategy),           ZLIB_VERSION, sizeof(z_stream))\n#define inflateInit2(strm, windowBits) \\\n        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))\n\n\n#if !defined(_Z_UTIL_H) &amp;&amp; !defined(NO_DUMMY_DECL)\n    struct internal_state {int dummy;}; /* hack for buggy compilers */\n#endif\n\nZEXTERN const char   * ZEXPORT zError           OF((int err));\nZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));\nZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* _ZLIB_H */\n</code></pre>"},{"location":"GGPOUE4/dir_85b7962d70ed8e910f117d16fb4825fd/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public","text":"<p>FileList &gt; GGPOUE4 &gt; Public</p>"},{"location":"GGPOUE4/dir_85b7962d70ed8e910f117d16fb4825fd/#files","title":"Files","text":"Type Name file GGPOGameInstance.h file GGPOUE4.h"},{"location":"GGPOUE4/dir_85b7962d70ed8e910f117d16fb4825fd/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/</code></p>"},{"location":"GGPOUE4/dir_a7503a859c0cbfef62dfa39920604457/","title":"Dir C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include","text":"<p>FileList &gt; GGPOUE4 &gt; Public &gt; include</p>"},{"location":"GGPOUE4/dir_a7503a859c0cbfef62dfa39920604457/#files","title":"Files","text":"Type Name file connection_manager.h file ggponet.cpp file ggponet.h <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/</code></p>"},{"location":"GGPOUE4/connection__manager_8h/","title":"File connection_manager.h","text":"<p>FileList &gt; GGPOUE4 &gt; Public &gt; include &gt; connection_manager.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"../../Private/types.h\"</code></li> </ul>"},{"location":"GGPOUE4/connection__manager_8h/#classes","title":"Classes","text":"Type Name class ConnectionInfo class ConnectionManager <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/connection_manager.h</code></p>"},{"location":"GGPOUE4/connection__manager_8h_source/","title":"File connection_manager.h","text":"<p>File List &gt; GGPOUE4 &gt; Public &gt; include &gt; connection_manager.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifndef _CONNECTION_MANAGER_H\n#define _CONNECTION_MANAGER_H\n\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include \"../../Private/types.h\"\n\nclass ConnectionInfo {\npublic:\n    ConnectionInfo() {}\n    virtual ~ConnectionInfo() {\n    }\n    virtual std::string ToString() = 0;\n};\n\nclass GGPOUE4_API ConnectionManager {\npublic:\n    ConnectionManager() : _id_to_issue(0) {}\n\n    virtual ~ConnectionManager();\n\n    virtual int SendTo(const char* buffer, int len, int flags, int connection_id) = 0;\n\n    virtual int RecvFrom(char* buffer, int len, int flags, int* connection_id) = 0;\n\n    virtual int ResetManager() {\n        _connection_map.clear();\n        return 0;\n    }\n\n    virtual std::string ToString(int connection_id);\n\n    void Log(const char* fmt, ...);\n\nprotected:\n    int AddConnection(std::shared_ptr&lt;ConnectionInfo&gt; info) {\n        _connection_map.insert({_id_to_issue, info});\n        return _id_to_issue++;\n    }\n\n    int _id_to_issue;\n    std::map &lt;int, std::shared_ptr&lt;ConnectionInfo&gt;&gt; _connection_map;\n};\n\n#if defined(_WINDOWS)\nclass UPDInfo : public ConnectionInfo   {\npublic:\n    UPDInfo(const char* ip_address, uint16 port);\n\n    sockaddr_in addr;\n\n    ~UPDInfo() {\n    }\n\n    virtual std::string ToString();\n};\n\nclass GGPOUE4_API UDPConnectionManager : public ConnectionManager {\n\npublic:\n    UDPConnectionManager();\n    virtual ~UDPConnectionManager();\n\n    virtual int SendTo(const char* buffer, int len, int flags, int connection_id);\n\n    virtual int RecvFrom(char* buffer, int len, int flags, int* connection_id);\n\n    int AddConnection(const char* ip_address, uint16 port);\n\n    void Init(uint16 port);\n\n    int FindIDFromIP(sockaddr_in* sockaddr);\n\nprotected:\n    std::shared_ptr&lt;ConnectionInfo&gt; BuildConnectionInfo(const char* ip_address, uint16 port);\n\n    sockaddr_in _peer_addr;\n\n    SOCKET _socket;\n\n};\n#endif\n\n\n#endif\n</code></pre>"},{"location":"GGPOUE4/ggponet_8cpp/","title":"File ggponet.cpp","text":"<p>FileList &gt; GGPOUE4 &gt; Public &gt; include &gt; ggponet.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"ggponet.h\"</code></li> <li><code>#include \"UObject/UObjectGlobals.h\"</code></li> </ul>"},{"location":"GGPOUE4/ggponet_8cpp/#macros","title":"Macros","text":"Type Name define ARRAYSIZEOF (a) <code>sizeof(a) / sizeof(a[0])</code>"},{"location":"GGPOUE4/ggponet_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/ggponet_8cpp/#define-arraysizeof","title":"define ARRAYSIZEOF","text":"<pre><code>#define ARRAYSIZEOF (\n    a\n) `sizeof(a) / sizeof(a[0])`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/ggponet.cpp</code></p>"},{"location":"GGPOUE4/ggponet_8cpp_source/","title":"File ggponet.cpp","text":"<p>File List &gt; GGPOUE4 &gt; Public &gt; include &gt; ggponet.cpp</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#include \"ggponet.h\"\n#include \"UObject/UObjectGlobals.h\"\n\n#define ARRAYSIZEOF(a) sizeof(a) / sizeof(a[0])\n\n//UGGPONetworkAddress\n\nUGGPONetworkAddress* UGGPONetworkAddress::CreateNetworkAddress(UObject* Outer, const FName Name, const FString Address)\n{\n    UGGPONetworkAddress* Result = NewObject&lt;UGGPONetworkAddress&gt;(Outer, Name);\n    // Same type, apparently?\n    const wchar_t* address = (wchar_t*)*Address;\n\n    wchar_t WideIpBuffer[128];\n    uint32 WideIpBufferSize = (uint32)ARRAYSIZEOF(WideIpBuffer);\n    // Check and get port\n    if (swscanf(address, L\"%[^:]:%hd\", WideIpBuffer, &amp;Result-&gt;Port) != 2) {\n        Result-&gt;bValidAddress = false;\n    }\n    else\n    {\n        // Get address\n#ifdef _WIN32\n        wcstombs_s(nullptr, Result-&gt;IpAddress, ARRAYSIZEOF(Result-&gt;IpAddress), WideIpBuffer, _TRUNCATE);\n#else\n        // FIXME: Implement this case.\n#endif\n    }\n\n    return Result;\n}\nUGGPONetworkAddress* UGGPONetworkAddress::CreateLocalAddress(UObject* Outer, const FName Name, int32 LocalPort)\n{\n    UGGPONetworkAddress* Result = NewObject&lt;UGGPONetworkAddress&gt;(Outer, Name);\n\n    Result-&gt;bValidAddress = true;\n    Result-&gt;Port = (uint16)LocalPort;\n    strcpy(Result-&gt;IpAddress, \"127.0.0.1\");\n\n    return Result;\n}\n\nvoid UGGPONetworkAddress::GetIpAddress(char OutAddress[32]) const\n{\n    std::memcpy(OutAddress, IpAddress, sizeof(IpAddress));\n}\n\nbool UGGPONetworkAddress::IsValidAddress() const\n{\n    return bValidAddress;\n}\nFString UGGPONetworkAddress::GetIpAddressString() const\n{\n    auto address = FString(ANSI_TO_TCHAR(IpAddress));\n    return address;\n}\nint32 UGGPONetworkAddress::GetPort() const\n{\n    return Port;\n}\n\nbool UGGPONetworkAddress::IsSameAddress(const UGGPONetworkAddress* Other) const\n{\n    if (bValidAddress != Other-&gt;bValidAddress)\n        return false;\n    if (!std::equal(std::begin(IpAddress), std::end(IpAddress), std::begin(Other-&gt;IpAddress)))\n        return false;\n    if (Port != Other-&gt;Port)\n        return false;\n\n    return true;\n}\n\n// UGGPONetwork\n\nUGGPONetwork* UGGPONetwork::CreateNetwork(UObject* Outer, const FName Name, int32 NumPlayers, int32 PlayerIndex, int32 LocalPort, TArray&lt;FString&gt; RemoteAddresses)\n{\n    UGGPONetwork* Result = NewObject&lt;UGGPONetwork&gt;(Outer, Name);\n\n    Result-&gt;LocalPlayerIndex = PlayerIndex - 1;\n    int32 remoteIndex = 0;\n    for (int32 i = 0; i &lt; NumPlayers; i++)\n    {\n        // Only the port matters for local player\n        if (i == Result-&gt;LocalPlayerIndex)\n        {\n            // Create a GGPO Network Address and add to the addresses\n            UGGPONetworkAddress* address = UGGPONetworkAddress::CreateLocalAddress(\n                Outer,\n                FName(FString::Printf(TEXT(\"P%dIPAddress\"), i + 1)),\n                LocalPort);\n            Result-&gt;Addresses.Add(address);\n        }\n        else\n        {\n            // If we ran out of remote addresses, clear the addresses and break\n            if (remoteIndex &gt;= RemoteAddresses.Num())\n            {\n                Result-&gt;Addresses.Empty();\n                break;\n            }\n\n            // Create a GGPO Network Address and add to the addresses\n            UGGPONetworkAddress* address = UGGPONetworkAddress::CreateNetworkAddress(\n                Outer,\n                FName(FString::Printf(TEXT(\"P%dIPAddress\"), i + 1)),\n                RemoteAddresses[remoteIndex]);\n            Result-&gt;Addresses.Add(address);\n            remoteIndex++;\n        }\n    }\n\n    return Result;\n}\n\nbool UGGPONetwork::AllValidAddresses() const\n{\n    // If there are no players, this isn't valid\n    if (Addresses.Num() == 0)\n        return false;\n\n    for (int32 i = 0; i &lt; Addresses.Num(); i++)\n    {\n        // If an address is invalid, return false\n        UGGPONetworkAddress* address = Addresses[i];\n        if (!address-&gt;IsValidAddress())\n            return false;\n    }\n\n    return AllUniqueAddresses();\n}\nbool UGGPONetwork::AllUniqueAddresses() const\n{\n    for (int32 i = 0; i &lt; Addresses.Num(); i++)\n    {\n        for (int32 j = i + 1; j &lt; Addresses.Num(); j++)\n        {\n            // If the address is the same, return false\n            if (Addresses[i]-&gt;IsSameAddress(Addresses[j]))\n                return false;\n        }\n    }\n\n    return true;\n}\n\nUGGPONetworkAddress* UGGPONetwork::GetAddress(int32 Index) const\n{\n    if (Index &lt; 0 || Index &gt;= Addresses.Num())\n        return nullptr;\n\n    return Addresses[Index];\n}\nint32 UGGPONetwork::NumPlayers() const\n{\n    return Addresses.Num();\n}\nint32 UGGPONetwork::GetPlayerIndex() const\n{\n    return LocalPlayerIndex;\n}\nint32 UGGPONetwork::GetLocalPort() const\n{\n    // Just in case\n    if (LocalPlayerIndex &lt;= -1)\n        return 7000;\n\n    return Addresses[LocalPlayerIndex]-&gt;GetPort();\n}\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/","title":"File ggponet.h","text":"<p>FileList &gt; GGPOUE4 &gt; Public &gt; include &gt; ggponet.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include &lt;stdarg.h&gt;</code></li> <li><code>#include \"connection_manager.h\"</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include \"ggponet.generated.h\"</code></li> </ul>"},{"location":"GGPOUE4/ggponet_8h/#classes","title":"Classes","text":"Type Name struct FGGPONetworkInfo struct FGGPONetworkStats struct FGGPOSyncInfo struct GGPOEvent struct GGPOLocalEndpoint class GGPONet struct GGPOPlayer struct GGPOSessionCallbacks class UGGPONetwork class UGGPONetworkAddress"},{"location":"GGPOUE4/ggponet_8h/#public-types","title":"Public Types","text":"Type Name enum GGPOErrorCode enum GGPOEventCode typedef struct GGPOLocalEndpoint GGPOLocalEndpoint typedef struct GGPOPlayer GGPOPlayer typedef int32 GGPOPlayerHandle enum GGPOPlayerType typedef struct GGPOSession GGPOSession typedef long long ggpo_milliseconds_t"},{"location":"GGPOUE4/ggponet_8h/#macros","title":"Macros","text":"Type Name define GGPONET_CONVENTION <code>\\_\\_cdecl</code> define GGPO_API define GGPO_ERRORLIST <code>/* multi line expression */</code> define GGPO_ERRORLIST_ENTRY (name, value) <code>name = value,</code> define GGPO_INVALID_HANDLE <code>(-1)</code> define GGPO_MAX_PLAYERS <code>4</code> define GGPO_MAX_PREDICTION_FRAMES <code>8</code> define GGPO_MAX_SPECTATORS <code>32</code> define GGPO_SPECTATOR_INPUT_INTERVAL <code>4</code> define GGPO_SUCCEEDED (result) <code>((result) == GGPO\\_ERRORCODE\\_SUCCESS)</code>"},{"location":"GGPOUE4/ggponet_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"GGPOUE4/ggponet_8h/#enum-ggpoerrorcode","title":"enum GGPOErrorCode","text":"<pre><code>enum GGPOErrorCode {\n    GGPO_ERRORLIST\n};\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#enum-ggpoeventcode","title":"enum GGPOEventCode","text":"<pre><code>enum GGPOEventCode {\n    GGPO_EVENTCODE_CONNECTED_TO_PEER = 1000,\n    GGPO_EVENTCODE_SYNCHRONIZING_WITH_PEER = 1001,\n    GGPO_EVENTCODE_SYNCHRONIZED_WITH_PEER = 1002,\n    GGPO_EVENTCODE_RUNNING = 1003,\n    GGPO_EVENTCODE_DISCONNECTED_FROM_PEER = 1004,\n    GGPO_EVENTCODE_TIMESYNC = 1005,\n    GGPO_EVENTCODE_CONNECTION_INTERRUPTED = 1006,\n    GGPO_EVENTCODE_CONNECTION_RESUMED = 1007,\n    GGPO_EVENTCODE_TIMESYNC_BEHIND = 1008\n};\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#typedef-ggpolocalendpoint","title":"typedef GGPOLocalEndpoint","text":"<pre><code>typedef struct GGPOLocalEndpoint GGPOLocalEndpoint;\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#typedef-ggpoplayer","title":"typedef GGPOPlayer","text":"<pre><code>typedef struct GGPOPlayer GGPOPlayer;\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#typedef-ggpoplayerhandle","title":"typedef GGPOPlayerHandle","text":"<pre><code>typedef int32 GGPOPlayerHandle;\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#enum-ggpoplayertype","title":"enum GGPOPlayerType","text":"<pre><code>enum GGPOPlayerType {\n    GGPO_PLAYERTYPE_LOCAL,\n    GGPO_PLAYERTYPE_REMOTE,\n    GGPO_PLAYERTYPE_SPECTATOR\n};\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#typedef-ggposession","title":"typedef GGPOSession","text":"<pre><code>typedef struct GGPOSession GGPOSession;\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#typedef-ggpo_milliseconds_t","title":"typedef ggpo_milliseconds_t","text":"<pre><code>typedef long long ggpo_milliseconds_t;\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"GGPOUE4/ggponet_8h/#define-ggponet_convention","title":"define GGPONET_CONVENTION","text":"<pre><code>#define GGPONET_CONVENTION `__cdecl`\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#define-ggpo_api","title":"define GGPO_API","text":"<pre><code>#define GGPO_API \n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#define-ggpo_errorlist","title":"define GGPO_ERRORLIST","text":"<pre><code>#define GGPO_ERRORLIST `/* multi line expression */`\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#define-ggpo_errorlist_entry","title":"define GGPO_ERRORLIST_ENTRY","text":"<pre><code>#define GGPO_ERRORLIST_ENTRY (\n    name,\n    value\n) `name = value,`\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#define-ggpo_invalid_handle","title":"define GGPO_INVALID_HANDLE","text":"<pre><code>#define GGPO_INVALID_HANDLE `(-1)`\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#define-ggpo_max_players","title":"define GGPO_MAX_PLAYERS","text":"<pre><code>#define GGPO_MAX_PLAYERS `4`\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#define-ggpo_max_prediction_frames","title":"define GGPO_MAX_PREDICTION_FRAMES","text":"<pre><code>#define GGPO_MAX_PREDICTION_FRAMES `8`\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#define-ggpo_max_spectators","title":"define GGPO_MAX_SPECTATORS","text":"<pre><code>#define GGPO_MAX_SPECTATORS `32`\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#define-ggpo_spectator_input_interval","title":"define GGPO_SPECTATOR_INPUT_INTERVAL","text":"<pre><code>#define GGPO_SPECTATOR_INPUT_INTERVAL `4`\n</code></pre>"},{"location":"GGPOUE4/ggponet_8h/#define-ggpo_succeeded","title":"define GGPO_SUCCEEDED","text":"<pre><code>#define GGPO_SUCCEEDED (\n    result\n) `((result) == GGPO_ERRORCODE_SUCCESS)`\n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/include/ggponet.h</code></p>"},{"location":"GGPOUE4/ggponet_8h_source/","title":"File ggponet.h","text":"<p>File List &gt; GGPOUE4 &gt; Public &gt; include &gt; ggponet.h</p> <p>Go to the documentation of this file</p> <pre><code>/* -----------------------------------------------------------------------\n * GGPO.net (http://ggpo.net)  -  Copyright 2009 GroundStorm Studios, LLC.\n *\n * Use of this software is governed by the MIT license that can be found\n * in the LICENSE file.\n */\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include &lt;stdarg.h&gt;\n#include \"connection_manager.h\"\n#include &lt;functional&gt;\n#include \"ggponet.generated.h\"\n\ntypedef enum\n{\n    GGPO_PLAYERTYPE_LOCAL,\n    GGPO_PLAYERTYPE_REMOTE,\n    GGPO_PLAYERTYPE_SPECTATOR,\n} GGPOPlayerType;\n\n/*\n * The GGPONetworkStats function contains some statistics about the current\n * session.\n *\n * network.send_queue_len - The length of the queue containing UDP packets\n * which have not yet been acknowledged by the end client.  The length of\n * the send queue is a rough indication of the quality of the connection.\n * The longer the send queue, the higher the round-trip time between the\n * clients.  The send queue will also be longer than usual during high\n * packet loss situations.\n *\n * network.recv_queue_len - The number of inputs currently buffered by the\n * GGPO.net network layer which have yet to be validated.  The length of\n * the prediction queue is roughly equal to the current frame number\n * minus the frame number of the last packet in the remote queue.\n *\n * network.ping - The roundtrip packet transmission time as calcuated\n * by GGPO.net.  This will be roughly equal to the actual round trip\n * packet transmission time + 2 the interval at which you call ggpo_idle\n * or ggpo_advance_frame.\n *\n * network.kbps_sent - The estimated bandwidth used between the two\n * clients, in kilobits per second.\n *\n * timesync.local_frames_behind - The number of frames GGPO.net calculates\n * that the local client is behind the remote client at this instant in\n * time.  For example, if at this instant the current game client is running\n * frame 1002 and the remote game client is running frame 1009, this value\n * will mostly likely roughly equal 7.\n *\n * timesync.remote_frames_behind - The same as local_frames_behind, but\n * calculated from the perspective of the remote player.\n *\n */\nUSTRUCT(BlueprintType)\nstruct FGGPONetworkInfo\n{\n    GENERATED_USTRUCT_BODY()\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 send_queue_len;\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 recv_queue_len;\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 ping;\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 kbps_sent;\n};\n\nUSTRUCT(BlueprintType)\nstruct FGGPOSyncInfo\n{\n    GENERATED_USTRUCT_BODY()\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 local_frames_behind;\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    int32 remote_frames_behind;\n};\n\nUSTRUCT(BlueprintType)\nstruct FGGPONetworkStats\n{\n    GENERATED_USTRUCT_BODY()\n\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    FGGPONetworkInfo network;\n    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)\n    FGGPOSyncInfo timesync;\n};\n\nUCLASS(Blueprintable)\nclass GGPOUE4_API UGGPONetworkAddress : public UObject\n{\n    GENERATED_BODY()\n\nprivate:\n    UPROPERTY()\n    bool bValidAddress = true;\n    char IpAddress[32];\n    uint16 Port = 0;\n\npublic:\n    UGGPONetworkAddress()\n    {\n    }\n\n    UFUNCTION(BlueprintCallable, Category = \"GGPO\")\n    static UGGPONetworkAddress* CreateNetworkAddress(UObject* Outer, const FName Name, const FString Address);\n    UFUNCTION(BlueprintCallable, Category = \"GGPO\")\n    static UGGPONetworkAddress* CreateLocalAddress(UObject* Outer, const FName Name, int32 LocalPort);\n\n    void GetIpAddress(char OutAddress[32]) const;\n\n    UFUNCTION(BlueprintCallable, BlueprintPure, Category = \"GGPO\")\n    bool IsValidAddress() const;\n    UFUNCTION(BlueprintCallable, BlueprintPure, Category = \"GGPO\")\n    FString GetIpAddressString() const;\n    UFUNCTION(BlueprintCallable, BlueprintPure, Category = \"GGPO\")\n    int32 GetPort() const;\n\n    UFUNCTION(BlueprintCallable, BlueprintPure, Category = \"GGPO\")\n    bool IsSameAddress(const UGGPONetworkAddress* Other) const;\n};\n\nUCLASS(Blueprintable)\nclass GGPOUE4_API UGGPONetwork : public UObject\n{\n    GENERATED_BODY()\n\nprivate:\n    UPROPERTY()\n    int32 LocalPlayerIndex = -1;\n    UPROPERTY()\n    TArray&lt;UGGPONetworkAddress*&gt; Addresses;\n\npublic:\n    UGGPONetwork()\n    {\n    }\n\n    UFUNCTION(BlueprintCallable, Category = \"GGPO\")\n    static UGGPONetwork* CreateNetwork(UObject* Outer, const FName Name, int32 NumPlayers, int32 PlayerIndex,\n                                       int32 LocalPort, TArray&lt;FString&gt; RemoteAddresses);\n\n    UFUNCTION(BlueprintCallable, BlueprintPure, Category = \"GGPO\")\n    bool AllValidAddresses() const;\n    UFUNCTION(BlueprintCallable, BlueprintPure, Category = \"GGPO\")\n    bool AllUniqueAddresses() const;\n\n    UFUNCTION(BlueprintCallable, BlueprintPure, Category = \"GGPO\")\n    UGGPONetworkAddress* GetAddress(int32 Index) const;\n    UFUNCTION(BlueprintCallable, BlueprintPure, Category = \"GGPO\")\n    int32 NumPlayers() const;\n    UFUNCTION(BlueprintCallable, BlueprintPure, Category = \"GGPO\")\n    int32 GetPlayerIndex() const;\n    UFUNCTION(BlueprintCallable, BlueprintPure, Category = \"GGPO\")\n    int32 GetLocalPort() const;\n};\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n// On windows, export at build time and import at runtime.\n// ELF systems don't need an explicit export/import.\n#ifdef _WIN32\n#  if defined(GGPO_SHARED_LIB)\n#  ifdef GGPO_SDK_EXPORT\n#       define GGPO_API __declspec(dllexport)\n#     else\n#       define GGPO_API __declspec(dllimport)\n#     endif\n#  else\n#     define GGPO_API\n#  endif\n#else\n#  define GGPO_API\n#endif\n\n#define GGPO_MAX_PLAYERS                  4\n#define GGPO_MAX_PREDICTION_FRAMES        8\n#define GGPO_MAX_SPECTATORS              32\n\n#define GGPO_SPECTATOR_INPUT_INTERVAL     4\n\ntypedef struct GGPOSession GGPOSession;\n\ntypedef int32 GGPOPlayerHandle;\n\n/*\n * The GGPOPlayer structure used to describe players in ggpo_add_player\n *\n * size: Should be set to the sizeof(GGPOPlayer)\n *\n * type: One of the GGPOPlayerType values describing how inputs should be handled\n *       Local players must have their inputs updated every frame via\n *       ggpo_add_local_inputs.  Remote players values will come over the\n *       network.\n *\n * player_num: The player number.  Should be between 1 and the number of players\n *       In the game (e.g. in a 2 player game, either 1 or 2).\n *\n * If type == GGPOPlayerType::REMOTE:\n * \n * u.remote.ip_address:  The ip address of the ggpo session which will host this\n *       player.\n *\n * u.remote.port: The port where udp packets should be sent to reach this player.\n *       All the local inputs for this session will be sent to this player at\n *       ip_address:port.\n *\n */\n\ntypedef struct GGPOPlayer\n{\n    int size;\n    GGPOPlayerType type;\n    int player_num;\n    int connection_id;\n} GGPOPlayer;\n\ntypedef struct GGPOLocalEndpoint\n{\n    int player_num;\n} GGPOLocalEndpoint;\n\n\n#define GGPO_ERRORLIST                                               \\\n   GGPO_ERRORLIST_ENTRY(GGPO_OK,                               0)    \\\n   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_SUCCESS,                0)    \\\n   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_GENERAL_FAILURE,        -1)   \\\n   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_INVALID_SESSION,        1)    \\\n   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_INVALID_PLAYER_HANDLE,  2)    \\\n   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_PLAYER_OUT_OF_RANGE,    3)    \\\n   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_PREDICTION_THRESHOLD,   4)    \\\n   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_UNSUPPORTED,            5)    \\\n   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_NOT_SYNCHRONIZED,       6)    \\\n   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_IN_ROLLBACK,            7)    \\\n   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_INPUT_DROPPED,          8)    \\\n   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_PLAYER_DISCONNECTED,    9)    \\\n   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_TOO_MANY_SPECTATORS,   10)    \\\n   GGPO_ERRORLIST_ENTRY(GGPO_ERRORCODE_INVALID_REQUEST,       11)\n\n#define GGPO_ERRORLIST_ENTRY(name, value)       name = value,\n\ntypedef enum\n{\n    GGPO_ERRORLIST\n} GGPOErrorCode;\n#undef GGPO_ERRORLIST_ENTRY\n\n#define GGPO_SUCCEEDED(result)      ((result) == GGPO_ERRORCODE_SUCCESS)\n\n\n#define GGPO_INVALID_HANDLE      (-1)\n\n\n/*\n * The GGPOEventCode enumeration describes what type of event just happened.\n *\n * GGPO_EVENTCODE_CONNECTED_TO_PEER - Handshake with the game running on the\n * other side of the network has been completed.\n * \n * GGPO_EVENTCODE_SYNCHRONIZING_WITH_PEER - Beginning the synchronization\n * process with the client on the other end of the networking.  The count\n * and total fields in the u.synchronizing struct of the GGPOEvent\n * object indicate progress.\n *\n * GGPO_EVENTCODE_SYNCHRONIZED_WITH_PEER - The synchronziation with this\n * peer has finished.\n *\n * GGPO_EVENTCODE_RUNNING - All the clients have synchronized.  You may begin\n * sending inputs with ggpo_synchronize_inputs.\n *\n * GGPO_EVENTCODE_DISCONNECTED_FROM_PEER - The network connection on \n * the other end of the network has closed.\n *\n * GGPO_EVENTCODE_TIMESYNC - The time synchronziation code has determined\n * that this client is too far ahead of the other one and should slow\n * down to ensure fairness.  The u.timesync.frames_ahead parameter in\n * the GGPOEvent object indicates how many frames the client is.\n *\n */\ntypedef enum\n{\n    GGPO_EVENTCODE_CONNECTED_TO_PEER = 1000,\n    GGPO_EVENTCODE_SYNCHRONIZING_WITH_PEER = 1001,\n    GGPO_EVENTCODE_SYNCHRONIZED_WITH_PEER = 1002,\n    GGPO_EVENTCODE_RUNNING = 1003,\n    GGPO_EVENTCODE_DISCONNECTED_FROM_PEER = 1004,\n    GGPO_EVENTCODE_TIMESYNC = 1005,\n    GGPO_EVENTCODE_CONNECTION_INTERRUPTED = 1006,\n    GGPO_EVENTCODE_CONNECTION_RESUMED = 1007,\n    GGPO_EVENTCODE_TIMESYNC_BEHIND = 1008,\n} GGPOEventCode;\n\n/*\n * The GGPOEvent structure contains an asynchronous event notification sent\n * by the on_event callback.  See GGPOEventCode, above, for a detailed\n * explanation of each event.\n */\ntypedef struct\n{\n    GGPOEventCode code;\n\n    union\n    {\n        struct\n        {\n            GGPOPlayerHandle player;\n        } connected;\n\n        struct\n        {\n            GGPOPlayerHandle player;\n            int count;\n            int total;\n        } synchronizing;\n\n        struct\n        {\n            GGPOPlayerHandle player;\n        } synchronized;\n\n        struct\n        {\n            GGPOPlayerHandle player;\n        } disconnected;\n\n        struct\n        {\n            int frames_ahead;\n        } timesync;\n\n        struct\n        {\n            GGPOPlayerHandle player;\n            int disconnect_timeout;\n        } connection_interrupted;\n\n        struct\n        {\n            GGPOPlayerHandle player;\n        } connection_resumed;\n    } u;\n} GGPOEvent;\n\n\n// If C++11, use std::function instead of function pointers for GGPOSessionCallbacks\n#if __cplusplus &gt;= 201103L || (defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1900)\n\n// Close extern \"C\"\n};\n\n/*\n * The GGPOSessionCallbacks structure contains the callback functions that\n * your application must implement.  GGPO.net will periodically call these\n * functions during the game.  All callback functions must be implemented.\n */\nstruct GGPOSessionCallbacks\n{\n    /*\n     * begin_game callback - This callback has been deprecated.  You must\n     * implement it, but should ignore the 'game' parameter.\n     */\n    std::function&lt;bool(const char* game)&gt; begin_game;\n\n    /*\n     * save_game_state - The client should allocate a buffer, copy the\n     * entire contents of the current game state into it, and copy the\n     * length into the *len parameter.  Optionally, the client can compute\n     * a checksum of the data and store it in the *checksum argument.\n     */\n    std::function&lt;bool(unsigned char** buffer, int* len, int* checksum, int frame)&gt; save_game_state;\n\n    /*\n     * load_game_state - GGPO.net will call this function at the beginning\n     * of a rollback.  The buffer and len parameters contain a previously\n     * saved state returned from the save_game_state function.  The client\n     * should make the current game state match the state contained in the\n     * buffer.\n     */\n    std::function&lt;bool(unsigned char* buffer, int len)&gt; load_game_state;\n\n    /*\n     * log_game_state - Used in diagnostic testing.  The client should use\n     * the ggpo_log function to write the contents of the specified save\n     * state in a human readible form.\n     */\n    std::function&lt;bool(const char* filename, unsigned char* buffer, int len)&gt; log_game_state;\n\n    /*\n     * free_buffer - Frees a game state allocated in save_game_state.  You\n     * should deallocate the memory contained in the buffer.\n     */\n    std::function&lt;void(void* buffer)&gt; free_buffer;\n\n    /*\n     * advance_frame - Called during a rollback.  You should advance your game\n     * state by exactly one frame.  Before each frame, call ggpo_synchronize_input\n     * to retrieve the inputs you should use for that frame.  After each frame,\n     * you should call ggpo_advance_frame to notify GGPO.net that you're\n     * finished.\n     *\n     * The flags parameter is reserved.  It can safely be ignored at this time.\n     */\n    std::function&lt;bool(int flags)&gt; advance_frame;\n\n    /*\n     * on_event - Notification that something has happened.  See the GGPOEventCode\n     * structure above for more information.\n     */\n    std::function&lt;bool(GGPOEvent* info)&gt; on_event;\n};\n\nextern \"C\" {\n#else\n\n/*\n * The GGPOSessionCallbacks structure contains the callback functions that\n * your application must implement.  GGPO.net will periodically call these\n * functions during the game.  All callback functions must be implemented.\n */\n typedef struct {\n     /*\n      * begin_game callback - This callback has been deprecated.  You must\n      * implement it, but should ignore the 'game' parameter.\n      */\n     bool(__cdecl* begin_game)(const char* game);\n\n     /*\n      * save_game_state - The client should allocate a buffer, copy the\n      * entire contents of the current game state into it, and copy the\n      * length into the *len parameter.  Optionally, the client can compute\n      * a checksum of the data and store it in the *checksum argument.\n      */\n     bool(__cdecl* save_game_state)(unsigned char** buffer, int* len, int* checksum, int frame);\n\n     /*\n      * load_game_state - GGPO.net will call this function at the beginning\n      * of a rollback.  The buffer and len parameters contain a previously\n      * saved state returned from the save_game_state function.  The client\n      * should make the current game state match the state contained in the\n      * buffer.\n      */\n     bool(__cdecl* load_game_state)(unsigned char* buffer, int len);\n\n     /*\n      * log_game_state - Used in diagnostic testing.  The client should use\n      * the ggpo_log function to write the contents of the specified save\n      * state in a human readible form.\n      */\n     bool(__cdecl* log_game_state)(char* filename, unsigned char* buffer, int len);\n\n     /*\n      * free_buffer - Frees a game state allocated in save_game_state.  You\n      * should deallocate the memory contained in the buffer.\n      */\n     void(__cdecl* free_buffer)(void* buffer);\n\n     /*\n      * advance_frame - Called during a rollback.  You should advance your game\n      * state by exactly one frame.  Before each frame, call ggpo_synchronize_input\n      * to retrieve the inputs you should use for that frame.  After each frame,\n      * you should call ggpo_advance_frame to notify GGPO.net that you're\n      * finished.\n      *\n      * The flags parameter is reserved.  It can safely be ignored at this time.\n      */\n     bool(__cdecl* advance_frame)(int flags);\n\n     /*\n      * on_event - Notification that something has happened.  See the GGPOEventCode\n      * structure above for more information.\n      */\n     bool(__cdecl* on_event)(GGPOEvent* info);\n } GGPOSessionCallbacks;\n\n#endif\n\n\nclass GGPOUE4_API GGPONet\n{\npublic:\n    /*\n     * ggpo_start_session --\n     *\n     * Used to being a new GGPO.net session.  The ggpo object returned by ggpo_start_session\n     * uniquely identifies the state for this session and should be passed to all other\n     * functions.\n     *\n     * session - An out parameter to the new ggpo session object.\n     *\n     * cb - A GGPOSessionCallbacks structure which contains the callbacks you implement\n     * to help GGPO.net synchronize the two games.  You must implement all functions in\n     * cb, even if they do nothing but 'return true';\n     *\n     * game - The name of the game.  This is used internally for GGPO for logging purposes only.\n     *\n     * num_players - The number of players which will be in this game.  The number of players\n     * per session is fixed.  If you need to change the number of players or any player\n     * disconnects, you must start a new session.\n     *\n     * input_size - The size of the game inputs which will be passsed to ggpo_add_local_input.\n     *\n     * local_port - The port GGPO should bind to for UDP traffic.\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_start_session(GGPOSession** session,\n                                                             GGPOSessionCallbacks* cb,\n                                                             ConnectionManager* connection_manager,\n                                                             const char* game,\n                                                             int num_players,\n                                                             int input_size);\n\n\n    /*\n     * ggpo_add_player --\n     *\n     * Must be called for each player in the session (e.g. in a 3 player session, must\n     * be called 3 times).\n     *\n     * player - A GGPOPlayer struct used to describe the player.\n     *\n     * handle - An out parameter to a handle used to identify this player in the future.\n     * (e.g. in the on_event callbacks).\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_add_player(GGPOSession* session,\n                                                          GGPOPlayer* player,\n                                                          GGPOPlayerHandle* handle);\n\n\n    /*\n     * ggpo_start_synctest --\n     *\n     * Used to being a new GGPO.net sync test session.  During a sync test, every\n     * frame of execution is run twice: once in prediction mode and once again to\n     * verify the result of the prediction.  If the checksums of your save states\n     * do not match, the test is aborted.\n     *\n     * cb - A GGPOSessionCallbacks structure which contains the callbacks you implement\n     * to help GGPO.net synchronize the two games.  You must implement all functions in\n     * cb, even if they do nothing but 'return true';\n     *\n     * game - The name of the game.  This is used internally for GGPO for logging purposes only.\n     *\n     * num_players - The number of players which will be in this game.  The number of players\n     * per session is fixed.  If you need to change the number of players or any player\n     * disconnects, you must start a new session.\n     *\n     * input_size - The size of the game inputs which will be passsed to ggpo_add_local_input.\n     *\n     * frames - The number of frames to run before verifying the prediction.  The\n     * recommended value is 1.\n     *\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_start_synctest(GGPOSession** session,\n                                                              GGPOSessionCallbacks* cb,\n                                                              const char* game,\n                                                              int num_players,\n                                                              int input_size,\n                                                              int frames);\n\n\n    /*\n     * ggpo_start_spectating --\n     *\n     * Start a spectator session.\n     *\n     * cb - A GGPOSessionCallbacks structure which contains the callbacks you implement\n     * to help GGPO.net synchronize the two games.  You must implement all functions in\n     * cb, even if they do nothing but 'return true';\n     *\n     * game - The name of the game.  This is used internally for GGPO for logging purposes only.\n     *\n     * num_players - The number of players which will be in this game.  The number of players\n     * per session is fixed.  If you need to change the number of players or any player\n     * disconnects, you must start a new session.\n     *\n     * input_size - The size of the game inputs which will be passsed to ggpo_add_local_input.\n     *\n     * local_port - The port GGPO should bind to for UDP traffic.\n     *\n     * host_ip - The IP address of the host who will serve you the inputs for the game.  Any\n     * player partcipating in the session can serve as a host.\n     *\n     * host_port - The port of the session on the host\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_start_spectating(GGPOSession** session,\n                                                                GGPOSessionCallbacks* cb,\n                                                                ConnectionManager* connection_manager,\n                                                                const char* game,\n                                                                int num_players,\n                                                                int input_size,\n                                                                int connection_id);\n\n    /*\n     * ggpo_close_session --\n     * Used to close a session.  You must call ggpo_close_session to\n     * free the resources allocated in ggpo_start_session.\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_close_session(GGPOSession*);\n\n\n    /*\n     * ggpo_set_frame_delay --\n     *\n     * Change the amount of frames ggpo will delay local input.  Must be called\n     * before the first call to ggpo_synchronize_input.\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_set_frame_delay(GGPOSession*,\n                                                               GGPOPlayerHandle player,\n                                                               int frame_delay);\n\n    /*\n     * ggpo_idle --\n     * Should be called periodically by your application to give GGPO.net\n     * a chance to do some work.  Most packet transmissions and rollbacks occur\n     * in ggpo_idle.\n     *\n     * timeout - The amount of time GGPO.net is allowed to spend in this function,\n     * in milliseconds.\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_idle(GGPOSession*,\n                                                    int timeout);\n\n    /*\n     * ggpo_add_local_input --\n     *\n     * Used to notify GGPO.net of inputs that should be trasmitted to remote\n     * players.  ggpo_add_local_input must be called once every frame for\n     * all player of type GGPOPlayerType::LOCAL.\n     *\n     * player - The player handle returned for this player when you called\n     * ggpo_add_local_player.\n     *\n     * values - The controller inputs for this player.\n     *\n     * size - The size of the controller inputs.  This must be exactly equal to the\n     * size passed into ggpo_start_session.\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_add_local_input(GGPOSession*,\n                                                               GGPOPlayerHandle player,\n                                                               void* values,\n                                                               int size);\n\n    /*\n     * ggpo_synchronize_input --\n     *\n     * You should call ggpo_synchronize_input before every frame of execution,\n     * including those frames which happen during rollback.\n     *\n     * values - When the function returns, the values parameter will contain\n     * inputs for this frame for all players.  The values array must be at\n     * least (size * players) large.\n     *\n     * size - The size of the values array.\n     *\n     * disconnect_flags - Indicated whether the input in slot (1 &lt;&lt; flag) is\n     * valid.  If a player has disconnected, the input in the values array for\n     * that player will be zeroed and the i-th flag will be set.  For example,\n     * if only player 3 has disconnected, disconnect flags will be 8 (i.e. 1 &lt;&lt; 3).\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_synchronize_input(GGPOSession*,\n                                                                 void* values,\n                                                                 int size,\n                                                                 int* disconnect_flags);\n\n    /*\n     * ggpo_disconnect_player --\n     *\n     * Disconnects a remote player from a game.  Will return GGPO_ERRORCODE_PLAYER_DISCONNECTED\n     * if you try to disconnect a player who has already been disconnected.\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_disconnect_player(GGPOSession*,\n                                                                 GGPOPlayerHandle player);\n\n    /*\n     * ggpo_advance_frame --\n     *\n     * You should call ggpo_advance_frame to notify GGPO.net that you have\n     * advanced your gamestate by a single frame.  You should call this everytime\n     * you advance the gamestate by a frame, even during rollbacks.  GGPO.net\n     * may call your save_state callback before this function returns.\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_advance_frame(GGPOSession*);\n\n    /*\n     * ggpo_get_network_stats --\n     *\n     * Used to fetch some statistics about the quality of the network connection.\n     *\n     * player - The player handle returned from the ggpo_add_player function you used\n     * to add the remote player.\n     *\n     * stats - Out parameter to the network statistics.\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_get_network_stats(GGPOSession*,\n                                                                 GGPOPlayerHandle player,\n                                                                 FGGPONetworkStats* stats);\n\n\n    /*\n     * ggpo_set_disconnect_timeout --\n     *\n     * Sets the disconnect timeout.  The session will automatically disconnect\n     * from a remote peer if it has not received a packet in the timeout window.\n     * You will be notified of the disconnect via a GGPO_EVENTCODE_DISCONNECTED_FROM_PEER\n     * event.\n     *\n     * Setting a timeout value of 0 will disable automatic disconnects.\n     *\n     * timeout - The time in milliseconds to wait before disconnecting a peer.\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_set_disconnect_timeout(GGPOSession*,\n                                                                      int timeout);\n\n    /*\n     * ggpo_set_disconnect_notify_start --\n     *\n     * The time to wait before the first GGPO_EVENTCODE_NETWORK_INTERRUPTED timeout\n     * will be sent.\n     *\n     * timeout - The amount of time which needs to elapse without receiving a packet\n     *           before the GGPO_EVENTCODE_NETWORK_INTERRUPTED event is sent.\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_set_disconnect_notify_start(GGPOSession*,\n                                                                           int timeout);\n\n    /*\n     * ggpo_try_synchronize_local --\n     *\n     * Attempts to skip waiting for a synchronize message, if the session is single\n     * player with no spectators ie. completely local.\n     */\n    static GGPO_API GGPOErrorCode __cdecl ggpo_try_synchronize_local(GGPOSession* ggpo);\n};\n\ntypedef long long ggpo_milliseconds_t;\n#define GGPONET_CONVENTION __cdecl\n\n#ifdef __cplusplus\n};\n#endif\n</code></pre>"},{"location":"GGPOUE4/_g_g_p_o_game_instance_8h/","title":"File GGPOGameInstance.h","text":"<p>FileList &gt; GGPOUE4 &gt; Public &gt; GGPOGameInstance.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Engine/GameInstance.h\"</code></li> <li><code>#include \"GGPOGameInstance.generated.h\"</code></li> </ul>"},{"location":"GGPOUE4/_g_g_p_o_game_instance_8h/#classes","title":"Classes","text":"Type Name class UGGPOGameInstance <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/GGPOGameInstance.h</code></p>"},{"location":"GGPOUE4/_g_g_p_o_game_instance_8h_source/","title":"File GGPOGameInstance.h","text":"<p>File List &gt; GGPOUE4 &gt; Public &gt; GGPOGameInstance.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2020 BwdYeti.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Engine/GameInstance.h\"\n#include \"GGPOGameInstance.generated.h\"\n\n// Forward declarations\nclass UGGPONetwork;\n\nUCLASS()\nclass GGPOUE4_API UGGPOGameInstance : public UGameInstance\n{\n    GENERATED_BODY()\n\npublic:\n    UPROPERTY(EditAnywhere, BlueprintReadWrite)\n        UGGPONetwork* NetworkAddresses;\n\n    UFUNCTION(BlueprintCallable, Category = \"GGPO\")\n        void CreateNetwork(int32 NumPlayers, int32 PlayerIndex, int32 LocalPort, TArray&lt;FString&gt; RemoteAddresses);\n\n};\n</code></pre>"},{"location":"GGPOUE4/_g_g_p_o_u_e4_8h/","title":"File GGPOUE4.h","text":"<p>FileList &gt; GGPOUE4 &gt; Public &gt; GGPOUE4.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"CoreMinimal.h\"</code></li> <li><code>#include \"Modules/ModuleManager.h\"</code></li> </ul>"},{"location":"GGPOUE4/_g_g_p_o_u_e4_8h/#classes","title":"Classes","text":"Type Name class FGGPOUE4Module"},{"location":"GGPOUE4/_g_g_p_o_u_e4_8h/#public-functions","title":"Public Functions","text":"Type Name DECLARE_LOG_CATEGORY_EXTERN (GGPOLOG, Log, All)"},{"location":"GGPOUE4/_g_g_p_o_u_e4_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GGPOUE4/_g_g_p_o_u_e4_8h/#function-declare_log_category_extern","title":"function DECLARE_LOG_CATEGORY_EXTERN","text":"<pre><code>DECLARE_LOG_CATEGORY_EXTERN (\n    GGPOLOG,\n    Log,\n    All\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>C:/Users/wistf/Unreal Projects/NightSkyEngine/Plugins/NightSkyEngine/Source/GGPOUE4/Public/GGPOUE4.h</code></p>"},{"location":"GGPOUE4/_g_g_p_o_u_e4_8h_source/","title":"File GGPOUE4.h","text":"<p>File List &gt; GGPOUE4 &gt; Public &gt; GGPOUE4.h</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright Epic Games, Inc. All Rights Reserved.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"Modules/ModuleManager.h\"\n\nDECLARE_LOG_CATEGORY_EXTERN(GGPOLOG, Log, All);\n\nclass FGGPOUE4Module : public IModuleInterface\n{\npublic:\n\n    virtual void StartupModule() override;\n    virtual void ShutdownModule() override;\n};\n</code></pre>"},{"location":"GGPOUE4/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace neosmart </li> </ul>"},{"location":"GGPOUE4/classes/","title":"Class Index","text":""},{"location":"GGPOUE4/classes/#c","title":"c","text":"<ul> <li>Callbacks (Udp)</li> <li>Config (Sync)</li> <li>connect_status (UdpMsg)</li> <li>ConnectionInfo</li> <li>ConnectionManager</li> </ul>"},{"location":"GGPOUE4/classes/#e","title":"e","text":"<ul> <li>Event (Sync)</li> <li>Event (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/classes/#f","title":"f","text":"<ul> <li>FGGPONetworkInfo</li> <li>FGGPONetworkStats</li> <li>FGGPOSyncInfo</li> <li>FGGPOUE4Module</li> </ul>"},{"location":"GGPOUE4/classes/#g","title":"g","text":"<ul> <li>GameInput</li> <li>GGPOEvent</li> <li>GGPOLocalEndpoint</li> <li>GGPONet</li> <li>GGPOPlayer</li> <li>GGPOSession</li> <li>GGPOSessionCallbacks</li> </ul>"},{"location":"GGPOUE4/classes/#i","title":"i","text":"<ul> <li>InputQueue</li> <li>internal_state</li> <li>IPollSink</li> </ul>"},{"location":"GGPOUE4/classes/#n","title":"n","text":"<ul> <li>neosmart_event_t_ (neosmart)</li> <li>neosmart_wfmo_info_t_ (neosmart)</li> <li>neosmart_wfmo_t_ (neosmart)</li> </ul>"},{"location":"GGPOUE4/classes/#p","title":"p","text":"<ul> <li>Peer2PeerBackend</li> <li>Poll</li> <li>PollPeriodicSinkCb (Poll)</li> <li>PollSinkCb (Poll)</li> </ul>"},{"location":"GGPOUE4/classes/#q","title":"q","text":"<ul> <li>QueueEntry (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/classes/#r","title":"r","text":"<ul> <li>RingBuffer</li> </ul>"},{"location":"GGPOUE4/classes/#s","title":"s","text":"<ul> <li>SavedFrame (Sync)</li> <li>SavedInfo (SyncTestBackend)</li> <li>SavedState (Sync)</li> <li>SpectatorBackend</li> <li>StaticBuffer</li> <li>Stats (Udp)</li> <li>Stats (UdpProtocol)</li> <li>Sync</li> <li>SyncTestBackend</li> </ul>"},{"location":"GGPOUE4/classes/#t","title":"t","text":"<ul> <li>TimeSync</li> </ul>"},{"location":"GGPOUE4/classes/#u","title":"u","text":"<ul> <li>Udp</li> <li>UdpMsg</li> <li>UdpProtocol</li> <li>UGGPOGameInstance</li> <li>UGGPONetwork</li> <li>UGGPONetworkAddress</li> </ul>"},{"location":"GGPOUE4/classes/#z","title":"z","text":"<ul> <li>z_stream_s</li> </ul>"},{"location":"GGPOUE4/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class ConnectionInfo </li> <li>class ConnectionManager </li> <li>class GGPONet </li> <li>class IPollSink <ul> <li>class Peer2PeerBackend </li> <li>class SpectatorBackend </li> <li>class Udp </li> <li>class UdpProtocol </li> </ul> </li> <li>class InputQueue </li> <li>struct GGPOSession <ul> <li>class Peer2PeerBackend </li> <li>class SpectatorBackend </li> <li>class SyncTestBackend </li> </ul> </li> <li>struct Udp::Callbacks <ul> <li>class Peer2PeerBackend </li> <li>class SpectatorBackend </li> </ul> </li> <li>class Poll </li> <li>class RingBuffer </li> <li>class StaticBuffer </li> <li>class Sync </li> <li>class TimeSync </li> <li>struct FGGPONetworkInfo </li> <li>struct FGGPONetworkStats </li> <li>struct FGGPOSyncInfo </li> <li>struct GGPOEvent </li> <li>struct GGPOLocalEndpoint </li> <li>struct GGPOPlayer </li> <li>struct GGPOSessionCallbacks </li> <li>struct GameInput </li> <li>struct Poll::PollSinkCb <ul> <li>struct Poll::PollPeriodicSinkCb </li> </ul> </li> <li>struct Sync::Config </li> <li>struct Sync::Event </li> <li>struct Sync::SavedFrame </li> <li>struct Sync::SavedState </li> <li>struct SyncTestBackend::SavedInfo </li> <li>struct Udp::Stats </li> <li>struct UdpMsg </li> <li>struct UdpMsg::connect_status </li> <li>struct UdpProtocol::Event </li> <li>struct UdpProtocol::QueueEntry </li> <li>struct UdpProtocol::Stats </li> <li>struct internal_state </li> <li>struct neosmart::neosmart_event_t_ </li> <li>struct neosmart::neosmart_wfmo_info_t_ </li> <li>struct neosmart::neosmart_wfmo_t_ </li> <li>struct z_stream_s </li> <li>class IModuleInterface <ul> <li>class FGGPOUE4Module </li> </ul> </li> <li>class UGameInstance <ul> <li>class UGGPOGameInstance </li> </ul> </li> <li>class UObject <ul> <li>class UGGPONetwork </li> <li>class UGGPONetworkAddress </li> </ul> </li> </ul>"},{"location":"GGPOUE4/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"GGPOUE4/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"GGPOUE4/class_members/","title":"Class Members","text":""},{"location":"GGPOUE4/class_members/#a","title":"a","text":"<ul> <li>AddConnection (ConnectionManager)</li> <li>AddLocalInput (GGPOSession, Peer2PeerBackend, SpectatorBackend, Sync, SyncTestBackend)</li> <li>AddPlayer (GGPOSession, Peer2PeerBackend, SpectatorBackend, SyncTestBackend)</li> <li>AddDelayedInputToQueue (InputQueue)</li> <li>AddInput (InputQueue)</li> <li>AdvanceQueueHead (InputQueue)</li> <li>AddRemotePlayer (Peer2PeerBackend)</li> <li>AddSpectator (Peer2PeerBackend)</li> <li>AddRemoteInput (Sync)</li> <li>AdjustSimulation (Sync)</li> <li>advance_frame (TimeSync)</li> <li>Addresses (UGGPONetwork)</li> <li>AllUniqueAddresses (UGGPONetwork)</li> <li>AllValidAddresses (UGGPONetwork)</li> <li>ack_frame (UdpMsg)</li> <li>AutoReset (neosmart::neosmart_event_t_)</li> <li>adler (z_stream_s)</li> <li>avail_in (z_stream_s)</li> <li>avail_out (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_members/#b","title":"b","text":"<ul> <li>bool (GGPOSessionCallbacks)</li> <li>buffer (GGPOSessionCallbacks)</li> <li>bits (GameInput, UdpMsg)</li> <li>buf (Sync::SavedFrame, SyncTestBackend::SavedInfo)</li> <li>BeginLog (SyncTestBackend)</li> <li>bValidAddress (UGGPONetworkAddress)</li> <li>bytes_sent (Udp::Stats)</li> </ul>"},{"location":"GGPOUE4/class_members/#c","title":"c","text":"<ul> <li>ConnectionInfo (ConnectionInfo)</li> <li>ConnectionManager (ConnectionManager)</li> <li>code (GGPOEvent)</li> <li>connected (GGPOEvent)</li> <li>connection_interrupted (GGPOEvent)</li> <li>connection_resumed (GGPOEvent)</li> <li>count (GGPOEvent, UdpProtocol::Event)</li> <li>connection_id (GGPOPlayer, UdpProtocol::QueueEntry, UdpProtocol)</li> <li>Chat (GGPOSession)</li> <li>checksum (GGPOSessionCallbacks, Sync::SavedFrame, SyncTestBackend::SavedInfo)</li> <li>Constants (GameInput)</li> <li>clear (GameInput)</li> <li>CheckInitialSync (Peer2PeerBackend, SpectatorBackend)</li> <li>ComputeWaitTime (Poll)</li> <li>cookie (Poll::PollSinkCb)</li> <li>CheckSimulation (Sync)</li> <li>CheckSimulationConsistency (Sync)</li> <li>CreateQueues (Sync)</li> <li>callbacks (Sync::Config)</li> <li>confirmedInput (Sync::Event)</li> <li>cbuf (Sync::SavedFrame, SyncTestBackend::SavedInfo)</li> <li>CreateNetwork (UGGPOGameInstance, UGGPONetwork)</li> <li>CreateLocalAddress (UGGPONetworkAddress)</li> <li>CreateNetworkAddress (UGGPONetworkAddress)</li> <li>ClearSendQueue (UdpProtocol)</li> <li>CreateSocket (UdpProtocol)</li> <li>connection_manager (UdpProtocol)</li> <li>CVariable (neosmart::neosmart_event_t_, neosmart::neosmart_wfmo_t_)</li> </ul>"},{"location":"GGPOUE4/class_members/#d","title":"d","text":"<ul> <li>disconnect_timeout (GGPOEvent, UdpProtocol::Event)</li> <li>disconnected (GGPOEvent, UdpMsg::connect_status)</li> <li>DisconnectPlayer (GGPOSession, Peer2PeerBackend, SpectatorBackend)</li> <li>DoPoll (GGPOSession, Peer2PeerBackend, SpectatorBackend, SyncTestBackend)</li> <li>desc (GameInput)</li> <li>DiscardConfirmedFrames (InputQueue)</li> <li>DisconnectPlayerQueue (Peer2PeerBackend)</li> <li>disconnect_requested (UdpMsg)</li> <li>Disconnect (UdpProtocol)</li> <li>DispatchMsg (UdpProtocol)</li> <li>dummy (internal_state)</li> <li>Destroy (neosmart::neosmart_wfmo_t_)</li> <li>data_type (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_members/#e","title":"e","text":"<ul> <li>equal (GameInput)</li> <li>erase (GameInput)</li> <li>empty (RingBuffer)</li> <li>Event (Sync::Event, UdpProtocol::Event)</li> <li>EndLog (SyncTestBackend)</li> <li>EventsLeft (neosmart::neosmart_wfmo_t_)</li> </ul>"},{"location":"GGPOUE4/class_members/#f","title":"f","text":"<ul> <li>frames_ahead (GGPOEvent)</li> <li>frame (GGPOSessionCallbacks, GameInput, Sync::SavedFrame, SyncTestBackend::SavedInfo)</li> <li>front (RingBuffer)</li> <li>FindSavedFrameIndex (Sync)</li> <li>frames (Sync::SavedState)</li> <li>frame_advantage (UdpMsg)</li> <li>FiredEvent (neosmart::neosmart_wfmo_t_)</li> </ul>"},{"location":"GGPOUE4/class_members/#g","title":"g","text":"<ul> <li>ggpo_add_local_input (GGPONet)</li> <li>ggpo_add_player (GGPONet)</li> <li>ggpo_advance_frame (GGPONet)</li> <li>ggpo_close_session (GGPONet)</li> <li>ggpo_disconnect_player (GGPONet)</li> <li>ggpo_get_network_stats (GGPONet)</li> <li>ggpo_idle (GGPONet)</li> <li>ggpo_set_disconnect_notify_start (GGPONet)</li> <li>ggpo_set_disconnect_timeout (GGPONet)</li> <li>ggpo_set_frame_delay (GGPONet)</li> <li>ggpo_start_session (GGPONet)</li> <li>ggpo_start_spectating (GGPONet)</li> <li>ggpo_start_synctest (GGPONet)</li> <li>ggpo_synchronize_input (GGPONet)</li> <li>ggpo_try_synchronize_local (GGPONet)</li> <li>GetNetworkStats (GGPOSession, Peer2PeerBackend, SpectatorBackend, UdpProtocol)</li> <li>GetConfirmedInput (InputQueue)</li> <li>GetFirstIncorrectFrame (InputQueue)</li> <li>GetInput (InputQueue)</li> <li>GetLastConfirmedFrame (InputQueue)</li> <li>GetLength (InputQueue)</li> <li>GetConfirmedInputs (Sync)</li> <li>GetEvent (Sync, UdpProtocol)</li> <li>GetFrameCount (Sync)</li> <li>GetLastSavedFrame (Sync)</li> <li>GetAddress (UGGPONetwork)</li> <li>GetLocalPort (UGGPONetwork)</li> <li>GetPlayerIndex (UGGPONetwork)</li> <li>GetIpAddress (UGGPONetworkAddress)</li> <li>GetIpAddressString (UGGPONetworkAddress)</li> <li>GetPort (UGGPONetworkAddress)</li> <li>GGPONetworkStats (UdpProtocol)</li> <li>GetPeerConnectStatus (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_members/#h","title":"h","text":"<ul> <li>head (Sync::SavedState)</li> <li>hdr (UdpMsg)</li> <li>HandlesMsg (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_members/#i","title":"i","text":"<ul> <li>IncrementFrame (GGPOSession, Peer2PeerBackend, SpectatorBackend, Sync, SyncTestBackend)</li> <li>init (GameInput)</li> <li>is_null (GameInput)</li> <li>Init (InputQueue, Sync, Udp, UdpProtocol)</li> <li>InputQueue (InputQueue)</li> <li>interval (Poll::PollPeriodicSinkCb)</li> <li>item (RingBuffer)</li> <li>InRollback (Sync)</li> <li>input_size (Sync::Config, UdpMsg)</li> <li>input (Sync::Event, SyncTestBackend::SavedInfo, UdpMsg, UdpProtocol::Event)</li> <li>IpAddress (UGGPONetworkAddress)</li> <li>IsSameAddress (UGGPONetworkAddress)</li> <li>IsValidAddress (UGGPONetworkAddress)</li> <li>input_ack (UdpMsg)</li> <li>IsInitialized (UdpProtocol)</li> <li>IsRunning (UdpProtocol)</li> <li>IsSynchronized (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_members/#k","title":"k","text":"<ul> <li>kbps_sent (FGGPONetworkInfo, Udp::Stats)</li> </ul>"},{"location":"GGPOUE4/class_members/#l","title":"l","text":"<ul> <li>Log (ConnectionManager, InputQueue, Udp, UdpProtocol)</li> <li>local_frames_behind (FGGPOSyncInfo)</li> <li>Logv (GGPOSession, SyncTestBackend)</li> <li>len (GGPOSessionCallbacks)</li> <li>log (GameInput)</li> <li>last_fired (Poll::PollPeriodicSinkCb)</li> <li>LoadFrame (Sync)</li> <li>LogSaveStates (SyncTestBackend)</li> <li>LocalPlayerIndex (UGGPONetwork)</li> <li>last_frame (UdpMsg::connect_status)</li> <li>LogEvent (UdpProtocol)</li> <li>LogMsg (UdpProtocol)</li> <li>local_frame_advantage (UdpProtocol::Stats)</li> <li>last_input_packet_recv_time (UdpProtocol)</li> <li>last_network_stats_interval (UdpProtocol)</li> <li>last_quality_report_time (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_members/#m","title":"m","text":"<ul> <li>MsgType (UdpMsg)</li> <li>magic (UdpMsg)</li> <li>msg (UdpProtocol::QueueEntry, UdpProtocol, z_stream_s)</li> <li>Mutex (neosmart::neosmart_event_t_, neosmart::neosmart_wfmo_t_)</li> </ul>"},{"location":"GGPOUE4/class_members/#n","title":"n","text":"<ul> <li>network (FGGPONetworkStats)</li> <li>num_players (Sync::Config)</li> <li>num_prediction_frames (Sync::Config)</li> <li>NetworkAddresses (UGGPOGameInstance)</li> <li>NumPlayers (UGGPONetwork)</li> <li>num_bits (UdpMsg)</li> <li>network_interrupted (UdpProtocol::Event)</li> <li>next_in (z_stream_s)</li> <li>next_out (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_members/#o","title":"o","text":"<ul> <li>OnHandlePoll (IPollSink)</li> <li>OnLoopPoll (IPollSink, Udp, UdpProtocol)</li> <li>OnMsgPoll (IPollSink)</li> <li>OnPeriodicPoll (IPollSink)</li> <li>OnMsg (Peer2PeerBackend, SpectatorBackend, Udp::Callbacks, UdpProtocol)</li> <li>OnSyncEvent (Peer2PeerBackend)</li> <li>OnUdpProtocolEvent (Peer2PeerBackend, SpectatorBackend)</li> <li>OnUdpProtocolPeerEvent (Peer2PeerBackend)</li> <li>OnUdpProtocolSpectatorEvent (Peer2PeerBackend)</li> <li>operator[] (StaticBuffer)</li> <li>OnInput (UdpProtocol)</li> <li>OnInputAck (UdpProtocol)</li> <li>OnInvalid (UdpProtocol)</li> <li>OnKeepAlive (UdpProtocol)</li> <li>OnQualityReply (UdpProtocol)</li> <li>OnQualityReport (UdpProtocol)</li> <li>OnSyncReply (UdpProtocol)</li> <li>OnSyncRequest (UdpProtocol)</li> <li>opaque (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_members/#p","title":"p","text":"<ul> <li>ping (FGGPONetworkInfo, UdpMsg, UdpProtocol::Stats)</li> <li>player (GGPOEvent)</li> <li>player_num (GGPOLocalEndpoint, GGPOPlayer)</li> <li>Peer2PeerBackend (Peer2PeerBackend)</li> <li>PlayerHandleToQueue (Peer2PeerBackend)</li> <li>Poll2Players (Peer2PeerBackend)</li> <li>PollNPlayers (Peer2PeerBackend)</li> <li>PollSyncEvents (Peer2PeerBackend)</li> <li>PollUdpProtocolEvents (Peer2PeerBackend, SpectatorBackend)</li> <li>Poll (Poll)</li> <li>PollPeriodicSinkCb (Poll::PollPeriodicSinkCb)</li> <li>PollSinkCb (Poll::PollSinkCb)</li> <li>Pump (Poll)</li> <li>pop (RingBuffer)</li> <li>push (RingBuffer)</li> <li>push_back (StaticBuffer)</li> <li>Port (UGGPONetworkAddress)</li> <li>packets_sent (Udp::Stats)</li> <li>PacketSize (UdpMsg)</li> <li>PayloadSize (UdpMsg)</li> <li>peer_connect_status (UdpMsg)</li> <li>pong (UdpMsg)</li> <li>PumpSendQueue (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_members/#q","title":"q","text":"<ul> <li>QueueToPlayerHandle (Peer2PeerBackend)</li> <li>QueueToSpectatorHandle (Peer2PeerBackend)</li> <li>quality_reply (UdpMsg)</li> <li>quality_report (UdpMsg)</li> <li>QueueEvent (UdpProtocol)</li> <li>QueueEntry (UdpProtocol::QueueEntry)</li> <li>queue_time (UdpProtocol::QueueEntry)</li> </ul>"},{"location":"GGPOUE4/class_members/#r","title":"r","text":"<ul> <li>RecvFrom (ConnectionManager)</li> <li>ResetManager (ConnectionManager)</li> <li>recv_queue_len (FGGPONetworkInfo)</li> <li>remote_frames_behind (FGGPOSyncInfo)</li> <li>ResetPrediction (InputQueue, Sync)</li> <li>remoteplayerId (Peer2PeerBackend)</li> <li>remoteplayerQueueu (Peer2PeerBackend)</li> <li>RegisterHandle (Poll)</li> <li>RegisterLoop (Poll)</li> <li>RegisterMsgLoop (Poll)</li> <li>RegisterPeriodic (Poll)</li> <li>Run (Poll)</li> <li>RingBuffer (RingBuffer)</li> <li>RaiseSyncError (SyncTestBackend)</li> <li>recommend_frame_wait_duration (TimeSync)</li> <li>random_reply (UdpMsg)</li> <li>random_request (UdpMsg)</li> <li>remote_endpoint (UdpMsg)</li> <li>remote_magic (UdpMsg)</li> <li>RecommendFrameDelay (UdpProtocol)</li> <li>remote_frame_advantage (UdpProtocol::Stats)</li> <li>random (UdpProtocol)</li> <li>roundtrips_remaining (UdpProtocol)</li> <li>running (UdpProtocol)</li> <li>RegisteredWaits (neosmart::neosmart_event_t_)</li> <li>RefCount (neosmart::neosmart_wfmo_t_)</li> <li>reserved (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_members/#s","title":"s","text":"<ul> <li>SendTo (ConnectionManager, Udp)</li> <li>send_queue_len (FGGPONetworkInfo, UdpProtocol::Stats)</li> <li>ShutdownModule (FGGPOUE4Module)</li> <li>StartupModule (FGGPOUE4Module)</li> <li>synchronized (GGPOEvent)</li> <li>synchronizing (GGPOEvent, UdpProtocol::Event)</li> <li>size (GGPOPlayer, GameInput, RingBuffer, StaticBuffer)</li> <li>SetDisconnectNotifyStart (GGPOSession, Peer2PeerBackend, SpectatorBackend, UdpProtocol)</li> <li>SetDisconnectTimeout (GGPOSession, Peer2PeerBackend, SpectatorBackend, UdpProtocol)</li> <li>SetFrameDelay (GGPOSession, InputQueue, Peer2PeerBackend, SpectatorBackend, Sync)</li> <li>SyncInput (GGPOSession, Peer2PeerBackend, SpectatorBackend, SyncTestBackend)</li> <li>set (GameInput)</li> <li>sink (Poll::PollSinkCb)</li> <li>SpectatorBackend (SpectatorBackend)</li> <li>StaticBuffer (StaticBuffer)</li> <li>SaveCurrentFrame (Sync)</li> <li>SetLastConfirmedFrame (Sync)</li> <li>Sync (Sync)</li> <li>SavedFrame (Sync::SavedFrame)</li> <li>SyncTestBackend (Sync, SyncTestBackend)</li> <li>SynchronizeInputs (Sync)</li> <li>sequence_number (UdpMsg)</li> <li>start_frame (UdpMsg)</li> <li>sync_reply (UdpMsg)</li> <li>sync_request (UdpMsg)</li> <li>SendInput (UdpProtocol)</li> <li>SendInputAck (UdpProtocol)</li> <li>SendMsg (UdpProtocol)</li> <li>SendPendingOutput (UdpProtocol)</li> <li>SendSyncRequest (UdpProtocol)</li> <li>SetLocalFrameNumber (UdpProtocol)</li> <li>State (UdpProtocol, neosmart::neosmart_event_t_)</li> <li>Synchronize (UdpProtocol)</li> <li>send_time (UdpProtocol)</li> <li>sync (UdpProtocol)</li> <li>Status (neosmart::neosmart_wfmo_t_)</li> <li>StillWaiting (neosmart::neosmart_wfmo_t_)</li> <li>state (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_members/#t","title":"t","text":"<ul> <li>ToString (ConnectionInfo, ConnectionManager)</li> <li>timesync (FGGPONetworkStats, GGPOEvent)</li> <li>total (GGPOEvent, UdpProtocol::Event)</li> <li>type (GGPOPlayer, Sync::Event, UdpMsg, UdpProtocol::Event)</li> <li>TrySynchronizeLocal (GGPOSession, Peer2PeerBackend)</li> <li>TimeSync (TimeSync)</li> <li>Type (UdpProtocol::Event)</li> <li>total_in (z_stream_s)</li> <li>total_out (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_members/#u","title":"u","text":"<ul> <li>u (GGPOEvent, Sync::Event, UdpMsg, UdpProtocol::Event)</li> <li>UGGPONetwork (UGGPONetwork)</li> <li>UGGPONetworkAddress (UGGPONetworkAddress)</li> <li>Udp (Udp)</li> <li>UdpMsg (UdpMsg)</li> <li>UdpProtocol (UdpProtocol)</li> <li>udp (UdpProtocol::Stats)</li> <li>UpdateNetworkStats (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_members/#v","title":"v","text":"<ul> <li>void (GGPOSessionCallbacks)</li> <li>value (GameInput)</li> </ul>"},{"location":"GGPOUE4/class_members/#w","title":"w","text":"<ul> <li>WaitIndex (neosmart::neosmart_wfmo_info_t_)</li> <li>Waiter (neosmart::neosmart_wfmo_info_t_)</li> <li>WaitAll (neosmart::neosmart_wfmo_t_)</li> </ul>"},{"location":"GGPOUE4/class_members/#z","title":"z","text":"<ul> <li>zalloc (z_stream_s)</li> <li>zfree (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_members/#_1","title":"~","text":"<ul> <li>~ConnectionInfo (ConnectionInfo)</li> <li>~ConnectionManager (ConnectionManager)</li> <li>~GGPOSession (GGPOSession)</li> <li>~IPollSink (IPollSink)</li> <li>~InputQueue (InputQueue)</li> <li>~Peer2PeerBackend (Peer2PeerBackend)</li> <li>~SpectatorBackend (SpectatorBackend)</li> <li>~Sync (Sync)</li> <li>~SyncTestBackend (SyncTestBackend)</li> <li>~TimeSync (TimeSync)</li> <li>~Callbacks (Udp::Callbacks)</li> <li>~Udp (Udp)</li> <li>~UdpProtocol (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_members/#_","title":"_","text":"<ul> <li>_connection_map (ConnectionManager)</li> <li>_id_to_issue (ConnectionManager)</li> <li>_first_frame (InputQueue)</li> <li>_first_incorrect_frame (InputQueue)</li> <li>_frame_delay (InputQueue)</li> <li>_head (InputQueue, RingBuffer)</li> <li>_id (InputQueue)</li> <li>_inputs (InputQueue, SpectatorBackend)</li> <li>_last_added_frame (InputQueue)</li> <li>_last_frame_requested (InputQueue)</li> <li>_last_user_added_frame (InputQueue)</li> <li>_length (InputQueue)</li> <li>_prediction (InputQueue)</li> <li>_tail (InputQueue, RingBuffer)</li> <li>_callbacks (Peer2PeerBackend, SpectatorBackend, Sync, SyncTestBackend, Udp)</li> <li>_disconnect_notify_start (Peer2PeerBackend, UdpProtocol)</li> <li>_disconnect_timeout (Peer2PeerBackend, UdpProtocol)</li> <li>_endpoints (Peer2PeerBackend)</li> <li>_input_size (Peer2PeerBackend, SpectatorBackend)</li> <li>_local_connect_status (Peer2PeerBackend, Sync, UdpProtocol)</li> <li>_next_recommended_sleep (Peer2PeerBackend)</li> <li>_next_spectator_frame (Peer2PeerBackend)</li> <li>_num_players (Peer2PeerBackend, SpectatorBackend, SyncTestBackend)</li> <li>_num_spectators (Peer2PeerBackend)</li> <li>_poll (Peer2PeerBackend, SpectatorBackend, Udp)</li> <li>_spectators (Peer2PeerBackend)</li> <li>_sync (Peer2PeerBackend, SyncTestBackend)</li> <li>_synchronizing (Peer2PeerBackend, SpectatorBackend)</li> <li>_udp (Peer2PeerBackend, SpectatorBackend, UdpProtocol)</li> <li>_handle_count (Poll)</li> <li>_handle_sinks (Poll)</li> <li>_handles (Poll)</li> <li>_loop_sinks (Poll)</li> <li>_msg_sinks (Poll)</li> <li>_periodic_sinks (Poll)</li> <li>_start_time (Poll)</li> <li>_elements (RingBuffer, StaticBuffer)</li> <li>_size (RingBuffer, StaticBuffer)</li> <li>_host (SpectatorBackend)</li> <li>_next_input_to_send (SpectatorBackend)</li> <li>_config (Sync)</li> <li>_event_queue (Sync, UdpProtocol)</li> <li>_framecount (Sync)</li> <li>_input_queues (Sync)</li> <li>_last_confirmed_frame (Sync)</li> <li>_max_prediction_frames (Sync)</li> <li>_rollingback (Sync, SyncTestBackend)</li> <li>_savedstate (Sync)</li> <li>_check_distance (SyncTestBackend)</li> <li>_current_input (SyncTestBackend)</li> <li>_game (SyncTestBackend)</li> <li>_last_input (SyncTestBackend)</li> <li>_last_verified (SyncTestBackend)</li> <li>_logfp (SyncTestBackend)</li> <li>_running (SyncTestBackend)</li> <li>_saved_frames (SyncTestBackend)</li> <li>_last_inputs (TimeSync)</li> <li>_local (TimeSync)</li> <li>_next_prediction (TimeSync)</li> <li>_remote (TimeSync)</li> <li>_connection_manager (Udp)</li> <li>_bytes_sent (UdpProtocol)</li> <li>_connected (UdpProtocol)</li> <li>_connection_id (UdpProtocol)</li> <li>_current_state (UdpProtocol)</li> <li>_disconnect_event_sent (UdpProtocol)</li> <li>_disconnect_notify_sent (UdpProtocol)</li> <li>_kbps_sent (UdpProtocol)</li> <li>_last_acked_input (UdpProtocol)</li> <li>_last_received_input (UdpProtocol)</li> <li>_last_recv_time (UdpProtocol)</li> <li>_last_send_time (UdpProtocol)</li> <li>_last_sent_input (UdpProtocol)</li> <li>_local_frame_advantage (UdpProtocol)</li> <li>_magic_number (UdpProtocol)</li> <li>_next_recv_seq (UdpProtocol)</li> <li>_next_send_seq (UdpProtocol)</li> <li>_oo_packet (UdpProtocol)</li> <li>_oop_percent (UdpProtocol)</li> <li>_packets_sent (UdpProtocol)</li> <li>_peer_connect_status (UdpProtocol)</li> <li>_pending_output (UdpProtocol)</li> <li>_queue (UdpProtocol)</li> <li>_remote_frame_advantage (UdpProtocol)</li> <li>_remote_magic_number (UdpProtocol)</li> <li>_round_trip_time (UdpProtocol)</li> <li>_send_latency (UdpProtocol)</li> <li>_send_queue (UdpProtocol)</li> <li>_shutdown_timeout (UdpProtocol)</li> <li>_state (UdpProtocol)</li> <li>_stats_start_time (UdpProtocol)</li> <li>_timesync (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/","title":"Class Member Functions","text":""},{"location":"GGPOUE4/class_member_functions/#a","title":"a","text":"<ul> <li>AddConnection (ConnectionManager)</li> <li>AddLocalInput (GGPOSession, Peer2PeerBackend, SpectatorBackend, Sync, SyncTestBackend)</li> <li>AddPlayer (GGPOSession, Peer2PeerBackend, SpectatorBackend, SyncTestBackend)</li> <li>AddDelayedInputToQueue (InputQueue)</li> <li>AddInput (InputQueue)</li> <li>AdvanceQueueHead (InputQueue)</li> <li>AddRemotePlayer (Peer2PeerBackend)</li> <li>AddSpectator (Peer2PeerBackend)</li> <li>AddRemoteInput (Sync)</li> <li>AdjustSimulation (Sync)</li> <li>advance_frame (TimeSync)</li> <li>AllUniqueAddresses (UGGPONetwork)</li> <li>AllValidAddresses (UGGPONetwork)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#b","title":"b","text":"<ul> <li>bool (GGPOSessionCallbacks)</li> <li>BeginLog (SyncTestBackend)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#c","title":"c","text":"<ul> <li>ConnectionInfo (ConnectionInfo)</li> <li>ConnectionManager (ConnectionManager)</li> <li>Chat (GGPOSession)</li> <li>clear (GameInput)</li> <li>CheckInitialSync (Peer2PeerBackend, SpectatorBackend)</li> <li>ComputeWaitTime (Poll)</li> <li>CheckSimulation (Sync)</li> <li>CheckSimulationConsistency (Sync)</li> <li>CreateQueues (Sync)</li> <li>CreateNetwork (UGGPOGameInstance, UGGPONetwork)</li> <li>CreateLocalAddress (UGGPONetworkAddress)</li> <li>CreateNetworkAddress (UGGPONetworkAddress)</li> <li>ClearSendQueue (UdpProtocol)</li> <li>CreateSocket (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#d","title":"d","text":"<ul> <li>DisconnectPlayer (GGPOSession, Peer2PeerBackend, SpectatorBackend)</li> <li>DoPoll (GGPOSession, Peer2PeerBackend, SpectatorBackend, SyncTestBackend)</li> <li>desc (GameInput)</li> <li>DiscardConfirmedFrames (InputQueue)</li> <li>DisconnectPlayerQueue (Peer2PeerBackend)</li> <li>Disconnect (UdpProtocol)</li> <li>DispatchMsg (UdpProtocol)</li> <li>Destroy (neosmart::neosmart_wfmo_t_)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#e","title":"e","text":"<ul> <li>equal (GameInput)</li> <li>erase (GameInput)</li> <li>empty (RingBuffer)</li> <li>EndLog (SyncTestBackend)</li> <li>Event (UdpProtocol::Event)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#f","title":"f","text":"<ul> <li>front (RingBuffer)</li> <li>FindSavedFrameIndex (Sync)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#g","title":"g","text":"<ul> <li>ggpo_add_local_input (GGPONet)</li> <li>ggpo_add_player (GGPONet)</li> <li>ggpo_advance_frame (GGPONet)</li> <li>ggpo_close_session (GGPONet)</li> <li>ggpo_disconnect_player (GGPONet)</li> <li>ggpo_get_network_stats (GGPONet)</li> <li>ggpo_idle (GGPONet)</li> <li>ggpo_set_disconnect_notify_start (GGPONet)</li> <li>ggpo_set_disconnect_timeout (GGPONet)</li> <li>ggpo_set_frame_delay (GGPONet)</li> <li>ggpo_start_session (GGPONet)</li> <li>ggpo_start_spectating (GGPONet)</li> <li>ggpo_start_synctest (GGPONet)</li> <li>ggpo_synchronize_input (GGPONet)</li> <li>ggpo_try_synchronize_local (GGPONet)</li> <li>GetNetworkStats (GGPOSession, Peer2PeerBackend, SpectatorBackend, UdpProtocol)</li> <li>GetConfirmedInput (InputQueue)</li> <li>GetFirstIncorrectFrame (InputQueue)</li> <li>GetInput (InputQueue)</li> <li>GetLastConfirmedFrame (InputQueue)</li> <li>GetLength (InputQueue)</li> <li>GetConfirmedInputs (Sync)</li> <li>GetEvent (Sync, UdpProtocol)</li> <li>GetFrameCount (Sync)</li> <li>GetLastSavedFrame (Sync)</li> <li>GetAddress (UGGPONetwork)</li> <li>GetLocalPort (UGGPONetwork)</li> <li>GetPlayerIndex (UGGPONetwork)</li> <li>GetIpAddress (UGGPONetworkAddress)</li> <li>GetIpAddressString (UGGPONetworkAddress)</li> <li>GetPort (UGGPONetworkAddress)</li> <li>GGPONetworkStats (UdpProtocol)</li> <li>GetPeerConnectStatus (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#h","title":"h","text":"<ul> <li>HandlesMsg (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#i","title":"i","text":"<ul> <li>IncrementFrame (GGPOSession, Peer2PeerBackend, SpectatorBackend, Sync, SyncTestBackend)</li> <li>init (GameInput)</li> <li>is_null (GameInput)</li> <li>Init (InputQueue, Sync, Udp, UdpProtocol)</li> <li>InputQueue (InputQueue)</li> <li>item (RingBuffer)</li> <li>InRollback (Sync)</li> <li>IsSameAddress (UGGPONetworkAddress)</li> <li>IsValidAddress (UGGPONetworkAddress)</li> <li>IsInitialized (UdpProtocol)</li> <li>IsRunning (UdpProtocol)</li> <li>IsSynchronized (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#l","title":"l","text":"<ul> <li>Log (ConnectionManager, InputQueue, Udp, UdpProtocol)</li> <li>Logv (GGPOSession, SyncTestBackend)</li> <li>log (GameInput)</li> <li>LoadFrame (Sync)</li> <li>LogSaveStates (SyncTestBackend)</li> <li>LogEvent (UdpProtocol)</li> <li>LogMsg (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#n","title":"n","text":"<ul> <li>NumPlayers (UGGPONetwork)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#o","title":"o","text":"<ul> <li>OnHandlePoll (IPollSink)</li> <li>OnLoopPoll (IPollSink, Udp, UdpProtocol)</li> <li>OnMsgPoll (IPollSink)</li> <li>OnPeriodicPoll (IPollSink)</li> <li>OnMsg (Peer2PeerBackend, SpectatorBackend, Udp::Callbacks, UdpProtocol)</li> <li>OnSyncEvent (Peer2PeerBackend)</li> <li>OnUdpProtocolEvent (Peer2PeerBackend, SpectatorBackend)</li> <li>OnUdpProtocolPeerEvent (Peer2PeerBackend)</li> <li>OnUdpProtocolSpectatorEvent (Peer2PeerBackend)</li> <li>operator[] (StaticBuffer)</li> <li>OnInput (UdpProtocol)</li> <li>OnInputAck (UdpProtocol)</li> <li>OnInvalid (UdpProtocol)</li> <li>OnKeepAlive (UdpProtocol)</li> <li>OnQualityReply (UdpProtocol)</li> <li>OnQualityReport (UdpProtocol)</li> <li>OnSyncReply (UdpProtocol)</li> <li>OnSyncRequest (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#p","title":"p","text":"<ul> <li>Peer2PeerBackend (Peer2PeerBackend)</li> <li>PlayerHandleToQueue (Peer2PeerBackend)</li> <li>Poll2Players (Peer2PeerBackend)</li> <li>PollNPlayers (Peer2PeerBackend)</li> <li>PollSyncEvents (Peer2PeerBackend)</li> <li>PollUdpProtocolEvents (Peer2PeerBackend, SpectatorBackend)</li> <li>Poll (Poll)</li> <li>PollPeriodicSinkCb (Poll::PollPeriodicSinkCb)</li> <li>PollSinkCb (Poll::PollSinkCb)</li> <li>Pump (Poll)</li> <li>pop (RingBuffer)</li> <li>push (RingBuffer)</li> <li>push_back (StaticBuffer)</li> <li>PacketSize (UdpMsg)</li> <li>PayloadSize (UdpMsg)</li> <li>PumpSendQueue (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#q","title":"q","text":"<ul> <li>QueueToPlayerHandle (Peer2PeerBackend)</li> <li>QueueToSpectatorHandle (Peer2PeerBackend)</li> <li>QueueEvent (UdpProtocol)</li> <li>QueueEntry (UdpProtocol::QueueEntry)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#r","title":"r","text":"<ul> <li>RecvFrom (ConnectionManager)</li> <li>ResetManager (ConnectionManager)</li> <li>ResetPrediction (InputQueue, Sync)</li> <li>RegisterHandle (Poll)</li> <li>RegisterLoop (Poll)</li> <li>RegisterMsgLoop (Poll)</li> <li>RegisterPeriodic (Poll)</li> <li>Run (Poll)</li> <li>RingBuffer (RingBuffer)</li> <li>RaiseSyncError (SyncTestBackend)</li> <li>recommend_frame_wait_duration (TimeSync)</li> <li>RecommendFrameDelay (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#s","title":"s","text":"<ul> <li>SendTo (ConnectionManager, Udp)</li> <li>ShutdownModule (FGGPOUE4Module)</li> <li>StartupModule (FGGPOUE4Module)</li> <li>SetDisconnectNotifyStart (GGPOSession, Peer2PeerBackend, SpectatorBackend, UdpProtocol)</li> <li>SetDisconnectTimeout (GGPOSession, Peer2PeerBackend, SpectatorBackend, UdpProtocol)</li> <li>SetFrameDelay (GGPOSession, InputQueue, Peer2PeerBackend, SpectatorBackend, Sync)</li> <li>SyncInput (GGPOSession, Peer2PeerBackend, SpectatorBackend, SyncTestBackend)</li> <li>set (GameInput)</li> <li>size (RingBuffer, StaticBuffer)</li> <li>SpectatorBackend (SpectatorBackend)</li> <li>StaticBuffer (StaticBuffer)</li> <li>SaveCurrentFrame (Sync)</li> <li>SetLastConfirmedFrame (Sync)</li> <li>Sync (Sync)</li> <li>SavedFrame (Sync::SavedFrame)</li> <li>SynchronizeInputs (Sync)</li> <li>SyncTestBackend (SyncTestBackend)</li> <li>SendInput (UdpProtocol)</li> <li>SendInputAck (UdpProtocol)</li> <li>SendMsg (UdpProtocol)</li> <li>SendPendingOutput (UdpProtocol)</li> <li>SendSyncRequest (UdpProtocol)</li> <li>SetLocalFrameNumber (UdpProtocol)</li> <li>Synchronize (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#t","title":"t","text":"<ul> <li>ToString (ConnectionInfo, ConnectionManager)</li> <li>TrySynchronizeLocal (GGPOSession, Peer2PeerBackend)</li> <li>TimeSync (TimeSync)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#u","title":"u","text":"<ul> <li>UGGPONetwork (UGGPONetwork)</li> <li>UGGPONetworkAddress (UGGPONetworkAddress)</li> <li>Udp (Udp)</li> <li>UdpMsg (UdpMsg)</li> <li>UdpProtocol (UdpProtocol)</li> <li>UpdateNetworkStats (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#v","title":"v","text":"<ul> <li>void (GGPOSessionCallbacks)</li> <li>value (GameInput)</li> </ul>"},{"location":"GGPOUE4/class_member_functions/#_1","title":"~","text":"<ul> <li>~ConnectionInfo (ConnectionInfo)</li> <li>~ConnectionManager (ConnectionManager)</li> <li>~GGPOSession (GGPOSession)</li> <li>~IPollSink (IPollSink)</li> <li>~InputQueue (InputQueue)</li> <li>~Peer2PeerBackend (Peer2PeerBackend)</li> <li>~SpectatorBackend (SpectatorBackend)</li> <li>~Sync (Sync)</li> <li>~SyncTestBackend (SyncTestBackend)</li> <li>~TimeSync (TimeSync)</li> <li>~Callbacks (Udp::Callbacks)</li> <li>~Udp (Udp)</li> <li>~UdpProtocol (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/","title":"Class Member Variables","text":""},{"location":"GGPOUE4/class_member_variables/#a","title":"a","text":"<ul> <li>Addresses (UGGPONetwork)</li> <li>ack_frame (UdpMsg)</li> <li>AutoReset (neosmart::neosmart_event_t_)</li> <li>adler (z_stream_s)</li> <li>avail_in (z_stream_s)</li> <li>avail_out (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#b","title":"b","text":"<ul> <li>buffer (GGPOSessionCallbacks)</li> <li>bits (GameInput, UdpMsg)</li> <li>buf (Sync::SavedFrame, SyncTestBackend::SavedInfo)</li> <li>bValidAddress (UGGPONetworkAddress)</li> <li>bytes_sent (Udp::Stats)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#c","title":"c","text":"<ul> <li>code (GGPOEvent)</li> <li>connected (GGPOEvent)</li> <li>connection_interrupted (GGPOEvent)</li> <li>connection_resumed (GGPOEvent)</li> <li>count (GGPOEvent, UdpProtocol::Event)</li> <li>connection_id (GGPOPlayer, UdpProtocol::QueueEntry, UdpProtocol)</li> <li>checksum (GGPOSessionCallbacks, Sync::SavedFrame, SyncTestBackend::SavedInfo)</li> <li>cookie (Poll::PollSinkCb)</li> <li>callbacks (Sync::Config)</li> <li>confirmedInput (Sync::Event)</li> <li>cbuf (Sync::SavedFrame, SyncTestBackend::SavedInfo)</li> <li>connection_manager (UdpProtocol)</li> <li>CVariable (neosmart::neosmart_event_t_, neosmart::neosmart_wfmo_t_)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#d","title":"d","text":"<ul> <li>disconnect_timeout (GGPOEvent, UdpProtocol::Event)</li> <li>disconnected (GGPOEvent, UdpMsg::connect_status)</li> <li>disconnect_requested (UdpMsg)</li> <li>dummy (internal_state)</li> <li>data_type (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#e","title":"e","text":"<ul> <li>EventsLeft (neosmart::neosmart_wfmo_t_)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#f","title":"f","text":"<ul> <li>frames_ahead (GGPOEvent)</li> <li>frame (GGPOSessionCallbacks, GameInput, Sync::SavedFrame, SyncTestBackend::SavedInfo)</li> <li>frames (Sync::SavedState)</li> <li>frame_advantage (UdpMsg)</li> <li>FiredEvent (neosmart::neosmart_wfmo_t_)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#h","title":"h","text":"<ul> <li>head (Sync::SavedState)</li> <li>hdr (UdpMsg)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#i","title":"i","text":"<ul> <li>interval (Poll::PollPeriodicSinkCb)</li> <li>input_size (Sync::Config, UdpMsg)</li> <li>input (Sync::Event, SyncTestBackend::SavedInfo, UdpMsg, UdpProtocol::Event)</li> <li>IpAddress (UGGPONetworkAddress)</li> <li>input_ack (UdpMsg)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#k","title":"k","text":"<ul> <li>kbps_sent (FGGPONetworkInfo, Udp::Stats)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#l","title":"l","text":"<ul> <li>local_frames_behind (FGGPOSyncInfo)</li> <li>len (GGPOSessionCallbacks)</li> <li>last_fired (Poll::PollPeriodicSinkCb)</li> <li>LocalPlayerIndex (UGGPONetwork)</li> <li>last_frame (UdpMsg::connect_status)</li> <li>local_frame_advantage (UdpProtocol::Stats)</li> <li>last_input_packet_recv_time (UdpProtocol)</li> <li>last_network_stats_interval (UdpProtocol)</li> <li>last_quality_report_time (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#m","title":"m","text":"<ul> <li>magic (UdpMsg)</li> <li>msg (UdpProtocol::QueueEntry, UdpProtocol, z_stream_s)</li> <li>Mutex (neosmart::neosmart_event_t_, neosmart::neosmart_wfmo_t_)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#n","title":"n","text":"<ul> <li>network (FGGPONetworkStats)</li> <li>num_players (Sync::Config)</li> <li>num_prediction_frames (Sync::Config)</li> <li>NetworkAddresses (UGGPOGameInstance)</li> <li>num_bits (UdpMsg)</li> <li>network_interrupted (UdpProtocol::Event)</li> <li>next_in (z_stream_s)</li> <li>next_out (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#o","title":"o","text":"<ul> <li>opaque (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#p","title":"p","text":"<ul> <li>ping (FGGPONetworkInfo, UdpMsg, UdpProtocol::Stats)</li> <li>player (GGPOEvent)</li> <li>player_num (GGPOLocalEndpoint, GGPOPlayer)</li> <li>Port (UGGPONetworkAddress)</li> <li>packets_sent (Udp::Stats)</li> <li>peer_connect_status (UdpMsg)</li> <li>pong (UdpMsg)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#q","title":"q","text":"<ul> <li>quality_reply (UdpMsg)</li> <li>quality_report (UdpMsg)</li> <li>queue_time (UdpProtocol::QueueEntry)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#r","title":"r","text":"<ul> <li>recv_queue_len (FGGPONetworkInfo)</li> <li>remote_frames_behind (FGGPOSyncInfo)</li> <li>remoteplayerId (Peer2PeerBackend)</li> <li>remoteplayerQueueu (Peer2PeerBackend)</li> <li>random_reply (UdpMsg)</li> <li>random_request (UdpMsg)</li> <li>remote_endpoint (UdpMsg)</li> <li>remote_magic (UdpMsg)</li> <li>remote_frame_advantage (UdpProtocol::Stats)</li> <li>random (UdpProtocol)</li> <li>roundtrips_remaining (UdpProtocol)</li> <li>running (UdpProtocol)</li> <li>RegisteredWaits (neosmart::neosmart_event_t_)</li> <li>RefCount (neosmart::neosmart_wfmo_t_)</li> <li>reserved (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#s","title":"s","text":"<ul> <li>send_queue_len (FGGPONetworkInfo, UdpProtocol::Stats)</li> <li>synchronized (GGPOEvent)</li> <li>synchronizing (GGPOEvent, UdpProtocol::Event)</li> <li>size (GGPOPlayer, GameInput)</li> <li>sink (Poll::PollSinkCb)</li> <li>SyncTestBackend (Sync)</li> <li>sequence_number (UdpMsg)</li> <li>start_frame (UdpMsg)</li> <li>sync_reply (UdpMsg)</li> <li>sync_request (UdpMsg)</li> <li>send_time (UdpProtocol)</li> <li>sync (UdpProtocol)</li> <li>State (neosmart::neosmart_event_t_)</li> <li>Status (neosmart::neosmart_wfmo_t_)</li> <li>StillWaiting (neosmart::neosmart_wfmo_t_)</li> <li>state (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#t","title":"t","text":"<ul> <li>timesync (FGGPONetworkStats, GGPOEvent)</li> <li>total (GGPOEvent, UdpProtocol::Event)</li> <li>type (GGPOPlayer, Sync::Event, UdpMsg, UdpProtocol::Event)</li> <li>total_in (z_stream_s)</li> <li>total_out (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#u","title":"u","text":"<ul> <li>u (GGPOEvent, Sync::Event, UdpMsg, UdpProtocol::Event)</li> <li>udp (UdpProtocol::Stats)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#w","title":"w","text":"<ul> <li>WaitIndex (neosmart::neosmart_wfmo_info_t_)</li> <li>Waiter (neosmart::neosmart_wfmo_info_t_)</li> <li>WaitAll (neosmart::neosmart_wfmo_t_)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#z","title":"z","text":"<ul> <li>zalloc (z_stream_s)</li> <li>zfree (z_stream_s)</li> </ul>"},{"location":"GGPOUE4/class_member_variables/#_","title":"_","text":"<ul> <li>_connection_map (ConnectionManager)</li> <li>_id_to_issue (ConnectionManager)</li> <li>_first_frame (InputQueue)</li> <li>_first_incorrect_frame (InputQueue)</li> <li>_frame_delay (InputQueue)</li> <li>_head (InputQueue, RingBuffer)</li> <li>_id (InputQueue)</li> <li>_inputs (InputQueue, SpectatorBackend)</li> <li>_last_added_frame (InputQueue)</li> <li>_last_frame_requested (InputQueue)</li> <li>_last_user_added_frame (InputQueue)</li> <li>_length (InputQueue)</li> <li>_prediction (InputQueue)</li> <li>_tail (InputQueue, RingBuffer)</li> <li>_callbacks (Peer2PeerBackend, SpectatorBackend, Sync, SyncTestBackend, Udp)</li> <li>_disconnect_notify_start (Peer2PeerBackend, UdpProtocol)</li> <li>_disconnect_timeout (Peer2PeerBackend, UdpProtocol)</li> <li>_endpoints (Peer2PeerBackend)</li> <li>_input_size (Peer2PeerBackend, SpectatorBackend)</li> <li>_local_connect_status (Peer2PeerBackend, Sync, UdpProtocol)</li> <li>_next_recommended_sleep (Peer2PeerBackend)</li> <li>_next_spectator_frame (Peer2PeerBackend)</li> <li>_num_players (Peer2PeerBackend, SpectatorBackend, SyncTestBackend)</li> <li>_num_spectators (Peer2PeerBackend)</li> <li>_poll (Peer2PeerBackend, SpectatorBackend, Udp)</li> <li>_spectators (Peer2PeerBackend)</li> <li>_sync (Peer2PeerBackend, SyncTestBackend)</li> <li>_synchronizing (Peer2PeerBackend, SpectatorBackend)</li> <li>_udp (Peer2PeerBackend, SpectatorBackend, UdpProtocol)</li> <li>_handle_count (Poll)</li> <li>_handle_sinks (Poll)</li> <li>_handles (Poll)</li> <li>_loop_sinks (Poll)</li> <li>_msg_sinks (Poll)</li> <li>_periodic_sinks (Poll)</li> <li>_start_time (Poll)</li> <li>_elements (RingBuffer, StaticBuffer)</li> <li>_size (RingBuffer, StaticBuffer)</li> <li>_host (SpectatorBackend)</li> <li>_next_input_to_send (SpectatorBackend)</li> <li>_config (Sync)</li> <li>_event_queue (Sync, UdpProtocol)</li> <li>_framecount (Sync)</li> <li>_input_queues (Sync)</li> <li>_last_confirmed_frame (Sync)</li> <li>_max_prediction_frames (Sync)</li> <li>_rollingback (Sync, SyncTestBackend)</li> <li>_savedstate (Sync)</li> <li>_check_distance (SyncTestBackend)</li> <li>_current_input (SyncTestBackend)</li> <li>_game (SyncTestBackend)</li> <li>_last_input (SyncTestBackend)</li> <li>_last_verified (SyncTestBackend)</li> <li>_logfp (SyncTestBackend)</li> <li>_running (SyncTestBackend)</li> <li>_saved_frames (SyncTestBackend)</li> <li>_last_inputs (TimeSync)</li> <li>_local (TimeSync)</li> <li>_next_prediction (TimeSync)</li> <li>_remote (TimeSync)</li> <li>_connection_manager (Udp)</li> <li>_bytes_sent (UdpProtocol)</li> <li>_connected (UdpProtocol)</li> <li>_connection_id (UdpProtocol)</li> <li>_current_state (UdpProtocol)</li> <li>_disconnect_event_sent (UdpProtocol)</li> <li>_disconnect_notify_sent (UdpProtocol)</li> <li>_kbps_sent (UdpProtocol)</li> <li>_last_acked_input (UdpProtocol)</li> <li>_last_received_input (UdpProtocol)</li> <li>_last_recv_time (UdpProtocol)</li> <li>_last_send_time (UdpProtocol)</li> <li>_last_sent_input (UdpProtocol)</li> <li>_local_frame_advantage (UdpProtocol)</li> <li>_magic_number (UdpProtocol)</li> <li>_next_recv_seq (UdpProtocol)</li> <li>_next_send_seq (UdpProtocol)</li> <li>_oo_packet (UdpProtocol)</li> <li>_oop_percent (UdpProtocol)</li> <li>_packets_sent (UdpProtocol)</li> <li>_peer_connect_status (UdpProtocol)</li> <li>_pending_output (UdpProtocol)</li> <li>_queue (UdpProtocol)</li> <li>_remote_frame_advantage (UdpProtocol)</li> <li>_remote_magic_number (UdpProtocol)</li> <li>_round_trip_time (UdpProtocol)</li> <li>_send_latency (UdpProtocol)</li> <li>_send_queue (UdpProtocol)</li> <li>_shutdown_timeout (UdpProtocol)</li> <li>_state (UdpProtocol)</li> <li>_stats_start_time (UdpProtocol)</li> <li>_timesync (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"GGPOUE4/class_member_enums/","title":"Class Member Enums","text":""},{"location":"GGPOUE4/class_member_enums/#c","title":"c","text":"<ul> <li>Constants (GameInput)</li> </ul>"},{"location":"GGPOUE4/class_member_enums/#e","title":"e","text":"<ul> <li>Event (Sync::Event)</li> </ul>"},{"location":"GGPOUE4/class_member_enums/#m","title":"m","text":"<ul> <li>MsgType (UdpMsg)</li> </ul>"},{"location":"GGPOUE4/class_member_enums/#s","title":"s","text":"<ul> <li>State (UdpProtocol)</li> </ul>"},{"location":"GGPOUE4/class_member_enums/#t","title":"t","text":"<ul> <li>Type (UdpProtocol::Event)</li> </ul>"},{"location":"GGPOUE4/namespace_members/","title":"Namespace Members","text":""},{"location":"GGPOUE4/namespace_members/#c","title":"c","text":"<ul> <li>CreateEvent (neosmart)</li> </ul>"},{"location":"GGPOUE4/namespace_members/#d","title":"d","text":"<ul> <li>DestroyEvent (neosmart)</li> </ul>"},{"location":"GGPOUE4/namespace_members/#n","title":"n","text":"<ul> <li>neosmart_event_t (neosmart)</li> <li>neosmart_wfmo_info_t (neosmart)</li> <li>neosmart_wfmo_t (neosmart)</li> </ul>"},{"location":"GGPOUE4/namespace_members/#r","title":"r","text":"<ul> <li>RemoveExpiredWaitHelper (neosmart)</li> <li>ResetEvent (neosmart)</li> </ul>"},{"location":"GGPOUE4/namespace_members/#s","title":"s","text":"<ul> <li>SetEvent (neosmart)</li> </ul>"},{"location":"GGPOUE4/namespace_members/#u","title":"u","text":"<ul> <li>UnlockedWaitForEvent (neosmart)</li> </ul>"},{"location":"GGPOUE4/namespace_members/#w","title":"w","text":"<ul> <li>WaitForEvent (neosmart)</li> <li>WaitForMultipleEvents (neosmart)</li> </ul>"},{"location":"GGPOUE4/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"GGPOUE4/namespace_member_functions/#c","title":"c","text":"<ul> <li>CreateEvent (neosmart)</li> </ul>"},{"location":"GGPOUE4/namespace_member_functions/#d","title":"d","text":"<ul> <li>DestroyEvent (neosmart)</li> </ul>"},{"location":"GGPOUE4/namespace_member_functions/#r","title":"r","text":"<ul> <li>RemoveExpiredWaitHelper (neosmart)</li> <li>ResetEvent (neosmart)</li> </ul>"},{"location":"GGPOUE4/namespace_member_functions/#s","title":"s","text":"<ul> <li>SetEvent (neosmart)</li> </ul>"},{"location":"GGPOUE4/namespace_member_functions/#u","title":"u","text":"<ul> <li>UnlockedWaitForEvent (neosmart)</li> </ul>"},{"location":"GGPOUE4/namespace_member_functions/#w","title":"w","text":"<ul> <li>WaitForEvent (neosmart)</li> <li>WaitForMultipleEvents (neosmart)</li> </ul>"},{"location":"GGPOUE4/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"GGPOUE4/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"GGPOUE4/namespace_member_typedefs/#n","title":"n","text":"<ul> <li>neosmart_event_t (neosmart)</li> <li>neosmart_wfmo_info_t (neosmart)</li> <li>neosmart_wfmo_t (neosmart)</li> </ul>"},{"location":"GGPOUE4/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"GGPOUE4/functions/","title":"Functions","text":""},{"location":"GGPOUE4/functions/#b","title":"b","text":"<ul> <li>BitVector_ClearBit (bitvector.cpp, bitvector.h)</li> <li>BitVector_ReadBit (bitvector.cpp, bitvector.h)</li> <li>BitVector_ReadNibblet (bitvector.cpp, bitvector.h)</li> <li>BitVector_SetBit (bitvector.cpp, bitvector.h)</li> <li>BitVector_WriteNibblet (bitvector.cpp, bitvector.h)</li> </ul>"},{"location":"GGPOUE4/functions/#d","title":"d","text":"<ul> <li>DEFINE_LOG_CATEGORY (GGPOUE4.cpp)</li> <li>DECLARE_LOG_CATEGORY_EXTERN (GGPOUE4.h)</li> </ul>"},{"location":"GGPOUE4/functions/#g","title":"g","text":"<ul> <li>ggpo_client_chat (main.cpp)</li> <li>ggpo_log (main.cpp)</li> <li>ggpo_logv (main.cpp)</li> </ul>"},{"location":"GGPOUE4/functions/#l","title":"l","text":"<ul> <li>Log (log.cpp, log.h)</li> <li>LogFlush (log.cpp, log.h)</li> <li>Logv (log.cpp, log.h)</li> <li>LogFlushOnLog (log.h)</li> </ul>"},{"location":"GGPOUE4/functions/#o","title":"o","text":"<ul> <li>OF (zlib.h)</li> </ul>"},{"location":"GGPOUE4/macros/","title":"Macros","text":""},{"location":"GGPOUE4/macros/#a","title":"a","text":"<ul> <li>ARRAY_SIZE (types.h)</li> <li>ASSERT (types.h)</li> <li>ARRAYSIZEOF (ggponet.cpp)</li> </ul>"},{"location":"GGPOUE4/macros/#b","title":"b","text":"<ul> <li>BITVECTOR_NIBBLE_SIZE (bitvector.h)</li> </ul>"},{"location":"GGPOUE4/macros/#c","title":"c","text":"<ul> <li>const (zconf.h)</li> </ul>"},{"location":"GGPOUE4/macros/#d","title":"d","text":"<ul> <li>DEFAULT_INPUT_SIZE (input_queue.h)</li> <li>deflateInit (zlib.h)</li> <li>deflateInit2 (zlib.h)</li> </ul>"},{"location":"GGPOUE4/macros/#f","title":"f","text":"<ul> <li>FRAME_WINDOW_SIZE (timesync.h)</li> <li>FAR (zconf.h)</li> </ul>"},{"location":"GGPOUE4/macros/#g","title":"g","text":"<ul> <li>GAMEINPUT_MAX_BYTES (game_input.h)</li> <li>GAMEINPUT_MAX_PLAYERS (game_input.h)</li> <li>GGPONET_CONVENTION (ggponet.h)</li> <li>GGPO_API (ggponet.h)</li> <li>GGPO_ERRORLIST (ggponet.h)</li> <li>GGPO_ERRORLIST_ENTRY (ggponet.h)</li> <li>GGPO_INVALID_HANDLE (ggponet.h)</li> <li>GGPO_MAX_PLAYERS (ggponet.h)</li> <li>GGPO_MAX_PREDICTION_FRAMES (ggponet.h)</li> <li>GGPO_MAX_SPECTATORS (ggponet.h)</li> <li>GGPO_SPECTATOR_INPUT_INTERVAL (ggponet.h)</li> <li>GGPO_SUCCEEDED (ggponet.h)</li> </ul>"},{"location":"GGPOUE4/macros/#i","title":"i","text":"<ul> <li>INPUT_QUEUE_LENGTH (input_queue.h)</li> <li>inflateInit (zlib.h)</li> <li>inflateInit2 (zlib.h)</li> </ul>"},{"location":"GGPOUE4/macros/#l","title":"l","text":"<ul> <li>LOCTEXT_NAMESPACE (GGPOUE4.cpp)</li> </ul>"},{"location":"GGPOUE4/macros/#m","title":"m","text":"<ul> <li>MAX_UDP_ENDPOINTS (udp.h)</li> <li>MAX_COMPRESSED_BITS (udp_msg.h)</li> <li>MAX_POLLABLE_HANDLES (poll.h)</li> <li>MAX_PREDICTION_FRAMES (sync.h)</li> <li>MAX_FRAME_ADVANTAGE (timesync.h)</li> <li>MIN_FRAME_ADVANTAGE (timesync.h)</li> <li>MIN_UNIQUE_FRAMES (timesync.h)</li> <li>MAX (types.h)</li> <li>MAX_INT (types.h)</li> <li>MIN (types.h)</li> <li>MAX_MEM_LEVEL (zconf.h)</li> <li>MAX_WBITS (zconf.h)</li> </ul>"},{"location":"GGPOUE4/macros/#o","title":"o","text":"<ul> <li>OF (zconf.h)</li> </ul>"},{"location":"GGPOUE4/macros/#p","title":"p","text":"<ul> <li>PREVIOUS_FRAME (input_queue.cpp)</li> </ul>"},{"location":"GGPOUE4/macros/#s","title":"s","text":"<ul> <li>SPECTATOR_FRAME_BUFFER_SIZE (spectator.h)</li> <li>SEEK_CUR (zconf.h)</li> <li>SEEK_END (zconf.h)</li> <li>SEEK_SET (zconf.h)</li> </ul>"},{"location":"GGPOUE4/macros/#u","title":"u","text":"<ul> <li>UDP_MSG_MAX_PLAYERS (udp_msg.h)</li> </ul>"},{"location":"GGPOUE4/macros/#w","title":"w","text":"<ul> <li>WAIT_TIMEOUT (pevents.h)</li> <li>WFMO (pevents.h)</li> </ul>"},{"location":"GGPOUE4/macros/#z","title":"z","text":"<ul> <li>ZEXPORT (zconf.h)</li> <li>ZEXPORTVA (zconf.h)</li> <li>ZEXTERN (zconf.h)</li> <li>z_off_t (zconf.h)</li> <li>ZLIB_VERSION (zlib.h)</li> <li>Z_ASCII (zlib.h)</li> <li>Z_BEST_COMPRESSION (zlib.h)</li> <li>Z_BEST_SPEED (zlib.h)</li> <li>Z_BINARY (zlib.h)</li> <li>Z_BUF_ERROR (zlib.h)</li> <li>Z_DATA_ERROR (zlib.h)</li> <li>Z_DEFAULT_COMPRESSION (zlib.h)</li> <li>Z_DEFAULT_STRATEGY (zlib.h)</li> <li>Z_DEFLATED (zlib.h)</li> <li>Z_ERRNO (zlib.h)</li> <li>Z_FILTERED (zlib.h)</li> <li>Z_FINISH (zlib.h)</li> <li>Z_FULL_FLUSH (zlib.h)</li> <li>Z_HUFFMAN_ONLY (zlib.h)</li> <li>Z_MEM_ERROR (zlib.h)</li> <li>Z_NEED_DICT (zlib.h)</li> <li>Z_NO_COMPRESSION (zlib.h)</li> <li>Z_NO_FLUSH (zlib.h)</li> <li>Z_NULL (zlib.h)</li> <li>Z_OK (zlib.h)</li> <li>Z_PARTIAL_FLUSH (zlib.h)</li> <li>Z_STREAM_END (zlib.h)</li> <li>Z_STREAM_ERROR (zlib.h)</li> <li>Z_SYNC_FLUSH (zlib.h)</li> <li>Z_UNKNOWN (zlib.h)</li> <li>Z_VERSION_ERROR (zlib.h)</li> <li>zlib_version (zlib.h)</li> </ul>"},{"location":"GGPOUE4/variables/","title":"Variables","text":""},{"location":"GGPOUE4/variables/#b","title":"b","text":"<ul> <li>byte (types.h)</li> <li>Byte (zconf.h)</li> <li>Bytef (zconf.h)</li> </ul>"},{"location":"GGPOUE4/variables/#c","title":"c","text":"<ul> <li>charf (zconf.h)</li> </ul>"},{"location":"GGPOUE4/variables/#d","title":"d","text":"<ul> <li>DEFAULT_DISCONNECT_NOTIFY_START (p2p.cpp)</li> <li>DEFAULT_DISCONNECT_TIMEOUT (p2p.cpp)</li> </ul>"},{"location":"GGPOUE4/variables/#g","title":"g","text":"<ul> <li>gzFile (zlib.h)</li> <li>GGPOErrorCode (ggponet.h)</li> <li>GGPOEventCode (ggponet.h)</li> <li>GGPOLocalEndpoint (ggponet.h)</li> <li>GGPOPlayer (ggponet.h)</li> <li>GGPOPlayerHandle (ggponet.h)</li> <li>GGPOPlayerType (ggponet.h)</li> <li>GGPOSession (ggponet.h)</li> <li>ggpo_milliseconds_t (ggponet.h)</li> </ul>"},{"location":"GGPOUE4/variables/#i","title":"i","text":"<ul> <li>IQuarkBackend (backend.h)</li> <li>intf (zconf.h)</li> </ul>"},{"location":"GGPOUE4/variables/#k","title":"k","text":"<ul> <li>KEEP_ALIVE_INTERVAL (udp_proto.cpp)</li> </ul>"},{"location":"GGPOUE4/variables/#l","title":"l","text":"<ul> <li>logbuf (log.cpp)</li> <li>logfile (log.cpp)</li> </ul>"},{"location":"GGPOUE4/variables/#m","title":"m","text":"<ul> <li>MAX_UDP_PACKET_SIZE (udp.h)</li> <li>MAX_SEQ_DISTANCE (udp_proto.cpp)</li> </ul>"},{"location":"GGPOUE4/variables/#n","title":"n","text":"<ul> <li>NETWORK_STATS_INTERVAL (udp_proto.cpp)</li> <li>NUM_SYNC_PACKETS (udp_proto.cpp)</li> </ul>"},{"location":"GGPOUE4/variables/#o","title":"o","text":"<ul> <li>OF (zlib.h)</li> </ul>"},{"location":"GGPOUE4/variables/#q","title":"q","text":"<ul> <li>Quark (backend.h)</li> <li>QUALITY_REPORT_INTERVAL (udp_proto.cpp)</li> </ul>"},{"location":"GGPOUE4/variables/#r","title":"r","text":"<ul> <li>RECOMMENDATION_INTERVAL (p2p.cpp)</li> <li>RUNNING_RETRY_INTERVAL (udp_proto.cpp)</li> </ul>"},{"location":"GGPOUE4/variables/#s","title":"s","text":"<ul> <li>SYNC_FIRST_RETRY_INTERVAL (udp_proto.cpp)</li> <li>SYNC_RETRY_INTERVAL (udp_proto.cpp)</li> </ul>"},{"location":"GGPOUE4/variables/#u","title":"u","text":"<ul> <li>UDP_HEADER_SIZE (udp_proto.cpp)</li> <li>UDP_SHUTDOWN_TIMER (udp_proto.cpp)</li> <li>uInt (zconf.h)</li> <li>uIntf (zconf.h)</li> <li>uLong (zconf.h)</li> <li>uLongf (zconf.h)</li> </ul>"},{"location":"GGPOUE4/variables/#v","title":"v","text":"<ul> <li>voidp (zconf.h)</li> <li>voidpf (zconf.h)</li> </ul>"},{"location":"GGPOUE4/variables/#z","title":"z","text":"<ul> <li>z_stream (zlib.h)</li> <li>z_streamp (zlib.h)</li> </ul>"},{"location":"GGPOUE4/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}